(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_mapbox-gl_dist_mapbox-gl_0f9823.js", {

"[project]/node_modules/mapbox-gl/dist/mapbox-gl.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, m: module, e: exports, t: __turbopack_require_real__ } = __turbopack_context__;
{
/* Mapbox GL JS is Copyright Â© 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */ (function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory() : ("TURBOPACK unreachable", undefined);
})(this, function() {
    'use strict';
    /* eslint-disable */ var shared, worker, mapboxgl;
    // define gets called three times: one for each chunk. we rely on the order
    // they're imported to know which is which
    function define(_, chunk) {
        if (!shared) {
            shared = chunk;
        } else if (!worker) {
            worker = chunk;
        } else {
            var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
            var sharedChunk = {};
            shared(sharedChunk);
            mapboxgl = chunk(sharedChunk);
            if (typeof window !== 'undefined' && window && window.URL && window.URL.createObjectURL) {
                mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([
                    workerBundleString
                ], {
                    type: 'text/javascript'
                }));
            }
        }
    }
    define([
        "exports"
    ], function(t1) {
        function e(t1) {
            return t1 && t1.__esModule && Object.prototype.hasOwnProperty.call(t1, "default") ? t1.default : t1;
        }
        var r, n = {}, i = {};
        function a() {
            if (r) return i;
            r = 1, Object.defineProperty(i, "__esModule", {
                value: !0
            }), i.setMatrixArrayType = function(t1) {
                i.ARRAY_TYPE = e = t1;
            }, i.toRadian = function(t1) {
                return t1 * a;
            }, i.equals = function(e, r) {
                return Math.abs(e - r) <= t1 * Math.max(1, Math.abs(e), Math.abs(r));
            }, i.RANDOM = i.ARRAY_TYPE = i.EPSILON = void 0;
            var t1 = 1e-6;
            i.EPSILON = t1;
            var e = "undefined" != typeof Float32Array ? Float32Array : Array;
            i.ARRAY_TYPE = e;
            var n = Math.random;
            i.RANDOM = n;
            var a = Math.PI / 180;
            return Math.hypot || (Math.hypot = function() {
                for(var t1 = 0, e = arguments.length; e--;)t1 += arguments[e] * arguments[e];
                return Math.sqrt(t1);
            }), i;
        }
        var s, o = {};
        function l() {
            if (s) return o;
            function t1(e) {
                return t1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                }, t1(e);
            }
            s = 1, Object.defineProperty(o, "__esModule", {
                value: !0
            }), o.create = function() {
                var t1 = new e.ARRAY_TYPE(4);
                return e.ARRAY_TYPE != Float32Array && (t1[1] = 0, t1[2] = 0), t1[0] = 1, t1[3] = 1, t1;
            }, o.clone = function(t1) {
                var r = new e.ARRAY_TYPE(4);
                return r[0] = t1[0], r[1] = t1[1], r[2] = t1[2], r[3] = t1[3], r;
            }, o.copy = function(t1, e) {
                return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1;
            }, o.identity = function(t1) {
                return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1;
            }, o.fromValues = function(t1, r, n, i) {
                var a = new e.ARRAY_TYPE(4);
                return a[0] = t1, a[1] = r, a[2] = n, a[3] = i, a;
            }, o.set = function(t1, e, r, n, i) {
                return t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = i, t1;
            }, o.transpose = function(t1, e) {
                if (t1 === e) {
                    var r = e[1];
                    t1[1] = e[2], t1[2] = r;
                } else t1[0] = e[0], t1[1] = e[2], t1[2] = e[1], t1[3] = e[3];
                return t1;
            }, o.invert = function(t1, e) {
                var r = e[0], n = e[1], i = e[2], a = e[3], s = r * a - i * n;
                return s ? (t1[0] = a * (s = 1 / s), t1[1] = -n * s, t1[2] = -i * s, t1[3] = r * s, t1) : null;
            }, o.adjoint = function(t1, e) {
                var r = e[0];
                return t1[0] = e[3], t1[1] = -e[1], t1[2] = -e[2], t1[3] = r, t1;
            }, o.determinant = function(t1) {
                return t1[0] * t1[3] - t1[2] * t1[1];
            }, o.multiply = n, o.rotate = function(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3], o = Math.sin(r), l = Math.cos(r);
                return t1[0] = n * l + a * o, t1[1] = i * l + s * o, t1[2] = n * -o + a * l, t1[3] = i * -o + s * l, t1;
            }, o.scale = function(t1, e, r) {
                var n = e[1], i = e[2], a = e[3], s = r[0], o = r[1];
                return t1[0] = e[0] * s, t1[1] = n * s, t1[2] = i * o, t1[3] = a * o, t1;
            }, o.fromRotation = function(t1, e) {
                var r = Math.sin(e), n = Math.cos(e);
                return t1[0] = n, t1[1] = r, t1[2] = -r, t1[3] = n, t1;
            }, o.fromScaling = function(t1, e) {
                return t1[0] = e[0], t1[1] = 0, t1[2] = 0, t1[3] = e[1], t1;
            }, o.str = function(t1) {
                return "mat2(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ", " + t1[3] + ")";
            }, o.frob = function(t1) {
                return Math.hypot(t1[0], t1[1], t1[2], t1[3]);
            }, o.LDU = function(t1, e, r, n) {
                return t1[2] = n[2] / n[0], r[0] = n[0], r[1] = n[1], r[3] = n[3] - t1[2] * r[1], [
                    t1,
                    e,
                    r
                ];
            }, o.add = function(t1, e, r) {
                return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1[3] = e[3] + r[3], t1;
            }, o.subtract = i, o.exactEquals = function(t1, e) {
                return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2] && t1[3] === e[3];
            }, o.equals = function(t1, r) {
                var n = t1[0], i = t1[1], a = t1[2], s = t1[3], o = r[0], l = r[1], u = r[2], c = r[3];
                return Math.abs(n - o) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - l) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(a - u) <= e.EPSILON * Math.max(1, Math.abs(a), Math.abs(u)) && Math.abs(s - c) <= e.EPSILON * Math.max(1, Math.abs(s), Math.abs(c));
            }, o.multiplyScalar = function(t1, e, r) {
                return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1[3] = e[3] * r, t1;
            }, o.multiplyScalarAndAdd = function(t1, e, r, n) {
                return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1[2] = e[2] + r[2] * n, t1[3] = e[3] + r[3] * n, t1;
            }, o.sub = o.mul = void 0;
            var e = function(e, n) {
                if (e && e.__esModule) return e;
                if (null === e || "object" !== t1(e) && "function" != typeof e) return {
                    default: e
                };
                var i = r(void 0);
                if (i && i.has(e)) return i.get(e);
                var a = {}, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var o in e)if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                    var l = s ? Object.getOwnPropertyDescriptor(e, o) : null;
                    l && (l.get || l.set) ? Object.defineProperty(a, o, l) : a[o] = e[o];
                }
                return a.default = e, i && i.set(e, a), a;
            }(a());
            function r(t1) {
                if ("function" != typeof WeakMap) return null;
                var e = new WeakMap, n = new WeakMap;
                return (r = function(t1) {
                    return t1 ? n : e;
                })(t1);
            }
            function n(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3], o = r[0], l = r[1], u = r[2], c = r[3];
                return t1[0] = n * o + a * l, t1[1] = i * o + s * l, t1[2] = n * u + a * c, t1[3] = i * u + s * c, t1;
            }
            function i(t1, e, r) {
                return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1[2] = e[2] - r[2], t1[3] = e[3] - r[3], t1;
            }
            return o.mul = n, o.sub = i, o;
        }
        var u, c = {};
        function h() {
            if (u) return c;
            function t1(e) {
                return t1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                }, t1(e);
            }
            u = 1, Object.defineProperty(c, "__esModule", {
                value: !0
            }), c.create = function() {
                var t1 = new e.ARRAY_TYPE(6);
                return e.ARRAY_TYPE != Float32Array && (t1[1] = 0, t1[2] = 0, t1[4] = 0, t1[5] = 0), t1[0] = 1, t1[3] = 1, t1;
            }, c.clone = function(t1) {
                var r = new e.ARRAY_TYPE(6);
                return r[0] = t1[0], r[1] = t1[1], r[2] = t1[2], r[3] = t1[3], r[4] = t1[4], r[5] = t1[5], r;
            }, c.copy = function(t1, e) {
                return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1[4] = e[4], t1[5] = e[5], t1;
            }, c.identity = function(t1) {
                return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1[4] = 0, t1[5] = 0, t1;
            }, c.fromValues = function(t1, r, n, i, a, s) {
                var o = new e.ARRAY_TYPE(6);
                return o[0] = t1, o[1] = r, o[2] = n, o[3] = i, o[4] = a, o[5] = s, o;
            }, c.set = function(t1, e, r, n, i, a, s) {
                return t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = i, t1[4] = a, t1[5] = s, t1;
            }, c.invert = function(t1, e) {
                var r = e[0], n = e[1], i = e[2], a = e[3], s = e[4], o = e[5], l = r * a - n * i;
                return l ? (t1[0] = a * (l = 1 / l), t1[1] = -n * l, t1[2] = -i * l, t1[3] = r * l, t1[4] = (i * o - a * s) * l, t1[5] = (n * s - r * o) * l, t1) : null;
            }, c.determinant = function(t1) {
                return t1[0] * t1[3] - t1[1] * t1[2];
            }, c.multiply = n, c.rotate = function(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = Math.sin(r), c = Math.cos(r);
                return t1[0] = n * c + a * u, t1[1] = i * c + s * u, t1[2] = n * -u + a * c, t1[3] = i * -u + s * c, t1[4] = o, t1[5] = l, t1;
            }, c.scale = function(t1, e, r) {
                var n = e[1], i = e[2], a = e[3], s = e[4], o = e[5], l = r[0], u = r[1];
                return t1[0] = e[0] * l, t1[1] = n * l, t1[2] = i * u, t1[3] = a * u, t1[4] = s, t1[5] = o, t1;
            }, c.translate = function(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = r[0], c = r[1];
                return t1[0] = n, t1[1] = i, t1[2] = a, t1[3] = s, t1[4] = n * u + a * c + o, t1[5] = i * u + s * c + l, t1;
            }, c.fromRotation = function(t1, e) {
                var r = Math.sin(e), n = Math.cos(e);
                return t1[0] = n, t1[1] = r, t1[2] = -r, t1[3] = n, t1[4] = 0, t1[5] = 0, t1;
            }, c.fromScaling = function(t1, e) {
                return t1[0] = e[0], t1[1] = 0, t1[2] = 0, t1[3] = e[1], t1[4] = 0, t1[5] = 0, t1;
            }, c.fromTranslation = function(t1, e) {
                return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1[4] = e[0], t1[5] = e[1], t1;
            }, c.str = function(t1) {
                return "mat2d(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ", " + t1[3] + ", " + t1[4] + ", " + t1[5] + ")";
            }, c.frob = function(t1) {
                return Math.hypot(t1[0], t1[1], t1[2], t1[3], t1[4], t1[5], 1);
            }, c.add = function(t1, e, r) {
                return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1[3] = e[3] + r[3], t1[4] = e[4] + r[4], t1[5] = e[5] + r[5], t1;
            }, c.subtract = i, c.multiplyScalar = function(t1, e, r) {
                return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1[3] = e[3] * r, t1[4] = e[4] * r, t1[5] = e[5] * r, t1;
            }, c.multiplyScalarAndAdd = function(t1, e, r, n) {
                return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1[2] = e[2] + r[2] * n, t1[3] = e[3] + r[3] * n, t1[4] = e[4] + r[4] * n, t1[5] = e[5] + r[5] * n, t1;
            }, c.exactEquals = function(t1, e) {
                return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2] && t1[3] === e[3] && t1[4] === e[4] && t1[5] === e[5];
            }, c.equals = function(t1, r) {
                var n = t1[0], i = t1[1], a = t1[2], s = t1[3], o = t1[4], l = t1[5], u = r[0], c = r[1], h = r[2], p = r[3], f = r[4], d = r[5];
                return Math.abs(n - u) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(i - c) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(c)) && Math.abs(a - h) <= e.EPSILON * Math.max(1, Math.abs(a), Math.abs(h)) && Math.abs(s - p) <= e.EPSILON * Math.max(1, Math.abs(s), Math.abs(p)) && Math.abs(o - f) <= e.EPSILON * Math.max(1, Math.abs(o), Math.abs(f)) && Math.abs(l - d) <= e.EPSILON * Math.max(1, Math.abs(l), Math.abs(d));
            }, c.sub = c.mul = void 0;
            var e = function(e, n) {
                if (e && e.__esModule) return e;
                if (null === e || "object" !== t1(e) && "function" != typeof e) return {
                    default: e
                };
                var i = r(void 0);
                if (i && i.has(e)) return i.get(e);
                var a = {}, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var o in e)if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                    var l = s ? Object.getOwnPropertyDescriptor(e, o) : null;
                    l && (l.get || l.set) ? Object.defineProperty(a, o, l) : a[o] = e[o];
                }
                return a.default = e, i && i.set(e, a), a;
            }(a());
            function r(t1) {
                if ("function" != typeof WeakMap) return null;
                var e = new WeakMap, n = new WeakMap;
                return (r = function(t1) {
                    return t1 ? n : e;
                })(t1);
            }
            function n(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = r[0], c = r[1], h = r[2], p = r[3], f = r[4], d = r[5];
                return t1[0] = n * u + a * c, t1[1] = i * u + s * c, t1[2] = n * h + a * p, t1[3] = i * h + s * p, t1[4] = n * f + a * d + o, t1[5] = i * f + s * d + l, t1;
            }
            function i(t1, e, r) {
                return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1[2] = e[2] - r[2], t1[3] = e[3] - r[3], t1[4] = e[4] - r[4], t1[5] = e[5] - r[5], t1;
            }
            return c.mul = n, c.sub = i, c;
        }
        var p, f = {};
        function d() {
            if (p) return f;
            function t1(e) {
                return t1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                }, t1(e);
            }
            p = 1, Object.defineProperty(f, "__esModule", {
                value: !0
            }), f.create = function() {
                var t1 = new e.ARRAY_TYPE(9);
                return e.ARRAY_TYPE != Float32Array && (t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[5] = 0, t1[6] = 0, t1[7] = 0), t1[0] = 1, t1[4] = 1, t1[8] = 1, t1;
            }, f.fromMat4 = function(t1, e) {
                return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[4], t1[4] = e[5], t1[5] = e[6], t1[6] = e[8], t1[7] = e[9], t1[8] = e[10], t1;
            }, f.clone = function(t1) {
                var r = new e.ARRAY_TYPE(9);
                return r[0] = t1[0], r[1] = t1[1], r[2] = t1[2], r[3] = t1[3], r[4] = t1[4], r[5] = t1[5], r[6] = t1[6], r[7] = t1[7], r[8] = t1[8], r;
            }, f.copy = function(t1, e) {
                return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1[4] = e[4], t1[5] = e[5], t1[6] = e[6], t1[7] = e[7], t1[8] = e[8], t1;
            }, f.fromValues = function(t1, r, n, i, a, s, o, l, u) {
                var c = new e.ARRAY_TYPE(9);
                return c[0] = t1, c[1] = r, c[2] = n, c[3] = i, c[4] = a, c[5] = s, c[6] = o, c[7] = l, c[8] = u, c;
            }, f.set = function(t1, e, r, n, i, a, s, o, l, u) {
                return t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = i, t1[4] = a, t1[5] = s, t1[6] = o, t1[7] = l, t1[8] = u, t1;
            }, f.identity = function(t1) {
                return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 1, t1[5] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 1, t1;
            }, f.transpose = function(t1, e) {
                if (t1 === e) {
                    var r = e[1], n = e[2], i = e[5];
                    t1[1] = e[3], t1[2] = e[6], t1[3] = r, t1[5] = e[7], t1[6] = n, t1[7] = i;
                } else t1[0] = e[0], t1[1] = e[3], t1[2] = e[6], t1[3] = e[1], t1[4] = e[4], t1[5] = e[7], t1[6] = e[2], t1[7] = e[5], t1[8] = e[8];
                return t1;
            }, f.invert = function(t1, e) {
                var r = e[0], n = e[1], i = e[2], a = e[3], s = e[4], o = e[5], l = e[6], u = e[7], c = e[8], h = c * s - o * u, p = -c * a + o * l, f = u * a - s * l, d = r * h + n * p + i * f;
                return d ? (t1[0] = h * (d = 1 / d), t1[1] = (-c * n + i * u) * d, t1[2] = (o * n - i * s) * d, t1[3] = p * d, t1[4] = (c * r - i * l) * d, t1[5] = (-o * r + i * a) * d, t1[6] = f * d, t1[7] = (-u * r + n * l) * d, t1[8] = (s * r - n * a) * d, t1) : null;
            }, f.adjoint = function(t1, e) {
                var r = e[0], n = e[1], i = e[2], a = e[3], s = e[4], o = e[5], l = e[6], u = e[7], c = e[8];
                return t1[0] = s * c - o * u, t1[1] = i * u - n * c, t1[2] = n * o - i * s, t1[3] = o * l - a * c, t1[4] = r * c - i * l, t1[5] = i * a - r * o, t1[6] = a * u - s * l, t1[7] = n * l - r * u, t1[8] = r * s - n * a, t1;
            }, f.determinant = function(t1) {
                var e = t1[3], r = t1[4], n = t1[5], i = t1[6], a = t1[7], s = t1[8];
                return t1[0] * (s * r - n * a) + t1[1] * (-s * e + n * i) + t1[2] * (a * e - r * i);
            }, f.multiply = n, f.translate = function(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = r[0], f = r[1];
                return t1[0] = n, t1[1] = i, t1[2] = a, t1[3] = s, t1[4] = o, t1[5] = l, t1[6] = p * n + f * s + u, t1[7] = p * i + f * o + c, t1[8] = p * a + f * l + h, t1;
            }, f.rotate = function(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = Math.sin(r), f = Math.cos(r);
                return t1[0] = f * n + p * s, t1[1] = f * i + p * o, t1[2] = f * a + p * l, t1[3] = f * s - p * n, t1[4] = f * o - p * i, t1[5] = f * l - p * a, t1[6] = u, t1[7] = c, t1[8] = h, t1;
            }, f.scale = function(t1, e, r) {
                var n = r[0], i = r[1];
                return t1[0] = n * e[0], t1[1] = n * e[1], t1[2] = n * e[2], t1[3] = i * e[3], t1[4] = i * e[4], t1[5] = i * e[5], t1[6] = e[6], t1[7] = e[7], t1[8] = e[8], t1;
            }, f.fromTranslation = function(t1, e) {
                return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 1, t1[5] = 0, t1[6] = e[0], t1[7] = e[1], t1[8] = 1, t1;
            }, f.fromRotation = function(t1, e) {
                var r = Math.sin(e), n = Math.cos(e);
                return t1[0] = n, t1[1] = r, t1[2] = 0, t1[3] = -r, t1[4] = n, t1[5] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 1, t1;
            }, f.fromScaling = function(t1, e) {
                return t1[0] = e[0], t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = e[1], t1[5] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 1, t1;
            }, f.fromMat2d = function(t1, e) {
                return t1[0] = e[0], t1[1] = e[1], t1[2] = 0, t1[3] = e[2], t1[4] = e[3], t1[5] = 0, t1[6] = e[4], t1[7] = e[5], t1[8] = 1, t1;
            }, f.fromQuat = function(t1, e) {
                var r = e[0], n = e[1], i = e[2], a = e[3], s = r + r, o = n + n, l = i + i, u = r * s, c = n * s, h = n * o, p = i * s, f = i * o, d = i * l, m = a * s, y = a * o, g = a * l;
                return t1[0] = 1 - h - d, t1[3] = c - g, t1[6] = p + y, t1[1] = c + g, t1[4] = 1 - u - d, t1[7] = f - m, t1[2] = p - y, t1[5] = f + m, t1[8] = 1 - u - h, t1;
            }, f.normalFromMat4 = function(t1, e) {
                var r = e[0], n = e[1], i = e[2], a = e[3], s = e[4], o = e[5], l = e[6], u = e[7], c = e[8], h = e[9], p = e[10], f = e[11], d = e[12], m = e[13], y = e[14], g = e[15], x = r * o - n * s, v = r * l - i * s, b = r * u - a * s, _ = n * l - i * o, w = n * u - a * o, M = i * u - a * l, A = c * m - h * d, S = c * y - p * d, I = c * g - f * d, P = h * y - p * m, z = h * g - f * m, E = p * g - f * y, k = x * E - v * z + b * P + _ * I - w * S + M * A;
                return k ? (t1[0] = (o * E - l * z + u * P) * (k = 1 / k), t1[1] = (l * I - s * E - u * S) * k, t1[2] = (s * z - o * I + u * A) * k, t1[3] = (i * z - n * E - a * P) * k, t1[4] = (r * E - i * I + a * S) * k, t1[5] = (n * I - r * z - a * A) * k, t1[6] = (m * M - y * w + g * _) * k, t1[7] = (y * b - d * M - g * v) * k, t1[8] = (d * w - m * b + g * x) * k, t1) : null;
            }, f.projection = function(t1, e, r) {
                return t1[0] = 2 / e, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = -2 / r, t1[5] = 0, t1[6] = -1, t1[7] = 1, t1[8] = 1, t1;
            }, f.str = function(t1) {
                return "mat3(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ", " + t1[3] + ", " + t1[4] + ", " + t1[5] + ", " + t1[6] + ", " + t1[7] + ", " + t1[8] + ")";
            }, f.frob = function(t1) {
                return Math.hypot(t1[0], t1[1], t1[2], t1[3], t1[4], t1[5], t1[6], t1[7], t1[8]);
            }, f.add = function(t1, e, r) {
                return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1[3] = e[3] + r[3], t1[4] = e[4] + r[4], t1[5] = e[5] + r[5], t1[6] = e[6] + r[6], t1[7] = e[7] + r[7], t1[8] = e[8] + r[8], t1;
            }, f.subtract = i, f.multiplyScalar = function(t1, e, r) {
                return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1[3] = e[3] * r, t1[4] = e[4] * r, t1[5] = e[5] * r, t1[6] = e[6] * r, t1[7] = e[7] * r, t1[8] = e[8] * r, t1;
            }, f.multiplyScalarAndAdd = function(t1, e, r, n) {
                return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1[2] = e[2] + r[2] * n, t1[3] = e[3] + r[3] * n, t1[4] = e[4] + r[4] * n, t1[5] = e[5] + r[5] * n, t1[6] = e[6] + r[6] * n, t1[7] = e[7] + r[7] * n, t1[8] = e[8] + r[8] * n, t1;
            }, f.exactEquals = function(t1, e) {
                return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2] && t1[3] === e[3] && t1[4] === e[4] && t1[5] === e[5] && t1[6] === e[6] && t1[7] === e[7] && t1[8] === e[8];
            }, f.equals = function(t1, r) {
                var n = t1[0], i = t1[1], a = t1[2], s = t1[3], o = t1[4], l = t1[5], u = t1[6], c = t1[7], h = t1[8], p = r[0], f = r[1], d = r[2], m = r[3], y = r[4], g = r[5], x = r[6], v = r[7], b = r[8];
                return Math.abs(n - p) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(p)) && Math.abs(i - f) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(f)) && Math.abs(a - d) <= e.EPSILON * Math.max(1, Math.abs(a), Math.abs(d)) && Math.abs(s - m) <= e.EPSILON * Math.max(1, Math.abs(s), Math.abs(m)) && Math.abs(o - y) <= e.EPSILON * Math.max(1, Math.abs(o), Math.abs(y)) && Math.abs(l - g) <= e.EPSILON * Math.max(1, Math.abs(l), Math.abs(g)) && Math.abs(u - x) <= e.EPSILON * Math.max(1, Math.abs(u), Math.abs(x)) && Math.abs(c - v) <= e.EPSILON * Math.max(1, Math.abs(c), Math.abs(v)) && Math.abs(h - b) <= e.EPSILON * Math.max(1, Math.abs(h), Math.abs(b));
            }, f.sub = f.mul = void 0;
            var e = function(e, n) {
                if (e && e.__esModule) return e;
                if (null === e || "object" !== t1(e) && "function" != typeof e) return {
                    default: e
                };
                var i = r(void 0);
                if (i && i.has(e)) return i.get(e);
                var a = {}, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var o in e)if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                    var l = s ? Object.getOwnPropertyDescriptor(e, o) : null;
                    l && (l.get || l.set) ? Object.defineProperty(a, o, l) : a[o] = e[o];
                }
                return a.default = e, i && i.set(e, a), a;
            }(a());
            function r(t1) {
                if ("function" != typeof WeakMap) return null;
                var e = new WeakMap, n = new WeakMap;
                return (r = function(t1) {
                    return t1 ? n : e;
                })(t1);
            }
            function n(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = r[0], f = r[1], d = r[2], m = r[3], y = r[4], g = r[5], x = r[6], v = r[7], b = r[8];
                return t1[0] = p * n + f * s + d * u, t1[1] = p * i + f * o + d * c, t1[2] = p * a + f * l + d * h, t1[3] = m * n + y * s + g * u, t1[4] = m * i + y * o + g * c, t1[5] = m * a + y * l + g * h, t1[6] = x * n + v * s + b * u, t1[7] = x * i + v * o + b * c, t1[8] = x * a + v * l + b * h, t1;
            }
            function i(t1, e, r) {
                return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1[2] = e[2] - r[2], t1[3] = e[3] - r[3], t1[4] = e[4] - r[4], t1[5] = e[5] - r[5], t1[6] = e[6] - r[6], t1[7] = e[7] - r[7], t1[8] = e[8] - r[8], t1;
            }
            return f.mul = n, f.sub = i, f;
        }
        var m, y = {};
        function g() {
            if (m) return y;
            function t1(e) {
                return t1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                }, t1(e);
            }
            m = 1, Object.defineProperty(y, "__esModule", {
                value: !0
            }), y.create = function() {
                var t1 = new e.ARRAY_TYPE(16);
                return e.ARRAY_TYPE != Float32Array && (t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0), t1[0] = 1, t1[5] = 1, t1[10] = 1, t1[15] = 1, t1;
            }, y.clone = function(t1) {
                var r = new e.ARRAY_TYPE(16);
                return r[0] = t1[0], r[1] = t1[1], r[2] = t1[2], r[3] = t1[3], r[4] = t1[4], r[5] = t1[5], r[6] = t1[6], r[7] = t1[7], r[8] = t1[8], r[9] = t1[9], r[10] = t1[10], r[11] = t1[11], r[12] = t1[12], r[13] = t1[13], r[14] = t1[14], r[15] = t1[15], r;
            }, y.copy = function(t1, e) {
                return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1[4] = e[4], t1[5] = e[5], t1[6] = e[6], t1[7] = e[7], t1[8] = e[8], t1[9] = e[9], t1[10] = e[10], t1[11] = e[11], t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15], t1;
            }, y.fromValues = function(t1, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y) {
                var g = new e.ARRAY_TYPE(16);
                return g[0] = t1, g[1] = r, g[2] = n, g[3] = i, g[4] = a, g[5] = s, g[6] = o, g[7] = l, g[8] = u, g[9] = c, g[10] = h, g[11] = p, g[12] = f, g[13] = d, g[14] = m, g[15] = y, g;
            }, y.set = function(t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y) {
                return t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = i, t1[4] = a, t1[5] = s, t1[6] = o, t1[7] = l, t1[8] = u, t1[9] = c, t1[10] = h, t1[11] = p, t1[12] = f, t1[13] = d, t1[14] = m, t1[15] = y, t1;
            }, y.identity = n, y.transpose = function(t1, e) {
                if (t1 === e) {
                    var r = e[1], n = e[2], i = e[3], a = e[6], s = e[7], o = e[11];
                    t1[1] = e[4], t1[2] = e[8], t1[3] = e[12], t1[4] = r, t1[6] = e[9], t1[7] = e[13], t1[8] = n, t1[9] = a, t1[11] = e[14], t1[12] = i, t1[13] = s, t1[14] = o;
                } else t1[0] = e[0], t1[1] = e[4], t1[2] = e[8], t1[3] = e[12], t1[4] = e[1], t1[5] = e[5], t1[6] = e[9], t1[7] = e[13], t1[8] = e[2], t1[9] = e[6], t1[10] = e[10], t1[11] = e[14], t1[12] = e[3], t1[13] = e[7], t1[14] = e[11], t1[15] = e[15];
                return t1;
            }, y.invert = function(t1, e) {
                var r = e[0], n = e[1], i = e[2], a = e[3], s = e[4], o = e[5], l = e[6], u = e[7], c = e[8], h = e[9], p = e[10], f = e[11], d = e[12], m = e[13], y = e[14], g = e[15], x = r * o - n * s, v = r * l - i * s, b = r * u - a * s, _ = n * l - i * o, w = n * u - a * o, M = i * u - a * l, A = c * m - h * d, S = c * y - p * d, I = c * g - f * d, P = h * y - p * m, z = h * g - f * m, E = p * g - f * y, k = x * E - v * z + b * P + _ * I - w * S + M * A;
                return k ? (t1[0] = (o * E - l * z + u * P) * (k = 1 / k), t1[1] = (i * z - n * E - a * P) * k, t1[2] = (m * M - y * w + g * _) * k, t1[3] = (p * w - h * M - f * _) * k, t1[4] = (l * I - s * E - u * S) * k, t1[5] = (r * E - i * I + a * S) * k, t1[6] = (y * b - d * M - g * v) * k, t1[7] = (c * M - p * b + f * v) * k, t1[8] = (s * z - o * I + u * A) * k, t1[9] = (n * I - r * z - a * A) * k, t1[10] = (d * w - m * b + g * x) * k, t1[11] = (h * b - c * w - f * x) * k, t1[12] = (o * S - s * P - l * A) * k, t1[13] = (r * P - n * S + i * A) * k, t1[14] = (m * v - d * _ - y * x) * k, t1[15] = (c * _ - h * v + p * x) * k, t1) : null;
            }, y.adjoint = function(t1, e) {
                var r = e[0], n = e[1], i = e[2], a = e[3], s = e[4], o = e[5], l = e[6], u = e[7], c = e[8], h = e[9], p = e[10], f = e[11], d = e[12], m = e[13], y = e[14], g = e[15];
                return t1[0] = o * (p * g - f * y) - h * (l * g - u * y) + m * (l * f - u * p), t1[1] = -(n * (p * g - f * y) - h * (i * g - a * y) + m * (i * f - a * p)), t1[2] = n * (l * g - u * y) - o * (i * g - a * y) + m * (i * u - a * l), t1[3] = -(n * (l * f - u * p) - o * (i * f - a * p) + h * (i * u - a * l)), t1[4] = -(s * (p * g - f * y) - c * (l * g - u * y) + d * (l * f - u * p)), t1[5] = r * (p * g - f * y) - c * (i * g - a * y) + d * (i * f - a * p), t1[6] = -(r * (l * g - u * y) - s * (i * g - a * y) + d * (i * u - a * l)), t1[7] = r * (l * f - u * p) - s * (i * f - a * p) + c * (i * u - a * l), t1[8] = s * (h * g - f * m) - c * (o * g - u * m) + d * (o * f - u * h), t1[9] = -(r * (h * g - f * m) - c * (n * g - a * m) + d * (n * f - a * h)), t1[10] = r * (o * g - u * m) - s * (n * g - a * m) + d * (n * u - a * o), t1[11] = -(r * (o * f - u * h) - s * (n * f - a * h) + c * (n * u - a * o)), t1[12] = -(s * (h * y - p * m) - c * (o * y - l * m) + d * (o * p - l * h)), t1[13] = r * (h * y - p * m) - c * (n * y - i * m) + d * (n * p - i * h), t1[14] = -(r * (o * y - l * m) - s * (n * y - i * m) + d * (n * l - i * o)), t1[15] = r * (o * p - l * h) - s * (n * p - i * h) + c * (n * l - i * o), t1;
            }, y.determinant = function(t1) {
                var e = t1[0], r = t1[1], n = t1[2], i = t1[3], a = t1[4], s = t1[5], o = t1[6], l = t1[7], u = t1[8], c = t1[9], h = t1[10], p = t1[11], f = t1[12], d = t1[13], m = t1[14], y = t1[15];
                return (e * s - r * a) * (h * y - p * m) - (e * o - n * a) * (c * y - p * d) + (e * l - i * a) * (c * m - h * d) + (r * o - n * s) * (u * y - p * f) - (r * l - i * s) * (u * m - h * f) + (n * l - i * o) * (u * d - c * f);
            }, y.multiply = i, y.translate = function(t1, e, r) {
                var n, i, a, s, o, l, u, c, h, p, f, d, m = r[0], y = r[1], g = r[2];
                return e === t1 ? (t1[12] = e[0] * m + e[4] * y + e[8] * g + e[12], t1[13] = e[1] * m + e[5] * y + e[9] * g + e[13], t1[14] = e[2] * m + e[6] * y + e[10] * g + e[14], t1[15] = e[3] * m + e[7] * y + e[11] * g + e[15]) : (i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], d = e[11], t1[0] = n = e[0], t1[1] = i, t1[2] = a, t1[3] = s, t1[4] = o, t1[5] = l, t1[6] = u, t1[7] = c, t1[8] = h, t1[9] = p, t1[10] = f, t1[11] = d, t1[12] = n * m + o * y + h * g + e[12], t1[13] = i * m + l * y + p * g + e[13], t1[14] = a * m + u * y + f * g + e[14], t1[15] = s * m + c * y + d * g + e[15]), t1;
            }, y.scale = function(t1, e, r) {
                var n = r[0], i = r[1], a = r[2];
                return t1[0] = e[0] * n, t1[1] = e[1] * n, t1[2] = e[2] * n, t1[3] = e[3] * n, t1[4] = e[4] * i, t1[5] = e[5] * i, t1[6] = e[6] * i, t1[7] = e[7] * i, t1[8] = e[8] * a, t1[9] = e[9] * a, t1[10] = e[10] * a, t1[11] = e[11] * a, t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15], t1;
            }, y.rotate = function(t1, r, n, i) {
                var a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _, w, M, A, S, I, P, z, E = i[0], k = i[1], T = i[2], B = Math.hypot(E, k, T);
                return B < e.EPSILON ? null : (E *= B = 1 / B, k *= B, T *= B, a = Math.sin(n), s = Math.cos(n), u = r[1], c = r[2], h = r[3], f = r[5], d = r[6], m = r[7], g = r[9], x = r[10], v = r[11], b = E * E * (o = 1 - s) + s, M = E * k * o - T * a, A = k * k * o + s, S = T * k * o + E * a, I = E * T * o + k * a, P = k * T * o - E * a, z = T * T * o + s, t1[0] = (l = r[0]) * b + (p = r[4]) * (_ = k * E * o + T * a) + (y = r[8]) * (w = T * E * o - k * a), t1[1] = u * b + f * _ + g * w, t1[2] = c * b + d * _ + x * w, t1[3] = h * b + m * _ + v * w, t1[4] = l * M + p * A + y * S, t1[5] = u * M + f * A + g * S, t1[6] = c * M + d * A + x * S, t1[7] = h * M + m * A + v * S, t1[8] = l * I + p * P + y * z, t1[9] = u * I + f * P + g * z, t1[10] = c * I + d * P + x * z, t1[11] = h * I + m * P + v * z, r !== t1 && (t1[12] = r[12], t1[13] = r[13], t1[14] = r[14], t1[15] = r[15]), t1);
            }, y.rotateX = function(t1, e, r) {
                var n = Math.sin(r), i = Math.cos(r), a = e[4], s = e[5], o = e[6], l = e[7], u = e[8], c = e[9], h = e[10], p = e[11];
                return e !== t1 && (t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15]), t1[4] = a * i + u * n, t1[5] = s * i + c * n, t1[6] = o * i + h * n, t1[7] = l * i + p * n, t1[8] = u * i - a * n, t1[9] = c * i - s * n, t1[10] = h * i - o * n, t1[11] = p * i - l * n, t1;
            }, y.rotateY = function(t1, e, r) {
                var n = Math.sin(r), i = Math.cos(r), a = e[0], s = e[1], o = e[2], l = e[3], u = e[8], c = e[9], h = e[10], p = e[11];
                return e !== t1 && (t1[4] = e[4], t1[5] = e[5], t1[6] = e[6], t1[7] = e[7], t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15]), t1[0] = a * i - u * n, t1[1] = s * i - c * n, t1[2] = o * i - h * n, t1[3] = l * i - p * n, t1[8] = a * n + u * i, t1[9] = s * n + c * i, t1[10] = o * n + h * i, t1[11] = l * n + p * i, t1;
            }, y.rotateZ = function(t1, e, r) {
                var n = Math.sin(r), i = Math.cos(r), a = e[0], s = e[1], o = e[2], l = e[3], u = e[4], c = e[5], h = e[6], p = e[7];
                return e !== t1 && (t1[8] = e[8], t1[9] = e[9], t1[10] = e[10], t1[11] = e[11], t1[12] = e[12], t1[13] = e[13], t1[14] = e[14], t1[15] = e[15]), t1[0] = a * i + u * n, t1[1] = s * i + c * n, t1[2] = o * i + h * n, t1[3] = l * i + p * n, t1[4] = u * i - a * n, t1[5] = c * i - s * n, t1[6] = h * i - o * n, t1[7] = p * i - l * n, t1;
            }, y.fromTranslation = function(t1, e) {
                return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = 1, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 1, t1[11] = 0, t1[12] = e[0], t1[13] = e[1], t1[14] = e[2], t1[15] = 1, t1;
            }, y.fromScaling = function(t1, e) {
                return t1[0] = e[0], t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = e[1], t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = e[2], t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
            }, y.fromRotation = function(t1, r, n) {
                var i, a, s, o = n[0], l = n[1], u = n[2], c = Math.hypot(o, l, u);
                return c < e.EPSILON ? null : (o *= c = 1 / c, l *= c, u *= c, i = Math.sin(r), a = Math.cos(r), t1[0] = o * o * (s = 1 - a) + a, t1[1] = l * o * s + u * i, t1[2] = u * o * s - l * i, t1[3] = 0, t1[4] = o * l * s - u * i, t1[5] = l * l * s + a, t1[6] = u * l * s + o * i, t1[7] = 0, t1[8] = o * u * s + l * i, t1[9] = l * u * s - o * i, t1[10] = u * u * s + a, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1);
            }, y.fromXRotation = function(t1, e) {
                var r = Math.sin(e), n = Math.cos(e);
                return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = n, t1[6] = r, t1[7] = 0, t1[8] = 0, t1[9] = -r, t1[10] = n, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
            }, y.fromYRotation = function(t1, e) {
                var r = Math.sin(e), n = Math.cos(e);
                return t1[0] = n, t1[1] = 0, t1[2] = -r, t1[3] = 0, t1[4] = 0, t1[5] = 1, t1[6] = 0, t1[7] = 0, t1[8] = r, t1[9] = 0, t1[10] = n, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
            }, y.fromZRotation = function(t1, e) {
                var r = Math.sin(e), n = Math.cos(e);
                return t1[0] = n, t1[1] = r, t1[2] = 0, t1[3] = 0, t1[4] = -r, t1[5] = n, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 1, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
            }, y.fromRotationTranslation = s, y.fromQuat2 = function(t1, r) {
                var n = new e.ARRAY_TYPE(3), i = -r[0], a = -r[1], o = -r[2], l = r[3], u = r[4], c = r[5], h = r[6], p = r[7], f = i * i + a * a + o * o + l * l;
                return f > 0 ? (n[0] = 2 * (u * l + p * i + c * o - h * a) / f, n[1] = 2 * (c * l + p * a + h * i - u * o) / f, n[2] = 2 * (h * l + p * o + u * a - c * i) / f) : (n[0] = 2 * (u * l + p * i + c * o - h * a), n[1] = 2 * (c * l + p * a + h * i - u * o), n[2] = 2 * (h * l + p * o + u * a - c * i)), s(t1, r, n), t1;
            }, y.getTranslation = function(t1, e) {
                return t1[0] = e[12], t1[1] = e[13], t1[2] = e[14], t1;
            }, y.getScaling = o, y.getRotation = function(t1, r) {
                var n = new e.ARRAY_TYPE(3);
                o(n, r);
                var i = 1 / n[0], a = 1 / n[1], s = 1 / n[2], l = r[0] * i, u = r[1] * a, c = r[2] * s, h = r[4] * i, p = r[5] * a, f = r[6] * s, d = r[8] * i, m = r[9] * a, y = r[10] * s, g = l + p + y, x = 0;
                return g > 0 ? (x = 2 * Math.sqrt(g + 1), t1[3] = .25 * x, t1[0] = (f - m) / x, t1[1] = (d - c) / x, t1[2] = (u - h) / x) : l > p && l > y ? (x = 2 * Math.sqrt(1 + l - p - y), t1[3] = (f - m) / x, t1[0] = .25 * x, t1[1] = (u + h) / x, t1[2] = (d + c) / x) : p > y ? (x = 2 * Math.sqrt(1 + p - l - y), t1[3] = (d - c) / x, t1[0] = (u + h) / x, t1[1] = .25 * x, t1[2] = (f + m) / x) : (x = 2 * Math.sqrt(1 + y - l - p), t1[3] = (u - h) / x, t1[0] = (d + c) / x, t1[1] = (f + m) / x, t1[2] = .25 * x), t1;
            }, y.fromRotationTranslationScale = function(t1, e, r, n) {
                var i = e[0], a = e[1], s = e[2], o = e[3], l = i + i, u = a + a, c = s + s, h = i * l, p = i * u, f = i * c, d = a * u, m = a * c, y = s * c, g = o * l, x = o * u, v = o * c, b = n[0], _ = n[1], w = n[2];
                return t1[0] = (1 - (d + y)) * b, t1[1] = (p + v) * b, t1[2] = (f - x) * b, t1[3] = 0, t1[4] = (p - v) * _, t1[5] = (1 - (h + y)) * _, t1[6] = (m + g) * _, t1[7] = 0, t1[8] = (f + x) * w, t1[9] = (m - g) * w, t1[10] = (1 - (h + d)) * w, t1[11] = 0, t1[12] = r[0], t1[13] = r[1], t1[14] = r[2], t1[15] = 1, t1;
            }, y.fromRotationTranslationScaleOrigin = function(t1, e, r, n, i) {
                var a = e[0], s = e[1], o = e[2], l = e[3], u = a + a, c = s + s, h = o + o, p = a * u, f = a * c, d = a * h, m = s * c, y = s * h, g = o * h, x = l * u, v = l * c, b = l * h, _ = n[0], w = n[1], M = n[2], A = i[0], S = i[1], I = i[2], P = (1 - (m + g)) * _, z = (f + b) * _, E = (d - v) * _, k = (f - b) * w, T = (1 - (p + g)) * w, B = (y + x) * w, V = (d + v) * M, C = (y - x) * M, D = (1 - (p + m)) * M;
                return t1[0] = P, t1[1] = z, t1[2] = E, t1[3] = 0, t1[4] = k, t1[5] = T, t1[6] = B, t1[7] = 0, t1[8] = V, t1[9] = C, t1[10] = D, t1[11] = 0, t1[12] = r[0] + A - (P * A + k * S + V * I), t1[13] = r[1] + S - (z * A + T * S + C * I), t1[14] = r[2] + I - (E * A + B * S + D * I), t1[15] = 1, t1;
            }, y.fromQuat = function(t1, e) {
                var r = e[0], n = e[1], i = e[2], a = e[3], s = r + r, o = n + n, l = i + i, u = r * s, c = n * s, h = n * o, p = i * s, f = i * o, d = i * l, m = a * s, y = a * o, g = a * l;
                return t1[0] = 1 - h - d, t1[1] = c + g, t1[2] = p - y, t1[3] = 0, t1[4] = c - g, t1[5] = 1 - u - d, t1[6] = f + m, t1[7] = 0, t1[8] = p + y, t1[9] = f - m, t1[10] = 1 - u - h, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
            }, y.frustum = function(t1, e, r, n, i, a, s) {
                var o = 1 / (r - e), l = 1 / (i - n), u = 1 / (a - s);
                return t1[0] = 2 * a * o, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = 2 * a * l, t1[6] = 0, t1[7] = 0, t1[8] = (r + e) * o, t1[9] = (i + n) * l, t1[10] = (s + a) * u, t1[11] = -1, t1[12] = 0, t1[13] = 0, t1[14] = s * a * 2 * u, t1[15] = 0, t1;
            }, y.perspectiveNO = l, y.perspectiveZO = function(t1, e, r, n, i) {
                var a, s = 1 / Math.tan(e / 2);
                return t1[0] = s / r, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = s, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = -1, t1[12] = 0, t1[13] = 0, t1[15] = 0, null != i && i !== 1 / 0 ? (t1[10] = i * (a = 1 / (n - i)), t1[14] = i * n * a) : (t1[10] = -1, t1[14] = -n), t1;
            }, y.perspectiveFromFieldOfView = function(t1, e, r, n) {
                var i = Math.tan(e.upDegrees * Math.PI / 180), a = Math.tan(e.downDegrees * Math.PI / 180), s = Math.tan(e.leftDegrees * Math.PI / 180), o = Math.tan(e.rightDegrees * Math.PI / 180), l = 2 / (s + o), u = 2 / (i + a);
                return t1[0] = l, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = u, t1[6] = 0, t1[7] = 0, t1[8] = -(s - o) * l * .5, t1[9] = (i - a) * u * .5, t1[10] = n / (r - n), t1[11] = -1, t1[12] = 0, t1[13] = 0, t1[14] = n * r / (r - n), t1[15] = 0, t1;
            }, y.orthoNO = u, y.orthoZO = function(t1, e, r, n, i, a, s) {
                var o = 1 / (e - r), l = 1 / (n - i), u = 1 / (a - s);
                return t1[0] = -2 * o, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = -2 * l, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = u, t1[11] = 0, t1[12] = (e + r) * o, t1[13] = (i + n) * l, t1[14] = a * u, t1[15] = 1, t1;
            }, y.lookAt = function(t1, r, i, a) {
                var s, o, l, u, c, h, p, f, d, m, y = r[0], g = r[1], x = r[2], v = a[0], b = a[1], _ = a[2], w = i[0], M = i[1], A = i[2];
                return Math.abs(y - w) < e.EPSILON && Math.abs(g - M) < e.EPSILON && Math.abs(x - A) < e.EPSILON ? n(t1) : (p = y - w, f = g - M, d = x - A, s = b * (d *= m = 1 / Math.hypot(p, f, d)) - _ * (f *= m), o = _ * (p *= m) - v * d, l = v * f - b * p, (m = Math.hypot(s, o, l)) ? (s *= m = 1 / m, o *= m, l *= m) : (s = 0, o = 0, l = 0), u = f * l - d * o, c = d * s - p * l, h = p * o - f * s, (m = Math.hypot(u, c, h)) ? (u *= m = 1 / m, c *= m, h *= m) : (u = 0, c = 0, h = 0), t1[0] = s, t1[1] = u, t1[2] = p, t1[3] = 0, t1[4] = o, t1[5] = c, t1[6] = f, t1[7] = 0, t1[8] = l, t1[9] = h, t1[10] = d, t1[11] = 0, t1[12] = -(s * y + o * g + l * x), t1[13] = -(u * y + c * g + h * x), t1[14] = -(p * y + f * g + d * x), t1[15] = 1, t1);
            }, y.targetTo = function(t1, e, r, n) {
                var i = e[0], a = e[1], s = e[2], o = n[0], l = n[1], u = n[2], c = i - r[0], h = a - r[1], p = s - r[2], f = c * c + h * h + p * p;
                f > 0 && (c *= f = 1 / Math.sqrt(f), h *= f, p *= f);
                var d = l * p - u * h, m = u * c - o * p, y = o * h - l * c;
                return (f = d * d + m * m + y * y) > 0 && (d *= f = 1 / Math.sqrt(f), m *= f, y *= f), t1[0] = d, t1[1] = m, t1[2] = y, t1[3] = 0, t1[4] = h * y - p * m, t1[5] = p * d - c * y, t1[6] = c * m - h * d, t1[7] = 0, t1[8] = c, t1[9] = h, t1[10] = p, t1[11] = 0, t1[12] = i, t1[13] = a, t1[14] = s, t1[15] = 1, t1;
            }, y.str = function(t1) {
                return "mat4(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ", " + t1[3] + ", " + t1[4] + ", " + t1[5] + ", " + t1[6] + ", " + t1[7] + ", " + t1[8] + ", " + t1[9] + ", " + t1[10] + ", " + t1[11] + ", " + t1[12] + ", " + t1[13] + ", " + t1[14] + ", " + t1[15] + ")";
            }, y.frob = function(t1) {
                return Math.hypot(t1[0], t1[1], t1[2], t1[3], t1[4], t1[5], t1[6], t1[7], t1[8], t1[9], t1[10], t1[11], t1[12], t1[13], t1[14], t1[15]);
            }, y.add = function(t1, e, r) {
                return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1[3] = e[3] + r[3], t1[4] = e[4] + r[4], t1[5] = e[5] + r[5], t1[6] = e[6] + r[6], t1[7] = e[7] + r[7], t1[8] = e[8] + r[8], t1[9] = e[9] + r[9], t1[10] = e[10] + r[10], t1[11] = e[11] + r[11], t1[12] = e[12] + r[12], t1[13] = e[13] + r[13], t1[14] = e[14] + r[14], t1[15] = e[15] + r[15], t1;
            }, y.subtract = c, y.multiplyScalar = function(t1, e, r) {
                return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1[3] = e[3] * r, t1[4] = e[4] * r, t1[5] = e[5] * r, t1[6] = e[6] * r, t1[7] = e[7] * r, t1[8] = e[8] * r, t1[9] = e[9] * r, t1[10] = e[10] * r, t1[11] = e[11] * r, t1[12] = e[12] * r, t1[13] = e[13] * r, t1[14] = e[14] * r, t1[15] = e[15] * r, t1;
            }, y.multiplyScalarAndAdd = function(t1, e, r, n) {
                return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1[2] = e[2] + r[2] * n, t1[3] = e[3] + r[3] * n, t1[4] = e[4] + r[4] * n, t1[5] = e[5] + r[5] * n, t1[6] = e[6] + r[6] * n, t1[7] = e[7] + r[7] * n, t1[8] = e[8] + r[8] * n, t1[9] = e[9] + r[9] * n, t1[10] = e[10] + r[10] * n, t1[11] = e[11] + r[11] * n, t1[12] = e[12] + r[12] * n, t1[13] = e[13] + r[13] * n, t1[14] = e[14] + r[14] * n, t1[15] = e[15] + r[15] * n, t1;
            }, y.exactEquals = function(t1, e) {
                return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2] && t1[3] === e[3] && t1[4] === e[4] && t1[5] === e[5] && t1[6] === e[6] && t1[7] === e[7] && t1[8] === e[8] && t1[9] === e[9] && t1[10] === e[10] && t1[11] === e[11] && t1[12] === e[12] && t1[13] === e[13] && t1[14] === e[14] && t1[15] === e[15];
            }, y.equals = function(t1, r) {
                var n = t1[0], i = t1[1], a = t1[2], s = t1[3], o = t1[4], l = t1[5], u = t1[6], c = t1[7], h = t1[8], p = t1[9], f = t1[10], d = t1[11], m = t1[12], y = t1[13], g = t1[14], x = t1[15], v = r[0], b = r[1], _ = r[2], w = r[3], M = r[4], A = r[5], S = r[6], I = r[7], P = r[8], z = r[9], E = r[10], k = r[11], T = r[12], B = r[13], V = r[14], C = r[15];
                return Math.abs(n - v) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(v)) && Math.abs(i - b) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(b)) && Math.abs(a - _) <= e.EPSILON * Math.max(1, Math.abs(a), Math.abs(_)) && Math.abs(s - w) <= e.EPSILON * Math.max(1, Math.abs(s), Math.abs(w)) && Math.abs(o - M) <= e.EPSILON * Math.max(1, Math.abs(o), Math.abs(M)) && Math.abs(l - A) <= e.EPSILON * Math.max(1, Math.abs(l), Math.abs(A)) && Math.abs(u - S) <= e.EPSILON * Math.max(1, Math.abs(u), Math.abs(S)) && Math.abs(c - I) <= e.EPSILON * Math.max(1, Math.abs(c), Math.abs(I)) && Math.abs(h - P) <= e.EPSILON * Math.max(1, Math.abs(h), Math.abs(P)) && Math.abs(p - z) <= e.EPSILON * Math.max(1, Math.abs(p), Math.abs(z)) && Math.abs(f - E) <= e.EPSILON * Math.max(1, Math.abs(f), Math.abs(E)) && Math.abs(d - k) <= e.EPSILON * Math.max(1, Math.abs(d), Math.abs(k)) && Math.abs(m - T) <= e.EPSILON * Math.max(1, Math.abs(m), Math.abs(T)) && Math.abs(y - B) <= e.EPSILON * Math.max(1, Math.abs(y), Math.abs(B)) && Math.abs(g - V) <= e.EPSILON * Math.max(1, Math.abs(g), Math.abs(V)) && Math.abs(x - C) <= e.EPSILON * Math.max(1, Math.abs(x), Math.abs(C));
            }, y.sub = y.mul = y.ortho = y.perspective = void 0;
            var e = function(e, n) {
                if (e && e.__esModule) return e;
                if (null === e || "object" !== t1(e) && "function" != typeof e) return {
                    default: e
                };
                var i = r(void 0);
                if (i && i.has(e)) return i.get(e);
                var a = {}, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var o in e)if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                    var l = s ? Object.getOwnPropertyDescriptor(e, o) : null;
                    l && (l.get || l.set) ? Object.defineProperty(a, o, l) : a[o] = e[o];
                }
                return a.default = e, i && i.set(e, a), a;
            }(a());
            function r(t1) {
                if ("function" != typeof WeakMap) return null;
                var e = new WeakMap, n = new WeakMap;
                return (r = function(t1) {
                    return t1 ? n : e;
                })(t1);
            }
            function n(t1) {
                return t1[0] = 1, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = 1, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 1, t1[11] = 0, t1[12] = 0, t1[13] = 0, t1[14] = 0, t1[15] = 1, t1;
            }
            function i(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], d = e[11], m = e[12], y = e[13], g = e[14], x = e[15], v = r[0], b = r[1], _ = r[2], w = r[3];
                return t1[0] = v * n + b * o + _ * h + w * m, t1[1] = v * i + b * l + _ * p + w * y, t1[2] = v * a + b * u + _ * f + w * g, t1[3] = v * s + b * c + _ * d + w * x, t1[4] = (v = r[4]) * n + (b = r[5]) * o + (_ = r[6]) * h + (w = r[7]) * m, t1[5] = v * i + b * l + _ * p + w * y, t1[6] = v * a + b * u + _ * f + w * g, t1[7] = v * s + b * c + _ * d + w * x, t1[8] = (v = r[8]) * n + (b = r[9]) * o + (_ = r[10]) * h + (w = r[11]) * m, t1[9] = v * i + b * l + _ * p + w * y, t1[10] = v * a + b * u + _ * f + w * g, t1[11] = v * s + b * c + _ * d + w * x, t1[12] = (v = r[12]) * n + (b = r[13]) * o + (_ = r[14]) * h + (w = r[15]) * m, t1[13] = v * i + b * l + _ * p + w * y, t1[14] = v * a + b * u + _ * f + w * g, t1[15] = v * s + b * c + _ * d + w * x, t1;
            }
            function s(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3], o = n + n, l = i + i, u = a + a, c = n * o, h = n * l, p = n * u, f = i * l, d = i * u, m = a * u, y = s * o, g = s * l, x = s * u;
                return t1[0] = 1 - (f + m), t1[1] = h + x, t1[2] = p - g, t1[3] = 0, t1[4] = h - x, t1[5] = 1 - (c + m), t1[6] = d + y, t1[7] = 0, t1[8] = p + g, t1[9] = d - y, t1[10] = 1 - (c + f), t1[11] = 0, t1[12] = r[0], t1[13] = r[1], t1[14] = r[2], t1[15] = 1, t1;
            }
            function o(t1, e) {
                var r = e[4], n = e[5], i = e[6], a = e[8], s = e[9], o = e[10];
                return t1[0] = Math.hypot(e[0], e[1], e[2]), t1[1] = Math.hypot(r, n, i), t1[2] = Math.hypot(a, s, o), t1;
            }
            function l(t1, e, r, n, i) {
                var a, s = 1 / Math.tan(e / 2);
                return t1[0] = s / r, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = s, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[11] = -1, t1[12] = 0, t1[13] = 0, t1[15] = 0, null != i && i !== 1 / 0 ? (t1[10] = (i + n) * (a = 1 / (n - i)), t1[14] = 2 * i * n * a) : (t1[10] = -1, t1[14] = -2 * n), t1;
            }
            function u(t1, e, r, n, i, a, s) {
                var o = 1 / (e - r), l = 1 / (n - i), u = 1 / (a - s);
                return t1[0] = -2 * o, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1[4] = 0, t1[5] = -2 * l, t1[6] = 0, t1[7] = 0, t1[8] = 0, t1[9] = 0, t1[10] = 2 * u, t1[11] = 0, t1[12] = (e + r) * o, t1[13] = (i + n) * l, t1[14] = (s + a) * u, t1[15] = 1, t1;
            }
            function c(t1, e, r) {
                return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1[2] = e[2] - r[2], t1[3] = e[3] - r[3], t1[4] = e[4] - r[4], t1[5] = e[5] - r[5], t1[6] = e[6] - r[6], t1[7] = e[7] - r[7], t1[8] = e[8] - r[8], t1[9] = e[9] - r[9], t1[10] = e[10] - r[10], t1[11] = e[11] - r[11], t1[12] = e[12] - r[12], t1[13] = e[13] - r[13], t1[14] = e[14] - r[14], t1[15] = e[15] - r[15], t1;
            }
            return y.perspective = l, y.ortho = u, y.mul = i, y.sub = c, y;
        }
        var x, v = {}, b = {};
        function _() {
            if (x) return b;
            function t1(e) {
                return t1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                }, t1(e);
            }
            x = 1, Object.defineProperty(b, "__esModule", {
                value: !0
            }), b.create = n, b.clone = function(t1) {
                var r = new e.ARRAY_TYPE(3);
                return r[0] = t1[0], r[1] = t1[1], r[2] = t1[2], r;
            }, b.length = i, b.fromValues = function(t1, r, n) {
                var i = new e.ARRAY_TYPE(3);
                return i[0] = t1, i[1] = r, i[2] = n, i;
            }, b.copy = function(t1, e) {
                return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1;
            }, b.set = function(t1, e, r, n) {
                return t1[0] = e, t1[1] = r, t1[2] = n, t1;
            }, b.add = function(t1, e, r) {
                return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1;
            }, b.subtract = s, b.multiply = o, b.divide = l, b.ceil = function(t1, e) {
                return t1[0] = Math.ceil(e[0]), t1[1] = Math.ceil(e[1]), t1[2] = Math.ceil(e[2]), t1;
            }, b.floor = function(t1, e) {
                return t1[0] = Math.floor(e[0]), t1[1] = Math.floor(e[1]), t1[2] = Math.floor(e[2]), t1;
            }, b.min = function(t1, e, r) {
                return t1[0] = Math.min(e[0], r[0]), t1[1] = Math.min(e[1], r[1]), t1[2] = Math.min(e[2], r[2]), t1;
            }, b.max = function(t1, e, r) {
                return t1[0] = Math.max(e[0], r[0]), t1[1] = Math.max(e[1], r[1]), t1[2] = Math.max(e[2], r[2]), t1;
            }, b.round = function(t1, e) {
                return t1[0] = Math.round(e[0]), t1[1] = Math.round(e[1]), t1[2] = Math.round(e[2]), t1;
            }, b.scale = function(t1, e, r) {
                return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1;
            }, b.scaleAndAdd = function(t1, e, r, n) {
                return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1[2] = e[2] + r[2] * n, t1;
            }, b.distance = u, b.squaredDistance = c, b.squaredLength = h, b.negate = function(t1, e) {
                return t1[0] = -e[0], t1[1] = -e[1], t1[2] = -e[2], t1;
            }, b.inverse = function(t1, e) {
                return t1[0] = 1 / e[0], t1[1] = 1 / e[1], t1[2] = 1 / e[2], t1;
            }, b.normalize = function(t1, e) {
                var r = e[0], n = e[1], i = e[2], a = r * r + n * n + i * i;
                return a > 0 && (a = 1 / Math.sqrt(a)), t1[0] = e[0] * a, t1[1] = e[1] * a, t1[2] = e[2] * a, t1;
            }, b.dot = p, b.cross = function(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = r[0], o = r[1], l = r[2];
                return t1[0] = i * l - a * o, t1[1] = a * s - n * l, t1[2] = n * o - i * s, t1;
            }, b.lerp = function(t1, e, r, n) {
                var i = e[0], a = e[1], s = e[2];
                return t1[0] = i + n * (r[0] - i), t1[1] = a + n * (r[1] - a), t1[2] = s + n * (r[2] - s), t1;
            }, b.hermite = function(t1, e, r, n, i, a) {
                var s = a * a, o = s * (2 * a - 3) + 1, l = s * (a - 2) + a, u = s * (a - 1), c = s * (3 - 2 * a);
                return t1[0] = e[0] * o + r[0] * l + n[0] * u + i[0] * c, t1[1] = e[1] * o + r[1] * l + n[1] * u + i[1] * c, t1[2] = e[2] * o + r[2] * l + n[2] * u + i[2] * c, t1;
            }, b.bezier = function(t1, e, r, n, i, a) {
                var s = 1 - a, o = s * s, l = a * a, u = o * s, c = 3 * a * o, h = 3 * l * s, p = l * a;
                return t1[0] = e[0] * u + r[0] * c + n[0] * h + i[0] * p, t1[1] = e[1] * u + r[1] * c + n[1] * h + i[1] * p, t1[2] = e[2] * u + r[2] * c + n[2] * h + i[2] * p, t1;
            }, b.random = function(t1, r) {
                r = r || 1;
                var n = 2 * e.RANDOM() * Math.PI, i = 2 * e.RANDOM() - 1, a = Math.sqrt(1 - i * i) * r;
                return t1[0] = Math.cos(n) * a, t1[1] = Math.sin(n) * a, t1[2] = i * r, t1;
            }, b.transformMat4 = function(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = r[3] * n + r[7] * i + r[11] * a + r[15];
                return t1[0] = (r[0] * n + r[4] * i + r[8] * a + r[12]) / (s = s || 1), t1[1] = (r[1] * n + r[5] * i + r[9] * a + r[13]) / s, t1[2] = (r[2] * n + r[6] * i + r[10] * a + r[14]) / s, t1;
            }, b.transformMat3 = function(t1, e, r) {
                var n = e[0], i = e[1], a = e[2];
                return t1[0] = n * r[0] + i * r[3] + a * r[6], t1[1] = n * r[1] + i * r[4] + a * r[7], t1[2] = n * r[2] + i * r[5] + a * r[8], t1;
            }, b.transformQuat = function(t1, e, r) {
                var n = r[0], i = r[1], a = r[2], s = e[0], o = e[1], l = e[2], u = i * l - a * o, c = a * s - n * l, h = n * o - i * s, p = i * h - a * c, f = a * u - n * h, d = n * c - i * u, m = 2 * r[3];
                return c *= m, h *= m, f *= 2, d *= 2, t1[0] = s + (u *= m) + (p *= 2), t1[1] = o + c + f, t1[2] = l + h + d, t1;
            }, b.rotateX = function(t1, e, r, n) {
                var i = [], a = [];
                return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], a[0] = i[0], a[1] = i[1] * Math.cos(n) - i[2] * Math.sin(n), a[2] = i[1] * Math.sin(n) + i[2] * Math.cos(n), t1[0] = a[0] + r[0], t1[1] = a[1] + r[1], t1[2] = a[2] + r[2], t1;
            }, b.rotateY = function(t1, e, r, n) {
                var i = [], a = [];
                return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], a[0] = i[2] * Math.sin(n) + i[0] * Math.cos(n), a[1] = i[1], a[2] = i[2] * Math.cos(n) - i[0] * Math.sin(n), t1[0] = a[0] + r[0], t1[1] = a[1] + r[1], t1[2] = a[2] + r[2], t1;
            }, b.rotateZ = function(t1, e, r, n) {
                var i = [], a = [];
                return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], a[0] = i[0] * Math.cos(n) - i[1] * Math.sin(n), a[1] = i[0] * Math.sin(n) + i[1] * Math.cos(n), a[2] = i[2], t1[0] = a[0] + r[0], t1[1] = a[1] + r[1], t1[2] = a[2] + r[2], t1;
            }, b.angle = function(t1, e) {
                var r = t1[0], n = t1[1], i = t1[2], a = e[0], s = e[1], o = e[2], l = Math.sqrt(r * r + n * n + i * i) * Math.sqrt(a * a + s * s + o * o), u = l && p(t1, e) / l;
                return Math.acos(Math.min(Math.max(u, -1), 1));
            }, b.zero = function(t1) {
                return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1;
            }, b.str = function(t1) {
                return "vec3(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ")";
            }, b.exactEquals = function(t1, e) {
                return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2];
            }, b.equals = function(t1, r) {
                var n = t1[0], i = t1[1], a = t1[2], s = r[0], o = r[1], l = r[2];
                return Math.abs(n - s) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(i - o) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(a - l) <= e.EPSILON * Math.max(1, Math.abs(a), Math.abs(l));
            }, b.forEach = b.sqrLen = b.len = b.sqrDist = b.dist = b.div = b.mul = b.sub = void 0;
            var e = function(e, n) {
                if (e && e.__esModule) return e;
                if (null === e || "object" !== t1(e) && "function" != typeof e) return {
                    default: e
                };
                var i = r(void 0);
                if (i && i.has(e)) return i.get(e);
                var a = {}, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var o in e)if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                    var l = s ? Object.getOwnPropertyDescriptor(e, o) : null;
                    l && (l.get || l.set) ? Object.defineProperty(a, o, l) : a[o] = e[o];
                }
                return a.default = e, i && i.set(e, a), a;
            }(a());
            function r(t1) {
                if ("function" != typeof WeakMap) return null;
                var e = new WeakMap, n = new WeakMap;
                return (r = function(t1) {
                    return t1 ? n : e;
                })(t1);
            }
            function n() {
                var t1 = new e.ARRAY_TYPE(3);
                return e.ARRAY_TYPE != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0), t1;
            }
            function i(t1) {
                return Math.hypot(t1[0], t1[1], t1[2]);
            }
            function s(t1, e, r) {
                return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1[2] = e[2] - r[2], t1;
            }
            function o(t1, e, r) {
                return t1[0] = e[0] * r[0], t1[1] = e[1] * r[1], t1[2] = e[2] * r[2], t1;
            }
            function l(t1, e, r) {
                return t1[0] = e[0] / r[0], t1[1] = e[1] / r[1], t1[2] = e[2] / r[2], t1;
            }
            function u(t1, e) {
                return Math.hypot(e[0] - t1[0], e[1] - t1[1], e[2] - t1[2]);
            }
            function c(t1, e) {
                var r = e[0] - t1[0], n = e[1] - t1[1], i = e[2] - t1[2];
                return r * r + n * n + i * i;
            }
            function h(t1) {
                var e = t1[0], r = t1[1], n = t1[2];
                return e * e + r * r + n * n;
            }
            function p(t1, e) {
                return t1[0] * e[0] + t1[1] * e[1] + t1[2] * e[2];
            }
            b.sub = s, b.mul = o, b.div = l, b.dist = u, b.sqrDist = c, b.len = i, b.sqrLen = h;
            var f, d = (f = n(), function(t1, e, r, n, i, a) {
                var s, o;
                for(e || (e = 3), r || (r = 0), o = n ? Math.min(n * e + r, t1.length) : t1.length, s = r; s < o; s += e)f[0] = t1[s], f[1] = t1[s + 1], f[2] = t1[s + 2], i(f, f, a), t1[s] = f[0], t1[s + 1] = f[1], t1[s + 2] = f[2];
                return t1;
            });
            return b.forEach = d, b;
        }
        var w, M, A = {};
        function S() {
            if (w) return A;
            function t1(e) {
                return t1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                }, t1(e);
            }
            w = 1, Object.defineProperty(A, "__esModule", {
                value: !0
            }), A.create = n, A.clone = function(t1) {
                var r = new e.ARRAY_TYPE(4);
                return r[0] = t1[0], r[1] = t1[1], r[2] = t1[2], r[3] = t1[3], r;
            }, A.fromValues = function(t1, r, n, i) {
                var a = new e.ARRAY_TYPE(4);
                return a[0] = t1, a[1] = r, a[2] = n, a[3] = i, a;
            }, A.copy = function(t1, e) {
                return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1;
            }, A.set = function(t1, e, r, n, i) {
                return t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = i, t1;
            }, A.add = function(t1, e, r) {
                return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1[3] = e[3] + r[3], t1;
            }, A.subtract = i, A.multiply = s, A.divide = o, A.ceil = function(t1, e) {
                return t1[0] = Math.ceil(e[0]), t1[1] = Math.ceil(e[1]), t1[2] = Math.ceil(e[2]), t1[3] = Math.ceil(e[3]), t1;
            }, A.floor = function(t1, e) {
                return t1[0] = Math.floor(e[0]), t1[1] = Math.floor(e[1]), t1[2] = Math.floor(e[2]), t1[3] = Math.floor(e[3]), t1;
            }, A.min = function(t1, e, r) {
                return t1[0] = Math.min(e[0], r[0]), t1[1] = Math.min(e[1], r[1]), t1[2] = Math.min(e[2], r[2]), t1[3] = Math.min(e[3], r[3]), t1;
            }, A.max = function(t1, e, r) {
                return t1[0] = Math.max(e[0], r[0]), t1[1] = Math.max(e[1], r[1]), t1[2] = Math.max(e[2], r[2]), t1[3] = Math.max(e[3], r[3]), t1;
            }, A.round = function(t1, e) {
                return t1[0] = Math.round(e[0]), t1[1] = Math.round(e[1]), t1[2] = Math.round(e[2]), t1[3] = Math.round(e[3]), t1;
            }, A.scale = function(t1, e, r) {
                return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1[3] = e[3] * r, t1;
            }, A.scaleAndAdd = function(t1, e, r, n) {
                return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1[2] = e[2] + r[2] * n, t1[3] = e[3] + r[3] * n, t1;
            }, A.distance = l, A.squaredDistance = u, A.length = c, A.squaredLength = h, A.negate = function(t1, e) {
                return t1[0] = -e[0], t1[1] = -e[1], t1[2] = -e[2], t1[3] = -e[3], t1;
            }, A.inverse = function(t1, e) {
                return t1[0] = 1 / e[0], t1[1] = 1 / e[1], t1[2] = 1 / e[2], t1[3] = 1 / e[3], t1;
            }, A.normalize = function(t1, e) {
                var r = e[0], n = e[1], i = e[2], a = e[3], s = r * r + n * n + i * i + a * a;
                return s > 0 && (s = 1 / Math.sqrt(s)), t1[0] = r * s, t1[1] = n * s, t1[2] = i * s, t1[3] = a * s, t1;
            }, A.dot = function(t1, e) {
                return t1[0] * e[0] + t1[1] * e[1] + t1[2] * e[2] + t1[3] * e[3];
            }, A.cross = function(t1, e, r, n) {
                var i = r[0] * n[1] - r[1] * n[0], a = r[0] * n[2] - r[2] * n[0], s = r[0] * n[3] - r[3] * n[0], o = r[1] * n[2] - r[2] * n[1], l = r[1] * n[3] - r[3] * n[1], u = r[2] * n[3] - r[3] * n[2], c = e[0], h = e[1], p = e[2], f = e[3];
                return t1[0] = h * u - p * l + f * o, t1[1] = -c * u + p * s - f * a, t1[2] = c * l - h * s + f * i, t1[3] = -c * o + h * a - p * i, t1;
            }, A.lerp = function(t1, e, r, n) {
                var i = e[0], a = e[1], s = e[2], o = e[3];
                return t1[0] = i + n * (r[0] - i), t1[1] = a + n * (r[1] - a), t1[2] = s + n * (r[2] - s), t1[3] = o + n * (r[3] - o), t1;
            }, A.random = function(t1, r) {
                var n, i, a, s, o, l;
                r = r || 1;
                do {
                    o = (n = 2 * e.RANDOM() - 1) * n + (i = 2 * e.RANDOM() - 1) * i;
                }while (o >= 1)
                do {
                    l = (a = 2 * e.RANDOM() - 1) * a + (s = 2 * e.RANDOM() - 1) * s;
                }while (l >= 1)
                var u = Math.sqrt((1 - o) / l);
                return t1[0] = r * n, t1[1] = r * i, t1[2] = r * a * u, t1[3] = r * s * u, t1;
            }, A.transformMat4 = function(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3];
                return t1[0] = r[0] * n + r[4] * i + r[8] * a + r[12] * s, t1[1] = r[1] * n + r[5] * i + r[9] * a + r[13] * s, t1[2] = r[2] * n + r[6] * i + r[10] * a + r[14] * s, t1[3] = r[3] * n + r[7] * i + r[11] * a + r[15] * s, t1;
            }, A.transformQuat = function(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = r[0], o = r[1], l = r[2], u = r[3], c = u * n + o * a - l * i, h = u * i + l * n - s * a, p = u * a + s * i - o * n, f = -s * n - o * i - l * a;
                return t1[0] = c * u + f * -s + h * -l - p * -o, t1[1] = h * u + f * -o + p * -s - c * -l, t1[2] = p * u + f * -l + c * -o - h * -s, t1[3] = e[3], t1;
            }, A.zero = function(t1) {
                return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 0, t1;
            }, A.str = function(t1) {
                return "vec4(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ", " + t1[3] + ")";
            }, A.exactEquals = function(t1, e) {
                return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2] && t1[3] === e[3];
            }, A.equals = function(t1, r) {
                var n = t1[0], i = t1[1], a = t1[2], s = t1[3], o = r[0], l = r[1], u = r[2], c = r[3];
                return Math.abs(n - o) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - l) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(a - u) <= e.EPSILON * Math.max(1, Math.abs(a), Math.abs(u)) && Math.abs(s - c) <= e.EPSILON * Math.max(1, Math.abs(s), Math.abs(c));
            }, A.forEach = A.sqrLen = A.len = A.sqrDist = A.dist = A.div = A.mul = A.sub = void 0;
            var e = function(e, n) {
                if (e && e.__esModule) return e;
                if (null === e || "object" !== t1(e) && "function" != typeof e) return {
                    default: e
                };
                var i = r(void 0);
                if (i && i.has(e)) return i.get(e);
                var a = {}, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var o in e)if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                    var l = s ? Object.getOwnPropertyDescriptor(e, o) : null;
                    l && (l.get || l.set) ? Object.defineProperty(a, o, l) : a[o] = e[o];
                }
                return a.default = e, i && i.set(e, a), a;
            }(a());
            function r(t1) {
                if ("function" != typeof WeakMap) return null;
                var e = new WeakMap, n = new WeakMap;
                return (r = function(t1) {
                    return t1 ? n : e;
                })(t1);
            }
            function n() {
                var t1 = new e.ARRAY_TYPE(4);
                return e.ARRAY_TYPE != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 0), t1;
            }
            function i(t1, e, r) {
                return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1[2] = e[2] - r[2], t1[3] = e[3] - r[3], t1;
            }
            function s(t1, e, r) {
                return t1[0] = e[0] * r[0], t1[1] = e[1] * r[1], t1[2] = e[2] * r[2], t1[3] = e[3] * r[3], t1;
            }
            function o(t1, e, r) {
                return t1[0] = e[0] / r[0], t1[1] = e[1] / r[1], t1[2] = e[2] / r[2], t1[3] = e[3] / r[3], t1;
            }
            function l(t1, e) {
                return Math.hypot(e[0] - t1[0], e[1] - t1[1], e[2] - t1[2], e[3] - t1[3]);
            }
            function u(t1, e) {
                var r = e[0] - t1[0], n = e[1] - t1[1], i = e[2] - t1[2], a = e[3] - t1[3];
                return r * r + n * n + i * i + a * a;
            }
            function c(t1) {
                return Math.hypot(t1[0], t1[1], t1[2], t1[3]);
            }
            function h(t1) {
                var e = t1[0], r = t1[1], n = t1[2], i = t1[3];
                return e * e + r * r + n * n + i * i;
            }
            A.sub = i, A.mul = s, A.div = o, A.dist = l, A.sqrDist = u, A.len = c, A.sqrLen = h;
            var p, f = (p = n(), function(t1, e, r, n, i, a) {
                var s, o;
                for(e || (e = 4), r || (r = 0), o = n ? Math.min(n * e + r, t1.length) : t1.length, s = r; s < o; s += e)p[0] = t1[s], p[1] = t1[s + 1], p[2] = t1[s + 2], p[3] = t1[s + 3], i(p, p, a), t1[s] = p[0], t1[s + 1] = p[1], t1[s + 2] = p[2], t1[s + 3] = p[3];
                return t1;
            });
            return A.forEach = f, A;
        }
        function I() {
            if (M) return v;
            function t1(e) {
                return t1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                }, t1(e);
            }
            M = 1, Object.defineProperty(v, "__esModule", {
                value: !0
            }), v.create = l, v.identity = function(t1) {
                return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1;
            }, v.setAxisAngle = u, v.getAxisAngle = function(t1, r) {
                var n = 2 * Math.acos(r[3]), i = Math.sin(n / 2);
                return i > e.EPSILON ? (t1[0] = r[0] / i, t1[1] = r[1] / i, t1[2] = r[2] / i) : (t1[0] = 1, t1[1] = 0, t1[2] = 0), n;
            }, v.getAngle = function(t1, e) {
                var r = g(t1, e);
                return Math.acos(2 * r * r - 1);
            }, v.multiply = c, v.rotateX = function(t1, e, r) {
                r *= .5;
                var n = e[0], i = e[1], a = e[2], s = e[3], o = Math.sin(r), l = Math.cos(r);
                return t1[0] = n * l + s * o, t1[1] = i * l + a * o, t1[2] = a * l - i * o, t1[3] = s * l - n * o, t1;
            }, v.rotateY = function(t1, e, r) {
                r *= .5;
                var n = e[0], i = e[1], a = e[2], s = e[3], o = Math.sin(r), l = Math.cos(r);
                return t1[0] = n * l - a * o, t1[1] = i * l + s * o, t1[2] = a * l + n * o, t1[3] = s * l - i * o, t1;
            }, v.rotateZ = function(t1, e, r) {
                r *= .5;
                var n = e[0], i = e[1], a = e[2], s = e[3], o = Math.sin(r), l = Math.cos(r);
                return t1[0] = n * l + i * o, t1[1] = i * l - n * o, t1[2] = a * l + s * o, t1[3] = s * l - a * o, t1;
            }, v.calculateW = function(t1, e) {
                var r = e[0], n = e[1], i = e[2];
                return t1[0] = r, t1[1] = n, t1[2] = i, t1[3] = Math.sqrt(Math.abs(1 - r * r - n * n - i * i)), t1;
            }, v.exp = h, v.ln = p, v.pow = function(t1, e, r) {
                return p(t1, e), y(t1, t1, r), h(t1, t1), t1;
            }, v.slerp = f, v.random = function(t1) {
                var r = e.RANDOM(), n = e.RANDOM(), i = e.RANDOM(), a = Math.sqrt(1 - r), s = Math.sqrt(r);
                return t1[0] = a * Math.sin(2 * Math.PI * n), t1[1] = a * Math.cos(2 * Math.PI * n), t1[2] = s * Math.sin(2 * Math.PI * i), t1[3] = s * Math.cos(2 * Math.PI * i), t1;
            }, v.invert = function(t1, e) {
                var r = e[0], n = e[1], i = e[2], a = e[3], s = r * r + n * n + i * i + a * a, o = s ? 1 / s : 0;
                return t1[0] = -r * o, t1[1] = -n * o, t1[2] = -i * o, t1[3] = a * o, t1;
            }, v.conjugate = function(t1, e) {
                return t1[0] = -e[0], t1[1] = -e[1], t1[2] = -e[2], t1[3] = e[3], t1;
            }, v.fromMat3 = m, v.fromEuler = function(t1, e, r, n) {
                var i = .5 * Math.PI / 180;
                e *= i, r *= i, n *= i;
                var a = Math.sin(e), s = Math.cos(e), o = Math.sin(r), l = Math.cos(r), u = Math.sin(n), c = Math.cos(n);
                return t1[0] = a * l * c - s * o * u, t1[1] = s * o * c + a * l * u, t1[2] = s * l * u - a * o * c, t1[3] = s * l * c + a * o * u, t1;
            }, v.str = function(t1) {
                return "quat(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ", " + t1[3] + ")";
            }, v.setAxes = v.sqlerp = v.rotationTo = v.equals = v.exactEquals = v.normalize = v.sqrLen = v.squaredLength = v.len = v.length = v.lerp = v.dot = v.scale = v.mul = v.add = v.set = v.copy = v.fromValues = v.clone = void 0;
            var e = o(a()), r = o(d()), n = o(_()), i = o(S());
            function s(t1) {
                if ("function" != typeof WeakMap) return null;
                var e = new WeakMap, r = new WeakMap;
                return (s = function(t1) {
                    return t1 ? r : e;
                })(t1);
            }
            function o(e, r) {
                if (e && e.__esModule) return e;
                if (null === e || "object" !== t1(e) && "function" != typeof e) return {
                    default: e
                };
                var n = s(r);
                if (n && n.has(e)) return n.get(e);
                var i = {}, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var o in e)if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                    var l = a ? Object.getOwnPropertyDescriptor(e, o) : null;
                    l && (l.get || l.set) ? Object.defineProperty(i, o, l) : i[o] = e[o];
                }
                return i.default = e, n && n.set(e, i), i;
            }
            function l() {
                var t1 = new e.ARRAY_TYPE(4);
                return e.ARRAY_TYPE != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0), t1[3] = 1, t1;
            }
            function u(t1, e, r) {
                r *= .5;
                var n = Math.sin(r);
                return t1[0] = n * e[0], t1[1] = n * e[1], t1[2] = n * e[2], t1[3] = Math.cos(r), t1;
            }
            function c(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3], o = r[0], l = r[1], u = r[2], c = r[3];
                return t1[0] = n * c + s * o + i * u - a * l, t1[1] = i * c + s * l + a * o - n * u, t1[2] = a * c + s * u + n * l - i * o, t1[3] = s * c - n * o - i * l - a * u, t1;
            }
            function h(t1, e) {
                var r = e[0], n = e[1], i = e[2], a = e[3], s = Math.sqrt(r * r + n * n + i * i), o = Math.exp(a), l = s > 0 ? o * Math.sin(s) / s : 0;
                return t1[0] = r * l, t1[1] = n * l, t1[2] = i * l, t1[3] = o * Math.cos(s), t1;
            }
            function p(t1, e) {
                var r = e[0], n = e[1], i = e[2], a = e[3], s = Math.sqrt(r * r + n * n + i * i), o = s > 0 ? Math.atan2(s, a) / s : 0;
                return t1[0] = r * o, t1[1] = n * o, t1[2] = i * o, t1[3] = .5 * Math.log(r * r + n * n + i * i + a * a), t1;
            }
            function f(t1, r, n, i) {
                var a, s, o, l, u, c = r[0], h = r[1], p = r[2], f = r[3], d = n[0], m = n[1], y = n[2], g = n[3];
                return (s = c * d + h * m + p * y + f * g) < 0 && (s = -s, d = -d, m = -m, y = -y, g = -g), 1 - s > e.EPSILON ? (a = Math.acos(s), o = Math.sin(a), l = Math.sin((1 - i) * a) / o, u = Math.sin(i * a) / o) : (l = 1 - i, u = i), t1[0] = l * c + u * d, t1[1] = l * h + u * m, t1[2] = l * p + u * y, t1[3] = l * f + u * g, t1;
            }
            function m(t1, e) {
                var r, n = e[0] + e[4] + e[8];
                if (n > 0) r = Math.sqrt(n + 1), t1[3] = .5 * r, t1[0] = (e[5] - e[7]) * (r = .5 / r), t1[1] = (e[6] - e[2]) * r, t1[2] = (e[1] - e[3]) * r;
                else {
                    var i = 0;
                    e[4] > e[0] && (i = 1), e[8] > e[3 * i + i] && (i = 2);
                    var a = (i + 1) % 3, s = (i + 2) % 3;
                    r = Math.sqrt(e[3 * i + i] - e[3 * a + a] - e[3 * s + s] + 1), t1[i] = .5 * r, t1[3] = (e[3 * a + s] - e[3 * s + a]) * (r = .5 / r), t1[a] = (e[3 * a + i] + e[3 * i + a]) * r, t1[s] = (e[3 * s + i] + e[3 * i + s]) * r;
                }
                return t1;
            }
            v.clone = i.clone, v.fromValues = i.fromValues, v.copy = i.copy, v.set = i.set, v.add = i.add, v.mul = c;
            var y = i.scale;
            v.scale = y;
            var g = i.dot;
            v.dot = g, v.lerp = i.lerp;
            var x = i.length;
            v.length = x, v.len = x;
            var b = i.squaredLength;
            v.squaredLength = b, v.sqrLen = b;
            var w = i.normalize;
            v.normalize = w, v.exactEquals = i.exactEquals, v.equals = i.equals;
            var A, I, P, z = (A = n.create(), I = n.fromValues(1, 0, 0), P = n.fromValues(0, 1, 0), function(t1, e, r) {
                var i = n.dot(e, r);
                return i < -.999999 ? (n.cross(A, I, e), n.len(A) < 1e-6 && n.cross(A, P, e), n.normalize(A, A), u(t1, A, Math.PI), t1) : i > .999999 ? (t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1) : (n.cross(A, e, r), t1[0] = A[0], t1[1] = A[1], t1[2] = A[2], t1[3] = 1 + i, w(t1, t1));
            });
            v.rotationTo = z;
            var E, k, T = (E = l(), k = l(), function(t1, e, r, n, i, a) {
                return f(E, e, i, a), f(k, r, n, a), f(t1, E, k, 2 * a * (1 - a)), t1;
            });
            v.sqlerp = T;
            var B, V = (B = r.create(), function(t1, e, r, n) {
                return B[0] = r[0], B[3] = r[1], B[6] = r[2], B[1] = n[0], B[4] = n[1], B[7] = n[2], B[2] = -e[0], B[5] = -e[1], B[8] = -e[2], w(t1, m(t1, B));
            });
            return v.setAxes = V, v;
        }
        var P, z = {};
        function E() {
            if (P) return z;
            function t1(e) {
                return t1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                }, t1(e);
            }
            P = 1, Object.defineProperty(z, "__esModule", {
                value: !0
            }), z.create = function() {
                var t1 = new e.ARRAY_TYPE(8);
                return e.ARRAY_TYPE != Float32Array && (t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[4] = 0, t1[5] = 0, t1[6] = 0, t1[7] = 0), t1[3] = 1, t1;
            }, z.clone = function(t1) {
                var r = new e.ARRAY_TYPE(8);
                return r[0] = t1[0], r[1] = t1[1], r[2] = t1[2], r[3] = t1[3], r[4] = t1[4], r[5] = t1[5], r[6] = t1[6], r[7] = t1[7], r;
            }, z.fromValues = function(t1, r, n, i, a, s, o, l) {
                var u = new e.ARRAY_TYPE(8);
                return u[0] = t1, u[1] = r, u[2] = n, u[3] = i, u[4] = a, u[5] = s, u[6] = o, u[7] = l, u;
            }, z.fromRotationTranslationValues = function(t1, r, n, i, a, s, o) {
                var l = new e.ARRAY_TYPE(8);
                l[0] = t1, l[1] = r, l[2] = n, l[3] = i;
                var u = .5 * a, c = .5 * s, h = .5 * o;
                return l[4] = u * i + c * n - h * r, l[5] = c * i + h * t1 - u * n, l[6] = h * i + u * r - c * t1, l[7] = -u * t1 - c * r - h * n, l;
            }, z.fromRotationTranslation = o, z.fromTranslation = function(t1, e) {
                return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1[4] = .5 * e[0], t1[5] = .5 * e[1], t1[6] = .5 * e[2], t1[7] = 0, t1;
            }, z.fromRotation = function(t1, e) {
                return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1[4] = 0, t1[5] = 0, t1[6] = 0, t1[7] = 0, t1;
            }, z.fromMat4 = function(t1, i) {
                var a = r.create();
                n.getRotation(a, i);
                var s = new e.ARRAY_TYPE(3);
                return n.getTranslation(s, i), o(t1, a, s), t1;
            }, z.copy = l, z.identity = function(t1) {
                return t1[0] = 0, t1[1] = 0, t1[2] = 0, t1[3] = 1, t1[4] = 0, t1[5] = 0, t1[6] = 0, t1[7] = 0, t1;
            }, z.set = function(t1, e, r, n, i, a, s, o, l) {
                return t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = i, t1[4] = a, t1[5] = s, t1[6] = o, t1[7] = l, t1;
            }, z.getDual = function(t1, e) {
                return t1[0] = e[4], t1[1] = e[5], t1[2] = e[6], t1[3] = e[7], t1;
            }, z.setDual = function(t1, e) {
                return t1[4] = e[0], t1[5] = e[1], t1[6] = e[2], t1[7] = e[3], t1;
            }, z.getTranslation = function(t1, e) {
                var r = e[4], n = e[5], i = e[6], a = e[7], s = -e[0], o = -e[1], l = -e[2], u = e[3];
                return t1[0] = 2 * (r * u + a * s + n * l - i * o), t1[1] = 2 * (n * u + a * o + i * s - r * l), t1[2] = 2 * (i * u + a * l + r * o - n * s), t1;
            }, z.translate = function(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3], o = .5 * r[0], l = .5 * r[1], u = .5 * r[2], c = e[4], h = e[5], p = e[6], f = e[7];
                return t1[0] = n, t1[1] = i, t1[2] = a, t1[3] = s, t1[4] = s * o + i * u - a * l + c, t1[5] = s * l + a * o - n * u + h, t1[6] = s * u + n * l - i * o + p, t1[7] = -n * o - i * l - a * u + f, t1;
            }, z.rotateX = function(t1, e, n) {
                var i = -e[0], a = -e[1], s = -e[2], o = e[3], l = e[4], u = e[5], c = e[6], h = e[7], p = l * o + h * i + u * s - c * a, f = u * o + h * a + c * i - l * s, d = c * o + h * s + l * a - u * i, m = h * o - l * i - u * a - c * s;
                return r.rotateX(t1, e, n), t1[4] = p * (o = t1[3]) + m * (i = t1[0]) + f * (s = t1[2]) - d * (a = t1[1]), t1[5] = f * o + m * a + d * i - p * s, t1[6] = d * o + m * s + p * a - f * i, t1[7] = m * o - p * i - f * a - d * s, t1;
            }, z.rotateY = function(t1, e, n) {
                var i = -e[0], a = -e[1], s = -e[2], o = e[3], l = e[4], u = e[5], c = e[6], h = e[7], p = l * o + h * i + u * s - c * a, f = u * o + h * a + c * i - l * s, d = c * o + h * s + l * a - u * i, m = h * o - l * i - u * a - c * s;
                return r.rotateY(t1, e, n), t1[4] = p * (o = t1[3]) + m * (i = t1[0]) + f * (s = t1[2]) - d * (a = t1[1]), t1[5] = f * o + m * a + d * i - p * s, t1[6] = d * o + m * s + p * a - f * i, t1[7] = m * o - p * i - f * a - d * s, t1;
            }, z.rotateZ = function(t1, e, n) {
                var i = -e[0], a = -e[1], s = -e[2], o = e[3], l = e[4], u = e[5], c = e[6], h = e[7], p = l * o + h * i + u * s - c * a, f = u * o + h * a + c * i - l * s, d = c * o + h * s + l * a - u * i, m = h * o - l * i - u * a - c * s;
                return r.rotateZ(t1, e, n), t1[4] = p * (o = t1[3]) + m * (i = t1[0]) + f * (s = t1[2]) - d * (a = t1[1]), t1[5] = f * o + m * a + d * i - p * s, t1[6] = d * o + m * s + p * a - f * i, t1[7] = m * o - p * i - f * a - d * s, t1;
            }, z.rotateByQuatAppend = function(t1, e, r) {
                var n = r[0], i = r[1], a = r[2], s = r[3], o = e[0], l = e[1], u = e[2], c = e[3];
                return t1[0] = o * s + c * n + l * a - u * i, t1[1] = l * s + c * i + u * n - o * a, t1[2] = u * s + c * a + o * i - l * n, t1[3] = c * s - o * n - l * i - u * a, t1[4] = (o = e[4]) * s + (c = e[7]) * n + (l = e[5]) * a - (u = e[6]) * i, t1[5] = l * s + c * i + u * n - o * a, t1[6] = u * s + c * a + o * i - l * n, t1[7] = c * s - o * n - l * i - u * a, t1;
            }, z.rotateByQuatPrepend = function(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3], o = r[0], l = r[1], u = r[2], c = r[3];
                return t1[0] = n * c + s * o + i * u - a * l, t1[1] = i * c + s * l + a * o - n * u, t1[2] = a * c + s * u + n * l - i * o, t1[3] = s * c - n * o - i * l - a * u, t1[4] = n * (c = r[7]) + s * (o = r[4]) + i * (u = r[6]) - a * (l = r[5]), t1[5] = i * c + s * l + a * o - n * u, t1[6] = a * c + s * u + n * l - i * o, t1[7] = s * c - n * o - i * l - a * u, t1;
            }, z.rotateAroundAxis = function(t1, r, n, i) {
                if (Math.abs(i) < e.EPSILON) return l(t1, r);
                var a = Math.hypot(n[0], n[1], n[2]);
                i *= .5;
                var s = Math.sin(i), o = s * n[0] / a, u = s * n[1] / a, c = s * n[2] / a, h = Math.cos(i), p = r[0], f = r[1], d = r[2], m = r[3];
                t1[0] = p * h + m * o + f * c - d * u, t1[1] = f * h + m * u + d * o - p * c, t1[2] = d * h + m * c + p * u - f * o, t1[3] = m * h - p * o - f * u - d * c;
                var y = r[4], g = r[5], x = r[6], v = r[7];
                return t1[4] = y * h + v * o + g * c - x * u, t1[5] = g * h + v * u + x * o - y * c, t1[6] = x * h + v * c + y * u - g * o, t1[7] = v * h - y * o - g * u - x * c, t1;
            }, z.add = function(t1, e, r) {
                return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1[2] = e[2] + r[2], t1[3] = e[3] + r[3], t1[4] = e[4] + r[4], t1[5] = e[5] + r[5], t1[6] = e[6] + r[6], t1[7] = e[7] + r[7], t1;
            }, z.multiply = u, z.scale = function(t1, e, r) {
                return t1[0] = e[0] * r, t1[1] = e[1] * r, t1[2] = e[2] * r, t1[3] = e[3] * r, t1[4] = e[4] * r, t1[5] = e[5] * r, t1[6] = e[6] * r, t1[7] = e[7] * r, t1;
            }, z.lerp = function(t1, e, r, n) {
                var i = 1 - n;
                return c(e, r) < 0 && (n = -n), t1[0] = e[0] * i + r[0] * n, t1[1] = e[1] * i + r[1] * n, t1[2] = e[2] * i + r[2] * n, t1[3] = e[3] * i + r[3] * n, t1[4] = e[4] * i + r[4] * n, t1[5] = e[5] * i + r[5] * n, t1[6] = e[6] * i + r[6] * n, t1[7] = e[7] * i + r[7] * n, t1;
            }, z.invert = function(t1, e) {
                var r = p(e);
                return t1[0] = -e[0] / r, t1[1] = -e[1] / r, t1[2] = -e[2] / r, t1[3] = e[3] / r, t1[4] = -e[4] / r, t1[5] = -e[5] / r, t1[6] = -e[6] / r, t1[7] = e[7] / r, t1;
            }, z.conjugate = function(t1, e) {
                return t1[0] = -e[0], t1[1] = -e[1], t1[2] = -e[2], t1[3] = e[3], t1[4] = -e[4], t1[5] = -e[5], t1[6] = -e[6], t1[7] = e[7], t1;
            }, z.normalize = function(t1, e) {
                var r = p(e);
                if (r > 0) {
                    r = Math.sqrt(r);
                    var n = e[0] / r, i = e[1] / r, a = e[2] / r, s = e[3] / r, o = e[4], l = e[5], u = e[6], c = e[7], h = n * o + i * l + a * u + s * c;
                    t1[0] = n, t1[1] = i, t1[2] = a, t1[3] = s, t1[4] = (o - n * h) / r, t1[5] = (l - i * h) / r, t1[6] = (u - a * h) / r, t1[7] = (c - s * h) / r;
                }
                return t1;
            }, z.str = function(t1) {
                return "quat2(" + t1[0] + ", " + t1[1] + ", " + t1[2] + ", " + t1[3] + ", " + t1[4] + ", " + t1[5] + ", " + t1[6] + ", " + t1[7] + ")";
            }, z.exactEquals = function(t1, e) {
                return t1[0] === e[0] && t1[1] === e[1] && t1[2] === e[2] && t1[3] === e[3] && t1[4] === e[4] && t1[5] === e[5] && t1[6] === e[6] && t1[7] === e[7];
            }, z.equals = function(t1, r) {
                var n = t1[0], i = t1[1], a = t1[2], s = t1[3], o = t1[4], l = t1[5], u = t1[6], c = t1[7], h = r[0], p = r[1], f = r[2], d = r[3], m = r[4], y = r[5], g = r[6], x = r[7];
                return Math.abs(n - h) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(h)) && Math.abs(i - p) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(p)) && Math.abs(a - f) <= e.EPSILON * Math.max(1, Math.abs(a), Math.abs(f)) && Math.abs(s - d) <= e.EPSILON * Math.max(1, Math.abs(s), Math.abs(d)) && Math.abs(o - m) <= e.EPSILON * Math.max(1, Math.abs(o), Math.abs(m)) && Math.abs(l - y) <= e.EPSILON * Math.max(1, Math.abs(l), Math.abs(y)) && Math.abs(u - g) <= e.EPSILON * Math.max(1, Math.abs(u), Math.abs(g)) && Math.abs(c - x) <= e.EPSILON * Math.max(1, Math.abs(c), Math.abs(x));
            }, z.sqrLen = z.squaredLength = z.len = z.length = z.dot = z.mul = z.setReal = z.getReal = void 0;
            var e = s(a()), r = s(I()), n = s(g());
            function i(t1) {
                if ("function" != typeof WeakMap) return null;
                var e = new WeakMap, r = new WeakMap;
                return (i = function(t1) {
                    return t1 ? r : e;
                })(t1);
            }
            function s(e, r) {
                if (e && e.__esModule) return e;
                if (null === e || "object" !== t1(e) && "function" != typeof e) return {
                    default: e
                };
                var n = i(r);
                if (n && n.has(e)) return n.get(e);
                var a = {}, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var o in e)if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                    var l = s ? Object.getOwnPropertyDescriptor(e, o) : null;
                    l && (l.get || l.set) ? Object.defineProperty(a, o, l) : a[o] = e[o];
                }
                return a.default = e, n && n.set(e, a), a;
            }
            function o(t1, e, r) {
                var n = .5 * r[0], i = .5 * r[1], a = .5 * r[2], s = e[0], o = e[1], l = e[2], u = e[3];
                return t1[0] = s, t1[1] = o, t1[2] = l, t1[3] = u, t1[4] = n * u + i * l - a * o, t1[5] = i * u + a * s - n * l, t1[6] = a * u + n * o - i * s, t1[7] = -n * s - i * o - a * l, t1;
            }
            function l(t1, e) {
                return t1[0] = e[0], t1[1] = e[1], t1[2] = e[2], t1[3] = e[3], t1[4] = e[4], t1[5] = e[5], t1[6] = e[6], t1[7] = e[7], t1;
            }
            function u(t1, e, r) {
                var n = e[0], i = e[1], a = e[2], s = e[3], o = r[4], l = r[5], u = r[6], c = r[7], h = e[4], p = e[5], f = e[6], d = e[7], m = r[0], y = r[1], g = r[2], x = r[3];
                return t1[0] = n * x + s * m + i * g - a * y, t1[1] = i * x + s * y + a * m - n * g, t1[2] = a * x + s * g + n * y - i * m, t1[3] = s * x - n * m - i * y - a * g, t1[4] = n * c + s * o + i * u - a * l + h * x + d * m + p * g - f * y, t1[5] = i * c + s * l + a * o - n * u + p * x + d * y + f * m - h * g, t1[6] = a * c + s * u + n * l - i * o + f * x + d * g + h * y - p * m, t1[7] = s * c - n * o - i * l - a * u + d * x - h * m - p * y - f * g, t1;
            }
            z.getReal = r.copy, z.setReal = r.copy, z.mul = u;
            var c = r.dot;
            z.dot = c;
            var h = r.length;
            z.length = h, z.len = h;
            var p = r.squaredLength;
            return z.squaredLength = p, z.sqrLen = p, z;
        }
        var k, T, B = {};
        function V() {
            if (k) return B;
            function t1(e) {
                return t1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                }, t1(e);
            }
            k = 1, Object.defineProperty(B, "__esModule", {
                value: !0
            }), B.create = n, B.clone = function(t1) {
                var r = new e.ARRAY_TYPE(2);
                return r[0] = t1[0], r[1] = t1[1], r;
            }, B.fromValues = function(t1, r) {
                var n = new e.ARRAY_TYPE(2);
                return n[0] = t1, n[1] = r, n;
            }, B.copy = function(t1, e) {
                return t1[0] = e[0], t1[1] = e[1], t1;
            }, B.set = function(t1, e, r) {
                return t1[0] = e, t1[1] = r, t1;
            }, B.add = function(t1, e, r) {
                return t1[0] = e[0] + r[0], t1[1] = e[1] + r[1], t1;
            }, B.subtract = i, B.multiply = s, B.divide = o, B.ceil = function(t1, e) {
                return t1[0] = Math.ceil(e[0]), t1[1] = Math.ceil(e[1]), t1;
            }, B.floor = function(t1, e) {
                return t1[0] = Math.floor(e[0]), t1[1] = Math.floor(e[1]), t1;
            }, B.min = function(t1, e, r) {
                return t1[0] = Math.min(e[0], r[0]), t1[1] = Math.min(e[1], r[1]), t1;
            }, B.max = function(t1, e, r) {
                return t1[0] = Math.max(e[0], r[0]), t1[1] = Math.max(e[1], r[1]), t1;
            }, B.round = function(t1, e) {
                return t1[0] = Math.round(e[0]), t1[1] = Math.round(e[1]), t1;
            }, B.scale = function(t1, e, r) {
                return t1[0] = e[0] * r, t1[1] = e[1] * r, t1;
            }, B.scaleAndAdd = function(t1, e, r, n) {
                return t1[0] = e[0] + r[0] * n, t1[1] = e[1] + r[1] * n, t1;
            }, B.distance = l, B.squaredDistance = u, B.length = c, B.squaredLength = h, B.negate = function(t1, e) {
                return t1[0] = -e[0], t1[1] = -e[1], t1;
            }, B.inverse = function(t1, e) {
                return t1[0] = 1 / e[0], t1[1] = 1 / e[1], t1;
            }, B.normalize = function(t1, e) {
                var r = e[0], n = e[1], i = r * r + n * n;
                return i > 0 && (i = 1 / Math.sqrt(i)), t1[0] = e[0] * i, t1[1] = e[1] * i, t1;
            }, B.dot = function(t1, e) {
                return t1[0] * e[0] + t1[1] * e[1];
            }, B.cross = function(t1, e, r) {
                var n = e[0] * r[1] - e[1] * r[0];
                return t1[0] = t1[1] = 0, t1[2] = n, t1;
            }, B.lerp = function(t1, e, r, n) {
                var i = e[0], a = e[1];
                return t1[0] = i + n * (r[0] - i), t1[1] = a + n * (r[1] - a), t1;
            }, B.random = function(t1, r) {
                r = r || 1;
                var n = 2 * e.RANDOM() * Math.PI;
                return t1[0] = Math.cos(n) * r, t1[1] = Math.sin(n) * r, t1;
            }, B.transformMat2 = function(t1, e, r) {
                var n = e[0], i = e[1];
                return t1[0] = r[0] * n + r[2] * i, t1[1] = r[1] * n + r[3] * i, t1;
            }, B.transformMat2d = function(t1, e, r) {
                var n = e[0], i = e[1];
                return t1[0] = r[0] * n + r[2] * i + r[4], t1[1] = r[1] * n + r[3] * i + r[5], t1;
            }, B.transformMat3 = function(t1, e, r) {
                var n = e[0], i = e[1];
                return t1[0] = r[0] * n + r[3] * i + r[6], t1[1] = r[1] * n + r[4] * i + r[7], t1;
            }, B.transformMat4 = function(t1, e, r) {
                var n = e[0], i = e[1];
                return t1[0] = r[0] * n + r[4] * i + r[12], t1[1] = r[1] * n + r[5] * i + r[13], t1;
            }, B.rotate = function(t1, e, r, n) {
                var i = e[0] - r[0], a = e[1] - r[1], s = Math.sin(n), o = Math.cos(n);
                return t1[0] = i * o - a * s + r[0], t1[1] = i * s + a * o + r[1], t1;
            }, B.angle = function(t1, e) {
                var r = t1[0], n = t1[1], i = e[0], a = e[1], s = Math.sqrt(r * r + n * n) * Math.sqrt(i * i + a * a);
                return Math.acos(Math.min(Math.max(s && (r * i + n * a) / s, -1), 1));
            }, B.zero = function(t1) {
                return t1[0] = 0, t1[1] = 0, t1;
            }, B.str = function(t1) {
                return "vec2(" + t1[0] + ", " + t1[1] + ")";
            }, B.exactEquals = function(t1, e) {
                return t1[0] === e[0] && t1[1] === e[1];
            }, B.equals = function(t1, r) {
                var n = t1[0], i = t1[1], a = r[0], s = r[1];
                return Math.abs(n - a) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - s) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(s));
            }, B.forEach = B.sqrLen = B.sqrDist = B.dist = B.div = B.mul = B.sub = B.len = void 0;
            var e = function(e, n) {
                if (e && e.__esModule) return e;
                if (null === e || "object" !== t1(e) && "function" != typeof e) return {
                    default: e
                };
                var i = r(void 0);
                if (i && i.has(e)) return i.get(e);
                var a = {}, s = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var o in e)if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
                    var l = s ? Object.getOwnPropertyDescriptor(e, o) : null;
                    l && (l.get || l.set) ? Object.defineProperty(a, o, l) : a[o] = e[o];
                }
                return a.default = e, i && i.set(e, a), a;
            }(a());
            function r(t1) {
                if ("function" != typeof WeakMap) return null;
                var e = new WeakMap, n = new WeakMap;
                return (r = function(t1) {
                    return t1 ? n : e;
                })(t1);
            }
            function n() {
                var t1 = new e.ARRAY_TYPE(2);
                return e.ARRAY_TYPE != Float32Array && (t1[0] = 0, t1[1] = 0), t1;
            }
            function i(t1, e, r) {
                return t1[0] = e[0] - r[0], t1[1] = e[1] - r[1], t1;
            }
            function s(t1, e, r) {
                return t1[0] = e[0] * r[0], t1[1] = e[1] * r[1], t1;
            }
            function o(t1, e, r) {
                return t1[0] = e[0] / r[0], t1[1] = e[1] / r[1], t1;
            }
            function l(t1, e) {
                return Math.hypot(e[0] - t1[0], e[1] - t1[1]);
            }
            function u(t1, e) {
                var r = e[0] - t1[0], n = e[1] - t1[1];
                return r * r + n * n;
            }
            function c(t1) {
                return Math.hypot(t1[0], t1[1]);
            }
            function h(t1) {
                var e = t1[0], r = t1[1];
                return e * e + r * r;
            }
            B.len = c, B.sub = i, B.mul = s, B.div = o, B.dist = l, B.sqrDist = u, B.sqrLen = h;
            var p, f = (p = n(), function(t1, e, r, n, i, a) {
                var s, o;
                for(e || (e = 2), r || (r = 0), o = n ? Math.min(n * e + r, t1.length) : t1.length, s = r; s < o; s += e)p[0] = t1[s], p[1] = t1[s + 1], i(p, p, a), t1[s] = p[0], t1[s + 1] = p[1];
                return t1;
            });
            return B.forEach = f, B;
        }
        function C() {
            if (T) return n;
            function t1(e) {
                return t1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t1) {
                    return typeof t1;
                } : function(t1) {
                    return t1 && "function" == typeof Symbol && t1.constructor === Symbol && t1 !== Symbol.prototype ? "symbol" : typeof t1;
                }, t1(e);
            }
            T = 1, Object.defineProperty(n, "__esModule", {
                value: !0
            }), n.vec4 = n.vec3 = n.vec2 = n.quat2 = n.quat = n.mat4 = n.mat3 = n.mat2d = n.mat2 = n.glMatrix = void 0;
            var e = x(a());
            n.glMatrix = e;
            var r = x(l());
            n.mat2 = r;
            var i = x(h());
            n.mat2d = i;
            var s = x(d());
            n.mat3 = s;
            var o = x(g());
            n.mat4 = o;
            var u = x(I());
            n.quat = u;
            var c = x(E());
            n.quat2 = c;
            var p = x(V());
            n.vec2 = p;
            var f = x(_());
            n.vec3 = f;
            var m = x(S());
            function y(t1) {
                if ("function" != typeof WeakMap) return null;
                var e = new WeakMap, r = new WeakMap;
                return (y = function(t1) {
                    return t1 ? r : e;
                })(t1);
            }
            function x(e, r) {
                if (e && e.__esModule) return e;
                if (null === e || "object" !== t1(e) && "function" != typeof e) return {
                    default: e
                };
                var n = y(r);
                if (n && n.has(e)) return n.get(e);
                var i = {}, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for(var s in e)if ("default" !== s && Object.prototype.hasOwnProperty.call(e, s)) {
                    var o = a ? Object.getOwnPropertyDescriptor(e, s) : null;
                    o && (o.get || o.set) ? Object.defineProperty(i, s, o) : i[s] = e[s];
                }
                return i.default = e, n && n.set(e, i), i;
            }
            return n.vec4 = m, n;
        }
        var D, L, R, F, O = C(), N = function() {
            if (L) return D;
            function t1(t1, e, r, n) {
                this.cx = 3 * t1, this.bx = 3 * (r - t1) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t1, this.p1y = e, this.p2x = r, this.p2y = n;
            }
            return L = 1, D = t1, t1.prototype = {
                sampleCurveX: function(t1) {
                    return ((this.ax * t1 + this.bx) * t1 + this.cx) * t1;
                },
                sampleCurveY: function(t1) {
                    return ((this.ay * t1 + this.by) * t1 + this.cy) * t1;
                },
                sampleCurveDerivativeX: function(t1) {
                    return (3 * this.ax * t1 + 2 * this.bx) * t1 + this.cx;
                },
                solveCurveX: function(t1, e) {
                    if (void 0 === e && (e = 1e-6), t1 < 0) return 0;
                    if (t1 > 1) return 1;
                    for(var r = t1, n = 0; n < 8; n++){
                        var i = this.sampleCurveX(r) - t1;
                        if (Math.abs(i) < e) return r;
                        var a = this.sampleCurveDerivativeX(r);
                        if (Math.abs(a) < 1e-6) break;
                        r -= i / a;
                    }
                    var s = 0, o = 1;
                    for(r = t1, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t1) < e)); n++)t1 > i ? s = r : o = r, r = .5 * (o - s) + s;
                    return r;
                },
                solve: function(t1, e) {
                    return this.sampleCurveY(this.solveCurveX(t1, e));
                }
            }, D;
        }(), U = e(N);
        function j() {
            if (F) return R;
            function t1(t1, e) {
                this.x = t1, this.y = e;
            }
            return F = 1, R = t1, t1.prototype = {
                clone: function() {
                    return new t1(this.x, this.y);
                },
                add: function(t1) {
                    return this.clone()._add(t1);
                },
                sub: function(t1) {
                    return this.clone()._sub(t1);
                },
                multByPoint: function(t1) {
                    return this.clone()._multByPoint(t1);
                },
                divByPoint: function(t1) {
                    return this.clone()._divByPoint(t1);
                },
                mult: function(t1) {
                    return this.clone()._mult(t1);
                },
                div: function(t1) {
                    return this.clone()._div(t1);
                },
                rotate: function(t1) {
                    return this.clone()._rotate(t1);
                },
                rotateAround: function(t1, e) {
                    return this.clone()._rotateAround(t1, e);
                },
                matMult: function(t1) {
                    return this.clone()._matMult(t1);
                },
                unit: function() {
                    return this.clone()._unit();
                },
                perp: function() {
                    return this.clone()._perp();
                },
                round: function() {
                    return this.clone()._round();
                },
                mag: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y);
                },
                equals: function(t1) {
                    return this.x === t1.x && this.y === t1.y;
                },
                dist: function(t1) {
                    return Math.sqrt(this.distSqr(t1));
                },
                distSqr: function(t1) {
                    var e = t1.x - this.x, r = t1.y - this.y;
                    return e * e + r * r;
                },
                angle: function() {
                    return Math.atan2(this.y, this.x);
                },
                angleTo: function(t1) {
                    return Math.atan2(this.y - t1.y, this.x - t1.x);
                },
                angleWith: function(t1) {
                    return this.angleWithSep(t1.x, t1.y);
                },
                angleWithSep: function(t1, e) {
                    return Math.atan2(this.x * e - this.y * t1, this.x * t1 + this.y * e);
                },
                _matMult: function(t1) {
                    var e = t1[2] * this.x + t1[3] * this.y;
                    return this.x = t1[0] * this.x + t1[1] * this.y, this.y = e, this;
                },
                _add: function(t1) {
                    return this.x += t1.x, this.y += t1.y, this;
                },
                _sub: function(t1) {
                    return this.x -= t1.x, this.y -= t1.y, this;
                },
                _mult: function(t1) {
                    return this.x *= t1, this.y *= t1, this;
                },
                _div: function(t1) {
                    return this.x /= t1, this.y /= t1, this;
                },
                _multByPoint: function(t1) {
                    return this.x *= t1.x, this.y *= t1.y, this;
                },
                _divByPoint: function(t1) {
                    return this.x /= t1.x, this.y /= t1.y, this;
                },
                _unit: function() {
                    return this._div(this.mag()), this;
                },
                _perp: function() {
                    var t1 = this.y;
                    return this.y = this.x, this.x = -t1, this;
                },
                _rotate: function(t1) {
                    var e = Math.cos(t1), r = Math.sin(t1), n = r * this.x + e * this.y;
                    return this.x = e * this.x - r * this.y, this.y = n, this;
                },
                _rotateAround: function(t1, e) {
                    var r = Math.cos(t1), n = Math.sin(t1), i = e.y + n * (this.x - e.x) + r * (this.y - e.y);
                    return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;
                },
                _round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
                }
            }, t1.convert = function(e) {
                return e instanceof t1 ? e : Array.isArray(e) ? new t1(e[0], e[1]) : e;
            }, R;
        }
        var q = e(j());
        function $(t1, e) {
            if (Array.isArray(t1)) {
                if (!Array.isArray(e) || t1.length !== e.length) return !1;
                for(let r = 0; r < t1.length; r++)if (!$(t1[r], e[r])) return !1;
                return !0;
            }
            if ("object" == typeof t1 && null !== t1 && null !== e) {
                if ("object" != typeof e) return !1;
                if (Object.keys(t1).length !== Object.keys(e).length) return !1;
                for(const r in t1)if (!$(t1[r], e[r])) return !1;
                return !0;
            }
            return t1 === e;
        }
        const G = Math.PI / 180, Y = 180 / Math.PI;
        function X(t1) {
            return t1 * G;
        }
        function Z(t1) {
            return t1 * Y;
        }
        const H = [
            [
                0,
                0
            ],
            [
                1,
                0
            ],
            [
                1,
                1
            ],
            [
                0,
                1
            ]
        ];
        function W(t1) {
            if (t1 <= 0) return 0;
            if (t1 >= 1) return 1;
            const e = t1 * t1, r = e * t1;
            return 4 * (t1 < .5 ? r : 3 * (t1 - e) + r - .75);
        }
        function K(t1, e, r, n) {
            const i = new U(t1, e, r, n);
            return function(t1) {
                return i.solve(t1);
            };
        }
        const J = K(.25, .1, .25, 1);
        function Q(t1, e, r) {
            return Math.min(r, Math.max(e, t1));
        }
        function tt(t1, e, r) {
            return (r = Q((r - t1) / (e - t1), 0, 1)) * r * (3 - 2 * r);
        }
        function et(t1, e, r) {
            const n = r - e, i = ((t1 - e) % n + n) % n + e;
            return i === e ? r : i;
        }
        function rt(t1, e, r) {
            if (!t1.length) return r(null, []);
            let n = t1.length;
            const i = new Array(t1.length);
            let a = null;
            t1.forEach((t1, s)=>{
                e(t1, (t1, e)=>{
                    t1 && (a = t1), i[s] = e, 0 == --n && r(a, i);
                });
            });
        }
        function nt(t1, ...e) {
            for (const r of e)for(const e in r)t1[e] = r[e];
            return t1;
        }
        let it = 1;
        function at() {
            return it++;
        }
        function st(t1) {
            return t1 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t1) / Math.LN2));
        }
        function ot(t1, e) {
            t1.forEach((t1)=>{
                e[t1] && (e[t1] = e[t1].bind(e));
            });
        }
        function lt(t1, e) {
            return -1 !== t1.indexOf(e, t1.length - e.length);
        }
        function ut(t1, e, r) {
            const n = {};
            for(const r in t1)n[r] = e.call(this, t1[r], r, t1);
            return n;
        }
        function ct(t1, e, r) {
            const n = {};
            for(const r in t1)e.call(this, t1[r], r, t1) && (n[r] = t1[r]);
            return n;
        }
        function ht(t1) {
            return Array.isArray(t1) ? t1.map(ht) : "object" == typeof t1 && t1 ? ut(t1, ht) : t1;
        }
        const pt = {};
        function ft(t1) {
            pt[t1] || ("undefined" != typeof console && console.warn(t1), pt[t1] = !0);
        }
        function dt(t1, e, r) {
            return (r.y - t1.y) * (e.x - t1.x) > (e.y - t1.y) * (r.x - t1.x);
        }
        function mt(t1) {
            let e = 0;
            for(let r, n, i = 0, a = t1.length, s = a - 1; i < a; s = i++)r = t1[i], n = t1[s], e += (n.x - r.x) * (r.y + n.y);
            return e;
        }
        function yt([t1, e, r]) {
            const n = X(e + 90), i = X(r);
            return {
                x: t1 * Math.cos(n) * Math.sin(i),
                y: t1 * Math.sin(n) * Math.sin(i),
                z: t1 * Math.cos(i),
                azimuthal: e,
                polar: r
            };
        }
        function gt() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
        }
        function xt(t1) {
            const e = {};
            if (t1.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t1, r, n, i)=>{
                const a = n || i;
                return e[r] = !a || a.toLowerCase(), "";
            }), e["max-age"]) {
                const t1 = parseInt(e["max-age"], 10);
                isNaN(t1) ? delete e["max-age"] : e["max-age"] = t1;
            }
            return e;
        }
        let vt = null;
        function bt(t1, e) {
            return [
                t1[4 * e],
                t1[4 * e + 1],
                t1[4 * e + 2],
                t1[4 * e + 3]
            ];
        }
        function _t(t1, e, r, n) {
            for(; e < r;){
                const i = e + r >> 1;
                t1[i] < n ? e = i + 1 : r = i;
            }
            return e;
        }
        function wt(t1, e, r, n) {
            for(; e < r;){
                const i = e + r >> 1;
                t1[i] <= n ? e = i + 1 : r = i;
            }
            return e;
        }
        function Mt(t1) {
            return t1 > 0 ? 1 / (1.001 - t1) : 1 + t1;
        }
        function At(t1) {
            return t1 > 0 ? 1 - 1 / (1.001 - t1) : -t1;
        }
        const St = {
            API_URL: "https://api.mapbox.com",
            get API_URL_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
            },
            get API_TILEJSON_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
            },
            get API_SPRITE_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
            },
            get API_FONTS_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
            },
            get API_STYLE_REGEX () {
                return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
            },
            get API_CDN_URL_REGEX () {
                return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
            },
            get EVENTS_URL () {
                if (!St.API_URL) return null;
                try {
                    const t1 = new URL(St.API_URL);
                    return "api.mapbox.cn" === t1.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t1.hostname ? "https://events.mapbox.com/events/v2" : null;
                } catch (t1) {
                    return null;
                }
            },
            SESSION_PATH: "/map-sessions/v1",
            FEEDBACK_URL: "https://apps.mapbox.com/feedback",
            TILE_URL_VERSION: "v4",
            RASTER_URL_PREFIX: "raster/v1",
            RASTERARRAYS_URL_PREFIX: "rasterarrays/v1",
            REQUIRE_ACCESS_TOKEN: !0,
            ACCESS_TOKEN: null,
            DEFAULT_STYLE: "mapbox://styles/mapbox/standard",
            MAX_PARALLEL_IMAGE_REQUESTS: 16,
            DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm",
            MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm",
            MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm",
            GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf",
            TILES3D_URL_PREFIX: "3dtiles/v1"
        };
        function It(t1) {
            return St.API_URL_REGEX.test(t1);
        }
        function Pt(t1) {
            return St.API_SPRITE_REGEX.test(t1);
        }
        let zt, Et, kt, Tt, Bt, Vt;
        function Ct() {
            return null == zt && (zt = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof self.createImageBitmap), zt;
        }
        const Dt = {
            now: ()=>void 0 !== Tt ? Tt : performance.now(),
            setNow (t1) {
                Tt = t1;
            },
            restoreNow () {
                Tt = void 0;
            },
            frame (t1) {
                const e = requestAnimationFrame(t1);
                return {
                    cancel: ()=>cancelAnimationFrame(e)
                };
            },
            getImageData (t1, e = 0) {
                const { width: r, height: n } = t1;
                Bt || (Bt = document.createElement("canvas"));
                const i = Bt.getContext("2d", {
                    willReadFrequently: !0
                });
                if (!i) throw new Error("failed to create canvas 2d context");
                return (r > Bt.width || n > Bt.height) && (Bt.width = r, Bt.height = n), i.clearRect(-e, -e, r + 2 * e, n + 2 * e), i.drawImage(t1, 0, 0, r, n), i.getImageData(-e, -e, r + 2 * e, n + 2 * e);
            },
            resolveURL: (t1)=>(Et || (Et = document.createElement("a")), Et.href = t1, Et.href),
            get devicePixelRatio () {
                return window.devicePixelRatio;
            },
            get prefersReducedMotion () {
                return !!window.matchMedia && (null == kt && (kt = window.matchMedia("(prefers-reduced-motion: reduce)")), kt.matches);
            },
            hasCanvasFingerprintNoise () {
                if (void 0 !== Vt) return Vt;
                if (!Ct()) return Vt = !1, !1;
                const t1 = new OffscreenCanvas(85, 1), e = t1.getContext("2d", {
                    willReadFrequently: !0
                });
                let r = 0;
                for(let n = 0; n < t1.width; ++n)e.fillStyle = `rgba(${r++},${r++},${r++}, 255)`, e.fillRect(n, 0, 1, 1);
                const n = e.getImageData(0, 0, t1.width, t1.height);
                r = 0;
                for(let t1 = 0; t1 < n.data.length; ++t1)if (t1 % 4 != 3 && r++ !== n.data[t1]) return Vt = !0, !0;
                return Vt = !1, !1;
            }
        };
        function Lt(t1, e) {
            const r = t1.indexOf("?");
            if (r < 0) return `${t1}?${new URLSearchParams(e).toString()}`;
            const n = new URLSearchParams(t1.slice(r));
            for(const t1 in e)n.set(t1, e[t1]);
            return `${t1.slice(0, r)}?${n.toString()}`;
        }
        function Rt(t1, e = {
            persistentParams: []
        }) {
            const r = t1.indexOf("?");
            if (r < 0) return t1;
            const n = new URLSearchParams, i = new URLSearchParams(t1.slice(r));
            for (const t1 of e.persistentParams){
                const e = i.get(t1);
                e && n.set(t1, e);
            }
            const a = n.toString();
            return `${t1.slice(0, r)}${a.length > 0 ? `?${a}` : ""}`;
        }
        const Ft = "mapbox-tiles";
        let Ot = 500, Nt = 50;
        const Ut = [
            "language",
            "worldview",
            "jobid"
        ];
        let jt, qt;
        function $t() {
            try {
                return caches;
            } catch (t1) {}
        }
        function Gt() {
            const t1 = $t();
            t1 && null == jt && (jt = t1.open(Ft));
        }
        let Yt = 1 / 0;
        const Xt = {
            supported: !1,
            testSupport: function(t1) {
                !Wt && Ht && (Kt ? Qt(t1) : Zt = t1);
            }
        };
        let Zt, Ht, Wt = !1, Kt = !1;
        const Jt = "undefined" != typeof self ? self : {};
        function Qt(t1) {
            const e = t1.createTexture();
            t1.bindTexture(t1.TEXTURE_2D, e);
            try {
                if (t1.texImage2D(t1.TEXTURE_2D, 0, t1.RGBA, t1.RGBA, t1.UNSIGNED_BYTE, Ht), t1.isContextLost()) return;
                Xt.supported = !0;
            } catch (t1) {}
            t1.deleteTexture(e), Wt = !0;
        }
        Jt.document && (Ht = Jt.document.createElement("img"), Ht.onload = function() {
            Zt && Qt(Zt), Zt = null, Kt = !0;
        }, Ht.onerror = function() {
            Wt = !0, Zt = null;
        }, Ht.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
        const te = {
            Unknown: "Unknown",
            Style: "Style",
            Source: "Source",
            Tile: "Tile",
            Glyphs: "Glyphs",
            SpriteImage: "SpriteImage",
            SpriteJSON: "SpriteJSON",
            Iconset: "Iconset",
            Image: "Image",
            Model: "Model"
        };
        "function" == typeof Object.freeze && Object.freeze(te);
        class ee extends Error {
            constructor(t1, e, r){
                401 === e && It(r) && (t1 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t1), this.status = e, this.url = r;
            }
            toString() {
                return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
            }
        }
        const re = gt() ? ()=>self.worker && self.worker.referrer : ()=>("blob:" === location.protocol ? parent : self).location.href;
        const ne = function(t1, e) {
            if (!(/^file:/.test(r = t1.url) || /^file:/.test(re()) && !/^\w+:/.test(r))) {
                if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal")) return function(t1, e) {
                    const r = new AbortController, n = new Request(t1.url, {
                        method: t1.method || "GET",
                        body: t1.body,
                        credentials: t1.credentials,
                        headers: t1.headers,
                        referrer: re(),
                        referrerPolicy: t1.referrerPolicy,
                        signal: r.signal
                    });
                    let i = !1, a = !1;
                    const s = (o = n.url).indexOf("sku=") > 0 && It(o);
                    var o;
                    "json" === t1.type && n.headers.set("Accept", "application/json");
                    const l = (r, i, o)=>{
                        if (a) return;
                        if (r && "SecurityError" !== r.message && ft(r.toString()), i && o) return u(i);
                        const l = Date.now();
                        fetch(n).then((r)=>{
                            if (r.ok) {
                                const t1 = s ? r.clone() : null;
                                return u(r, t1, l);
                            }
                            return e(new ee(r.statusText, r.status, t1.url));
                        }).catch((r)=>{
                            "AbortError" !== r.name && e(new Error(`${r.message} ${t1.url}`));
                        });
                    }, u = (r, s, o)=>{
                        ("arrayBuffer" === t1.type ? r.arrayBuffer() : "json" === t1.type ? r.json() : r.text()).then((t1)=>{
                            a || (s && o && function(t1, e, r) {
                                if (Gt(), null == jt) return;
                                const n = xt(e.headers.get("Cache-Control") || "");
                                if (n["no-store"]) return;
                                const i = {
                                    status: e.status,
                                    statusText: e.statusText,
                                    headers: new Headers
                                };
                                e.headers.forEach((t1, e)=>i.headers.set(e, t1)), n["max-age"] && i.headers.set("Expires", new Date(r + 1e3 * n["max-age"]).toUTCString());
                                const a = i.headers.get("Expires");
                                if (!a) return;
                                if (new Date(a).getTime() - r < 42e4) return;
                                let s = Rt(t1.url, {
                                    persistentParams: Ut
                                });
                                if (206 === e.status) {
                                    const e = t1.headers.get("Range");
                                    if (!e) return;
                                    i.status = 200, s = Lt(s, {
                                        range: e
                                    });
                                }
                                !function(t1, e) {
                                    if (void 0 === qt) try {
                                        new Response(new ReadableStream), qt = !0;
                                    } catch (t1) {
                                        qt = !1;
                                    }
                                    qt ? e(t1.body) : t1.blob().then(e);
                                }(e, (t1)=>{
                                    const r = new Response(200 !== (n = e.status) && 404 !== n && [
                                        101,
                                        103,
                                        204,
                                        205,
                                        304
                                    ].includes(n) ? null : t1, i);
                                    var n;
                                    Gt(), null != jt && jt.then((t1)=>t1.put(s, r)).catch((t1)=>ft(t1.message));
                                });
                            }(n, s, o), i = !0, e(null, t1, r.headers.get("Cache-Control"), r.headers.get("Expires")));
                        }).catch((t1)=>{
                            a || e(new Error(t1.message));
                        });
                    };
                    return s ? function(t1, e) {
                        if (Gt(), null == jt) return e(null);
                        jt.then((r)=>{
                            let n = Rt(t1.url, {
                                persistentParams: Ut
                            });
                            const i = t1.headers.get("Range");
                            i && (n = Lt(n, {
                                range: i
                            })), r.match(n).then((t1)=>{
                                const i = function(t1) {
                                    if (!t1) return !1;
                                    const e = new Date(t1.headers.get("Expires") || 0), r = xt(t1.headers.get("Cache-Control") || "");
                                    return e > Date.now() && !r["no-cache"];
                                }(t1);
                                r.delete(n), i && r.put(n, t1.clone()), e(null, t1, i);
                            }).catch(e);
                        }).catch(e);
                    }(n, l) : l(null, null), {
                        cancel: ()=>{
                            a = !0, i || r.abort();
                        }
                    };
                }(t1, e);
                if (gt() && self.worker && self.worker.actor) return self.worker.actor.send("getResource", t1, e, void 0, !0);
            }
            var r;
            return function(t1, e) {
                const r = new XMLHttpRequest;
                r.open(t1.method || "GET", t1.url, !0), "arrayBuffer" === t1.type && (r.responseType = "arraybuffer");
                for(const e in t1.headers)r.setRequestHeader(e, t1.headers[e]);
                return "json" === t1.type && (r.responseType = "text", r.setRequestHeader("Accept", "application/json")), r.withCredentials = "include" === t1.credentials, r.onerror = ()=>{
                    e(new Error(r.statusText));
                }, r.onload = ()=>{
                    if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {
                        let n = r.response;
                        if ("json" === t1.type) try {
                            n = JSON.parse(r.response);
                        } catch (t1) {
                            return e(t1);
                        }
                        e(null, n, r.getResponseHeader("Cache-Control"), r.getResponseHeader("Expires"));
                    } else e(new ee(r.statusText, r.status, t1.url));
                }, r.send(t1.body), {
                    cancel: ()=>r.abort()
                };
            }(t1, e);
        }, ie = function(t1, e) {
            return ne(nt(t1, {
                type: "arrayBuffer"
            }), e);
        };
        function ae(t1) {
            const e = document.createElement("a");
            return e.href = t1, e.protocol === location.protocol && e.host === location.host;
        }
        const se = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        let oe, le;
        oe = [], le = 0;
        const ue = function(t1, e) {
            if (Xt.supported && (t1.headers || (t1.headers = {}), t1.headers.accept = "image/webp,*/*"), le >= St.MAX_PARALLEL_IMAGE_REQUESTS) {
                const r = {
                    requestParameters: t1,
                    callback: e,
                    cancelled: !1,
                    cancel () {
                        this.cancelled = !0;
                    }
                };
                return oe.push(r), r;
            }
            le++;
            let r = !1;
            const n = ()=>{
                if (!r) for(r = !0, le--; oe.length && le < St.MAX_PARALLEL_IMAGE_REQUESTS;){
                    const t1 = oe.shift(), { requestParameters: e, callback: r, cancelled: n } = t1;
                    n || (t1.cancel = ue(e, r).cancel);
                }
            }, i = ie(t1, (t1, r, i, a)=>{
                n(), t1 ? e(t1) : r && (self.createImageBitmap ? function(t1, e) {
                    const r = new Blob([
                        new Uint8Array(t1)
                    ], {
                        type: "image/png"
                    });
                    createImageBitmap(r).then((t1)=>{
                        e(null, t1);
                    }).catch((t1)=>{
                        e(new Error(`Could not load image because of ${t1.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                    });
                }(r, (t1, r)=>e(t1, r, i, a)) : function(t1, e) {
                    const r = new Image;
                    r.onload = ()=>{
                        e(null, r), URL.revokeObjectURL(r.src), r.onload = null, requestAnimationFrame(()=>{
                            r.src = se;
                        });
                    }, r.onerror = ()=>e(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                    const n = new Blob([
                        new Uint8Array(t1)
                    ], {
                        type: "image/png"
                    });
                    r.src = t1.byteLength ? URL.createObjectURL(n) : se;
                }(r, (t1, r)=>e(t1, r, i, a)));
            });
            return {
                cancel: ()=>{
                    i.cancel(), n();
                }
            };
        };
        var ce, he, pe, fe = {
            exports: {}
        }, de = {
            exports: {}
        }, me = {
            exports: {}
        }, ye = function() {
            if (pe) return fe.exports;
            pe = 1;
            var t1 = (ce || (ce = 1, de.exports = function(t1, e) {
                var r, n, i, a, s, o, l, u;
                for(n = t1.length - (r = 3 & t1.length), i = e, s = 3432918353, o = 461845907, u = 0; u < n;)l = 255 & t1.charCodeAt(u) | (255 & t1.charCodeAt(++u)) << 8 | (255 & t1.charCodeAt(++u)) << 16 | (255 & t1.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (a = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a >>> 16) & 65535) << 16);
                switch(l = 0, r){
                    case 3:
                        l ^= (255 & t1.charCodeAt(u + 2)) << 16;
                    case 2:
                        l ^= (255 & t1.charCodeAt(u + 1)) << 8;
                    case 1:
                        i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t1.charCodeAt(u))) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;
                }
                return i ^= t1.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;
            }), de.exports), e = (he || (he = 1, me.exports = function(t1, e) {
                for(var r, n = t1.length, i = e ^ n, a = 0; n >= 4;)r = 1540483477 * (65535 & (r = 255 & t1.charCodeAt(a) | (255 & t1.charCodeAt(++a)) << 8 | (255 & t1.charCodeAt(++a)) << 16 | (255 & t1.charCodeAt(++a)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++a;
                switch(n){
                    case 3:
                        i ^= (255 & t1.charCodeAt(a + 2)) << 16;
                    case 2:
                        i ^= (255 & t1.charCodeAt(a + 1)) << 8;
                    case 1:
                        i = 1540483477 * (65535 & (i ^= 255 & t1.charCodeAt(a))) + ((1540483477 * (i >>> 16) & 65535) << 16);
                }
                return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;
            }), me.exports);
            return fe.exports = t1, fe.exports.murmur3 = t1, fe.exports.murmur2 = e, fe.exports;
        }(), ge = e(ye);
        class xe {
            constructor(t1, ...e){
                nt(this, e[0] || {}), this.type = t1;
            }
        }
        class ve extends xe {
            constructor(t1, e = {}){
                super("error", nt({
                    error: t1
                }, e));
            }
        }
        function be(t1, e, r) {
            r[t1] && -1 !== r[t1].indexOf(e) || (r[t1] = r[t1] || [], r[t1].push(e));
        }
        function _e(t1, e, r) {
            if (r && r[t1]) {
                const n = r[t1].indexOf(e);
                -1 !== n && r[t1].splice(n, 1);
            }
        }
        class we {
            on(t1, e) {
                return this._listeners = this._listeners || {}, be(t1, e, this._listeners), this;
            }
            off(t1, e) {
                return _e(t1, e, this._listeners), _e(t1, e, this._oneTimeListeners), this;
            }
            once(t1, e) {
                return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, be(t1, e, this._oneTimeListeners), this) : new Promise((e)=>this.once(t1, e));
            }
            fire(t1, e) {
                const r = "string" == typeof t1 ? new xe(t1, e) : t1, n = r.type;
                if (this.listens(n)) {
                    r.target = this;
                    const t1 = this._listeners && this._listeners[n] ? this._listeners[n].slice() : [];
                    for (const e of t1)e.call(this, r);
                    const e = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : [];
                    for (const t1 of e)_e(n, t1, this._oneTimeListeners), t1.call(this, r);
                    const i = this._eventedParent;
                    i && (nt(r, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(r));
                } else r instanceof ve && console.error(r.error);
                return this;
            }
            listens(t1) {
                return !!(this._listeners && this._listeners[t1] && this._listeners[t1].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t1] && this._oneTimeListeners[t1].length > 0 || this._eventedParent && this._eventedParent.listens(t1));
            }
            setEventedParent(t1, e) {
                return this._eventedParent = t1, this._eventedParentData = e, this;
            }
        }
        var Me, Ae = {}, Se = function() {
            if (Me) return Ae;
            Me = 1;
            var t1 = {
                transparent: [
                    0,
                    0,
                    0,
                    0
                ],
                aliceblue: [
                    240,
                    248,
                    255,
                    1
                ],
                antiquewhite: [
                    250,
                    235,
                    215,
                    1
                ],
                aqua: [
                    0,
                    255,
                    255,
                    1
                ],
                aquamarine: [
                    127,
                    255,
                    212,
                    1
                ],
                azure: [
                    240,
                    255,
                    255,
                    1
                ],
                beige: [
                    245,
                    245,
                    220,
                    1
                ],
                bisque: [
                    255,
                    228,
                    196,
                    1
                ],
                black: [
                    0,
                    0,
                    0,
                    1
                ],
                blanchedalmond: [
                    255,
                    235,
                    205,
                    1
                ],
                blue: [
                    0,
                    0,
                    255,
                    1
                ],
                blueviolet: [
                    138,
                    43,
                    226,
                    1
                ],
                brown: [
                    165,
                    42,
                    42,
                    1
                ],
                burlywood: [
                    222,
                    184,
                    135,
                    1
                ],
                cadetblue: [
                    95,
                    158,
                    160,
                    1
                ],
                chartreuse: [
                    127,
                    255,
                    0,
                    1
                ],
                chocolate: [
                    210,
                    105,
                    30,
                    1
                ],
                coral: [
                    255,
                    127,
                    80,
                    1
                ],
                cornflowerblue: [
                    100,
                    149,
                    237,
                    1
                ],
                cornsilk: [
                    255,
                    248,
                    220,
                    1
                ],
                crimson: [
                    220,
                    20,
                    60,
                    1
                ],
                cyan: [
                    0,
                    255,
                    255,
                    1
                ],
                darkblue: [
                    0,
                    0,
                    139,
                    1
                ],
                darkcyan: [
                    0,
                    139,
                    139,
                    1
                ],
                darkgoldenrod: [
                    184,
                    134,
                    11,
                    1
                ],
                darkgray: [
                    169,
                    169,
                    169,
                    1
                ],
                darkgreen: [
                    0,
                    100,
                    0,
                    1
                ],
                darkgrey: [
                    169,
                    169,
                    169,
                    1
                ],
                darkkhaki: [
                    189,
                    183,
                    107,
                    1
                ],
                darkmagenta: [
                    139,
                    0,
                    139,
                    1
                ],
                darkolivegreen: [
                    85,
                    107,
                    47,
                    1
                ],
                darkorange: [
                    255,
                    140,
                    0,
                    1
                ],
                darkorchid: [
                    153,
                    50,
                    204,
                    1
                ],
                darkred: [
                    139,
                    0,
                    0,
                    1
                ],
                darksalmon: [
                    233,
                    150,
                    122,
                    1
                ],
                darkseagreen: [
                    143,
                    188,
                    143,
                    1
                ],
                darkslateblue: [
                    72,
                    61,
                    139,
                    1
                ],
                darkslategray: [
                    47,
                    79,
                    79,
                    1
                ],
                darkslategrey: [
                    47,
                    79,
                    79,
                    1
                ],
                darkturquoise: [
                    0,
                    206,
                    209,
                    1
                ],
                darkviolet: [
                    148,
                    0,
                    211,
                    1
                ],
                deeppink: [
                    255,
                    20,
                    147,
                    1
                ],
                deepskyblue: [
                    0,
                    191,
                    255,
                    1
                ],
                dimgray: [
                    105,
                    105,
                    105,
                    1
                ],
                dimgrey: [
                    105,
                    105,
                    105,
                    1
                ],
                dodgerblue: [
                    30,
                    144,
                    255,
                    1
                ],
                firebrick: [
                    178,
                    34,
                    34,
                    1
                ],
                floralwhite: [
                    255,
                    250,
                    240,
                    1
                ],
                forestgreen: [
                    34,
                    139,
                    34,
                    1
                ],
                fuchsia: [
                    255,
                    0,
                    255,
                    1
                ],
                gainsboro: [
                    220,
                    220,
                    220,
                    1
                ],
                ghostwhite: [
                    248,
                    248,
                    255,
                    1
                ],
                gold: [
                    255,
                    215,
                    0,
                    1
                ],
                goldenrod: [
                    218,
                    165,
                    32,
                    1
                ],
                gray: [
                    128,
                    128,
                    128,
                    1
                ],
                green: [
                    0,
                    128,
                    0,
                    1
                ],
                greenyellow: [
                    173,
                    255,
                    47,
                    1
                ],
                grey: [
                    128,
                    128,
                    128,
                    1
                ],
                honeydew: [
                    240,
                    255,
                    240,
                    1
                ],
                hotpink: [
                    255,
                    105,
                    180,
                    1
                ],
                indianred: [
                    205,
                    92,
                    92,
                    1
                ],
                indigo: [
                    75,
                    0,
                    130,
                    1
                ],
                ivory: [
                    255,
                    255,
                    240,
                    1
                ],
                khaki: [
                    240,
                    230,
                    140,
                    1
                ],
                lavender: [
                    230,
                    230,
                    250,
                    1
                ],
                lavenderblush: [
                    255,
                    240,
                    245,
                    1
                ],
                lawngreen: [
                    124,
                    252,
                    0,
                    1
                ],
                lemonchiffon: [
                    255,
                    250,
                    205,
                    1
                ],
                lightblue: [
                    173,
                    216,
                    230,
                    1
                ],
                lightcoral: [
                    240,
                    128,
                    128,
                    1
                ],
                lightcyan: [
                    224,
                    255,
                    255,
                    1
                ],
                lightgoldenrodyellow: [
                    250,
                    250,
                    210,
                    1
                ],
                lightgray: [
                    211,
                    211,
                    211,
                    1
                ],
                lightgreen: [
                    144,
                    238,
                    144,
                    1
                ],
                lightgrey: [
                    211,
                    211,
                    211,
                    1
                ],
                lightpink: [
                    255,
                    182,
                    193,
                    1
                ],
                lightsalmon: [
                    255,
                    160,
                    122,
                    1
                ],
                lightseagreen: [
                    32,
                    178,
                    170,
                    1
                ],
                lightskyblue: [
                    135,
                    206,
                    250,
                    1
                ],
                lightslategray: [
                    119,
                    136,
                    153,
                    1
                ],
                lightslategrey: [
                    119,
                    136,
                    153,
                    1
                ],
                lightsteelblue: [
                    176,
                    196,
                    222,
                    1
                ],
                lightyellow: [
                    255,
                    255,
                    224,
                    1
                ],
                lime: [
                    0,
                    255,
                    0,
                    1
                ],
                limegreen: [
                    50,
                    205,
                    50,
                    1
                ],
                linen: [
                    250,
                    240,
                    230,
                    1
                ],
                magenta: [
                    255,
                    0,
                    255,
                    1
                ],
                maroon: [
                    128,
                    0,
                    0,
                    1
                ],
                mediumaquamarine: [
                    102,
                    205,
                    170,
                    1
                ],
                mediumblue: [
                    0,
                    0,
                    205,
                    1
                ],
                mediumorchid: [
                    186,
                    85,
                    211,
                    1
                ],
                mediumpurple: [
                    147,
                    112,
                    219,
                    1
                ],
                mediumseagreen: [
                    60,
                    179,
                    113,
                    1
                ],
                mediumslateblue: [
                    123,
                    104,
                    238,
                    1
                ],
                mediumspringgreen: [
                    0,
                    250,
                    154,
                    1
                ],
                mediumturquoise: [
                    72,
                    209,
                    204,
                    1
                ],
                mediumvioletred: [
                    199,
                    21,
                    133,
                    1
                ],
                midnightblue: [
                    25,
                    25,
                    112,
                    1
                ],
                mintcream: [
                    245,
                    255,
                    250,
                    1
                ],
                mistyrose: [
                    255,
                    228,
                    225,
                    1
                ],
                moccasin: [
                    255,
                    228,
                    181,
                    1
                ],
                navajowhite: [
                    255,
                    222,
                    173,
                    1
                ],
                navy: [
                    0,
                    0,
                    128,
                    1
                ],
                oldlace: [
                    253,
                    245,
                    230,
                    1
                ],
                olive: [
                    128,
                    128,
                    0,
                    1
                ],
                olivedrab: [
                    107,
                    142,
                    35,
                    1
                ],
                orange: [
                    255,
                    165,
                    0,
                    1
                ],
                orangered: [
                    255,
                    69,
                    0,
                    1
                ],
                orchid: [
                    218,
                    112,
                    214,
                    1
                ],
                palegoldenrod: [
                    238,
                    232,
                    170,
                    1
                ],
                palegreen: [
                    152,
                    251,
                    152,
                    1
                ],
                paleturquoise: [
                    175,
                    238,
                    238,
                    1
                ],
                palevioletred: [
                    219,
                    112,
                    147,
                    1
                ],
                papayawhip: [
                    255,
                    239,
                    213,
                    1
                ],
                peachpuff: [
                    255,
                    218,
                    185,
                    1
                ],
                peru: [
                    205,
                    133,
                    63,
                    1
                ],
                pink: [
                    255,
                    192,
                    203,
                    1
                ],
                plum: [
                    221,
                    160,
                    221,
                    1
                ],
                powderblue: [
                    176,
                    224,
                    230,
                    1
                ],
                purple: [
                    128,
                    0,
                    128,
                    1
                ],
                rebeccapurple: [
                    102,
                    51,
                    153,
                    1
                ],
                red: [
                    255,
                    0,
                    0,
                    1
                ],
                rosybrown: [
                    188,
                    143,
                    143,
                    1
                ],
                royalblue: [
                    65,
                    105,
                    225,
                    1
                ],
                saddlebrown: [
                    139,
                    69,
                    19,
                    1
                ],
                salmon: [
                    250,
                    128,
                    114,
                    1
                ],
                sandybrown: [
                    244,
                    164,
                    96,
                    1
                ],
                seagreen: [
                    46,
                    139,
                    87,
                    1
                ],
                seashell: [
                    255,
                    245,
                    238,
                    1
                ],
                sienna: [
                    160,
                    82,
                    45,
                    1
                ],
                silver: [
                    192,
                    192,
                    192,
                    1
                ],
                skyblue: [
                    135,
                    206,
                    235,
                    1
                ],
                slateblue: [
                    106,
                    90,
                    205,
                    1
                ],
                slategray: [
                    112,
                    128,
                    144,
                    1
                ],
                slategrey: [
                    112,
                    128,
                    144,
                    1
                ],
                snow: [
                    255,
                    250,
                    250,
                    1
                ],
                springgreen: [
                    0,
                    255,
                    127,
                    1
                ],
                steelblue: [
                    70,
                    130,
                    180,
                    1
                ],
                tan: [
                    210,
                    180,
                    140,
                    1
                ],
                teal: [
                    0,
                    128,
                    128,
                    1
                ],
                thistle: [
                    216,
                    191,
                    216,
                    1
                ],
                tomato: [
                    255,
                    99,
                    71,
                    1
                ],
                turquoise: [
                    64,
                    224,
                    208,
                    1
                ],
                violet: [
                    238,
                    130,
                    238,
                    1
                ],
                wheat: [
                    245,
                    222,
                    179,
                    1
                ],
                white: [
                    255,
                    255,
                    255,
                    1
                ],
                whitesmoke: [
                    245,
                    245,
                    245,
                    1
                ],
                yellow: [
                    255,
                    255,
                    0,
                    1
                ],
                yellowgreen: [
                    154,
                    205,
                    50,
                    1
                ]
            };
            function e(t1) {
                return (t1 = Math.round(t1)) < 0 ? 0 : t1 > 255 ? 255 : t1;
            }
            function r(t1) {
                return e("%" === t1[t1.length - 1] ? parseFloat(t1) / 100 * 255 : parseInt(t1));
            }
            function n(t1) {
                return (e = "%" === t1[t1.length - 1] ? parseFloat(t1) / 100 : parseFloat(t1)) < 0 ? 0 : e > 1 ? 1 : e;
                "TURBOPACK unreachable";
                var e;
            }
            function i(t1, e, r) {
                return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t1 + (e - t1) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t1 + (e - t1) * (2 / 3 - r) * 6 : t1;
            }
            try {
                Ae.parseCSSColor = function(a) {
                    var s, o = a.replace(/ /g, "").toLowerCase();
                    if (o in t1) return t1[o].slice();
                    if ("#" === o[0]) return 4 === o.length ? (s = parseInt(o.substr(1), 16)) >= 0 && s <= 4095 ? [
                        (3840 & s) >> 4 | (3840 & s) >> 8,
                        240 & s | (240 & s) >> 4,
                        15 & s | (15 & s) << 4,
                        1
                    ] : null : 7 === o.length && (s = parseInt(o.substr(1), 16)) >= 0 && s <= 16777215 ? [
                        (16711680 & s) >> 16,
                        (65280 & s) >> 8,
                        255 & s,
                        1
                    ] : null;
                    var l = o.indexOf("("), u = o.indexOf(")");
                    if (-1 !== l && u + 1 === o.length) {
                        var c = o.substr(0, l), h = o.substr(l + 1, u - (l + 1)).split(","), p = 1;
                        switch(c){
                            case "rgba":
                                if (4 !== h.length) return null;
                                p = n(h.pop());
                            case "rgb":
                                return 3 !== h.length ? null : [
                                    r(h[0]),
                                    r(h[1]),
                                    r(h[2]),
                                    p
                                ];
                            case "hsla":
                                if (4 !== h.length) return null;
                                p = n(h.pop());
                            case "hsl":
                                if (3 !== h.length) return null;
                                var f = (parseFloat(h[0]) % 360 + 360) % 360 / 360, d = n(h[1]), m = n(h[2]), y = m <= .5 ? m * (d + 1) : m + d - m * d, g = 2 * m - y;
                                return [
                                    e(255 * i(g, y, f + 1 / 3)),
                                    e(255 * i(g, y, f)),
                                    e(255 * i(g, y, f - 1 / 3)),
                                    p
                                ];
                            default:
                                return null;
                        }
                    }
                    return null;
                };
            } catch (t1) {}
            return Ae;
        }();
        class Ie {
            constructor(t1, e, r, n = 1){
                this.r = t1, this.g = e, this.b = r, this.a = n;
            }
            static parse(t1) {
                if (!t1) return;
                if (t1 instanceof Ie) return t1;
                if ("string" != typeof t1) return;
                const e = Se.parseCSSColor(t1);
                return e ? new Ie(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]) : void 0;
            }
            toStringPremultipliedAlpha() {
                const [t1, e, r, n] = 0 === this.a ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    255 * this.r / this.a,
                    255 * this.g / this.a,
                    255 * this.b / this.a,
                    this.a
                ];
                return `rgba(${Math.round(t1)},${Math.round(e)},${Math.round(r)},${n})`;
            }
            toString() {
                const [t1, e, r, n] = [
                    this.r,
                    this.g,
                    this.b,
                    this.a
                ];
                return `rgba(${Math.round(255 * t1)},${Math.round(255 * e)},${Math.round(255 * r)},${n})`;
            }
            toRenderColor(t1) {
                const { r: e, g: r, b: n, a: i } = this;
                return new Pe(t1, e, r, n, i);
            }
            clone() {
                return new Ie(this.r, this.g, this.b, this.a);
            }
        }
        class Pe {
            constructor(t1, e, r, n, i){
                if (t1) {
                    const a = t1.image.height, s = a * a;
                    e = 0 === i ? 0 : e / i * (a - 1), r = 0 === i ? 0 : r / i * (a - 1), n = 0 === i ? 0 : n / i * (a - 1);
                    const o = Math.floor(e), l = Math.floor(r), u = Math.floor(n), c = Math.ceil(e), h = Math.ceil(r), p = Math.ceil(n), f = e - o, d = r - l, m = n - u, y = t1.image.data, g = 4 * (o + l * s + u * a), x = 4 * (o + l * s + p * a), v = 4 * (o + h * s + u * a), b = 4 * (o + h * s + p * a), _ = 4 * (c + l * s + u * a), w = 4 * (c + l * s + p * a), M = 4 * (c + h * s + u * a), A = 4 * (c + h * s + p * a);
                    if (g < 0 || A >= y.length) throw new Error("out of range");
                    this.r = ze(ze(ze(y[g], y[x], m), ze(y[v], y[b], m), d), ze(ze(y[_], y[w], m), ze(y[M], y[A], m), d), f) / 255 * i, this.g = ze(ze(ze(y[g + 1], y[x + 1], m), ze(y[v + 1], y[b + 1], m), d), ze(ze(y[_ + 1], y[w + 1], m), ze(y[M + 1], y[A + 1], m), d), f) / 255 * i, this.b = ze(ze(ze(y[g + 2], y[x + 2], m), ze(y[v + 2], y[b + 2], m), d), ze(ze(y[_ + 2], y[w + 2], m), ze(y[M + 2], y[A + 2], m), d), f) / 255 * i, this.a = i;
                } else this.r = e, this.g = r, this.b = n, this.a = i;
            }
            toArray() {
                const { r: t1, g: e, b: r, a: n } = this;
                return 0 === n ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    255 * t1 / n,
                    255 * e / n,
                    255 * r / n,
                    n
                ];
            }
            toHslaArray() {
                if (0 === this.a) return [
                    0,
                    0,
                    0,
                    0
                ];
                const { r: t1, g: e, b: r, a: n } = this, i = Math.min(Math.max(t1 / n, 0), 1), a = Math.min(Math.max(e / n, 0), 1), s = Math.min(Math.max(r / n, 0), 1), o = Math.min(i, a, s), l = Math.max(i, a, s), u = (o + l) / 2;
                if (o === l) return [
                    0,
                    0,
                    100 * u,
                    n
                ];
                const c = l - o, h = u > .5 ? c / (2 - l - o) : c / (l + o);
                let p = 0;
                return l === i ? p = (a - s) / c + (a < s ? 6 : 0) : l === a ? p = (s - i) / c + 2 : l === s && (p = (i - a) / c + 4), p *= 60, [
                    Math.min(Math.max(p, 0), 360),
                    Math.min(Math.max(100 * h, 0), 100),
                    Math.min(Math.max(100 * u, 0), 100),
                    n
                ];
            }
            toArray01() {
                const { r: t1, g: e, b: r, a: n } = this;
                return 0 === n ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    t1 / n,
                    e / n,
                    r / n,
                    n
                ];
            }
            toArray01Scaled(t1) {
                const { r: e, g: r, b: n, a: i } = this;
                return 0 === i ? [
                    0,
                    0,
                    0
                ] : [
                    e / i * t1,
                    r / i * t1,
                    n / i * t1
                ];
            }
            toArray01PremultipliedAlpha() {
                const { r: t1, g: e, b: r, a: n } = this;
                return [
                    t1,
                    e,
                    r,
                    n
                ];
            }
            toArray01Linear() {
                const { r: t1, g: e, b: r, a: n } = this;
                return 0 === n ? [
                    0,
                    0,
                    0,
                    0
                ] : [
                    Math.pow(t1 / n, 2.2),
                    Math.pow(e / n, 2.2),
                    Math.pow(r / n, 2.2),
                    n
                ];
            }
        }
        function ze(t1, e, r) {
            return t1 * (1 - r) + e * r;
        }
        function Ee(t1, e, r) {
            return t1.map((t1, n)=>ze(t1, e[n], r));
        }
        Ie.black = new Ie(0, 0, 0, 1), Ie.white = new Ie(1, 1, 1, 1), Ie.transparent = new Ie(0, 0, 0, 0), Ie.red = new Ie(1, 0, 0, 1), Ie.blue = new Ie(0, 0, 1, 1);
        var ke = Object.freeze({
            __proto__: null,
            array: Ee,
            color: function(t1, e, r) {
                return new Ie(ze(t1.r, e.r, r), ze(t1.g, e.g, r), ze(t1.b, e.b, r), ze(t1.a, e.a, r));
            },
            number: ze
        });
        function Te(t1, ...e) {
            for (const r of e)for(const e in r)t1[e] = r[e];
            return t1;
        }
        class Be extends Error {
            constructor(t1, e){
                super(e), this.message = e, this.key = t1;
            }
        }
        class Ve {
            constructor(t1, e = []){
                this.parent = t1, this.bindings = {};
                for (const [t1, r] of e)this.bindings[t1] = r;
            }
            concat(t1) {
                return new Ve(this, t1);
            }
            get(t1) {
                if (this.bindings[t1]) return this.bindings[t1];
                if (this.parent) return this.parent.get(t1);
                throw new Error(`${t1} not found in scope.`);
            }
            has(t1) {
                return !!this.bindings[t1] || !!this.parent && this.parent.has(t1);
            }
        }
        const Ce = {
            kind: "null"
        }, De = {
            kind: "number"
        }, Le = {
            kind: "string"
        }, Re = {
            kind: "boolean"
        }, Fe = {
            kind: "color"
        }, Oe = {
            kind: "object"
        }, Ne = {
            kind: "value"
        }, Ue = {
            kind: "collator"
        }, je = {
            kind: "formatted"
        }, qe = {
            kind: "resolvedImage"
        };
        function $e(t1, e) {
            return {
                kind: "array",
                itemType: t1,
                N: e
            };
        }
        function Ge(t1) {
            if ("array" === t1.kind) {
                const e = Ge(t1.itemType);
                return "number" == typeof t1.N ? `array<${e}, ${t1.N}>` : "value" === t1.itemType.kind ? "array" : `array<${e}>`;
            }
            return t1.kind;
        }
        const Ye = [
            Ce,
            De,
            Le,
            Re,
            Fe,
            je,
            Oe,
            $e(Ne),
            qe
        ];
        function Xe(t1, e) {
            if ("error" === e.kind) return null;
            if ("array" === t1.kind) {
                if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !Xe(t1.itemType, e.itemType)) && ("number" != typeof t1.N || t1.N === e.N)) return null;
            } else {
                if (t1.kind === e.kind) return null;
                if ("value" === t1.kind) {
                    for (const t1 of Ye)if (!Xe(t1, e)) return null;
                }
            }
            return `Expected ${Ge(t1)} but found ${Ge(e)} instead.`;
        }
        function Ze(t1, e) {
            return e.some((e)=>e.kind === t1.kind);
        }
        function He(t1, e) {
            return e.some((e)=>"null" === e ? null === t1 : "array" === e ? Array.isArray(t1) : "object" === e ? t1 && !Array.isArray(t1) && "object" == typeof t1 : e === typeof t1);
        }
        class We {
            constructor(t1, e, r){
                this.sensitivity = t1 ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
                    sensitivity: this.sensitivity,
                    usage: "search"
                });
            }
            compare(t1, e) {
                return this.collator.compare(t1, e);
            }
            resolvedLocale() {
                return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
        }
        class Ke {
            constructor(t1, e, r, n, i){
                this.text = t1.normalize ? t1.normalize() : t1, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;
            }
        }
        class Je {
            constructor(t1){
                this.sections = t1;
            }
            static fromString(t1) {
                return new Je([
                    new Ke(t1, null, null, null, null)
                ]);
            }
            isEmpty() {
                return 0 === this.sections.length || !this.sections.some((t1)=>0 !== t1.text.length || t1.image && t1.image.namePrimary);
            }
            static factory(t1) {
                return t1 instanceof Je ? t1 : Je.fromString(t1);
            }
            toString() {
                return 0 === this.sections.length ? "" : this.sections.map((t1)=>t1.text).join("");
            }
            serialize() {
                const t1 = [
                    "format"
                ];
                for (const e of this.sections){
                    if (e.image) {
                        t1.push([
                            "image",
                            e.image.namePrimary
                        ]);
                        continue;
                    }
                    t1.push(e.text);
                    const r = {};
                    e.fontStack && (r["text-font"] = [
                        "literal",
                        e.fontStack.split(",")
                    ]), e.scale && (r["font-scale"] = e.scale), e.textColor && (r["text-color"] = [
                        "rgba"
                    ].concat(e.textColor.toRenderColor(null).toArray())), t1.push(r);
                }
                return t1;
            }
        }
        class Qe {
            constructor(t1, e){
                if (this.id = t1, this.options = e || {
                    params: {}
                }, this.options.transform) {
                    const { a: t1, b: e, c: r, d: n, e: i, f: a } = this.options.transform;
                    this.options.transform = new DOMMatrix([
                        t1,
                        e,
                        r,
                        n,
                        i,
                        a
                    ]);
                } else this.options.transform = new DOMMatrix([
                    1,
                    0,
                    0,
                    1,
                    0,
                    0
                ]);
            }
            static deserializeId(t1) {
                return JSON.parse(t1).id;
            }
            static deserializeFromString(t1) {
                const e = JSON.parse(t1), { a: r, b: n, c: i, d: a, e: s, f: o } = e.options.transform;
                return new DOMMatrix([
                    r,
                    n,
                    i,
                    a,
                    s,
                    o
                ]), new Qe(e.id, e.options);
            }
            scaleSelf(t1) {
                return this.options.transform = this.options.transform.scale(t1), this;
            }
            serialize() {
                const t1 = {
                    id: this.id
                };
                this.options && (t1.options = this.options);
                const { a: e, b: r, c: n, d: i, e: a, f: s } = this.options.transform;
                return t1.options.transform = {
                    a: e,
                    b: r,
                    c: n,
                    d: i,
                    e: a,
                    f: s
                }, JSON.stringify(t1);
            }
        }
        class tr {
            constructor(t1){
                this.namePrimary = t1.namePrimary, t1.nameSecondary && (this.nameSecondary = t1.nameSecondary), t1.optionsPrimary && (this.optionsPrimary = t1.optionsPrimary), t1.optionsSecondary && (this.optionsSecondary = t1.optionsSecondary), this.available = t1.available;
            }
            toString() {
                return this.namePrimary && this.nameSecondary ? `[${this.namePrimary},${this.nameSecondary}]` : this.namePrimary;
            }
            getPrimary() {
                return new Qe(this.namePrimary, {
                    params: this.optionsPrimary && this.optionsPrimary.params || {}
                });
            }
            getSerializedPrimary() {
                return this.getPrimary().serialize();
            }
            getSecondary() {
                return this.nameSecondary ? new Qe(this.nameSecondary, {
                    params: this.optionsSecondary && this.optionsSecondary.params || {}
                }) : null;
            }
            static from(t1) {
                return "string" == typeof t1 ? tr.build(t1) : t1;
            }
            static build(t1, e, r, n) {
                return t1 ? new tr({
                    namePrimary: t1,
                    nameSecondary: e,
                    optionsPrimary: r,
                    optionsSecondary: n,
                    available: !1
                }) : null;
            }
        }
        function er(t1, e, r, n) {
            return "number" == typeof t1 && t1 >= 0 && t1 <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[
                t1,
                e,
                r,
                n
            ].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [
                t1,
                e,
                r,
                n
            ] : [
                t1,
                e,
                r
            ]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function rr(t1) {
            if (null === t1) return !0;
            if ("string" == typeof t1) return !0;
            if ("boolean" == typeof t1) return !0;
            if ("number" == typeof t1) return !0;
            if (t1 instanceof Ie) return !0;
            if (t1 instanceof We) return !0;
            if (t1 instanceof Je) return !0;
            if (t1 instanceof tr) return !0;
            if (Array.isArray(t1)) {
                for (const e of t1)if (!rr(e)) return !1;
                return !0;
            }
            if ("object" == typeof t1) {
                for(const e in t1)if (!rr(t1[e])) return !1;
                return !0;
            }
            return !1;
        }
        function nr(t1) {
            if (null === t1) return Ce;
            if ("string" == typeof t1) return Le;
            if ("boolean" == typeof t1) return Re;
            if ("number" == typeof t1) return De;
            if (t1 instanceof Ie) return Fe;
            if (t1 instanceof We) return Ue;
            if (t1 instanceof Je) return je;
            if (t1 instanceof tr) return qe;
            if (Array.isArray(t1)) {
                const e = t1.length;
                let r;
                for (const e of t1){
                    const t1 = nr(e);
                    if (r) {
                        if (r === t1) continue;
                        r = Ne;
                        break;
                    }
                    r = t1;
                }
                return $e(r || Ne, e);
            }
            return Oe;
        }
        function ir(t1) {
            const e = typeof t1;
            return null === t1 ? "" : "string" === e || "number" === e || "boolean" === e ? String(t1) : t1 instanceof Ie ? t1.toStringPremultipliedAlpha() : t1 instanceof Je || t1 instanceof tr ? t1.toString() : JSON.stringify(t1);
        }
        class ar {
            constructor(t1, e){
                this.type = t1, this.value = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`'literal' expression requires exactly one argument, but found ${t1.length - 1} instead.`);
                if (!rr(t1[1])) return e.error("invalid value");
                const r = t1[1];
                let n = nr(r);
                const i = e.expectedType;
                return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new ar(n, r);
            }
            evaluate() {
                return this.value;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return "array" === this.type.kind || "object" === this.type.kind ? [
                    "literal",
                    this.value
                ] : this.value instanceof Ie ? [
                    "rgba"
                ].concat(this.value.toRenderColor(null).toArray()) : this.value instanceof Je ? this.value.serialize() : this.value;
            }
        }
        class sr {
            constructor(t1){
                this.name = "ExpressionEvaluationError", this.message = t1;
            }
            toJSON() {
                return this.message;
            }
        }
        const or = {
            string: Le,
            number: De,
            boolean: Re,
            object: Oe
        };
        class lr {
            constructor(t1, e){
                this.type = t1, this.args = e;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected at least one argument.");
                let r, n = 1;
                const i = t1[0];
                if ("array" === i) {
                    let i, a;
                    if (t1.length > 2) {
                        const r = t1[1];
                        if ("string" != typeof r || !(r in or) || "object" === r) return e.error('The item type argument of "array" must be one of string, number, boolean', 1);
                        i = or[r], n++;
                    } else i = Ne;
                    if (t1.length > 3) {
                        if (null !== t1[2] && ("number" != typeof t1[2] || t1[2] < 0 || t1[2] !== Math.floor(t1[2]))) return e.error('The length argument to "array" must be a positive integer literal', 2);
                        a = t1[2], n++;
                    }
                    r = $e(i, a);
                } else r = or[i];
                const a = [];
                for(; n < t1.length; n++){
                    const r = e.parse(t1[n], n, Ne);
                    if (!r) return null;
                    a.push(r);
                }
                return new lr(r, a);
            }
            evaluate(t1) {
                for(let e = 0; e < this.args.length; e++){
                    const r = this.args[e].evaluate(t1);
                    if (!Xe(this.type, nr(r))) return r;
                    if (e === this.args.length - 1) throw new sr(`The expression ${JSON.stringify(this.args[e].serialize())} evaluated to ${Ge(nr(r))} but was expected to be of type ${Ge(this.type)}.`);
                }
                return null;
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = this.type, e = [
                    t1.kind
                ];
                if ("array" === t1.kind) {
                    const r = t1.itemType;
                    if ("string" === r.kind || "number" === r.kind || "boolean" === r.kind) {
                        e.push(r.kind);
                        const n = t1.N;
                        ("number" == typeof n || this.args.length > 1) && e.push(n);
                    }
                }
                return e.concat(this.args.map((t1)=>t1.serialize()));
            }
        }
        class ur {
            constructor(t1){
                this.type = je, this.sections = t1;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected at least one argument.");
                const r = t1[1];
                if (!Array.isArray(r) && "object" == typeof r) return e.error("First argument must be an image or text section.");
                const n = [];
                let i = !1;
                for(let r = 1; r <= t1.length - 1; ++r){
                    const a = t1[r];
                    if (i && "object" == typeof a && !Array.isArray(a)) {
                        i = !1;
                        let t1 = null;
                        if (a["font-scale"] && (t1 = e.parseObjectValue(a["font-scale"], r, "font-scale", De), !t1)) return null;
                        let s = null;
                        if (a["text-font"] && (s = e.parseObjectValue(a["text-font"], r, "text-font", $e(Le)), !s)) return null;
                        let o = null;
                        if (a["text-color"] && (o = e.parseObjectValue(a["text-color"], r, "text-color", Fe), !o)) return null;
                        const l = n[n.length - 1];
                        l.scale = t1, l.font = s, l.textColor = o;
                    } else {
                        const a = e.parse(t1[r], r, Ne);
                        if (!a) return null;
                        const s = a.type.kind;
                        if ("string" !== s && "value" !== s && "null" !== s && "resolvedImage" !== s) return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                        i = !0, n.push({
                            content: a,
                            scale: null,
                            font: null,
                            textColor: null
                        });
                    }
                }
                return new ur(n);
            }
            evaluate(t1) {
                return new Je(this.sections.map((e)=>{
                    const r = e.content.evaluate(t1);
                    return nr(r) === qe ? new Ke("", r, null, null, null) : new Ke(ir(r), null, e.scale ? e.scale.evaluate(t1) : null, e.font ? e.font.evaluate(t1).join(",") : null, e.textColor ? e.textColor.evaluate(t1) : null);
                }));
            }
            eachChild(t1) {
                for (const e of this.sections)t1(e.content), e.scale && t1(e.scale), e.font && t1(e.font), e.textColor && t1(e.textColor);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "format"
                ];
                for (const e of this.sections){
                    t1.push(e.content.serialize());
                    const r = {};
                    e.scale && (r["font-scale"] = e.scale.serialize()), e.font && (r["text-font"] = e.font.serialize()), e.textColor && (r["text-color"] = e.textColor.serialize()), t1.push(r);
                }
                return t1;
            }
        }
        class cr {
            constructor(t1, e, r, n){
                this._imageWarnHistory = {}, this.type = qe, this.inputPrimary = t1, this.inputSecondary = e, this.inputPrimaryParams = r, this.inputSecondaryParams = n;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected two or more arguments.");
                let r = 1;
                const n = [];
                function i() {
                    if (r < t1.length) {
                        const i = e.parse(t1[r], r++, Le);
                        return i ? (n.push({
                            image: i,
                            options: void 0
                        }), !0) : (e.error(n.length ? "Secondary image variant is not a string." : "No image name provided."), !1);
                    }
                    return !0;
                }
                function a() {
                    if (r < t1.length) {
                        if (null === (i = t1[r]) || "object" != typeof i || Array.isArray(i)) return !0;
                        const a = t1[r].params, s = e.concat(r);
                        if (!a) return r++, !0;
                        if ("object" != typeof a || a.constructor !== Object) return s.error('Image options "params" should be an object'), !1;
                        const o = {}, l = s.concat(void 0, "params");
                        for(const t1 in a){
                            if (!t1) return l.error("Image parameter name should be non-empty"), !1;
                            const e = l.concat(void 0, t1).parse(a[t1], void 0, Fe, void 0, {
                                typeAnnotation: "coerce"
                            });
                            if (!e) return !1;
                            o[t1] = e;
                        }
                        return n[n.length - 1].options = o, r++, !0;
                    }
                    var i;
                    return !0;
                }
                for(let t1 = 0; t1 < 2; t1++)if (!i() || !a()) return;
                return new cr(n[0].image, n[1] ? n[1].image : void 0, n[0].options, n[1] ? n[1].options : void 0);
            }
            evaluateParams(t1, e) {
                const r = {};
                if (e) {
                    for(const n in e)if (e[n]) try {
                        const i = e[n].evaluate(t1), a = `Ignoring image parameter "${n}" with semi-transparent color ${i.toString()}`;
                        if (1 !== i.a) {
                            this._imageWarnHistory[a] || (console.warn(a), this._imageWarnHistory[a] = !0);
                            continue;
                        }
                        r[n] = i;
                    } catch (t1) {
                        continue;
                    }
                    if (0 !== Object.keys(r).length) return {
                        params: r
                    };
                }
            }
            evaluate(t1) {
                const e = tr.build(this.inputPrimary.evaluate(t1), this.inputSecondary ? this.inputSecondary.evaluate(t1) : void 0, this.inputPrimaryParams ? this.evaluateParams(t1, this.inputPrimaryParams) : void 0, this.inputSecondaryParams ? this.evaluateParams(t1, this.inputSecondaryParams) : void 0);
                return e && t1.availableImages && (e.available = t1.availableImages.indexOf(e.namePrimary) > -1, e.nameSecondary && e.available && t1.availableImages && (e.available = t1.availableImages.indexOf(e.nameSecondary) > -1)), e;
            }
            eachChild(t1) {
                if (t1(this.inputPrimary), this.inputPrimaryParams) for(const e in this.inputPrimaryParams)this.inputPrimaryParams[e] && t1(this.inputPrimaryParams[e]);
                if (this.inputSecondary && (t1(this.inputSecondary), this.inputSecondaryParams)) for(const e in this.inputSecondaryParams)this.inputSecondaryParams[e] && t1(this.inputSecondaryParams[e]);
            }
            outputDefined() {
                return !1;
            }
            serializeParams(t1) {
                const e = {};
                if (t1) {
                    for(const r in t1)t1[r] && (e[r] = t1[r].serialize());
                    return {
                        params: e
                    };
                }
            }
            serialize() {
                const t1 = [
                    "image",
                    this.inputPrimary.serialize()
                ];
                return this.inputPrimaryParams && t1.push(this.serializeParams(this.inputPrimaryParams)), this.inputSecondary && (t1.push(this.inputSecondary.serialize()), this.inputSecondaryParams && t1.push(this.serializeParams(this.inputSecondaryParams))), t1;
            }
        }
        function hr(t1) {
            return t1 instanceof Number ? "number" : t1 instanceof String ? "string" : t1 instanceof Boolean ? "boolean" : Array.isArray(t1) ? "array" : null === t1 ? "null" : typeof t1;
        }
        const pr = {
            "to-boolean": Re,
            "to-color": Fe,
            "to-number": De,
            "to-string": Le
        };
        class fr {
            constructor(t1, e){
                this.type = t1, this.args = e;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expected at least one argument.");
                const r = t1[0], n = [];
                let i = Ce;
                if ("to-array" === r) {
                    if (!Array.isArray(t1[1])) return null;
                    const r = t1[1].length;
                    if (e.expectedType) {
                        if ("array" !== e.expectedType.kind) return e.error(`Expected ${e.expectedType.kind} but found array.`);
                        i = $e(e.expectedType.itemType, r);
                    } else {
                        if (!(r > 0 && rr(t1[1][0]))) return null;
                        i = $e(nr(t1[1][0]), r);
                    }
                    for(let a = 0; a < r; a++){
                        const r = t1[1][a];
                        let s;
                        if ("array" === hr(r)) s = e.parse(r, void 0, i.itemType);
                        else {
                            const t1 = hr(r);
                            if (t1 !== i.itemType.kind) return e.error(`Expected ${i.itemType.kind} but found ${t1}.`);
                            s = e.registry.literal.parse([
                                "literal",
                                void 0 === r ? null : r
                            ], e);
                        }
                        if (!s) return null;
                        n.push(s);
                    }
                } else {
                    if (("to-boolean" === r || "to-string" === r) && 2 !== t1.length) return e.error("Expected one argument.");
                    i = pr[r];
                    for(let r = 1; r < t1.length; r++){
                        const i = e.parse(t1[r], r, Ne);
                        if (!i) return null;
                        n.push(i);
                    }
                }
                return new fr(i, n);
            }
            evaluate(t1) {
                if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t1));
                if ("color" === this.type.kind) {
                    let e, r;
                    for (const n of this.args){
                        if (e = n.evaluate(t1), r = null, e instanceof Ie) return e;
                        if ("string" == typeof e) {
                            const r = t1.parseColor(e);
                            if (r) return r;
                        } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : er(e[0], e[1], e[2], e[3]), !r)) return new Ie(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);
                    }
                    throw new sr(r || `Could not parse color from value '${"string" == typeof e ? e : String(JSON.stringify(e))}'`);
                }
                if ("number" === this.type.kind) {
                    let e = null;
                    for (const r of this.args){
                        if (e = r.evaluate(t1), null === e) return 0;
                        const n = Number(e);
                        if (!isNaN(n)) return n;
                    }
                    throw new sr(`Could not convert ${JSON.stringify(e)} to number.`);
                }
                return "formatted" === this.type.kind ? Je.fromString(ir(this.args[0].evaluate(t1))) : "resolvedImage" === this.type.kind ? tr.build(ir(this.args[0].evaluate(t1))) : "array" === this.type.kind ? this.args.map((e)=>e.evaluate(t1)) : ir(this.args[0].evaluate(t1));
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                if ("formatted" === this.type.kind) return new ur([
                    {
                        content: this.args[0],
                        scale: null,
                        font: null,
                        textColor: null
                    }
                ]).serialize();
                if ("resolvedImage" === this.type.kind) return new cr(this.args[0]).serialize();
                const t1 = "array" === this.type.kind ? [] : [
                    `to-${this.type.kind}`
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        const dr = [
            "Unknown",
            "Point",
            "LineString",
            "Polygon"
        ];
        class mr {
            constructor(t1, e){
                this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t1, this.options = e;
            }
            id() {
                return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
            }
            geometryType() {
                return this.feature ? "number" == typeof this.feature.type ? dr[this.feature.type] : this.feature.type : null;
            }
            geometry() {
                return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
                return this.canonical;
            }
            properties() {
                return this.feature && this.feature.properties || {};
            }
            measureLight(t1) {
                return this.globals.brightness || 0;
            }
            distanceFromCenter() {
                if (this.featureTileCoord && this.featureDistanceData) {
                    const t1 = this.featureDistanceData.center, e = this.featureDistanceData.scale, { x: r, y: n } = this.featureTileCoord;
                    return this.featureDistanceData.bearing[0] * (r * e - t1[0]) + this.featureDistanceData.bearing[1] * (n * e - t1[1]);
                }
                return 0;
            }
            parseColor(t1) {
                let e = this._parseColorCache[t1];
                return e || (e = this._parseColorCache[t1] = Ie.parse(t1)), e;
            }
            getConfig(t1) {
                return this.options ? this.options.get(t1) : null;
            }
        }
        class yr {
            constructor(t1, e, r, n, i){
                this.name = t1, this.type = e, this._evaluate = r, this.args = n, this._overloadIndex = i;
            }
            evaluate(t1) {
                if (!this._evaluate) {
                    const t1 = yr.definitions[this.name];
                    this._evaluate = Array.isArray(t1) ? t1[2] : t1.overloads[this._overloadIndex][1];
                }
                return this._evaluate(t1, this.args);
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    this.name
                ].concat(this.args.map((t1)=>t1.serialize()));
            }
            static parse(t1, e) {
                const r = t1[0], n = yr.definitions[r];
                if (!n) return e.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
                const i = Array.isArray(n) ? n[0] : n.type, a = Array.isArray(n) ? [
                    [
                        n[1],
                        n[2]
                    ]
                ] : n.overloads, s = [];
                let o = null, l = -1;
                for (const [n, u] of a){
                    if (Array.isArray(n) && n.length !== t1.length - 1) continue;
                    s.push(n), l++, o = new Rn(e.registry, e.path, null, e.scope, void 0, e._scope, e.options);
                    const a = [];
                    let c = !1;
                    for(let e = 1; e < t1.length; e++){
                        const r = t1[e], i = Array.isArray(n) ? n[e - 1] : n.type, s = o.parse(r, 1 + a.length, i);
                        if (!s) {
                            c = !0;
                            break;
                        }
                        a.push(s);
                    }
                    if (!c) if (Array.isArray(n) && n.length !== a.length) o.error(`Expected ${n.length} arguments, but found ${a.length} instead.`);
                    else {
                        for(let t1 = 0; t1 < a.length; t1++){
                            const e = Array.isArray(n) ? n[t1] : n.type, r = a[t1];
                            o.concat(t1 + 1).checkSubtype(e, r.type);
                        }
                        if (0 === o.errors.length) return new yr(r, i, u, a, l);
                    }
                }
                if (1 === s.length) e.errors.push(...o.errors);
                else {
                    const r = (s.length ? s : a.map(([t1])=>t1)).map(gr).join(" | "), n = [];
                    for(let r = 1; r < t1.length; r++){
                        const i = e.parse(t1[r], 1 + n.length);
                        if (!i) return null;
                        n.push(Ge(i.type));
                    }
                    e.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`);
                }
                return null;
            }
            static register(t1, e) {
                yr.definitions = e;
                for(const r in e)t1[r] = yr;
            }
        }
        function gr(t1) {
            return Array.isArray(t1) ? `(${t1.map(Ge).join(", ")})` : `(${Ge(t1.type)}...)`;
        }
        class xr {
            constructor(t1, e, r){
                this.type = Ue, this.locale = r, this.caseSensitive = t1, this.diacriticSensitive = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error("Expected one argument.");
                const r = t1[1];
                if ("object" != typeof r || Array.isArray(r)) return e.error("Collator options argument must be an object.");
                const n = void 0 === r["case-sensitive"] ? e.parse(!1, 1, Re) : e.parseObjectValue(r["case-sensitive"], 1, "case-sensitive", Re);
                if (!n) return null;
                const i = void 0 === r["diacritic-sensitive"] ? e.parse(!1, 1, Re) : e.parseObjectValue(r["diacritic-sensitive"], 1, "diacritic-sensitive", Re);
                if (!i) return null;
                let a = null;
                return r.locale && (a = e.parseObjectValue(r.locale, 1, "locale", Le), !a) ? null : new xr(n, i, a);
            }
            evaluate(t1) {
                return new We(this.caseSensitive.evaluate(t1), this.diacriticSensitive.evaluate(t1), this.locale ? this.locale.evaluate(t1) : null);
            }
            eachChild(t1) {
                t1(this.caseSensitive), t1(this.diacriticSensitive), this.locale && t1(this.locale);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = {};
                return t1["case-sensitive"] = this.caseSensitive.serialize(), t1["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t1.locale = this.locale.serialize()), [
                    "collator",
                    t1
                ];
            }
        }
        function vr(t1, e, r = 0, n = t1.length - 1, i = _r) {
            for(; n > r;){
                if (n - r > 600) {
                    const a = n - r + 1, s = e - r + 1, o = Math.log(a), l = .5 * Math.exp(2 * o / 3), u = .5 * Math.sqrt(o * l * (a - l) / a) * (s - a / 2 < 0 ? -1 : 1);
                    vr(t1, e, Math.max(r, Math.floor(e - s * l / a + u)), Math.min(n, Math.floor(e + (a - s) * l / a + u)), i);
                }
                const a = t1[e];
                let s = r, o = n;
                for(br(t1, r, e), i(t1[n], a) > 0 && br(t1, r, n); s < o;){
                    for(br(t1, s, o), s++, o--; i(t1[s], a) < 0;)s++;
                    for(; i(t1[o], a) > 0;)o--;
                }
                0 === i(t1[r], a) ? br(t1, r, o) : (o++, br(t1, o, n)), o <= e && (r = o + 1), e <= o && (n = o - 1);
            }
        }
        function br(t1, e, r) {
            const n = t1[e];
            t1[e] = t1[r], t1[r] = n;
        }
        function _r(t1, e) {
            return t1 < e ? -1 : t1 > e ? 1 : 0;
        }
        function wr(t1) {
            let e = 0;
            for(let r, n, i = 0, a = t1.length, s = a - 1; i < a; s = i++)r = t1[i], n = t1[s], e += (n.x - r.x) * (r.y + n.y);
            return e;
        }
        function Mr(t1, e) {
            t1[0] = Math.min(t1[0], e[0]), t1[1] = Math.min(t1[1], e[1]), t1[2] = Math.max(t1[2], e[0]), t1[3] = Math.max(t1[3], e[1]);
        }
        function Ar(t1, e) {
            return !(t1[0] <= e[0] || t1[2] >= e[2] || t1[1] <= e[1] || t1[3] >= e[3]);
        }
        function Sr(t1, e, r) {
            const n = t1[0] - e[0], i = t1[1] - e[1], a = t1[0] - r[0], s = t1[1] - r[1];
            return n * s - a * i == 0 && n * a <= 0 && i * s <= 0;
        }
        function Ir(t1, e, r = !1) {
            let n = !1;
            for(let o = 0, l = e.length; o < l; o++){
                const l = e[o];
                for(let e = 0, o = l.length, u = o - 1; e < o; u = e++){
                    const o = l[u], c = l[e];
                    if (Sr(t1, o, c)) return r;
                    (a = o)[1] > (i = t1)[1] != (s = c)[1] > i[1] && i[0] < (s[0] - a[0]) * (i[1] - a[1]) / (s[1] - a[1]) + a[0] && (n = !n);
                }
            }
            var i, a, s;
            return n;
        }
        function Pr(t1, e, r, n) {
            const i = n[0] - r[0], a = n[1] - r[1], s = (t1[0] - r[0]) * a - i * (t1[1] - r[1]), o = (e[0] - r[0]) * a - i * (e[1] - r[1]);
            return s > 0 && o < 0 || s < 0 && o > 0;
        }
        function zr(t1, e, r, n) {
            return 0 != (i = [
                n[0] - r[0],
                n[1] - r[1]
            ])[0] * (a = [
                e[0] - t1[0],
                e[1] - t1[1]
            ])[1] - i[1] * a[0] && !(!Pr(t1, e, r, n) || !Pr(r, n, t1, e));
            "TURBOPACK unreachable";
            var i, a;
        }
        const Er = 8192;
        function kr(t1, e) {
            const r = (180 + t1[0]) / 360, n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t1[1] * Math.PI / 360))) / 360, i = Math.pow(2, e.z);
            return [
                Math.round(r * i * Er),
                Math.round(n * i * Er)
            ];
        }
        function Tr(t1, e) {
            for(let r = 0; r < e.length; r++)if (Ir(t1, e[r])) return !0;
            return !1;
        }
        function Br(t1, e, r) {
            for (const n of r)for(let r = 0, i = n.length, a = i - 1; r < i; a = r++)if (zr(t1, e, n[a], n[r])) return !0;
            return !1;
        }
        function Vr(t1, e) {
            for(let r = 0; r < t1.length; ++r)if (!Ir(t1[r], e)) return !1;
            for(let r = 0; r < t1.length - 1; ++r)if (Br(t1[r], t1[r + 1], e)) return !1;
            return !0;
        }
        function Cr(t1, e) {
            for(let r = 0; r < e.length; r++)if (Vr(t1, e[r])) return !0;
            return !1;
        }
        function Dr(t1, e, r) {
            const n = [];
            for(let i = 0; i < t1.length; i++){
                const a = [];
                for(let n = 0; n < t1[i].length; n++){
                    const s = kr(t1[i][n], r);
                    Mr(e, s), a.push(s);
                }
                n.push(a);
            }
            return n;
        }
        function Lr(t1, e, r) {
            const n = [];
            for(let i = 0; i < t1.length; i++){
                const a = Dr(t1[i], e, r);
                n.push(a);
            }
            return n;
        }
        function Rr(t1, e, r, n) {
            if (t1[0] < r[0] || t1[0] > r[2]) {
                const e = .5 * n;
                let i = t1[0] - r[0] > e ? -n : r[0] - t1[0] > e ? n : 0;
                0 === i && (i = t1[0] - r[2] > e ? -n : r[2] - t1[0] > e ? n : 0), t1[0] += i;
            }
            Mr(e, t1);
        }
        function Fr(t1, e, r, n) {
            const i = Math.pow(2, n.z) * Er, a = [
                n.x * Er,
                n.y * Er
            ], s = [];
            if (!t1) return s;
            for (const n of t1)for (const t1 of n){
                const n = [
                    t1.x + a[0],
                    t1.y + a[1]
                ];
                Rr(n, e, r, i), s.push(n);
            }
            return s;
        }
        function Or(t1, e, r, n) {
            const i = Math.pow(2, n.z) * Er, a = [
                n.x * Er,
                n.y * Er
            ], s = [];
            if (!t1) return s;
            for (const r of t1){
                const t1 = [];
                for (const n of r){
                    const r = [
                        n.x + a[0],
                        n.y + a[1]
                    ];
                    Mr(e, r), t1.push(r);
                }
                s.push(t1);
            }
            if (e[2] - e[0] <= i / 2) {
                (o = e)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0;
                for (const t1 of s)for (const n of t1)Rr(n, e, r, i);
            }
            var o;
            return s;
        }
        class Nr {
            constructor(t1, e){
                this.type = Re, this.geojson = t1, this.geometries = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`'within' expression requires exactly one argument, but found ${t1.length - 1} instead.`);
                if (rr(t1[1])) {
                    const e = t1[1];
                    if ("FeatureCollection" === e.type) for(let t1 = 0; t1 < e.features.length; ++t1){
                        const r = e.features[t1].geometry.type;
                        if ("Polygon" === r || "MultiPolygon" === r) return new Nr(e, e.features[t1].geometry);
                    }
                    else if ("Feature" === e.type) {
                        const t1 = e.geometry.type;
                        if ("Polygon" === t1 || "MultiPolygon" === t1) return new Nr(e, e.geometry);
                    } else if ("Polygon" === e.type || "MultiPolygon" === e.type) return new Nr(e, e);
                }
                return e.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t1) {
                if (null != t1.geometry() && null != t1.canonicalID()) {
                    if ("Point" === t1.geometryType()) return function(t1, e) {
                        const r = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i = t1.canonicalID();
                        if (!i) return !1;
                        if ("Polygon" === e.type) {
                            const a = Dr(e.coordinates, n, i), s = Fr(t1.geometry(), r, n, i);
                            if (!Ar(r, n)) return !1;
                            for (const t1 of s)if (!Ir(t1, a)) return !1;
                        }
                        if ("MultiPolygon" === e.type) {
                            const a = Lr(e.coordinates, n, i), s = Fr(t1.geometry(), r, n, i);
                            if (!Ar(r, n)) return !1;
                            for (const t1 of s)if (!Tr(t1, a)) return !1;
                        }
                        return !0;
                    }(t1, this.geometries);
                    if ("LineString" === t1.geometryType()) return function(t1, e) {
                        const r = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], n = [
                            1 / 0,
                            1 / 0,
                            -1 / 0,
                            -1 / 0
                        ], i = t1.canonicalID();
                        if (!i) return !1;
                        if ("Polygon" === e.type) {
                            const a = Dr(e.coordinates, n, i), s = Or(t1.geometry(), r, n, i);
                            if (!Ar(r, n)) return !1;
                            for (const t1 of s)if (!Vr(t1, a)) return !1;
                        }
                        if ("MultiPolygon" === e.type) {
                            const a = Lr(e.coordinates, n, i), s = Or(t1.geometry(), r, n, i);
                            if (!Ar(r, n)) return !1;
                            for (const t1 of s)if (!Cr(t1, a)) return !1;
                        }
                        return !0;
                    }(t1, this.geometries);
                }
                return !1;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "within",
                    this.geojson
                ];
            }
        }
        const Ur = {
            kilometers: 1,
            miles: 1e3 / 1609.344,
            nauticalmiles: 1e3 / 1852,
            meters: 1e3,
            metres: 1e3,
            yards: 1e3 / .9144,
            feet: 1e3 / .3048,
            inches: 1e3 / .0254
        }, jr = 1 / 298.257223563, qr = jr * (2 - jr), $r = Math.PI / 180;
        class Gr {
            static fromTile(t1, e, r) {
                const n = Math.PI * (1 - 2 * (t1 + .5) / Math.pow(2, e)), i = Math.atan(.5 * (Math.exp(n) - Math.exp(-n))) / $r;
                return new Gr(i, r);
            }
            static get units() {
                return Ur;
            }
            constructor(t1, e){
                if (void 0 === t1) throw new Error("No latitude given.");
                if (e && !Ur[e]) throw new Error(`Unknown unit ${e}. Use one of: ${Object.keys(Ur).join(", ")}`);
                const r = 6378.137 * $r * (e ? Ur[e] : 1), n = Math.cos(t1 * $r), i = 1 / (1 - qr * (1 - n * n)), a = Math.sqrt(i);
                this.kx = r * a * n, this.ky = r * a * i * (1 - qr);
            }
            distance(t1, e) {
                const r = Zr(t1[0] - e[0]) * this.kx, n = (t1[1] - e[1]) * this.ky;
                return Math.sqrt(r * r + n * n);
            }
            bearing(t1, e) {
                const r = Zr(e[0] - t1[0]) * this.kx;
                return Math.atan2(r, (e[1] - t1[1]) * this.ky) / $r;
            }
            destination(t1, e, r) {
                const n = r * $r;
                return this.offset(t1, Math.sin(n) * e, Math.cos(n) * e);
            }
            offset(t1, e, r) {
                return [
                    t1[0] + e / this.kx,
                    t1[1] + r / this.ky
                ];
            }
            lineDistance(t1) {
                let e = 0;
                for(let r = 0; r < t1.length - 1; r++)e += this.distance(t1[r], t1[r + 1]);
                return e;
            }
            area(t1) {
                let e = 0;
                for(let r = 0; r < t1.length; r++){
                    const n = t1[r];
                    for(let t1 = 0, i = n.length, a = i - 1; t1 < i; a = t1++)e += Zr(n[t1][0] - n[a][0]) * (n[t1][1] + n[a][1]) * (r ? -1 : 1);
                }
                return Math.abs(e) / 2 * this.kx * this.ky;
            }
            along(t1, e) {
                let r = 0;
                if (e <= 0) return t1[0];
                for(let n = 0; n < t1.length - 1; n++){
                    const i = t1[n], a = t1[n + 1], s = this.distance(i, a);
                    if (r += s, r > e) return Xr(i, a, (e - (r - s)) / s);
                }
                return t1[t1.length - 1];
            }
            pointToSegmentDistance(t1, e, r) {
                let [n, i] = e, a = Zr(r[0] - n) * this.kx, s = (r[1] - i) * this.ky;
                if (0 !== a || 0 !== s) {
                    const e = (Zr(t1[0] - n) * this.kx * a + (t1[1] - i) * this.ky * s) / (a * a + s * s);
                    e > 1 ? (n = r[0], i = r[1]) : e > 0 && (n += a / this.kx * e, i += s / this.ky * e);
                }
                return a = Zr(t1[0] - n) * this.kx, s = (t1[1] - i) * this.ky, Math.sqrt(a * a + s * s);
            }
            pointOnLine(t1, e) {
                let r = 1 / 0, n = t1[0][0], i = t1[0][1], a = 0, s = 0;
                for(let o = 0; o < t1.length - 1; o++){
                    let l = t1[o][0], u = t1[o][1], c = Zr(t1[o + 1][0] - l) * this.kx, h = (t1[o + 1][1] - u) * this.ky, p = 0;
                    0 === c && 0 === h || (p = (Zr(e[0] - l) * this.kx * c + (e[1] - u) * this.ky * h) / (c * c + h * h), p > 1 ? (l = t1[o + 1][0], u = t1[o + 1][1]) : p > 0 && (l += c / this.kx * p, u += h / this.ky * p)), c = Zr(e[0] - l) * this.kx, h = (e[1] - u) * this.ky;
                    const f = c * c + h * h;
                    f < r && (r = f, n = l, i = u, a = o, s = p);
                }
                return {
                    point: [
                        n,
                        i
                    ],
                    index: a,
                    t: Math.max(0, Math.min(1, s))
                };
            }
            lineSlice(t1, e, r) {
                let n = this.pointOnLine(r, t1), i = this.pointOnLine(r, e);
                if (n.index > i.index || n.index === i.index && n.t > i.t) {
                    const t1 = n;
                    n = i, i = t1;
                }
                const a = [
                    n.point
                ], s = n.index + 1, o = i.index;
                !Yr(r[s], a[0]) && s <= o && a.push(r[s]);
                for(let t1 = s + 1; t1 <= o; t1++)a.push(r[t1]);
                return Yr(r[o], i.point) || a.push(i.point), a;
            }
            lineSliceAlong(t1, e, r) {
                let n = 0;
                const i = [];
                for(let a = 0; a < r.length - 1; a++){
                    const s = r[a], o = r[a + 1], l = this.distance(s, o);
                    if (n += l, n > t1 && 0 === i.length && i.push(Xr(s, o, (t1 - (n - l)) / l)), n >= e) return i.push(Xr(s, o, (e - (n - l)) / l)), i;
                    n > t1 && i.push(o);
                }
                return i;
            }
            bufferPoint(t1, e) {
                const r = e / this.ky, n = e / this.kx;
                return [
                    t1[0] - n,
                    t1[1] - r,
                    t1[0] + n,
                    t1[1] + r
                ];
            }
            bufferBBox(t1, e) {
                const r = e / this.ky, n = e / this.kx;
                return [
                    t1[0] - n,
                    t1[1] - r,
                    t1[2] + n,
                    t1[3] + r
                ];
            }
            insideBBox(t1, e) {
                return Zr(t1[0] - e[0]) >= 0 && Zr(t1[0] - e[2]) <= 0 && t1[1] >= e[1] && t1[1] <= e[3];
            }
        }
        function Yr(t1, e) {
            return t1[0] === e[0] && t1[1] === e[1];
        }
        function Xr(t1, e, r) {
            const n = Zr(e[0] - t1[0]);
            return [
                t1[0] + n * r,
                t1[1] + (e[1] - t1[1]) * r
            ];
        }
        function Zr(t1) {
            for(; t1 < -180;)t1 += 360;
            for(; t1 > 180;)t1 -= 360;
            return t1;
        }
        class Hr {
            constructor(t1 = [], e = (t1, e)=>t1 < e ? -1 : t1 > e ? 1 : 0){
                if (this.data = t1, this.length = this.data.length, this.compare = e, this.length > 0) for(let t1 = (this.length >> 1) - 1; t1 >= 0; t1--)this._down(t1);
            }
            push(t1) {
                this.data.push(t1), this._up(this.length++);
            }
            pop() {
                if (0 === this.length) return;
                const t1 = this.data[0], e = this.data.pop();
                return --this.length > 0 && (this.data[0] = e, this._down(0)), t1;
            }
            peek() {
                return this.data[0];
            }
            _up(t1) {
                const { data: e, compare: r } = this, n = e[t1];
                for(; t1 > 0;){
                    const i = t1 - 1 >> 1, a = e[i];
                    if (r(n, a) >= 0) break;
                    e[t1] = a, t1 = i;
                }
                e[t1] = n;
            }
            _down(t1) {
                const { data: e, compare: r } = this, n = this.length >> 1, i = e[t1];
                for(; t1 < n;){
                    let n = 1 + (t1 << 1);
                    const a = n + 1;
                    if (a < this.length && r(e[a], e[n]) < 0 && (n = a), r(e[n], i) >= 0) break;
                    e[t1] = e[n], t1 = n;
                }
                e[t1] = i;
            }
        }
        var Wr = 8192;
        function Kr(t1, e) {
            return e.dist - t1.dist;
        }
        const Jr = 100, Qr = 50;
        function tn(t1) {
            const e = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            if (e.length !== t1.length) return !1;
            for(let r = 0; r < e.length; r++)if (e[r] !== t1[r]) return !1;
            return !0;
        }
        function en(t1) {
            return t1[1] - t1[0] + 1;
        }
        function rn(t1, e) {
            const r = t1[1] >= t1[0] && t1[1] < e;
            return r || console.warn("Distance Expression: Index is out of range"), r;
        }
        function nn(t1, e) {
            if (t1[0] > t1[1]) return [
                null,
                null
            ];
            const r = en(t1);
            if (e) {
                if (2 === r) return [
                    t1,
                    null
                ];
                const e = Math.floor(r / 2);
                return [
                    [
                        t1[0],
                        t1[0] + e
                    ],
                    [
                        t1[0] + e,
                        t1[1]
                    ]
                ];
            }
            {
                if (1 === r) return [
                    t1,
                    null
                ];
                const e = Math.floor(r / 2) - 1;
                return [
                    [
                        t1[0],
                        t1[0] + e
                    ],
                    [
                        t1[0] + e + 1,
                        t1[1]
                    ]
                ];
            }
        }
        function an(t1, e) {
            const r = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            if (!rn(e, t1.length)) return r;
            for(let n = e[0]; n <= e[1]; ++n)Mr(r, t1[n]);
            return r;
        }
        function sn(t1) {
            const e = [
                1 / 0,
                1 / 0,
                -1 / 0,
                -1 / 0
            ];
            for(let r = 0; r < t1.length; ++r)for(let n = 0; n < t1[r].length; ++n)Mr(e, t1[r][n]);
            return e;
        }
        function on(t1, e, r) {
            if (tn(t1) || tn(e)) return NaN;
            let n = 0, i = 0;
            return t1[2] < e[0] && (n = e[0] - t1[2]), t1[0] > e[2] && (n = t1[0] - e[2]), t1[1] > e[3] && (i = t1[1] - e[3]), t1[3] < e[1] && (i = e[1] - t1[3]), r.distance([
                0,
                0
            ], [
                n,
                i
            ]);
        }
        function ln(t1) {
            return 360 * t1 - 180;
        }
        function un(t1) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t1) * Math.PI / 180)) - 90;
        }
        function cn(t1, e) {
            const r = Math.pow(2, e.z), n = (t1.y / Wr + e.y) / r;
            return [
                ln((t1.x / Wr + e.x) / r),
                un(n)
            ];
        }
        function hn(t1, e) {
            const r = [];
            for(let n = 0; n < t1.length; ++n)r.push(cn(t1[n], e));
            return r;
        }
        function pn(t1, e, r) {
            const n = r.pointOnLine(e, t1).point;
            return r.distance(t1, n);
        }
        function fn(t1, e, r, n, i) {
            const a = r.slice(n[0], n[1] + 1);
            let s = 1 / 0;
            for(let r = e[0]; r <= e[1]; ++r)if (0 === (s = Math.min(s, pn(t1[r], a, i)))) return 0;
            return s;
        }
        function dn(t1, e, r, n, i) {
            const a = Math.min(i.pointToSegmentDistance(t1, r, n), i.pointToSegmentDistance(e, r, n)), s = Math.min(i.pointToSegmentDistance(r, t1, e), i.pointToSegmentDistance(n, t1, e));
            return Math.min(a, s);
        }
        function mn(t1, e, r, n, i) {
            if (!rn(e, t1.length) || !rn(n, r.length)) return NaN;
            let a = 1 / 0;
            for(let s = e[0]; s < e[1]; ++s)for(let e = n[0]; e < n[1]; ++e){
                if (zr(t1[s], t1[s + 1], r[e], r[e + 1])) return 0;
                a = Math.min(a, dn(t1[s], t1[s + 1], r[e], r[e + 1], i));
            }
            return a;
        }
        function yn(t1, e, r, n, i) {
            if (!rn(e, t1.length) || !rn(n, r.length)) return NaN;
            let a = 1 / 0;
            for(let s = e[0]; s <= e[1]; ++s)for(let e = n[0]; e <= n[1]; ++e)if (0 === (a = Math.min(a, i.distance(t1[s], r[e])))) return a;
            return a;
        }
        function gn(t1, e, r) {
            if (Ir(t1, e, !0)) return 0;
            let n = 1 / 0;
            for (const i of e){
                const e = i.length;
                if (e < 2) return console.warn("Distance Expression: Invalid polygon!"), NaN;
                if (i[0] !== i[e - 1] && 0 === (n = Math.min(n, r.pointToSegmentDistance(t1, i[e - 1], i[0])))) return n;
                if (0 === (n = Math.min(n, pn(t1, i, r)))) return n;
            }
            return n;
        }
        function xn(t1, e, r, n) {
            if (!rn(e, t1.length)) return NaN;
            for(let n = e[0]; n <= e[1]; ++n)if (Ir(t1[n], r, !0)) return 0;
            let i = 1 / 0;
            for(let a = e[0]; a < e[1]; ++a)for (const e of r)for(let r = 0, s = e.length, o = s - 1; r < s; o = r++){
                if (zr(t1[a], t1[a + 1], e[o], e[r])) return 0;
                i = Math.min(i, dn(t1[a], t1[a + 1], e[o], e[r], n));
            }
            return i;
        }
        function vn(t1, e) {
            for (const r of t1)for(let t1 = 0; t1 <= r.length - 1; ++t1)if (Ir(r[t1], e, !0)) return !0;
            return !1;
        }
        function bn(t1, e, r, n = 1 / 0) {
            const i = sn(t1), a = sn(e);
            if (n !== 1 / 0 && on(i, a, r) >= n) return n;
            if (Ar(i, a)) {
                if (vn(t1, e)) return 0;
            } else if (vn(e, t1)) return 0;
            let s = n;
            for (const n of t1)for(let t1 = 0, i = n.length, a = i - 1; t1 < i; a = t1++)for (const i of e)for(let e = 0, o = i.length, l = o - 1; e < o; l = e++){
                if (zr(n[a], n[t1], i[l], i[e])) return 0;
                s = Math.min(s, dn(n[a], n[t1], i[l], i[e], r));
            }
            return s;
        }
        function _n(t1, e, r, n, i, a, s) {
            if (null === a || null === s) return;
            const o = on(an(n, a), an(i, s), r);
            o < e && t1.push({
                dist: o,
                range1: a,
                range2: s
            });
        }
        function wn(t1, e, r, n, i = 1 / 0) {
            let a = Math.min(n.distance(t1[0], r[0][0]), i);
            if (0 === a) return a;
            const s = new Hr([
                {
                    dist: 0,
                    range1: [
                        0,
                        t1.length - 1
                    ],
                    range2: [
                        0,
                        0
                    ]
                }
            ], Kr), o = e ? Qr : Jr, l = sn(r);
            for(; s.length;){
                const i = s.pop();
                if (i.dist >= a) continue;
                const u = i.range1;
                if (en(u) <= o) {
                    if (!rn(u, t1.length)) return NaN;
                    if (e) {
                        const e = xn(t1, u, r, n);
                        if (0 === (a = Math.min(a, e))) return a;
                    } else for(let e = u[0]; e <= u[1]; ++e){
                        const i = gn(t1[e], r, n);
                        if (0 === (a = Math.min(a, i))) return a;
                    }
                } else {
                    const r = nn(u, e);
                    if (null !== r[0]) {
                        const e = on(an(t1, r[0]), l, n);
                        e < a && s.push({
                            dist: e,
                            range1: r[0],
                            range2: [
                                0,
                                0
                            ]
                        });
                    }
                    if (null !== r[1]) {
                        const e = on(an(t1, r[1]), l, n);
                        e < a && s.push({
                            dist: e,
                            range1: r[1],
                            range2: [
                                0,
                                0
                            ]
                        });
                    }
                }
            }
            return a;
        }
        function Mn(t1, e, r, n, i, a = 1 / 0) {
            let s = Math.min(a, i.distance(t1[0], r[0]));
            if (0 === s) return s;
            const o = new Hr([
                {
                    dist: 0,
                    range1: [
                        0,
                        t1.length - 1
                    ],
                    range2: [
                        0,
                        r.length - 1
                    ]
                }
            ], Kr), l = e ? Qr : Jr, u = n ? Qr : Jr;
            for(; o.length;){
                const a = o.pop();
                if (a.dist >= s) continue;
                const c = a.range1, h = a.range2;
                if (en(c) <= l && en(h) <= u) {
                    if (!rn(c, t1.length) || !rn(h, r.length)) return NaN;
                    if (e && n ? s = Math.min(s, mn(t1, c, r, h, i)) : e || n ? e && !n ? s = Math.min(s, fn(r, h, t1, c, i)) : !e && n && (s = Math.min(s, fn(t1, c, r, h, i))) : s = Math.min(s, yn(t1, c, r, h, i)), 0 === s) return s;
                } else {
                    const a = nn(c, e), l = nn(h, n);
                    _n(o, s, i, t1, r, a[0], l[0]), _n(o, s, i, t1, r, a[0], l[1]), _n(o, s, i, t1, r, a[1], l[0]), _n(o, s, i, t1, r, a[1], l[1]);
                }
            }
            return s;
        }
        function An(t1, e, r, n, i = 1 / 0) {
            let a = i;
            const s = an(t1, [
                0,
                t1.length - 1
            ]);
            for (const i of r)if (!(a !== 1 / 0 && on(s, an(i, [
                0,
                i.length - 1
            ]), n) >= a) && (a = Math.min(a, Mn(t1, e, i, !0, n, a)), 0 === a)) return a;
            return a;
        }
        function Sn(t1, e, r, n, i = 1 / 0) {
            let a = i;
            const s = an(t1, [
                0,
                t1.length - 1
            ]);
            for (const i of r){
                if (a !== 1 / 0 && on(s, sn(i), n) >= a) continue;
                const r = wn(t1, e, i, n, a);
                if (isNaN(r)) return r;
                if (0 === (a = Math.min(a, r))) return a;
            }
            return a;
        }
        function In(t1) {
            return "Point" === t1 || "MultiPoint" === t1 || "LineString" === t1 || "MultiLineString" === t1 || "Polygon" === t1 || "MultiPolygon" === t1;
        }
        class Pn {
            constructor(t1, e){
                this.type = De, this.geojson = t1, this.geometries = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`'distance' expression requires either one argument, but found ' ${t1.length - 1} instead.`);
                if (rr(t1[1])) {
                    const e = t1[1];
                    if ("FeatureCollection" === e.type) {
                        for(let t1 = 0; t1 < e.features.length; ++t1)if (In(e.features[t1].geometry.type)) return new Pn(e, e.features[t1].geometry);
                    } else if ("Feature" === e.type) {
                        if (In(e.geometry.type)) return new Pn(e, e.geometry);
                    } else if (In(e.type)) return new Pn(e, e);
                }
                return e.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
            }
            evaluate(t1) {
                const e = t1.geometry(), r = t1.canonicalID();
                if (null != e && null != r) {
                    if ("Point" === t1.geometryType()) return function(t1, e, r) {
                        const n = [];
                        for (const r of t1)for (const t1 of r)n.push(cn(t1, e));
                        const i = new Gr(n[0][1], "meters");
                        return "Point" === r.type || "MultiPoint" === r.type || "LineString" === r.type ? Mn(n, !1, "Point" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, "LineString" === r.type, i) : "MultiLineString" === r.type ? An(n, !1, r.coordinates, i) : "Polygon" === r.type || "MultiPolygon" === r.type ? Sn(n, !1, "Polygon" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, i) : null;
                    }(e, r, this.geometries);
                    if ("LineString" === t1.geometryType()) return function(t1, e, r) {
                        const n = [];
                        for (const r of t1){
                            const t1 = [];
                            for (const n of r)t1.push(cn(n, e));
                            n.push(t1);
                        }
                        const i = new Gr(n[0][0][1], "meters");
                        if ("Point" === r.type || "MultiPoint" === r.type || "LineString" === r.type) return An("Point" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, "LineString" === r.type, n, i);
                        if ("MultiLineString" === r.type) {
                            let t1 = 1 / 0;
                            for(let e = 0; e < r.coordinates.length; e++){
                                const a = An(r.coordinates[e], !0, n, i, t1);
                                if (isNaN(a)) return a;
                                if (0 === (t1 = Math.min(t1, a))) return t1;
                            }
                            return t1;
                        }
                        if ("Polygon" === r.type || "MultiPolygon" === r.type) {
                            let t1 = 1 / 0;
                            for(let e = 0; e < n.length; e++){
                                const a = Sn(n[e], !0, "Polygon" === r.type ? [
                                    r.coordinates
                                ] : r.coordinates, i, t1);
                                if (isNaN(a)) return a;
                                if (0 === (t1 = Math.min(t1, a))) return t1;
                            }
                            return t1;
                        }
                        return null;
                    }(e, r, this.geometries);
                    if ("Polygon" === t1.geometryType()) return function(t1, e, r) {
                        const n = [];
                        for (const r of function(t1, e) {
                            const r = t1.length;
                            if (r <= 1) return [
                                t1
                            ];
                            const n = [];
                            let i, a;
                            for(let e = 0; e < r; e++){
                                const r = wr(t1[e]);
                                0 !== r && (t1[e].area = Math.abs(r), void 0 === a && (a = r < 0), a === r < 0 ? (i && n.push(i), i = [
                                    t1[e]
                                ]) : i.push(t1[e]));
                            }
                            return i && n.push(i), n;
                        }(t1)){
                            const t1 = [];
                            for(let n = 0; n < r.length; ++n)t1.push(hn(r[n], e));
                            n.push(t1);
                        }
                        const i = new Gr(n[0][0][0][1], "meters");
                        if ("Point" === r.type || "MultiPoint" === r.type || "LineString" === r.type) return Sn("Point" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, "LineString" === r.type, n, i);
                        if ("MultiLineString" === r.type) {
                            let t1 = 1 / 0;
                            for(let e = 0; e < r.coordinates.length; e++){
                                const a = Sn(r.coordinates[e], !0, n, i, t1);
                                if (isNaN(a)) return a;
                                if (0 === (t1 = Math.min(t1, a))) return t1;
                            }
                            return t1;
                        }
                        return "Polygon" === r.type || "MultiPolygon" === r.type ? function(t1, e, r) {
                            let n = 1 / 0;
                            for (const i of t1)for (const t1 of e){
                                const e = bn(i, t1, r, n);
                                if (isNaN(e)) return e;
                                if (0 === (n = Math.min(n, e))) return n;
                            }
                            return n;
                        }("Polygon" === r.type ? [
                            r.coordinates
                        ] : r.coordinates, n, i) : null;
                    }(e, r, this.geometries);
                    console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
                } else console.warn("Distance Expression: requirs valid feature and canonical information.");
                return null;
            }
            eachChild() {}
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "distance",
                    this.geojson
                ];
            }
        }
        function zn(t1, e) {
            switch(t1){
                case "string":
                    return ir(e);
                case "number":
                    return +e;
                case "boolean":
                    return !!e;
                case "color":
                    return Ie.parse(e);
                case "formatted":
                    return Je.fromString(ir(e));
                case "resolvedImage":
                    return tr.build(ir(e));
            }
            return e;
        }
        function En(t1, e, r, n) {
            return void 0 !== n && (t1 = n * Math.round(t1 / n)), void 0 !== e && t1 < e && (t1 = e), void 0 !== r && t1 > r && (t1 = r), t1;
        }
        class kn {
            constructor(t1, e, r){
                this.type = t1, this.key = e, this.scope = r;
            }
            static parse(t1, e) {
                let r = e.expectedType;
                if (null == r && (r = Ne), t1.length < 2 || t1.length > 3) return e.error("Invalid number of arguments for 'config' expression.");
                const n = e.parse(t1[1], 1);
                if (!(n instanceof ar)) return e.error("Key name of 'config' expression must be a string literal.");
                if (t1.length >= 3) {
                    const i = e.parse(t1[2], 2);
                    return i instanceof ar ? new kn(r, ir(n.value), ir(i.value)) : e.error("Scope of 'config' expression must be a string literal.");
                }
                return new kn(r, ir(n.value));
            }
            evaluate(t1) {
                const e = [
                    this.key,
                    this.scope,
                    t1.scope
                ].filter(Boolean).join(""), r = t1.getConfig(e);
                if (!r) return null;
                const { type: n, value: i, values: a, minValue: s, maxValue: o, stepValue: l } = r, u = r.default.evaluate(t1);
                let c = u;
                if (i) {
                    const e = t1.scope;
                    t1.scope = (e || "").split("").slice(1).join(""), c = i.evaluate(t1), t1.scope = e;
                }
                return n && (c = zn(n, c)), void 0 === c || void 0 === s && void 0 === o && void 0 === l || ("number" == typeof c ? c = En(c, s, o, l) : Array.isArray(c) && (c = c.map((t1)=>"number" == typeof t1 ? En(t1, s, o, l) : t1))), void 0 !== i && void 0 !== c && a && !a.includes(c) && (c = u, n && (c = zn(n, c))), (n && n !== this.type || void 0 !== c && nr(c) !== this.type) && (c = zn(this.type.kind, c)), c;
            }
            eachChild() {}
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "config",
                    this.key
                ];
                return this.scope && t1.concat(this.key), t1;
            }
        }
        function Tn(t1) {
            if (t1 instanceof yr) {
                if ("get" === t1.name && 1 === t1.args.length) return !1;
                if ("feature-state" === t1.name) return !1;
                if ("has" === t1.name && 1 === t1.args.length) return !1;
                if ("properties" === t1.name || "geometry-type" === t1.name || "id" === t1.name) return !1;
                if (/^filter-/.test(t1.name)) return !1;
            }
            if (t1 instanceof Nr) return !1;
            if (t1 instanceof Pn) return !1;
            let e = !0;
            return t1.eachChild((t1)=>{
                e && !Tn(t1) && (e = !1);
            }), e;
        }
        function Bn(t1) {
            if (t1 instanceof yr && "feature-state" === t1.name) return !1;
            let e = !0;
            return t1.eachChild((t1)=>{
                e && !Bn(t1) && (e = !1);
            }), e;
        }
        function Vn(t1) {
            if (t1 instanceof kn) return new Set([
                t1.key
            ]);
            let e = new Set;
            return t1.eachChild((t1)=>{
                e = new Set([
                    ...e,
                    ...Vn(t1)
                ]);
            }), e;
        }
        function Cn(t1, e) {
            if (t1 instanceof yr && e.indexOf(t1.name) >= 0) return !1;
            let r = !0;
            return t1.eachChild((t1)=>{
                r && !Cn(t1, e) && (r = !1);
            }), r;
        }
        class Dn {
            constructor(t1, e){
                this.type = e.type, this.name = t1, this.boundExpression = e;
            }
            static parse(t1, e) {
                if (2 !== t1.length || "string" != typeof t1[1]) return e.error("'var' expression requires exactly one string literal argument.");
                const r = t1[1];
                return e.scope.has(r) ? new Dn(r, e.scope.get(r)) : e.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t1) {
                return this.boundExpression.evaluate(t1);
            }
            eachChild() {}
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "var",
                    this.name
                ];
            }
        }
        class Ln {
            constructor(t1, e = [], r, n = new Ve, i = [], a, s){
                this.registry = t1, this.path = e, this.key = e.map((t1)=>"string" == typeof t1 ? `['${t1}']` : `[${t1}]`).join(""), this.scope = n, this.errors = i, this.expectedType = r, this._scope = a, this.options = s;
            }
            parse(t1, e, r, n, i = {}) {
                return e || r ? this.concat(e, null, r, n)._parse(t1, i) : this._parse(t1, i);
            }
            parseObjectValue(t1, e, r, n, i, a = {}) {
                return this.concat(e, r, n, i)._parse(t1, a);
            }
            _parse(t1, e) {
                function r(t1, e, r) {
                    return "assert" === r ? new lr(e, [
                        t1
                    ]) : "coerce" === r ? new fr(e, [
                        t1
                    ]) : t1;
                }
                if (null !== t1 && "string" != typeof t1 && "boolean" != typeof t1 && "number" != typeof t1 || (t1 = [
                    "literal",
                    t1
                ]), Array.isArray(t1)) {
                    if (0 === t1.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                    const n = "string" == typeof t1[0] ? this.registry[t1[0]] : void 0;
                    if (n) {
                        let i = n.parse(t1, this);
                        if (!i) return null;
                        if (this.expectedType) {
                            const t1 = this.expectedType, n = i.type;
                            if ("string" !== t1.kind && "number" !== t1.kind && "boolean" !== t1.kind && "object" !== t1.kind && "array" !== t1.kind || "value" !== n.kind) if ("color" !== t1.kind && "formatted" !== t1.kind && "resolvedImage" !== t1.kind || "value" !== n.kind && "string" !== n.kind) {
                                if (this.checkSubtype(t1, n)) return null;
                            } else i = r(i, t1, e.typeAnnotation || "coerce");
                            else i = r(i, t1, e.typeAnnotation || "assert");
                        }
                        if (!(i instanceof ar) && "resolvedImage" !== i.type.kind && Fn(i)) {
                            const t1 = new mr(this._scope, this.options);
                            try {
                                i = new ar(i.type, i.evaluate(t1));
                            } catch (t1) {
                                return this.error(t1.message), null;
                            }
                        }
                        return i;
                    }
                    return fr.parse([
                        "to-array",
                        t1
                    ], this);
                }
                return this.error(void 0 === t1 ? "'undefined' value invalid. Use null instead." : "object" == typeof t1 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t1} instead.`);
            }
            concat(t1, e, r, n) {
                let i = "number" == typeof t1 ? this.path.concat(t1) : this.path;
                i = "string" == typeof e ? i.concat(e) : i;
                const a = n ? this.scope.concat(n) : this.scope;
                return new Ln(this.registry, i, r || null, a, this.errors, this._scope, this.options);
            }
            error(t1, ...e) {
                const r = `${this.key}${e.map((t1)=>`[${t1}]`).join("")}`;
                this.errors.push(new Be(r, t1));
            }
            checkSubtype(t1, e) {
                const r = Xe(t1, e);
                return r && this.error(r), r;
            }
        }
        var Rn = Ln;
        function Fn(t1) {
            if (t1 instanceof Dn) return Fn(t1.boundExpression);
            if (t1 instanceof yr && "error" === t1.name) return !1;
            if (t1 instanceof xr) return !1;
            if (t1 instanceof Nr) return !1;
            if (t1 instanceof Pn) return !1;
            if (t1 instanceof kn) return !1;
            const e = t1 instanceof fr || t1 instanceof lr;
            let r = !0;
            return t1.eachChild((t1)=>{
                r = e ? r && Fn(t1) : r && t1 instanceof ar;
            }), !!r && Tn(t1) && Cn(t1, [
                "zoom",
                "heatmap-density",
                "line-progress",
                "raster-value",
                "sky-radial-progress",
                "accumulated",
                "is-supported-script",
                "pitch",
                "distance-from-center",
                "measure-light",
                "raster-particle-speed"
            ]);
        }
        function On(t1, e) {
            const r = t1.length - 1;
            let n, i, a = 0, s = r, o = 0;
            for(; a <= s;)if (o = Math.floor((a + s) / 2), n = t1[o], i = t1[o + 1], n <= e) {
                if (o === r || e < i) return o;
                a = o + 1;
            } else {
                if (!(n > e)) throw new sr("Input is not a number.");
                s = o - 1;
            }
            return 0;
        }
        class Nn {
            constructor(t1, e, r){
                this.type = t1, this.input = e, this.labels = [], this.outputs = [];
                for (const [t1, e] of r)this.labels.push(t1), this.outputs.push(e);
            }
            static parse(t1, e) {
                if (t1.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if ((t1.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
                const r = e.parse(t1[1], 1, De);
                if (!r) return null;
                const n = [];
                let i = null;
                e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType);
                for(let r = 1; r < t1.length; r += 2){
                    const a = 1 === r ? -1 / 0 : t1[r], s = t1[r + 1], o = r, l = r + 1;
                    if ("number" != typeof a) return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);
                    if (n.length && n[n.length - 1][0] >= a) return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o);
                    const u = e.parse(s, l, i);
                    if (!u) return null;
                    i = i || u.type, n.push([
                        a,
                        u
                    ]);
                }
                return new Nn(i, r, n);
            }
            evaluate(t1) {
                const e = this.labels, r = this.outputs;
                if (1 === e.length) return r[0].evaluate(t1);
                const n = this.input.evaluate(t1);
                if (n <= e[0]) return r[0].evaluate(t1);
                const i = e.length;
                return n >= e[i - 1] ? r[i - 1].evaluate(t1) : r[On(e, n)].evaluate(t1);
            }
            eachChild(t1) {
                t1(this.input);
                for (const e of this.outputs)t1(e);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = [
                    "step",
                    this.input.serialize()
                ];
                for(let e = 0; e < this.labels.length; e++)e > 0 && t1.push(this.labels[e]), t1.push(this.outputs[e].serialize());
                return t1;
            }
        }
        const Un = .95047, jn = 1.08883, qn = 4 / 29, $n = 6 / 29, Gn = 3 * $n * $n, Yn = $n * $n * $n, Xn = Math.PI / 180, Zn = 180 / Math.PI;
        function Hn(t1) {
            return t1 > Yn ? Math.pow(t1, 1 / 3) : t1 / Gn + qn;
        }
        function Wn(t1) {
            return t1 > $n ? t1 * t1 * t1 : Gn * (t1 - qn);
        }
        function Kn(t1) {
            return 255 * (t1 <= .0031308 ? 12.92 * t1 : 1.055 * Math.pow(t1, 1 / 2.4) - .055);
        }
        function Jn(t1) {
            return (t1 /= 255) <= .04045 ? t1 / 12.92 : Math.pow((t1 + .055) / 1.055, 2.4);
        }
        function Qn(t1) {
            const e = Jn(t1.r), r = Jn(t1.g), n = Jn(t1.b), i = Hn((.4124564 * e + .3575761 * r + .1804375 * n) / Un), a = Hn((.2126729 * e + .7151522 * r + .072175 * n) / 1);
            return {
                l: 116 * a - 16,
                a: 500 * (i - a),
                b: 200 * (a - Hn((.0193339 * e + .119192 * r + .9503041 * n) / jn)),
                alpha: t1.a
            };
        }
        function ti(t1) {
            let e = (t1.l + 16) / 116, r = isNaN(t1.a) ? e : e + t1.a / 500, n = isNaN(t1.b) ? e : e - t1.b / 200;
            return e = 1 * Wn(e), r = Un * Wn(r), n = jn * Wn(n), new Ie(Kn(3.2404542 * r - 1.5371385 * e - .4985314 * n), Kn(-.969266 * r + 1.8760108 * e + .041556 * n), Kn(.0556434 * r - .2040259 * e + 1.0572252 * n), t1.alpha);
        }
        function ei(t1, e, r) {
            const n = e - t1;
            return t1 + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);
        }
        const ri = {
            forward: Qn,
            reverse: ti,
            interpolate: function(t1, e, r) {
                return {
                    l: ze(t1.l, e.l, r),
                    a: ze(t1.a, e.a, r),
                    b: ze(t1.b, e.b, r),
                    alpha: ze(t1.alpha, e.alpha, r)
                };
            }
        }, ni = {
            forward: function(t1) {
                const { l: e, a: r, b: n } = Qn(t1), i = Math.atan2(n, r) * Zn;
                return {
                    h: i < 0 ? i + 360 : i,
                    c: Math.sqrt(r * r + n * n),
                    l: e,
                    alpha: t1.a
                };
            },
            reverse: function(t1) {
                const e = t1.h * Xn, r = t1.c;
                return ti({
                    l: t1.l,
                    a: Math.cos(e) * r,
                    b: Math.sin(e) * r,
                    alpha: t1.alpha
                });
            },
            interpolate: function(t1, e, r) {
                return {
                    h: ei(t1.h, e.h, r),
                    c: ze(t1.c, e.c, r),
                    l: ze(t1.l, e.l, r),
                    alpha: ze(t1.alpha, e.alpha, r)
                };
            }
        };
        var ii = Object.freeze({
            __proto__: null,
            hcl: ni,
            lab: ri
        });
        class ai {
            constructor(t1, e, r, n, i, a){
                this.type = t1, this.operator = e, this.interpolation = r, this.input = n, this.dynamicStops = i, this.labels = [], this.outputs = [];
                for (const [t1, e] of a)this.labels.push(t1), this.outputs.push(e);
            }
            static interpolationFactor(t1, e, r, n) {
                let i = 0;
                if ("exponential" === t1.name) i = si(e, t1.base, r, n);
                else if ("linear" === t1.name) i = si(e, 1, r, n);
                else if ("cubic-bezier" === t1.name) {
                    const a = t1.controlPoints;
                    i = new U(a[0], a[1], a[2], a[3]).solve(si(e, 1, r, n));
                }
                return i;
            }
            static parse(t1, e) {
                let [r, n, i, ...a] = t1;
                if (!Array.isArray(n) || 0 === n.length) return e.error("Expected an interpolation type expression.", 1);
                if ("linear" === n[0]) n = {
                    name: "linear"
                };
                else if ("exponential" === n[0]) {
                    const t1 = n[1];
                    if ("number" != typeof t1) return e.error("Exponential interpolation requires a numeric base.", 1, 1);
                    n = {
                        name: "exponential",
                        base: t1
                    };
                } else {
                    if ("cubic-bezier" !== n[0]) return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);
                    {
                        const t1 = n.slice(1);
                        if (4 !== t1.length || t1.some((t1)=>"number" != typeof t1 || t1 < 0 || t1 > 1)) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                        n = {
                            name: "cubic-bezier",
                            controlPoints: t1
                        };
                    }
                }
                if (t1.length - 1 < 3) return e.error(`Expected at least 3 arguments, but found only ${t1.length - 1}.`);
                if (t1.length - 1 > 3 && (t1.length - 1) % 2 != 0) return e.error("Expected an even number of arguments.");
                if (i = e.parse(i, 2, De), !i) return null;
                const s = [];
                let o = null;
                if ("interpolate-hcl" === r || "interpolate-lab" === r ? o = Fe : e.expectedType && "value" !== e.expectedType.kind && (o = e.expectedType), t1.length - 1 == 3) {
                    const t1 = e.parse(a[0], 3, Ne);
                    return t1 ? new ai(o, r, n, i, t1, s) : null;
                }
                for(let t1 = 0; t1 < a.length; t1 += 2){
                    const r = a[t1], n = a[t1 + 1], i = t1 + 3, l = t1 + 4;
                    if ("number" != typeof r) return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);
                    if (s.length && s[s.length - 1][0] >= r) return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i);
                    const u = e.parse(n, l, o);
                    if (!u) return null;
                    o = o || u.type, s.push([
                        r,
                        u
                    ]);
                }
                return "number" === o.kind || "color" === o.kind || "array" === o.kind && "number" === o.itemType.kind && "number" == typeof o.N ? new ai(o, r, n, i, null, s) : e.error(`Type ${Ge(o)} is not interpolatable.`);
            }
            evaluate(t1) {
                let e = this.labels, r = this.outputs;
                if (this.dynamicStops) {
                    const n = this.dynamicStops.evaluate(t1);
                    if (n.length % 2 != 0) throw new sr("Expected an even number of arguments.");
                    e = [], r = [];
                    for(let t1 = 0; t1 < n.length; t1 += 2){
                        const i = n[t1], a = new ar(De, n[t1 + 1]);
                        if ("number" != typeof i) throw new sr('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.');
                        if (e.length && e[e.length - 1] >= i) throw new sr('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.');
                        e.push(i), r.push(a);
                    }
                    if (0 === e.length) throw new sr("Expected at least one input/output pair.");
                }
                if (1 === e.length) return r[0].evaluate(t1);
                const n = this.input.evaluate(t1);
                if (n <= e[0]) return r[0].evaluate(t1);
                const i = e.length;
                if (n >= e[i - 1]) return r[i - 1].evaluate(t1);
                const a = On(e, n), s = ai.interpolationFactor(this.interpolation, n, e[a], e[a + 1]), o = r[a].evaluate(t1), l = r[a + 1].evaluate(t1);
                return "interpolate" === this.operator ? ke[this.type.kind.toLowerCase()](o, l, s) : "interpolate-hcl" === this.operator ? ni.reverse(ni.interpolate(ni.forward(o), ni.forward(l), s)) : ri.reverse(ri.interpolate(ri.forward(o), ri.forward(l), s));
            }
            eachChild(t1) {
                t1(this.input);
                for (const e of this.outputs)t1(e);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined());
            }
            serialize() {
                let t1;
                t1 = "linear" === this.interpolation.name ? [
                    "linear"
                ] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? [
                    "linear"
                ] : [
                    "exponential",
                    this.interpolation.base
                ] : [
                    "cubic-bezier"
                ].concat(this.interpolation.controlPoints);
                const e = [
                    this.operator,
                    t1,
                    this.input.serialize()
                ];
                if (this.dynamicStops) e.push(this.dynamicStops.serialize());
                else for(let t1 = 0; t1 < this.labels.length; t1++)e.push(this.labels[t1], this.outputs[t1].serialize());
                return e;
            }
        }
        function si(t1, e, r, n) {
            const i = n - r, a = t1 - r;
            return 0 === i ? 0 : 1 === e ? a / i : (Math.pow(e, a) - 1) / (Math.pow(e, i) - 1);
        }
        class oi {
            constructor(t1, e){
                this.type = t1, this.args = e;
            }
            static parse(t1, e) {
                if (t1.length < 2) return e.error("Expectected at least one argument.");
                let r = null;
                const n = e.expectedType;
                n && "value" !== n.kind && (r = n);
                const i = [];
                for (const n of t1.slice(1)){
                    const t1 = e.parse(n, 1 + i.length, r, void 0, {
                        typeAnnotation: "omit"
                    });
                    if (!t1) return null;
                    r = r || t1.type, i.push(t1);
                }
                const a = n && i.some((t1)=>Xe(n, t1.type));
                return new oi(a ? Ne : r, i);
            }
            evaluate(t1) {
                let e, r = null, n = 0;
                for (const i of this.args){
                    if (n++, r = i.evaluate(t1), r && r instanceof tr && !r.available && (e || (e = r), r = null, n === this.args.length)) return e;
                    if (null !== r) break;
                }
                return r;
            }
            eachChild(t1) {
                this.args.forEach(t1);
            }
            outputDefined() {
                return this.args.every((t1)=>t1.outputDefined());
            }
            serialize() {
                const t1 = [
                    "coalesce"
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        class li {
            constructor(t1, e){
                this.type = e.type, this.bindings = [].concat(t1), this.result = e;
            }
            evaluate(t1) {
                return this.result.evaluate(t1);
            }
            eachChild(t1) {
                for (const e of this.bindings)t1(e[1]);
                t1(this.result);
            }
            static parse(t1, e) {
                if (t1.length < 4) return e.error(`Expected at least 3 arguments, but found ${t1.length - 1} instead.`);
                const r = [];
                for(let n = 1; n < t1.length - 1; n += 2){
                    const i = t1[n];
                    if ("string" != typeof i) return e.error(`Expected string, but found ${typeof i} instead.`, n);
                    if (/[^a-zA-Z0-9_]/.test(i)) return e.error("Variable names must contain only alphanumeric characters or '_'.", n);
                    const a = e.parse(t1[n + 1], n + 1);
                    if (!a) return null;
                    r.push([
                        i,
                        a
                    ]);
                }
                const n = e.parse(t1[t1.length - 1], t1.length - 1, e.expectedType, r);
                return n ? new li(r, n) : null;
            }
            outputDefined() {
                return this.result.outputDefined();
            }
            serialize() {
                const t1 = [
                    "let"
                ];
                for (const [e, r] of this.bindings)t1.push(e, r.serialize());
                return t1.push(this.result.serialize()), t1;
            }
        }
        class ui {
            constructor(t1, e, r){
                this.type = t1, this.index = e, this.input = r;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, De), n = e.parse(t1[2], 2, $e(e.expectedType || Ne));
                return r && n ? new ui(n.type.itemType, r, n) : null;
            }
            evaluate(t1) {
                const e = this.index.evaluate(t1), r = this.input.evaluate(t1);
                if (e < 0) throw new sr(`Array index out of bounds: ${e} < 0.`);
                if (e > r.length - 1) throw new sr(`Array index out of bounds: ${e} > ${r.length - 1}.`);
                if (e === Math.floor(e)) return r[e];
                const n = Math.floor(e), i = Math.ceil(e), a = r[n], s = r[i];
                if ("number" != typeof a || "number" != typeof s) throw new sr(`Cannot interpolate between non-number values at index ${e}.`);
                const o = e - n;
                return a * (1 - o) + s * o;
            }
            eachChild(t1) {
                t1(this.index), t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return [
                    "at",
                    this.index.serialize(),
                    this.input.serialize()
                ];
            }
        }
        class ci {
            constructor(t1, e){
                this.type = Re, this.needle = t1, this.haystack = e;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error(`Expected 2 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, Ne), n = e.parse(t1[2], 2, Ne);
                return r && n ? Ze(r.type, [
                    Re,
                    Le,
                    De,
                    Ce,
                    Ne
                ]) ? new ci(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ge(r.type)} instead`) : null;
            }
            evaluate(t1) {
                const e = this.needle.evaluate(t1), r = this.haystack.evaluate(t1);
                if (null == r) return !1;
                if (!He(e, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new sr(`Expected first argument to be of type boolean, string, number or null, but found ${Ge(nr(e))} instead.`);
                if (!He(r, [
                    "string",
                    "array"
                ])) throw new sr(`Expected second argument to be of type array or string, but found ${Ge(nr(r))} instead.`);
                return r.indexOf(e) >= 0;
            }
            eachChild(t1) {
                t1(this.needle), t1(this.haystack);
            }
            outputDefined() {
                return !0;
            }
            serialize() {
                return [
                    "in",
                    this.needle.serialize(),
                    this.haystack.serialize()
                ];
            }
        }
        class hi {
            constructor(t1, e, r){
                this.type = De, this.needle = t1, this.haystack = e, this.fromIndex = r;
            }
            static parse(t1, e) {
                if (t1.length <= 2 || t1.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, Ne), n = e.parse(t1[2], 2, Ne);
                if (!r || !n) return null;
                if (!Ze(r.type, [
                    Re,
                    Le,
                    De,
                    Ce,
                    Ne
                ])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ge(r.type)} instead`);
                if (4 === t1.length) {
                    const i = e.parse(t1[3], 3, De);
                    return i ? new hi(r, n, i) : null;
                }
                return new hi(r, n);
            }
            evaluate(t1) {
                const e = this.needle.evaluate(t1), r = this.haystack.evaluate(t1);
                if (!He(e, [
                    "boolean",
                    "string",
                    "number",
                    "null"
                ])) throw new sr(`Expected first argument to be of type boolean, string, number or null, but found ${Ge(nr(e))} instead.`);
                if (!He(r, [
                    "string",
                    "array"
                ])) throw new sr(`Expected second argument to be of type array or string, but found ${Ge(nr(r))} instead.`);
                if (this.fromIndex) {
                    const n = this.fromIndex.evaluate(t1);
                    return r.indexOf(e, n);
                }
                return r.indexOf(e);
            }
            eachChild(t1) {
                t1(this.needle), t1(this.haystack), this.fromIndex && t1(this.fromIndex);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                if (null != this.fromIndex && void 0 !== this.fromIndex) {
                    const t1 = this.fromIndex.serialize();
                    return [
                        "index-of",
                        this.needle.serialize(),
                        this.haystack.serialize(),
                        t1
                    ];
                }
                return [
                    "index-of",
                    this.needle.serialize(),
                    this.haystack.serialize()
                ];
            }
        }
        class pi {
            constructor(t1, e, r, n, i, a){
                this.inputType = t1, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = a;
            }
            static parse(t1, e) {
                if (t1.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t1.length - 1}.`);
                if (t1.length % 2 != 1) return e.error("Expected an even number of arguments.");
                let r, n;
                e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType);
                const i = {}, a = [];
                for(let s = 2; s < t1.length - 1; s += 2){
                    let o = t1[s];
                    const l = t1[s + 1];
                    Array.isArray(o) || (o = [
                        o
                    ]);
                    const u = e.concat(s);
                    if (0 === o.length) return u.error("Expected at least one branch label.");
                    for (const t1 of o){
                        if ("number" != typeof t1 && "string" != typeof t1) return u.error("Branch labels must be numbers or strings.");
                        if ("number" == typeof t1 && Math.abs(t1) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                        if ("number" == typeof t1 && Math.floor(t1) !== t1) return u.error("Numeric branch labels must be integer values.");
                        if (r) {
                            if (u.checkSubtype(r, nr(t1))) return null;
                        } else r = nr(t1);
                        if (void 0 !== i[String(t1)]) return u.error("Branch labels must be unique.");
                        i[String(t1)] = a.length;
                    }
                    const c = e.parse(l, s, n);
                    if (!c) return null;
                    n = n || c.type, a.push(c);
                }
                const s = e.parse(t1[1], 1, Ne);
                if (!s) return null;
                const o = e.parse(t1[t1.length - 1], t1.length - 1, n);
                return o ? "value" !== s.type.kind && e.concat(1).checkSubtype(r, s.type) ? null : new pi(r, n, s, i, a, o) : null;
            }
            evaluate(t1) {
                const e = this.input.evaluate(t1);
                return (nr(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t1);
            }
            eachChild(t1) {
                t1(this.input), this.outputs.forEach(t1), t1(this.otherwise);
            }
            outputDefined() {
                return this.outputs.every((t1)=>t1.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
                const t1 = [
                    "match",
                    this.input.serialize()
                ], e = Object.keys(this.cases).sort(), r = [], n = {};
                for (const t1 of e){
                    const e = n[this.cases[t1]];
                    void 0 === e ? (n[this.cases[t1]] = r.length, r.push([
                        this.cases[t1],
                        [
                            t1
                        ]
                    ])) : r[e][1].push(t1);
                }
                const i = (t1)=>"number" === this.inputType.kind ? Number(t1) : t1;
                for (const [e, n] of r)t1.push(1 === n.length ? i(n[0]) : n.map(i)), t1.push(this.outputs[e].serialize());
                return t1.push(this.otherwise.serialize()), t1;
            }
        }
        class fi {
            constructor(t1, e, r){
                this.type = t1, this.branches = e, this.otherwise = r;
            }
            static parse(t1, e) {
                if (t1.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t1.length - 1}.`);
                if (t1.length % 2 != 0) return e.error("Expected an odd number of arguments.");
                let r;
                e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType);
                const n = [];
                for(let i = 1; i < t1.length - 1; i += 2){
                    const a = e.parse(t1[i], i, Re);
                    if (!a) return null;
                    const s = e.parse(t1[i + 1], i + 1, r);
                    if (!s) return null;
                    n.push([
                        a,
                        s
                    ]), r = r || s.type;
                }
                const i = e.parse(t1[t1.length - 1], t1.length - 1, r);
                return i ? new fi(r, n, i) : null;
            }
            evaluate(t1) {
                for (const [e, r] of this.branches)if (e.evaluate(t1)) return r.evaluate(t1);
                return this.otherwise.evaluate(t1);
            }
            eachChild(t1) {
                for (const [e, r] of this.branches)t1(e), t1(r);
                t1(this.otherwise);
            }
            outputDefined() {
                return this.branches.every(([t1, e])=>e.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
                const t1 = [
                    "case"
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        class di {
            constructor(t1, e, r, n){
                this.type = t1, this.input = e, this.beginIndex = r, this.endIndex = n;
            }
            static parse(t1, e) {
                if (t1.length <= 2 || t1.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1, Ne), n = e.parse(t1[2], 2, De);
                if (!r || !n) return null;
                if (!Ze(r.type, [
                    $e(Ne),
                    Le,
                    Ne
                ])) return e.error(`Expected first argument to be of type array or string, but found ${Ge(r.type)} instead`);
                if (4 === t1.length) {
                    const i = e.parse(t1[3], 3, De);
                    return i ? new di(r.type, r, n, i) : null;
                }
                return new di(r.type, r, n);
            }
            evaluate(t1) {
                const e = this.input.evaluate(t1), r = this.beginIndex.evaluate(t1);
                if (!He(e, [
                    "string",
                    "array"
                ])) throw new sr(`Expected first argument to be of type array or string, but found ${Ge(nr(e))} instead.`);
                if (this.endIndex) {
                    const n = this.endIndex.evaluate(t1);
                    return e.slice(r, n);
                }
                return e.slice(r);
            }
            eachChild(t1) {
                t1(this.input), t1(this.beginIndex), this.endIndex && t1(this.endIndex);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                if (null != this.endIndex && void 0 !== this.endIndex) {
                    const t1 = this.endIndex.serialize();
                    return [
                        "slice",
                        this.input.serialize(),
                        this.beginIndex.serialize(),
                        t1
                    ];
                }
                return [
                    "slice",
                    this.input.serialize(),
                    this.beginIndex.serialize()
                ];
            }
        }
        function mi(t1, e) {
            return "==" === t1 || "!=" === t1 ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind;
        }
        function yi(t1, e, r, n) {
            return 0 === n.compare(e, r);
        }
        function gi(t1, e, r) {
            const n = "==" !== t1 && "!=" !== t1;
            return class i {
                constructor(t1, e, r){
                    this.type = Re, this.lhs = t1, this.rhs = e, this.collator = r, this.hasUntypedArgument = "value" === t1.type.kind || "value" === e.type.kind;
                }
                static parse(t1, e) {
                    if (3 !== t1.length && 4 !== t1.length) return e.error("Expected two or three arguments.");
                    const r = t1[0];
                    let a = e.parse(t1[1], 1, Ne);
                    if (!a) return null;
                    if (!mi(r, a.type)) return e.concat(1).error(`"${r}" comparisons are not supported for type '${Ge(a.type)}'.`);
                    let s = e.parse(t1[2], 2, Ne);
                    if (!s) return null;
                    if (!mi(r, s.type)) return e.concat(2).error(`"${r}" comparisons are not supported for type '${Ge(s.type)}'.`);
                    if (a.type.kind !== s.type.kind && "value" !== a.type.kind && "value" !== s.type.kind) return e.error(`Cannot compare types '${Ge(a.type)}' and '${Ge(s.type)}'.`);
                    n && ("value" === a.type.kind && "value" !== s.type.kind ? a = new lr(s.type, [
                        a
                    ]) : "value" !== a.type.kind && "value" === s.type.kind && (s = new lr(a.type, [
                        s
                    ])));
                    let o = null;
                    if (4 === t1.length) {
                        if ("string" !== a.type.kind && "string" !== s.type.kind && "value" !== a.type.kind && "value" !== s.type.kind) return e.error("Cannot use collator to compare non-string types.");
                        if (o = e.parse(t1[3], 3, Ue), !o) return null;
                    }
                    return new i(a, s, o);
                }
                evaluate(i) {
                    const a = this.lhs.evaluate(i), s = this.rhs.evaluate(i);
                    if (n && this.hasUntypedArgument) {
                        const e = nr(a), r = nr(s);
                        if (e.kind !== r.kind || "string" !== e.kind && "number" !== e.kind) throw new sr(`Expected arguments for "${t1}" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`);
                    }
                    if (this.collator && !n && this.hasUntypedArgument) {
                        const t1 = nr(a), r = nr(s);
                        if ("string" !== t1.kind || "string" !== r.kind) return e(i, a, s);
                    }
                    return this.collator ? r(i, a, s, this.collator.evaluate(i)) : e(i, a, s);
                }
                eachChild(t1) {
                    t1(this.lhs), t1(this.rhs), this.collator && t1(this.collator);
                }
                outputDefined() {
                    return !0;
                }
                serialize() {
                    const e = [
                        t1
                    ];
                    return this.eachChild((t1)=>{
                        e.push(t1.serialize());
                    }), e;
                }
            };
        }
        const xi = gi("==", function(t1, e, r) {
            return e === r;
        }, yi), vi = gi("!=", function(t1, e, r) {
            return e !== r;
        }, function(t1, e, r, n) {
            return !yi(0, e, r, n);
        }), bi = gi("<", function(t1, e, r) {
            return e < r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) < 0;
        }), _i = gi(">", function(t1, e, r) {
            return e > r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) > 0;
        }), wi = gi("<=", function(t1, e, r) {
            return e <= r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) <= 0;
        }), Mi = gi(">=", function(t1, e, r) {
            return e >= r;
        }, function(t1, e, r, n) {
            return n.compare(e, r) >= 0;
        });
        class Ai {
            constructor(t1, e, r, n, i, a){
                this.type = Le, this.number = t1, this.locale = e, this.currency = r, this.unit = n, this.minFractionDigits = i, this.maxFractionDigits = a;
            }
            static parse(t1, e) {
                if (3 !== t1.length) return e.error("Expected two arguments.");
                const r = e.parse(t1[1], 1, De);
                if (!r) return null;
                const n = t1[2];
                if ("object" != typeof n || Array.isArray(n)) return e.error("NumberFormat options argument must be an object.");
                let i = null;
                if (n.locale && (i = e.parseObjectValue(n.locale, 2, "locale", Le), !i)) return null;
                let a = null;
                if (n.currency && (a = e.parseObjectValue(n.currency, 2, "currency", Le), !a)) return null;
                let s = null;
                if (n.unit && (s = e.parseObjectValue(n.unit, 2, "unit", Le), !s)) return null;
                let o = null;
                if (n["min-fraction-digits"] && (o = e.parseObjectValue(n["min-fraction-digits"], 2, "min-fraction-digits", De), !o)) return null;
                let l = null;
                return n["max-fraction-digits"] && (l = e.parseObjectValue(n["max-fraction-digits"], 2, "max-fraction-digits", De), !l) ? null : new Ai(r, i, a, s, o, l);
            }
            evaluate(t1) {
                return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t1) : [], {
                    style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
                    currency: this.currency ? this.currency.evaluate(t1) : void 0,
                    unit: this.unit ? this.unit.evaluate(t1) : void 0,
                    minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t1) : void 0,
                    maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t1) : void 0
                }).format(this.number.evaluate(t1));
            }
            eachChild(t1) {
                t1(this.number), this.locale && t1(this.locale), this.currency && t1(this.currency), this.unit && t1(this.unit), this.minFractionDigits && t1(this.minFractionDigits), this.maxFractionDigits && t1(this.maxFractionDigits);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = {};
                return this.locale && (t1.locale = this.locale.serialize()), this.currency && (t1.currency = this.currency.serialize()), this.unit && (t1.unit = this.unit.serialize()), this.minFractionDigits && (t1["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t1["max-fraction-digits"] = this.maxFractionDigits.serialize()), [
                    "number-format",
                    this.number.serialize(),
                    t1
                ];
            }
        }
        class Si {
            constructor(t1){
                this.type = De, this.input = t1;
            }
            static parse(t1, e) {
                if (2 !== t1.length) return e.error(`Expected 1 argument, but found ${t1.length - 1} instead.`);
                const r = e.parse(t1[1], 1);
                return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${Ge(r.type)} instead.`) : new Si(r) : null;
            }
            evaluate(t1) {
                const e = this.input.evaluate(t1);
                if ("string" == typeof e) return e.length;
                if (Array.isArray(e)) return e.length;
                throw new sr(`Expected value to be of type string or array, but found ${Ge(nr(e))} instead.`);
            }
            eachChild(t1) {
                t1(this.input);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                const t1 = [
                    "length"
                ];
                return this.eachChild((e)=>{
                    t1.push(e.serialize());
                }), t1;
            }
        }
        function Ii(t1) {
            return function() {
                t1 = 1831565813 + (t1 |= 0) | 0;
                let e = Math.imul(t1 ^ t1 >>> 15, 1 | t1);
                return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296;
            };
        }
        const Pi = {
            "==": xi,
            "!=": vi,
            ">": _i,
            "<": bi,
            ">=": Mi,
            "<=": wi,
            array: lr,
            at: ui,
            boolean: lr,
            case: fi,
            coalesce: oi,
            collator: xr,
            format: ur,
            image: cr,
            in: ci,
            "index-of": hi,
            interpolate: ai,
            "interpolate-hcl": ai,
            "interpolate-lab": ai,
            length: Si,
            let: li,
            literal: ar,
            match: pi,
            number: lr,
            "number-format": Ai,
            object: lr,
            slice: di,
            step: Nn,
            string: lr,
            "to-boolean": fr,
            "to-color": fr,
            "to-number": fr,
            "to-string": fr,
            var: Dn,
            within: Nr,
            distance: Pn,
            config: kn
        };
        function zi(t1, [e, r, n, i]) {
            e = e.evaluate(t1), r = r.evaluate(t1), n = n.evaluate(t1);
            const a = i ? i.evaluate(t1) : 1, s = er(e, r, n, a);
            if (s) throw new sr(s);
            return new Ie(e / 255 * a, r / 255 * a, n / 255 * a, a);
        }
        function Ei(t1, [e, r, n, i]) {
            e = e.evaluate(t1), r = r.evaluate(t1), n = n.evaluate(t1);
            const a = i ? i.evaluate(t1) : 1, s = function(t1, e, r, n) {
                return "number" == typeof t1 && t1 >= 0 && t1 <= 360 ? "number" == typeof e && e >= 0 && e <= 100 && "number" == typeof r && r >= 0 && r <= 100 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid hsla value [${[
                    t1,
                    e,
                    r,
                    n
                ].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${("number" == typeof n ? [
                    t1,
                    e,
                    r,
                    n
                ] : [
                    t1,
                    e,
                    r
                ]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${("number" == typeof n ? [
                    t1,
                    e,
                    r,
                    n
                ] : [
                    t1,
                    e,
                    r
                ]).join(", ")}]: 'h' must be between 0 and 360.`;
            }(e, r, n, a);
            if (s) throw new sr(s);
            const o = `hsla(${e}, ${r}%, ${n}%, ${a})`, l = Ie.parse(o);
            if (!l) throw new sr(`Failed to parse HSLA color: ${o}`);
            return l;
        }
        function ki(t1, e) {
            return t1 in e;
        }
        function Ti(t1, e) {
            const r = e[t1];
            return void 0 === r ? null : r;
        }
        function Bi(t1) {
            return {
                type: t1
            };
        }
        function Vi(t1) {
            return {
                result: "success",
                value: t1
            };
        }
        function Ci(t1) {
            return {
                result: "error",
                value: t1
            };
        }
        function Di(t1, e) {
            return !!t1 && !!t1.parameters && t1.parameters.indexOf(e) > -1;
        }
        function Li(t1) {
            return "data-driven" === t1["property-type"];
        }
        function Ri(t1) {
            return Di(t1.expression, "measure-light");
        }
        function Fi(t1) {
            return Di(t1.expression, "zoom");
        }
        function Oi(t1) {
            return !!t1.expression && t1.expression.interpolated;
        }
        function Ni(t1) {
            return "object" == typeof t1 && null !== t1 && !Array.isArray(t1);
        }
        function Ui(t1) {
            return t1;
        }
        function ji(t1, e) {
            const r = "color" === e.type, n = t1.stops && "object" == typeof t1.stops[0][0], i = n || !(n || void 0 !== t1.property), a = t1.type || (Oi(e) ? "exponential" : "interval");
            if (r && ((t1 = Te({}, t1)).stops && (t1.stops = t1.stops.map((t1)=>[
                    t1[0],
                    Ie.parse(t1[1])
                ])), t1.default = Ie.parse(t1.default ? t1.default : e.default)), t1.colorSpace && "rgb" !== t1.colorSpace && !ii[t1.colorSpace]) throw new Error(`Unknown color space: ${t1.colorSpace}`);
            let s, o, l;
            if ("exponential" === a) s = Yi;
            else if ("interval" === a) s = Gi;
            else if ("categorical" === a) {
                s = $i, o = Object.create(null);
                for (const e of t1.stops)o[e[0]] = e[1];
                l = typeof t1.stops[0][0];
            } else {
                if ("identity" !== a) throw new Error(`Unknown function type "${a}"`);
                s = Xi;
            }
            if (n) {
                const r = {}, n = [];
                for(let e = 0; e < t1.stops.length; e++){
                    const i = t1.stops[e], a = i[0].zoom;
                    void 0 === r[a] && (r[a] = {
                        zoom: a,
                        type: t1.type,
                        property: t1.property,
                        default: t1.default,
                        stops: []
                    }, n.push(a)), r[a].stops.push([
                        i[0].value,
                        i[1]
                    ]);
                }
                const i = [];
                for (const t1 of n)i.push([
                    r[t1].zoom,
                    ji(r[t1], e)
                ]);
                const a = {
                    name: "linear"
                };
                return {
                    kind: "composite",
                    interpolationType: a,
                    interpolationFactor: ai.interpolationFactor.bind(void 0, a),
                    zoomStops: i.map((t1)=>t1[0]),
                    evaluate: ({ zoom: r }, n)=>Yi({
                            stops: i,
                            base: t1.base
                        }, e, r).evaluate(r, n)
                };
            }
            if (i) {
                const r = "exponential" === a ? {
                    name: "exponential",
                    base: void 0 !== t1.base ? t1.base : 1
                } : null;
                return {
                    kind: "camera",
                    interpolationType: r,
                    interpolationFactor: ai.interpolationFactor.bind(void 0, r),
                    zoomStops: t1.stops.map((t1)=>t1[0]),
                    evaluate: ({ zoom: r })=>s(t1, e, r, o, l)
                };
            }
            return {
                kind: "source",
                evaluate (r, n) {
                    const i = n && n.properties ? n.properties[t1.property] : void 0;
                    return void 0 === i ? qi(t1.default, e.default) : s(t1, e, i, o, l);
                }
            };
        }
        function qi(t1, e, r) {
            return void 0 !== t1 ? t1 : void 0 !== e ? e : void 0 !== r ? r : void 0;
        }
        function $i(t1, e, r, n, i) {
            return qi(typeof r === i ? n[r] : void 0, t1.default, e.default);
        }
        function Gi(t1, e, r) {
            if ("number" !== hr(r)) return qi(t1.default, e.default);
            const n = t1.stops.length;
            if (1 === n) return t1.stops[0][1];
            if (r <= t1.stops[0][0]) return t1.stops[0][1];
            if (r >= t1.stops[n - 1][0]) return t1.stops[n - 1][1];
            const i = On(t1.stops.map((t1)=>t1[0]), r);
            return t1.stops[i][1];
        }
        function Yi(t1, e, r) {
            const n = void 0 !== t1.base ? t1.base : 1;
            if ("number" !== hr(r)) return qi(t1.default, e.default);
            const i = t1.stops.length;
            if (1 === i) return t1.stops[0][1];
            if (r <= t1.stops[0][0]) return t1.stops[0][1];
            if (r >= t1.stops[i - 1][0]) return t1.stops[i - 1][1];
            const a = On(t1.stops.map((t1)=>t1[0]), r), s = function(t1, e, r, n) {
                const i = n - r, a = t1 - r;
                return 0 === i ? 0 : 1 === e ? a / i : (Math.pow(e, a) - 1) / (Math.pow(e, i) - 1);
            }(r, n, t1.stops[a][0], t1.stops[a + 1][0]), o = t1.stops[a][1], l = t1.stops[a + 1][1];
            let u = ke[e.type] || Ui;
            if (t1.colorSpace && "rgb" !== t1.colorSpace) {
                const e = ii[t1.colorSpace];
                u = (t1, r)=>e.reverse(e.interpolate(e.forward(t1), e.forward(r), s));
            }
            return "function" == typeof o.evaluate ? {
                evaluate (...t1) {
                    const e = o.evaluate.apply(void 0, t1), r = l.evaluate.apply(void 0, t1);
                    if (void 0 !== e && void 0 !== r) return u(e, r, s);
                }
            } : u(o, l, s);
        }
        function Xi(t1, e, r) {
            return "color" === e.type ? r = Ie.parse(r) : "formatted" === e.type ? r = Je.fromString(r.toString()) : "resolvedImage" === e.type ? r = tr.build(r.toString()) : hr(r) === e.type || "enum" === e.type && e.values[r] || (r = void 0), qi(r, t1.default, e.default);
        }
        yr.register(Pi, {
            error: [
                {
                    kind: "error"
                },
                [
                    Le
                ],
                (t1, [e])=>{
                    throw new sr(e.evaluate(t1));
                }
            ],
            typeof: [
                Le,
                [
                    Ne
                ],
                (t1, [e])=>Ge(nr(e.evaluate(t1)))
            ],
            "to-rgba": [
                $e(De, 4),
                [
                    Fe
                ],
                (t1, [e])=>e.evaluate(t1).toRenderColor(null).toArray()
            ],
            "to-hsla": [
                $e(De, 4),
                [
                    Fe
                ],
                (t1, [e])=>e.evaluate(t1).toRenderColor(null).toHslaArray()
            ],
            rgb: [
                Fe,
                [
                    De,
                    De,
                    De
                ],
                zi
            ],
            rgba: [
                Fe,
                [
                    De,
                    De,
                    De,
                    De
                ],
                zi
            ],
            hsl: [
                Fe,
                [
                    De,
                    De,
                    De
                ],
                Ei
            ],
            hsla: [
                Fe,
                [
                    De,
                    De,
                    De,
                    De
                ],
                Ei
            ],
            has: {
                type: Re,
                overloads: [
                    [
                        [
                            Le
                        ],
                        (t1, [e])=>ki(e.evaluate(t1), t1.properties())
                    ],
                    [
                        [
                            Le,
                            Oe
                        ],
                        (t1, [e, r])=>ki(e.evaluate(t1), r.evaluate(t1))
                    ]
                ]
            },
            get: {
                type: Ne,
                overloads: [
                    [
                        [
                            Le
                        ],
                        (t1, [e])=>Ti(e.evaluate(t1), t1.properties())
                    ],
                    [
                        [
                            Le,
                            Oe
                        ],
                        (t1, [e, r])=>Ti(e.evaluate(t1), r.evaluate(t1))
                    ]
                ]
            },
            "feature-state": [
                Ne,
                [
                    Le
                ],
                (t1, [e])=>Ti(e.evaluate(t1), t1.featureState || {})
            ],
            properties: [
                Oe,
                [],
                (t1)=>t1.properties()
            ],
            "geometry-type": [
                Le,
                [],
                (t1)=>t1.geometryType()
            ],
            id: [
                Ne,
                [],
                (t1)=>t1.id()
            ],
            zoom: [
                De,
                [],
                (t1)=>t1.globals.zoom
            ],
            pitch: [
                De,
                [],
                (t1)=>t1.globals.pitch || 0
            ],
            "distance-from-center": [
                De,
                [],
                (t1)=>t1.distanceFromCenter()
            ],
            "measure-light": [
                De,
                [
                    Le
                ],
                (t1, [e])=>t1.measureLight(e.evaluate(t1))
            ],
            "heatmap-density": [
                De,
                [],
                (t1)=>t1.globals.heatmapDensity || 0
            ],
            "line-progress": [
                De,
                [],
                (t1)=>t1.globals.lineProgress || 0
            ],
            "raster-value": [
                De,
                [],
                (t1)=>t1.globals.rasterValue || 0
            ],
            "raster-particle-speed": [
                De,
                [],
                (t1)=>t1.globals.rasterParticleSpeed || 0
            ],
            "sky-radial-progress": [
                De,
                [],
                (t1)=>t1.globals.skyRadialProgress || 0
            ],
            accumulated: [
                Ne,
                [],
                (t1)=>void 0 === t1.globals.accumulated ? null : t1.globals.accumulated
            ],
            "+": [
                De,
                Bi(De),
                (t1, e)=>{
                    let r = 0;
                    for (const n of e)r += n.evaluate(t1);
                    return r;
                }
            ],
            "*": [
                De,
                Bi(De),
                (t1, e)=>{
                    let r = 1;
                    for (const n of e)r *= n.evaluate(t1);
                    return r;
                }
            ],
            "-": {
                type: De,
                overloads: [
                    [
                        [
                            De,
                            De
                        ],
                        (t1, [e, r])=>e.evaluate(t1) - r.evaluate(t1)
                    ],
                    [
                        [
                            De
                        ],
                        (t1, [e])=>-e.evaluate(t1)
                    ]
                ]
            },
            "/": [
                De,
                [
                    De,
                    De
                ],
                (t1, [e, r])=>e.evaluate(t1) / r.evaluate(t1)
            ],
            "%": [
                De,
                [
                    De,
                    De
                ],
                (t1, [e, r])=>e.evaluate(t1) % r.evaluate(t1)
            ],
            ln2: [
                De,
                [],
                ()=>Math.LN2
            ],
            pi: [
                De,
                [],
                ()=>Math.PI
            ],
            e: [
                De,
                [],
                ()=>Math.E
            ],
            "^": [
                De,
                [
                    De,
                    De
                ],
                (t1, [e, r])=>Math.pow(e.evaluate(t1), r.evaluate(t1))
            ],
            sqrt: [
                De,
                [
                    De
                ],
                (t1, [e])=>Math.sqrt(e.evaluate(t1))
            ],
            log10: [
                De,
                [
                    De
                ],
                (t1, [e])=>Math.log(e.evaluate(t1)) / Math.LN10
            ],
            ln: [
                De,
                [
                    De
                ],
                (t1, [e])=>Math.log(e.evaluate(t1))
            ],
            log2: [
                De,
                [
                    De
                ],
                (t1, [e])=>Math.log(e.evaluate(t1)) / Math.LN2
            ],
            sin: [
                De,
                [
                    De
                ],
                (t1, [e])=>Math.sin(e.evaluate(t1))
            ],
            cos: [
                De,
                [
                    De
                ],
                (t1, [e])=>Math.cos(e.evaluate(t1))
            ],
            tan: [
                De,
                [
                    De
                ],
                (t1, [e])=>Math.tan(e.evaluate(t1))
            ],
            asin: [
                De,
                [
                    De
                ],
                (t1, [e])=>Math.asin(e.evaluate(t1))
            ],
            acos: [
                De,
                [
                    De
                ],
                (t1, [e])=>Math.acos(e.evaluate(t1))
            ],
            atan: [
                De,
                [
                    De
                ],
                (t1, [e])=>Math.atan(e.evaluate(t1))
            ],
            min: [
                De,
                Bi(De),
                (t1, e)=>Math.min(...e.map((e)=>e.evaluate(t1)))
            ],
            max: [
                De,
                Bi(De),
                (t1, e)=>Math.max(...e.map((e)=>e.evaluate(t1)))
            ],
            abs: [
                De,
                [
                    De
                ],
                (t1, [e])=>Math.abs(e.evaluate(t1))
            ],
            round: [
                De,
                [
                    De
                ],
                (t1, [e])=>{
                    const r = e.evaluate(t1);
                    return r < 0 ? -Math.round(-r) : Math.round(r);
                }
            ],
            floor: [
                De,
                [
                    De
                ],
                (t1, [e])=>Math.floor(e.evaluate(t1))
            ],
            ceil: [
                De,
                [
                    De
                ],
                (t1, [e])=>Math.ceil(e.evaluate(t1))
            ],
            "filter-==": [
                Re,
                [
                    Le,
                    Ne
                ],
                (t1, [e, r])=>t1.properties()[e.value] === r.value
            ],
            "filter-id-==": [
                Re,
                [
                    Ne
                ],
                (t1, [e])=>t1.id() === e.value
            ],
            "filter-type-==": [
                Re,
                [
                    Le
                ],
                (t1, [e])=>t1.geometryType() === e.value
            ],
            "filter-<": [
                Re,
                [
                    Le,
                    Ne
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n < i;
                }
            ],
            "filter-id-<": [
                Re,
                [
                    Ne
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r < n;
                }
            ],
            "filter->": [
                Re,
                [
                    Le,
                    Ne
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n > i;
                }
            ],
            "filter-id->": [
                Re,
                [
                    Ne
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r > n;
                }
            ],
            "filter-<=": [
                Re,
                [
                    Le,
                    Ne
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n <= i;
                }
            ],
            "filter-id-<=": [
                Re,
                [
                    Ne
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r <= n;
                }
            ],
            "filter->=": [
                Re,
                [
                    Le,
                    Ne
                ],
                (t1, [e, r])=>{
                    const n = t1.properties()[e.value], i = r.value;
                    return typeof n == typeof i && n >= i;
                }
            ],
            "filter-id->=": [
                Re,
                [
                    Ne
                ],
                (t1, [e])=>{
                    const r = t1.id(), n = e.value;
                    return typeof r == typeof n && r >= n;
                }
            ],
            "filter-has": [
                Re,
                [
                    Ne
                ],
                (t1, [e])=>e.value in t1.properties()
            ],
            "filter-has-id": [
                Re,
                [],
                (t1)=>null !== t1.id() && void 0 !== t1.id()
            ],
            "filter-type-in": [
                Re,
                [
                    $e(Le)
                ],
                (t1, [e])=>e.value.indexOf(t1.geometryType()) >= 0
            ],
            "filter-id-in": [
                Re,
                [
                    $e(Ne)
                ],
                (t1, [e])=>e.value.indexOf(t1.id()) >= 0
            ],
            "filter-in-small": [
                Re,
                [
                    Le,
                    $e(Ne)
                ],
                (t1, [e, r])=>r.value.indexOf(t1.properties()[e.value]) >= 0
            ],
            "filter-in-large": [
                Re,
                [
                    Le,
                    $e(Ne)
                ],
                (t1, [e, r])=>(function(t1, e, r, n) {
                        for(; r <= n;){
                            const i = r + n >> 1;
                            if (e[i] === t1) return !0;
                            e[i] > t1 ? n = i - 1 : r = i + 1;
                        }
                        return !1;
                    })(t1.properties()[e.value], r.value, 0, r.value.length - 1)
            ],
            all: {
                type: Re,
                overloads: [
                    [
                        [
                            Re,
                            Re
                        ],
                        (t1, [e, r])=>e.evaluate(t1) && r.evaluate(t1)
                    ],
                    [
                        Bi(Re),
                        (t1, e)=>{
                            for (const r of e)if (!r.evaluate(t1)) return !1;
                            return !0;
                        }
                    ]
                ]
            },
            any: {
                type: Re,
                overloads: [
                    [
                        [
                            Re,
                            Re
                        ],
                        (t1, [e, r])=>e.evaluate(t1) || r.evaluate(t1)
                    ],
                    [
                        Bi(Re),
                        (t1, e)=>{
                            for (const r of e)if (r.evaluate(t1)) return !0;
                            return !1;
                        }
                    ]
                ]
            },
            "!": [
                Re,
                [
                    Re
                ],
                (t1, [e])=>!e.evaluate(t1)
            ],
            "is-supported-script": [
                Re,
                [
                    Le
                ],
                (t1, [e])=>{
                    const r = t1.globals && t1.globals.isSupportedScript;
                    return !r || r(e.evaluate(t1));
                }
            ],
            upcase: [
                Le,
                [
                    Le
                ],
                (t1, [e])=>e.evaluate(t1).toUpperCase()
            ],
            downcase: [
                Le,
                [
                    Le
                ],
                (t1, [e])=>e.evaluate(t1).toLowerCase()
            ],
            concat: [
                Le,
                Bi(Ne),
                (t1, e)=>e.map((e)=>ir(e.evaluate(t1))).join("")
            ],
            "resolved-locale": [
                Le,
                [
                    Ue
                ],
                (t1, [e])=>e.evaluate(t1).resolvedLocale()
            ],
            random: [
                De,
                [
                    De,
                    De,
                    Ne
                ],
                (t1, e)=>{
                    const [r, n, i] = e.map((e)=>e.evaluate(t1));
                    if (r > n) return r;
                    if (r === n) return r;
                    let a;
                    if ("string" == typeof i) a = function(t1) {
                        let e = 0;
                        if (0 === t1.length) return e;
                        for(let r = 0; r < t1.length; r++)e = (e << 5) - e + t1.charCodeAt(r), e |= 0;
                        return e;
                    }(i);
                    else {
                        if ("number" != typeof i) throw new sr(`Invalid seed input: ${i}`);
                        a = i;
                    }
                    return r + Ii(a)() * (n - r);
                }
            ]
        });
        class Zi {
            constructor(t1, e, r, n){
                this.expression = t1, this._warningHistory = {}, this._evaluator = new mr(r, n), this._defaultValue = e ? function(t1) {
                    return "color" === t1.type && (Ni(t1.default) || Array.isArray(t1.default)) ? new Ie(0, 0, 0, 0) : "color" === t1.type ? Ie.parse(t1.default) || null : void 0 === t1.default ? null : t1.default;
                }(e) : null, this._enumValues = e && "enum" === e.type ? e.values : null, this.configDependencies = Vn(t1);
            }
            evaluateWithoutErrorHandling(t1, e, r, n, i, a, s, o) {
                return this._evaluator.globals = t1, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a, this._evaluator.featureTileCoord = s || null, this._evaluator.featureDistanceData = o || null, this.expression.evaluate(this._evaluator);
            }
            evaluate(t1, e, r, n, i, a, s, o) {
                this._evaluator.globals = t1, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = a || null, this._evaluator.featureTileCoord = s || null, this._evaluator.featureDistanceData = o || null;
                try {
                    const t1 = this.expression.evaluate(this._evaluator);
                    if (null == t1 || "number" == typeof t1 && t1 != t1) return this._defaultValue;
                    if (this._enumValues && !(t1 in this._enumValues)) throw new sr(`Expected value to be one of ${Object.keys(this._enumValues).map((t1)=>JSON.stringify(t1)).join(", ")}, but found ${JSON.stringify(t1)} instead.`);
                    return t1;
                } catch (t1) {
                    return this._warningHistory[t1.message] || (this._warningHistory[t1.message] = !0, "undefined" != typeof console && console.warn(`Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${t1.message}`)), this._defaultValue;
                }
            }
        }
        function Hi(t1) {
            return Array.isArray(t1) && t1.length > 0 && "string" == typeof t1[0] && t1[0] in Pi;
        }
        function Wi(t1, e, r, n) {
            const i = new Rn(Pi, [], e ? function(t1) {
                const e = {
                    color: Fe,
                    string: Le,
                    number: De,
                    enum: Le,
                    boolean: Re,
                    formatted: je,
                    resolvedImage: qe
                };
                return "array" === t1.type ? $e(e[t1.value] || Ne, t1.length) : e[t1.type];
            }(e) : void 0, void 0, void 0, r, n), a = i.parse(t1, void 0, void 0, void 0, e && "string" === e.type ? {
                typeAnnotation: "coerce"
            } : void 0);
            return a ? Vi(new Zi(a, e, r, n)) : Ci(i.errors);
        }
        class Ki {
            constructor(t1, e, r, n){
                this.kind = t1, this._styleExpression = e, this.isLightConstant = r, this.isLineProgressConstant = n, this.isStateDependent = "constant" !== t1 && !Bn(e.expression), this.configDependencies = Vn(e.expression);
            }
            evaluateWithoutErrorHandling(t1, e, r, n, i, a) {
                return this._styleExpression.evaluateWithoutErrorHandling(t1, e, r, n, i, a);
            }
            evaluate(t1, e, r, n, i, a) {
                return this._styleExpression.evaluate(t1, e, r, n, i, a);
            }
        }
        class Ji {
            constructor(t1, e, r, n, i, a){
                this.kind = t1, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = "camera" !== t1 && !Bn(e.expression), this.isLightConstant = i, this.isLineProgressConstant = a, this.configDependencies = Vn(e.expression), this.interpolationType = n;
            }
            evaluateWithoutErrorHandling(t1, e, r, n, i, a) {
                return this._styleExpression.evaluateWithoutErrorHandling(t1, e, r, n, i, a);
            }
            evaluate(t1, e, r, n, i, a) {
                return this._styleExpression.evaluate(t1, e, r, n, i, a);
            }
            interpolationFactor(t1, e, r) {
                return this.interpolationType ? ai.interpolationFactor(this.interpolationType, t1, e, r) : 0;
            }
        }
        function Qi(t1, e, r, n) {
            if ("error" === (t1 = Wi(t1, e, r, n)).result) return t1;
            const i = t1.value.expression, a = Tn(i);
            if (!a && !Li(e)) return Ci([
                new Be("", "data expressions not supported")
            ]);
            const s = Cn(i, [
                "zoom",
                "pitch",
                "distance-from-center"
            ]);
            if (!s && !Fi(e)) return Ci([
                new Be("", "zoom expressions not supported")
            ]);
            const o = Cn(i, [
                "measure-light"
            ]);
            if (!o && !Ri(e)) return Ci([
                new Be("", "measure-light expression not supported")
            ]);
            const l = Cn(i, [
                "line-progress"
            ]);
            if (!l && !function(t1) {
                return Di(t1.expression, "line-progress");
            }(e)) return Ci([
                new Be("", "line-progress expression not supported")
            ]);
            const u = e.expression && e.expression.relaxZoomRestriction, c = ea(i);
            return c || s || u ? c instanceof Be ? Ci([
                c
            ]) : c instanceof ai && !Oi(e) ? Ci([
                new Be("", '"interpolate" expressions cannot be used with this property')
            ]) : Vi(c ? new Ji(a && l ? "camera" : "composite", t1.value, c.labels, c instanceof ai ? c.interpolation : void 0, o, l) : new Ki(a && l ? "constant" : "source", t1.value, o, l)) : Ci([
                new Be("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')
            ]);
        }
        class ta {
            constructor(t1, e){
                this._parameters = t1, this._specification = e, Te(this, ji(this._parameters, this._specification));
            }
            static deserialize(t1) {
                return new ta(t1._parameters, t1._specification);
            }
            static serialize(t1) {
                return {
                    _parameters: t1._parameters,
                    _specification: t1._specification
                };
            }
        }
        function ea(t1) {
            let e = null;
            if (t1 instanceof li) e = ea(t1.result);
            else if (t1 instanceof oi) {
                for (const r of t1.args)if (e = ea(r), e) break;
            } else (t1 instanceof Nn || t1 instanceof ai) && t1.input instanceof yr && "zoom" === t1.input.name && (e = t1);
            return e instanceof Be || t1.eachChild((t1)=>{
                const r = ea(t1);
                r instanceof Be ? e = r : e && r && e !== r && (e = new Be("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e;
        }
        var ra, na, ia = function() {
            if (na) return ra;
            na = 1, ra = e;
            var t1 = 3;
            function e(e, r, n) {
                var i = this.cells = [];
                if (e instanceof ArrayBuffer) {
                    this.arrayBuffer = e;
                    var a = new Int32Array(this.arrayBuffer);
                    e = a[0], this.d = (r = a[1]) + 2 * (n = a[2]);
                    for(var s = 0; s < this.d * this.d; s++){
                        var o = a[t1 + s], l = a[t1 + s + 1];
                        i.push(o === l ? null : a.subarray(o, l));
                    }
                    var u = a[t1 + i.length + 1];
                    this.keys = a.subarray(a[t1 + i.length], u), this.bboxes = a.subarray(u), this.insert = this._insertReadonly;
                } else {
                    this.d = r + 2 * n;
                    for(var c = 0; c < this.d * this.d; c++)i.push([]);
                    this.keys = [], this.bboxes = [];
                }
                this.n = r, this.extent = e, this.padding = n, this.scale = r / e, this.uid = 0;
                var h = n / r * e;
                this.min = -h, this.max = e + h;
            }
            return e.prototype.insert = function(t1, e, r, n, i) {
                this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t1), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);
            }, e.prototype._insertReadonly = function() {
                throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
            }, e.prototype._insertCell = function(t1, e, r, n, i, a) {
                this.cells[i].push(a);
            }, e.prototype.query = function(t1, e, r, n, i) {
                var a = this.min, s = this.max;
                if (t1 <= a && e <= a && s <= r && s <= n && !i) return Array.prototype.slice.call(this.keys);
                var o = [];
                return this._forEachCell(t1, e, r, n, this._queryCell, o, {}, i), o;
            }, e.prototype._queryCell = function(t1, e, r, n, i, a, s, o) {
                var l = this.cells[i];
                if (null !== l) for(var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++){
                    var p = l[h];
                    if (void 0 === s[p]) {
                        var f = 4 * p;
                        (o ? o(c[f + 0], c[f + 1], c[f + 2], c[f + 3]) : t1 <= c[f + 2] && e <= c[f + 3] && r >= c[f + 0] && n >= c[f + 1]) ? (s[p] = !0, a.push(u[p])) : s[p] = !1;
                    }
                }
            }, e.prototype._forEachCell = function(t1, e, r, n, i, a, s, o) {
                for(var l = this._convertToCellCoord(t1), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++)for(var f = u; f <= h; f++){
                    var d = this.d * f + p;
                    if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(f), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t1, e, r, n, d, a, s, o)) return;
                }
            }, e.prototype._convertFromCellCoord = function(t1) {
                return (t1 - this.padding) / this.scale;
            }, e.prototype._convertToCellCoord = function(t1) {
                return Math.max(0, Math.min(this.d - 1, Math.floor(t1 * this.scale) + this.padding));
            }, e.prototype.toArrayBuffer = function() {
                if (this.arrayBuffer) return this.arrayBuffer;
                for(var e = this.cells, r = t1 + this.cells.length + 1 + 1, n = 0, i = 0; i < this.cells.length; i++)n += this.cells[i].length;
                var a = new Int32Array(r + n + this.keys.length + this.bboxes.length);
                a[0] = this.extent, a[1] = this.n, a[2] = this.padding;
                for(var s = r, o = 0; o < e.length; o++){
                    var l = e[o];
                    a[t1 + o] = s, a.set(l, s), s += l.length;
                }
                return a[t1 + e.length] = s, a.set(this.keys, s), a[t1 + e.length + 1] = s += this.keys.length, a.set(this.bboxes, s), s += this.bboxes.length, a.buffer;
            }, ra;
        }(), aa = e(ia);
        const sa = {};
        function oa(t1, e, r = {}) {
            Object.defineProperty(t1, "_classRegistryKey", {
                value: e,
                writable: !1
            }), sa[e] = {
                klass: t1,
                omit: r.omit || []
            };
        }
        oa(Object, "Object"), aa.serialize = function(t1, e) {
            const r = t1.toArrayBuffer();
            return e && e.add(r), {
                buffer: r
            };
        }, aa.deserialize = function(t1) {
            return new aa(t1.buffer);
        }, Object.defineProperty(aa, "name", {
            value: "Grid"
        }), oa(aa, "Grid"), "undefined" != typeof DOMMatrix && oa(DOMMatrix, "DOMMatrix"), oa(Ie, "Color"), oa(Error, "Error"), oa(Je, "Formatted"), oa(Ke, "FormattedSection"), oa(ee, "AJAXError"), oa(tr, "ResolvedImage"), oa(ta, "StylePropertyFunction"), oa(Zi, "StyleExpression", {
            omit: [
                "_evaluator"
            ]
        }), oa(Qe, "ImageIdWithOptions"), oa(Ji, "ZoomDependentExpression"), oa(Ki, "ZoomConstantExpression"), oa(yr, "CompoundExpression", {
            omit: [
                "_evaluate"
            ]
        });
        for(const t1 in Pi)sa[Pi[t1]._classRegistryKey] || oa(Pi[t1], `Expression${t1}`);
        function la(t1) {
            return t1 && "undefined" != typeof ArrayBuffer && (t1 instanceof ArrayBuffer || t1.constructor && "ArrayBuffer" === t1.constructor.name);
        }
        function ua(t1) {
            return self.ImageBitmap && t1 instanceof ImageBitmap;
        }
        function ca(t1, e) {
            if (null == t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String || t1 instanceof Date || t1 instanceof RegExp) return t1;
            if (la(t1) || ua(t1)) return e && e.add(t1), t1;
            if (ArrayBuffer.isView(t1)) return e && e.add(t1.buffer), t1;
            if (t1 instanceof ImageData) return e && e.add(t1.data.buffer), t1;
            if (Array.isArray(t1)) {
                const r = [];
                for (const n of t1)r.push(ca(n, e));
                return r;
            }
            if (t1 instanceof Map) {
                const e = {
                    $name: "Map"
                };
                for (const [r, n] of t1.entries())e[r] = ca(n);
                return e;
            }
            if (t1 instanceof Set) {
                const e = {
                    $name: "Set"
                };
                let r = 0;
                for (const n of t1.values())e[++r] = ca(n);
                return e;
            }
            if ("object" == typeof t1) {
                const r = t1.constructor, n = r._classRegistryKey;
                if (!n) throw new Error(`Can't serialize object of unregistered class "${n}".`);
                const i = r.serialize ? r.serialize(t1, e) : {};
                if (!r.serialize) {
                    for(const r in t1)t1.hasOwnProperty(r) && (sa[n].omit.indexOf(r) >= 0 || (i[r] = ca(t1[r], e)));
                    t1 instanceof Error && (i.message = t1.message);
                }
                if (i.$name) throw new Error("$name property is reserved for worker serialization logic.");
                return "Object" !== n && (i.$name = n), i;
            }
            throw new Error("can't serialize object of type " + typeof t1);
        }
        function ha(t1) {
            if (null == t1 || "boolean" == typeof t1 || "number" == typeof t1 || "string" == typeof t1 || t1 instanceof Boolean || t1 instanceof Number || t1 instanceof String || t1 instanceof Date || t1 instanceof RegExp || la(t1) || ua(t1) || ArrayBuffer.isView(t1) || t1 instanceof ImageData) return t1;
            if (Array.isArray(t1)) return t1.map(ha);
            if ("object" == typeof t1) {
                const e = t1.$name || "Object";
                if ("Map" === e) {
                    const e = new Map;
                    for (const r of Object.keys(t1))"$name" !== r && e.set(r, ha(t1[r]));
                    return e;
                }
                if ("Set" === e) {
                    const e = new Set;
                    for (const r of Object.keys(t1))"$name" !== r && e.add(ha(t1[r]));
                    return e;
                }
                const { klass: r } = sa[e];
                if (!r) throw new Error(`Can't deserialize unregistered class "${e}".`);
                if (r.deserialize) return r.deserialize(t1);
                const n = Object.create(r.prototype);
                for (const e of Object.keys(t1))"$name" !== e && (n[e] = ha(t1[e]));
                return n;
            }
            throw new Error("can't deserialize object of type " + typeof t1);
        }
        const pa = {
            "Latin-1 Supplement": (t1)=>t1 >= 128 && t1 <= 255,
            Arabic: (t1)=>t1 >= 1536 && t1 <= 1791,
            "Arabic Supplement": (t1)=>t1 >= 1872 && t1 <= 1919,
            "Arabic Extended-A": (t1)=>t1 >= 2208 && t1 <= 2303,
            "Hangul Jamo": (t1)=>t1 >= 4352 && t1 <= 4607,
            "Unified Canadian Aboriginal Syllabics": (t1)=>t1 >= 5120 && t1 <= 5759,
            Khmer: (t1)=>t1 >= 6016 && t1 <= 6143,
            "Unified Canadian Aboriginal Syllabics Extended": (t1)=>t1 >= 6320 && t1 <= 6399,
            "General Punctuation": (t1)=>t1 >= 8192 && t1 <= 8303,
            "Letterlike Symbols": (t1)=>t1 >= 8448 && t1 <= 8527,
            "Number Forms": (t1)=>t1 >= 8528 && t1 <= 8591,
            "Miscellaneous Technical": (t1)=>t1 >= 8960 && t1 <= 9215,
            "Control Pictures": (t1)=>t1 >= 9216 && t1 <= 9279,
            "Optical Character Recognition": (t1)=>t1 >= 9280 && t1 <= 9311,
            "Enclosed Alphanumerics": (t1)=>t1 >= 9312 && t1 <= 9471,
            "Geometric Shapes": (t1)=>t1 >= 9632 && t1 <= 9727,
            "Miscellaneous Symbols": (t1)=>t1 >= 9728 && t1 <= 9983,
            "Miscellaneous Symbols and Arrows": (t1)=>t1 >= 11008 && t1 <= 11263,
            "CJK Radicals Supplement": (t1)=>t1 >= 11904 && t1 <= 12031,
            "Kangxi Radicals": (t1)=>t1 >= 12032 && t1 <= 12255,
            "Ideographic Description Characters": (t1)=>t1 >= 12272 && t1 <= 12287,
            "CJK Symbols and Punctuation": (t1)=>t1 >= 12288 && t1 <= 12351,
            Hiragana: (t1)=>t1 >= 12352 && t1 <= 12447,
            Katakana: (t1)=>t1 >= 12448 && t1 <= 12543,
            Bopomofo: (t1)=>t1 >= 12544 && t1 <= 12591,
            "Hangul Compatibility Jamo": (t1)=>t1 >= 12592 && t1 <= 12687,
            Kanbun: (t1)=>t1 >= 12688 && t1 <= 12703,
            "Bopomofo Extended": (t1)=>t1 >= 12704 && t1 <= 12735,
            "CJK Strokes": (t1)=>t1 >= 12736 && t1 <= 12783,
            "Katakana Phonetic Extensions": (t1)=>t1 >= 12784 && t1 <= 12799,
            "Enclosed CJK Letters and Months": (t1)=>t1 >= 12800 && t1 <= 13055,
            "CJK Compatibility": (t1)=>t1 >= 13056 && t1 <= 13311,
            "CJK Unified Ideographs Extension A": (t1)=>t1 >= 13312 && t1 <= 19903,
            "Yijing Hexagram Symbols": (t1)=>t1 >= 19904 && t1 <= 19967,
            "CJK Unified Ideographs": (t1)=>t1 >= 19968 && t1 <= 40959,
            "Yi Syllables": (t1)=>t1 >= 40960 && t1 <= 42127,
            "Yi Radicals": (t1)=>t1 >= 42128 && t1 <= 42191,
            "Hangul Jamo Extended-A": (t1)=>t1 >= 43360 && t1 <= 43391,
            "Hangul Syllables": (t1)=>t1 >= 44032 && t1 <= 55215,
            "Hangul Jamo Extended-B": (t1)=>t1 >= 55216 && t1 <= 55295,
            "Private Use Area": (t1)=>t1 >= 57344 && t1 <= 63743,
            "CJK Compatibility Ideographs": (t1)=>t1 >= 63744 && t1 <= 64255,
            "Arabic Presentation Forms-A": (t1)=>t1 >= 64336 && t1 <= 65023,
            "Vertical Forms": (t1)=>t1 >= 65040 && t1 <= 65055,
            "CJK Compatibility Forms": (t1)=>t1 >= 65072 && t1 <= 65103,
            "Small Form Variants": (t1)=>t1 >= 65104 && t1 <= 65135,
            "Arabic Presentation Forms-B": (t1)=>t1 >= 65136 && t1 <= 65279,
            "Halfwidth and Fullwidth Forms": (t1)=>t1 >= 65280 && t1 <= 65519,
            Osage: (t1)=>t1 >= 66736 && t1 <= 66815,
            "CJK Unified Ideographs Extension B": (t1)=>t1 >= 131072 && t1 <= 173791
        };
        function fa(t1) {
            for (const e of t1)if (ya(e.charCodeAt(0))) return !0;
            return !1;
        }
        function da(t1) {
            for (const e of t1)if (!ma(e.charCodeAt(0))) return !1;
            return !0;
        }
        function ma(t1) {
            return !(pa.Arabic(t1) || pa["Arabic Supplement"](t1) || pa["Arabic Extended-A"](t1) || pa["Arabic Presentation Forms-A"](t1) || pa["Arabic Presentation Forms-B"](t1));
        }
        function ya(t1) {
            return !(746 !== t1 && 747 !== t1 && (t1 < 4352 || !(pa["Bopomofo Extended"](t1) || pa.Bopomofo(t1) || pa["CJK Compatibility Forms"](t1) && !(t1 >= 65097 && t1 <= 65103) || pa["CJK Compatibility Ideographs"](t1) || pa["CJK Compatibility"](t1) || pa["CJK Radicals Supplement"](t1) || pa["CJK Strokes"](t1) || !(!pa["CJK Symbols and Punctuation"](t1) || t1 >= 12296 && t1 <= 12305 || t1 >= 12308 && t1 <= 12319 || 12336 === t1) || pa["CJK Unified Ideographs Extension A"](t1) || pa["CJK Unified Ideographs"](t1) || pa["Enclosed CJK Letters and Months"](t1) || pa["Hangul Compatibility Jamo"](t1) || pa["Hangul Jamo Extended-A"](t1) || pa["Hangul Jamo Extended-B"](t1) || pa["Hangul Jamo"](t1) || pa["Hangul Syllables"](t1) || pa.Hiragana(t1) || pa["Ideographic Description Characters"](t1) || pa.Kanbun(t1) || pa["Kangxi Radicals"](t1) || pa["Katakana Phonetic Extensions"](t1) || pa.Katakana(t1) && 12540 !== t1 || !(!pa["Halfwidth and Fullwidth Forms"](t1) || 65288 === t1 || 65289 === t1 || 65293 === t1 || t1 >= 65306 && t1 <= 65310 || 65339 === t1 || 65341 === t1 || 65343 === t1 || t1 >= 65371 && t1 <= 65503 || 65507 === t1 || t1 >= 65512 && t1 <= 65519) || !(!pa["Small Form Variants"](t1) || t1 >= 65112 && t1 <= 65118 || t1 >= 65123 && t1 <= 65126) || pa["Unified Canadian Aboriginal Syllabics"](t1) || pa["Unified Canadian Aboriginal Syllabics Extended"](t1) || pa["Vertical Forms"](t1) || pa["Yijing Hexagram Symbols"](t1) || pa["Yi Syllables"](t1) || pa["Yi Radicals"](t1))));
        }
        function ga(t1) {
            return !(ya(t1) || function(t1) {
                return !!(pa["Latin-1 Supplement"](t1) && (167 === t1 || 169 === t1 || 174 === t1 || 177 === t1 || 188 === t1 || 189 === t1 || 190 === t1 || 215 === t1 || 247 === t1) || pa["General Punctuation"](t1) && (8214 === t1 || 8224 === t1 || 8225 === t1 || 8240 === t1 || 8241 === t1 || 8251 === t1 || 8252 === t1 || 8258 === t1 || 8263 === t1 || 8264 === t1 || 8265 === t1 || 8273 === t1) || pa["Letterlike Symbols"](t1) || pa["Number Forms"](t1) || pa["Miscellaneous Technical"](t1) && (t1 >= 8960 && t1 <= 8967 || t1 >= 8972 && t1 <= 8991 || t1 >= 8996 && t1 <= 9e3 || 9003 === t1 || t1 >= 9085 && t1 <= 9114 || t1 >= 9150 && t1 <= 9165 || 9167 === t1 || t1 >= 9169 && t1 <= 9179 || t1 >= 9186 && t1 <= 9215) || pa["Control Pictures"](t1) && 9251 !== t1 || pa["Optical Character Recognition"](t1) || pa["Enclosed Alphanumerics"](t1) || pa["Geometric Shapes"](t1) || pa["Miscellaneous Symbols"](t1) && !(t1 >= 9754 && t1 <= 9759) || pa["Miscellaneous Symbols and Arrows"](t1) && (t1 >= 11026 && t1 <= 11055 || t1 >= 11088 && t1 <= 11097 || t1 >= 11192 && t1 <= 11243) || pa["CJK Symbols and Punctuation"](t1) || pa.Katakana(t1) || pa["Private Use Area"](t1) || pa["CJK Compatibility Forms"](t1) || pa["Small Form Variants"](t1) || pa["Halfwidth and Fullwidth Forms"](t1) || 8734 === t1 || 8756 === t1 || 8757 === t1 || t1 >= 9984 && t1 <= 10087 || t1 >= 10102 && t1 <= 10131 || 65532 === t1 || 65533 === t1);
            }(t1));
        }
        function xa(t1) {
            return t1 >= 1424 && t1 <= 2303 || pa["Arabic Presentation Forms-A"](t1) || pa["Arabic Presentation Forms-B"](t1);
        }
        function va(t1, e) {
            return !(!e && xa(t1) || t1 >= 2304 && t1 <= 3583 || t1 >= 3840 && t1 <= 4255 || pa.Khmer(t1));
        }
        function ba(t1) {
            for (const e of t1)if (xa(e.charCodeAt(0))) return !0;
            return !1;
        }
        const _a = "deferred", wa = "loading", Ma = "loaded";
        let Aa = null, Sa = "unavailable", Ia = null;
        const Pa = function(t1) {
            t1 && "string" == typeof t1 && t1.indexOf("NetworkError") > -1 && (Sa = "error"), Aa && Aa(t1);
        };
        function za() {
            Ea.fire(new xe("pluginStateChange", {
                pluginStatus: Sa,
                pluginURL: Ia
            }));
        }
        const Ea = new we, ka = function() {
            return Sa;
        }, Ta = function() {
            if (Sa !== _a || !Ia) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            Sa = wa, za(), Ia && ie({
                url: Ia
            }, (t1)=>{
                t1 ? Pa(t1) : (Sa = Ma, za());
            });
        }, Ba = {
            applyArabicShaping: null,
            processBidirectionalText: null,
            processStyledBidirectionalText: null,
            isLoaded: ()=>Sa === Ma || null != Ba.applyArabicShaping,
            isLoading: ()=>Sa === wa,
            setState (t1) {
                Sa = t1.pluginStatus, Ia = t1.pluginURL;
            },
            isParsed: ()=>null != Ba.applyArabicShaping && null != Ba.processBidirectionalText && null != Ba.processStyledBidirectionalText,
            getPluginURL: ()=>Ia
        };
        class Va {
            constructor(t1, e){
                this.zoom = t1, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.transition = e.transition, this.pitch = e.pitch, this.brightness = e.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
            }
            isSupportedScript(t1) {
                return function(t1, e) {
                    for (const r of t1)if (!va(r.charCodeAt(0), e)) return !1;
                    return !0;
                }(t1, Ba.isLoaded());
            }
        }
        class Ca {
            constructor(t1, e, r, n){
                this.property = t1, this.value = e, this.expression = function(t1, e, r, n) {
                    if (Ni(t1)) return new ta(t1, e);
                    if (Hi(t1) || Array.isArray(t1) && t1.length > 0) {
                        const i = Qi(t1, e, r, n);
                        if ("error" === i.result) throw new Error(i.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                        return i.value;
                    }
                    {
                        let r = t1;
                        return "string" == typeof t1 && "color" === e.type && (r = Ie.parse(t1)), {
                            kind: "constant",
                            configDependencies: new Set,
                            evaluate: ()=>r
                        };
                    }
                }(void 0 === e ? t1.specification.default : e, t1.specification, r, n);
            }
            isDataDriven() {
                return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t1, e, r) {
                return this.property.possiblyEvaluate(this, t1, e, r);
            }
        }
        class Da {
            constructor(t1, e, r){
                this.property = t1, this.value = new Ca(t1, void 0, e, r);
            }
            transitioned(t1, e) {
                return new Ra(this.property, this.value, e, nt({}, t1.transition, this.transition), t1.now);
            }
            untransitioned() {
                return new Ra(this.property, this.value, null, {}, 0);
            }
        }
        class La {
            constructor(t1, e, r){
                this._properties = t1, this._values = Object.create(t1.defaultTransitionablePropertyValues), this._scope = e, this._options = r, this.configDependencies = new Set;
            }
            getValue(t1) {
                return ht(this._values[t1].value.value);
            }
            setValue(t1, e) {
                this._values.hasOwnProperty(t1) || (this._values[t1] = new Da(this._values[t1].property, this._scope, this._options)), this._values[t1].value = new Ca(this._values[t1].property, null === e ? void 0 : ht(e), this._scope, this._options), this._values[t1].value.expression.configDependencies && (this.configDependencies = new Set([
                    ...this.configDependencies,
                    ...this._values[t1].value.expression.configDependencies
                ]));
            }
            setTransitionOrValue(t1, e) {
                e && (this._options = e);
                const r = this._properties.properties;
                if (t1) for(const e in t1){
                    const n = t1[e];
                    if (lt(e, "-transition")) {
                        const t1 = e.slice(0, -11);
                        r[t1] && this.setTransition(t1, n);
                    } else r.hasOwnProperty(e) && this.setValue(e, n);
                }
            }
            getTransition(t1) {
                return ht(this._values[t1].transition);
            }
            setTransition(t1, e) {
                this._values.hasOwnProperty(t1) || (this._values[t1] = new Da(this._values[t1].property)), this._values[t1].transition = ht(e) || void 0;
            }
            serialize() {
                const t1 = {};
                for (const e of Object.keys(this._values)){
                    const r = this.getValue(e);
                    void 0 !== r && (t1[e] = r);
                    const n = this.getTransition(e);
                    void 0 !== n && (t1[`${e}-transition`] = n);
                }
                return t1;
            }
            transitioned(t1, e) {
                const r = new Fa(this._properties);
                for (const n of Object.keys(this._values))r._values[n] = this._values[n].transitioned(t1, e._values[n]);
                return r;
            }
            untransitioned() {
                const t1 = new Fa(this._properties);
                for (const e of Object.keys(this._values))t1._values[e] = this._values[e].untransitioned();
                return t1;
            }
        }
        class Ra {
            constructor(t1, e, r, n, i){
                const a = n.delay || 0, s = n.duration || 0;
                i = i || 0, this.property = t1, this.value = e, this.begin = i + a, this.end = this.begin + s, t1.specification.transition && (n.delay || n.duration) && (this.prior = r);
            }
            possiblyEvaluate(t1, e, r) {
                const n = t1.now || 0, i = this.value.possiblyEvaluate(t1, e, r), a = this.prior;
                if (a) {
                    if (n > this.end) return this.prior = null, i;
                    if (this.value.isDataDriven()) return this.prior = null, i;
                    if (n < this.begin) return a.possiblyEvaluate(t1, e, r);
                    {
                        const s = (n - this.begin) / (this.end - this.begin);
                        return this.property.interpolate(a.possiblyEvaluate(t1, e, r), i, W(s));
                    }
                }
                return i;
            }
        }
        class Fa {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t1, e, r) {
                const n = new Ua(this._properties);
                for (const i of Object.keys(this._values))n._values[i] = this._values[i].possiblyEvaluate(t1, e, r);
                return n;
            }
            hasTransition() {
                for (const t1 of Object.keys(this._values))if (this._values[t1].prior) return !0;
                return !1;
            }
        }
        class Oa {
            constructor(t1, e, r){
                this._properties = t1, this._values = Object.create(t1.defaultPropertyValues), this._scope = e, this._options = r, this.configDependencies = new Set;
            }
            getValue(t1) {
                return ht(this._values[t1].value);
            }
            setValue(t1, e) {
                this._values[t1] = new Ca(this._values[t1].property, null === e ? void 0 : ht(e), this._scope, this._options), this._values[t1].expression.configDependencies && (this.configDependencies = new Set([
                    ...this.configDependencies,
                    ...this._values[t1].expression.configDependencies
                ]));
            }
            serialize() {
                const t1 = {};
                for (const e of Object.keys(this._values)){
                    const r = this.getValue(e);
                    void 0 !== r && (t1[e] = r);
                }
                return t1;
            }
            possiblyEvaluate(t1, e, r) {
                const n = new Ua(this._properties);
                for (const i of Object.keys(this._values))n._values[i] = this._values[i].possiblyEvaluate(t1, e, r);
                return n;
            }
        }
        class Na {
            constructor(t1, e, r){
                this.property = t1, this.value = e, this.parameters = r;
            }
            isConstant() {
                return "constant" === this.value.kind;
            }
            constantOr(t1) {
                return "constant" === this.value.kind ? this.value.value : t1;
            }
            evaluate(t1, e, r, n) {
                return this.property.evaluate(this.value, this.parameters, t1, e, r, n);
            }
        }
        class Ua {
            constructor(t1){
                this._properties = t1, this._values = Object.create(t1.defaultPossiblyEvaluatedValues);
            }
            get(t1) {
                return this._values[t1];
            }
        }
        class ja {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e) {
                return t1.expression.evaluate(e);
            }
            interpolate(t1, e, r) {
                const n = ke[this.specification.type];
                return n ? n(t1, e, r) : t1;
            }
        }
        class qa {
            constructor(t1, e){
                this.specification = t1, this.overrides = e;
            }
            possiblyEvaluate(t1, e, r, n) {
                return new Na(this, "constant" === t1.expression.kind || "camera" === t1.expression.kind ? {
                    kind: "constant",
                    value: t1.expression.evaluate(e, null, {}, r, n)
                } : t1.expression, e);
            }
            interpolate(t1, e, r) {
                if ("constant" !== t1.value.kind || "constant" !== e.value.kind) return t1;
                if (void 0 === t1.value.value || void 0 === e.value.value) return new Na(this, {
                    kind: "constant",
                    value: void 0
                }, t1.parameters);
                const n = ke[this.specification.type];
                return n ? new Na(this, {
                    kind: "constant",
                    value: n(t1.value.value, e.value.value, r)
                }, t1.parameters) : t1;
            }
            evaluate(t1, e, r, n, i, a) {
                return "constant" === t1.kind ? t1.value : t1.evaluate(e, r, n, i, a);
            }
        }
        class $a {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e, r, n) {
                return !!t1.expression.evaluate(e, null, {}, r, n);
            }
            interpolate() {
                return !1;
            }
        }
        class Ga {
            constructor(t1){
                this.properties = t1, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
                const e = new Va(0, {});
                for(const r in t1){
                    const n = t1[r];
                    n.specification.overridable && this.overridableProperties.push(r);
                    const i = this.defaultPropertyValues[r] = new Ca(n, void 0), a = this.defaultTransitionablePropertyValues[r] = new Da(n);
                    this.defaultTransitioningPropertyValues[r] = a.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = i.possiblyEvaluate(e);
                }
            }
        }
        oa(qa, "DataDrivenProperty"), oa(ja, "DataConstantProperty"), oa($a, "ColorRampProperty");
        var Ya = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"snow":{"type":"snow","experimental":true},"rain":{"type":"rain","experimental":true},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"indoor":{"type":"indoor","experimental":true},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"experimental":true,"type":"featuresets"}},"featuresets":{"experimental":true,"*":{"type":"featureset"}},"featureset":{"experimental":true,"metadata":{"type":"*"},"selectors":{"type":"array","value":"selector"}},"selector":{"experimental":true,"layer":{"type":"string","required":true},"properties":{"type":"selectorProperty","required":false},"featureNamespace":{"type":"string","required":false}},"selectorProperty":{"experimental":true,"*":{"type":"*"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"},"color-theme":{"type":"colorTheme","optional":true}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","property-type":"data-constant","expression":{},"required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"property-type":"data-constant"},"shadow-quality":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"parameters":["zoom"]},"experimental":true},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"experimental":true,"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"raster-particle":{"experimental":true},"hillshade":{},"model":{"experimental":true},"background":{},"sky":{},"slot":{},"clip":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{},"property-type":"data-constant"},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{},"property-type":"data-constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-base":1,"hd-road-markup":1},"default":"none","experimental":true,"private":true,"expression":{},"property-type":"data-constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","experimental":true,"default":0,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"line-elevation-reference":{"type":"enum","values":{"none":1,"sea":1,"ground":1,"hd-road-markup":1},"default":"none","experimental":true,"expression":{},"property-type":"data-constant"},"line-cross-slope":{"type":"number","experimental":true,"expression":{},"property-type":"constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"line-width-unit":{"type":"enum","values":{"pixels":1,"meters":1},"default":"pixels","experimental":true,"private":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","experimental":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"experimental":true,"private":true,"expression":{},"property-type":"data-constant"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"experimental":true,"private":true,"expression":{},"property-type":"data-constant"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_hillshade":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster-particle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_clip":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_model":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"snow":{"density":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.85],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.3],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","property-type":"data-constant","default":"#ffffff","experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","property-type":"data-constant","default":0.4,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,50],"minimum":0,"maximum":360,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"flake-size":{"type":"number","property-type":"data-constant","default":0.71,"minimum":0,"maximum":5,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"rain":{"density":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,0.5],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,"#03113d",0.3,"#a8adbc"],"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,0.88,1,0.7],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],11,0,13,1],"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["measure-light","brightness"],0,"#001736",0.3,"#464646"],"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","property-type":"data-constant","default":0.57,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,80],"minimum":0,"maximum":360,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"droplet-size":{"type":"array","default":[2.6,18.2],"minimum":0,"maximum":50,"length":2,"value":"number","property-type":"data-constant","transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"distortion-strength":{"type":"number","property-type":"data-constant","default":0.7,"minimum":0,"maximum":1,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"colorTheme":{"data":{"type":"string","property-type":"data-constant","expression":{}}},"indoor":{"floorplanFeaturesetId":{"type":"string","experimental":true,"property-type":"data-constant","expression":{}},"buildingFeaturesetId":{"type":"string","experimental":true,"property-type":"data-constant","expression":{}}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-height-alignment":{"type":"enum","experimental":true,"values":{"terrain":1,"flat":1},"default":"flat","property-type":"data-constant"},"fill-extrusion-base-alignment":{"type":"enum","experimental":true,"values":{"terrain":1,"flat":1},"default":"terrain","property-type":"data-constant"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","experimental":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","experimental":true,"default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","experimental":true,"default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","experimental":true,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","experimental":true,"default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","experimental":true,"default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"experimental":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light","line-progress"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-trim-fade-range":{"type":"array","value":"number","experimental":true,"length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-trim-color":{"type":"color","experimental":true,"default":"transparent","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"property-type":"data-constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"experimental":true,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"experimental":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-particle-count":{"type":"number","default":512,"minimum":1,"property-type":"data-constant"},"raster-particle-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-particle-speed"]},"property-type":"color-ramp"},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1,"property-type":"data-constant"},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1,"property-type":"data-constant"},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]},"experimental":true,"property-type":"data-constant"},"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"property-type":"data-driven"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"model-front-cutoff":{"type":"array","private":true,"value":"number","property-type":"data-constant","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
        function Xa(t1) {
            return t1 instanceof Number || t1 instanceof String || t1 instanceof Boolean ? t1.valueOf() : t1;
        }
        function Za(t1) {
            if (Array.isArray(t1)) return t1.map(Za);
            if (t1 instanceof Object && !(t1 instanceof Number || t1 instanceof String || t1 instanceof Boolean)) {
                const e = {};
                for(const r in t1)e[r] = Za(t1[r]);
                return e;
            }
            return Xa(t1);
        }
        function Ha(t1) {
            if (!0 === t1 || !1 === t1) return !0;
            if (!Array.isArray(t1) || 0 === t1.length) return !1;
            switch(t1[0]){
                case "has":
                    return t1.length >= 2 && "$id" !== t1[1] && "$type" !== t1[1];
                case "in":
                    return t1.length >= 3 && ("string" != typeof t1[1] || Array.isArray(t1[2]));
                case "!in":
                case "!has":
                case "none":
                    return !1;
                case "==":
                case "!=":
                case ">":
                case ">=":
                case "<":
                case "<=":
                    return 3 !== t1.length || Array.isArray(t1[1]) || Array.isArray(t1[2]);
                case "any":
                case "all":
                    for (const e of t1.slice(1))if (!Ha(e) && "boolean" != typeof e) return !1;
                    return !0;
                default:
                    return !0;
            }
        }
        function Wa(t1, e = "", r = null, n = "fill") {
            if (null == t1) return {
                filter: ()=>!0,
                needGeometry: !1,
                needFeature: !1
            };
            Ha(t1) || (t1 = ns(t1));
            const i = t1;
            let a = !0;
            try {
                a = function(t1) {
                    if (!Qa(t1)) return t1;
                    let e = Za(t1);
                    return Ja(e), e = Ka(e), e;
                }(i);
            } catch (t1) {
                console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(i, null, 2)}\n        `);
            }
            let s = null, o = null;
            if ("background" !== n && "sky" !== n && "slot" !== n) {
                o = Ya[`filter_${n}`];
                const t1 = Wi(a, o, e, r);
                if ("error" === t1.result) throw new Error(t1.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                s = (e, r, n)=>t1.value.evaluate(e, r, {}, n);
            }
            let l = null, u = null;
            if (a !== i) {
                const t1 = Wi(i, o, e, r);
                if ("error" === t1.result) throw new Error(t1.value.map((t1)=>`${t1.key}: ${t1.message}`).join(", "));
                l = (e, r, n, i, a)=>t1.value.evaluate(e, r, {}, n, void 0, void 0, i, a), u = !Tn(t1.value.expression);
            }
            return {
                filter: s,
                dynamicFilter: l || void 0,
                needGeometry: rs(a),
                needFeature: !!u
            };
        }
        function Ka(t1) {
            if (!Array.isArray(t1)) return t1;
            const e = function(t1) {
                if (ts.has(t1[0])) {
                    for(let e = 1; e < t1.length; e++)if (Qa(t1[e])) return !0;
                }
                return t1;
            }(t1);
            return !0 === e ? e : e.map((t1)=>Ka(t1));
        }
        function Ja(t1) {
            let e = !1;
            const r = [];
            if ("case" === t1[0]) {
                for(let n = 1; n < t1.length - 1; n += 2)e = e || Qa(t1[n]), r.push(t1[n + 1]);
                r.push(t1[t1.length - 1]);
            } else if ("match" === t1[0]) {
                e = e || Qa(t1[1]);
                for(let e = 2; e < t1.length - 1; e += 2)r.push(t1[e + 1]);
                r.push(t1[t1.length - 1]);
            } else if ("step" === t1[0]) {
                e = e || Qa(t1[1]);
                for(let e = 1; e < t1.length - 1; e += 2)r.push(t1[e + 1]);
            }
            e && (t1.length = 0, t1.push("any", ...r));
            for(let e = 1; e < t1.length; e++)Ja(t1[e]);
        }
        function Qa(t1) {
            if (!Array.isArray(t1)) return !1;
            if ("pitch" === (e = t1[0]) || "distance-from-center" === e) return !0;
            var e;
            for(let e = 1; e < t1.length; e++)if (Qa(t1[e])) return !0;
            return !1;
        }
        const ts = new Set([
            "in",
            "==",
            "!=",
            ">",
            ">=",
            "<",
            "<=",
            "to-boolean"
        ]);
        function es(t1, e) {
            return t1 < e ? -1 : t1 > e ? 1 : 0;
        }
        function rs(t1) {
            if (!Array.isArray(t1)) return !1;
            if ("within" === t1[0] || "distance" === t1[0]) return !0;
            for(let e = 1; e < t1.length; e++)if (rs(t1[e])) return !0;
            return !1;
        }
        function ns(t1) {
            if (!t1) return !0;
            const e = t1[0];
            return t1.length <= 1 ? "any" !== e : "==" === e ? is(t1[1], t1[2], "==") : "!=" === e ? os(is(t1[1], t1[2], "==")) : "<" === e || ">" === e || "<=" === e || ">=" === e ? is(t1[1], t1[2], e) : "any" === e ? (r = t1.slice(1), [
                "any"
            ].concat(r.map(ns))) : "all" === e ? [
                "all"
            ].concat(t1.slice(1).map(ns)) : "none" === e ? [
                "all"
            ].concat(t1.slice(1).map(ns).map(os)) : "in" === e ? as(t1[1], t1.slice(2)) : "!in" === e ? os(as(t1[1], t1.slice(2))) : "has" === e ? ss(t1[1]) : "!has" !== e || os(ss(t1[1]));
            "TURBOPACK unreachable";
            var r;
        }
        function is(t1, e, r) {
            switch(t1){
                case "$type":
                    return [
                        `filter-type-${r}`,
                        e
                    ];
                case "$id":
                    return [
                        `filter-id-${r}`,
                        e
                    ];
                default:
                    return [
                        `filter-${r}`,
                        t1,
                        e
                    ];
            }
        }
        function as(t1, e) {
            if (0 === e.length) return !1;
            switch(t1){
                case "$type":
                    return [
                        "filter-type-in",
                        [
                            "literal",
                            e
                        ]
                    ];
                case "$id":
                    return [
                        "filter-id-in",
                        [
                            "literal",
                            e
                        ]
                    ];
                default:
                    return e.length > 200 && !e.some((t1)=>typeof t1 != typeof e[0]) ? [
                        "filter-in-large",
                        t1,
                        [
                            "literal",
                            e.sort(es)
                        ]
                    ] : [
                        "filter-in-small",
                        t1,
                        [
                            "literal",
                            e
                        ]
                    ];
            }
        }
        function ss(t1) {
            switch(t1){
                case "$type":
                    return !0;
                case "$id":
                    return [
                        "filter-has-id"
                    ];
                default:
                    return [
                        "filter-has",
                        t1
                    ];
            }
        }
        function os(t1) {
            return [
                "!",
                t1
            ];
        }
        const ls = "";
        function us(t1, e) {
            return e ? `${t1}${ls}${e}` : t1;
        }
        const cs = "-transition", hs = new Set([
            "fill",
            "line",
            "background",
            "hillshade",
            "raster"
        ]);
        class ps extends we {
            constructor(t1, e, r, n, i){
                if (super(), this.id = t1.id, this.fqid = us(this.id, r), this.type = t1.type, this.scope = r, this.lut = n, this.options = i, this._featureFilter = {
                    filter: ()=>!0,
                    needGeometry: !1,
                    needFeature: !1
                }, this._filterCompiled = !1, this.configDependencies = new Set, "custom" !== t1.type) {
                    if (this.metadata = t1.metadata, this.minzoom = t1.minzoom, this.maxzoom = t1.maxzoom, t1.type && "background" !== t1.type && "sky" !== t1.type && "slot" !== t1.type) {
                        this.source = t1.source, this.sourceLayer = t1["source-layer"], this.filter = t1.filter;
                        const e = Wi(this.filter, Ya[`filter_${t1.type}`]);
                        "error" !== e.result && (this.configDependencies = new Set([
                            ...this.configDependencies,
                            ...e.value.configDependencies
                        ]));
                    }
                    if (t1.slot && (this.slot = t1.slot), e.layout && (this._unevaluatedLayout = new Oa(e.layout, this.scope, i), this.configDependencies = new Set([
                        ...this.configDependencies,
                        ...this._unevaluatedLayout.configDependencies
                    ])), e.paint) {
                        this._transitionablePaint = new La(e.paint, this.scope, i);
                        for(const e in t1.paint)this.setPaintProperty(e, t1.paint[e]);
                        for(const e in t1.layout)this.setLayoutProperty(e, t1.layout[e]);
                        this.configDependencies = new Set([
                            ...this.configDependencies,
                            ...this._transitionablePaint.configDependencies
                        ]), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Ua(e.paint);
                    }
                }
            }
            onAdd(t1) {}
            onRemove(t1) {}
            isDraped(t1) {
                return !this.is3D() && hs.has(this.type);
            }
            getLayoutProperty(t1) {
                return "visibility" === t1 ? this.visibility : this._unevaluatedLayout.getValue(t1);
            }
            setLayoutProperty(t1, e) {
                if ("custom" === this.type && "visibility" === t1) return void (this.visibility = e);
                const r = this._unevaluatedLayout;
                r._properties.properties[t1] && (r.setValue(t1, e), this.configDependencies = new Set([
                    ...this.configDependencies,
                    ...r.configDependencies
                ]), "visibility" === t1 && this.possiblyEvaluateVisibility());
            }
            possiblyEvaluateVisibility() {
                this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({
                    zoom: 0
                }));
            }
            getPaintProperty(t1) {
                return lt(t1, cs) ? this._transitionablePaint.getTransition(t1.slice(0, -11)) : this._transitionablePaint.getValue(t1);
            }
            setPaintProperty(t1, e) {
                const r = this._transitionablePaint, n = r._properties.properties;
                if (lt(t1, cs)) {
                    const i = t1.slice(0, -11);
                    return n[i] && r.setTransition(i, e || void 0), !1;
                }
                if (!n[t1]) return !1;
                const i = r._values[t1], a = i.value.isDataDriven(), s = i.value;
                r.setValue(t1, e), this.configDependencies = new Set([
                    ...this.configDependencies,
                    ...r.configDependencies
                ]), this._handleSpecialPaintPropertyUpdate(t1);
                const o = r._values[t1].value, l = o.isDataDriven(), u = lt(t1, "pattern") || "line-dasharray" === t1;
                return l || a || u || this._handleOverridablePaintPropertyUpdate(t1, s, o);
            }
            _handleSpecialPaintPropertyUpdate(t1) {}
            getProgramIds() {
                return null;
            }
            getDefaultProgramParams(t1, e, r) {
                return null;
            }
            _handleOverridablePaintPropertyUpdate(t1, e, r) {
                return !1;
            }
            isHidden(t1) {
                return !!(this.minzoom && t1 < this.minzoom) || !!(this.maxzoom && t1 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t1) {
                this._transitioningPaint = this._transitionablePaint.transitioned(t1, this._transitioningPaint);
            }
            hasTransition() {
                return this._transitioningPaint.hasTransition();
            }
            recalculate(t1, e) {
                this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t1, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t1, void 0, e);
            }
            serialize() {
                return ct({
                    id: this.id,
                    type: this.type,
                    slot: this.slot,
                    source: this.source,
                    "source-layer": this.sourceLayer,
                    metadata: this.metadata,
                    minzoom: this.minzoom,
                    maxzoom: this.maxzoom,
                    filter: this.filter,
                    layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                    paint: this._transitionablePaint && this._transitionablePaint.serialize()
                }, (t1, e)=>!(void 0 === t1 || "layout" === e && !Object.keys(t1).length || "paint" === e && !Object.keys(t1).length));
            }
            is3D() {
                return !1;
            }
            isSky() {
                return !1;
            }
            isTileClipped() {
                return !1;
            }
            hasOffscreenPass() {
                return !1;
            }
            hasShadowPass() {
                return !1;
            }
            canCastShadows() {
                return !1;
            }
            hasLightBeamPass() {
                return !1;
            }
            cutoffRange() {
                return 0;
            }
            tileCoverLift() {
                return 0;
            }
            resize() {}
            isStateDependent() {
                for(const t1 in this.paint._values){
                    const e = this.paint.get(t1);
                    if (e instanceof Na && Li(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0;
                }
                return !1;
            }
            compileFilter(t1) {
                this._filterCompiled || (this._featureFilter = Wa(this.filter, this.scope, t1), this._filterCompiled = !0);
            }
            invalidateCompiledFilter() {
                this._filterCompiled = !1;
            }
            dynamicFilter() {
                return this._featureFilter.dynamicFilter;
            }
            dynamicFilterNeedsFeature() {
                return this._featureFilter.needFeature;
            }
            getLayerRenderingStats() {
                return this._stats;
            }
            resetLayerRenderingStats(t1) {
                this._stats && ("shadow" === t1.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
            }
            queryRadius(t1) {}
            queryIntersectsFeature(t1, e, r, n, i, a, s, o, l) {}
        }
        const fs = {
            Int8: Int8Array,
            Uint8: Uint8Array,
            Int16: Int16Array,
            Uint16: Uint16Array,
            Int32: Int32Array,
            Uint32: Uint32Array,
            Float32: Float32Array
        };
        class ds {
            constructor(t1, e){
                this._structArray = t1, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
        }
        class ms {
            constructor(){
                this.isTransferred = !1, this.capacity = -1, this.resize(0);
            }
            static serialize(t1, e) {
                return t1._trim(), e && (t1.isTransferred = !0, e.add(t1.arrayBuffer)), {
                    length: t1.length,
                    arrayBuffer: t1.arrayBuffer
                };
            }
            static deserialize(t1) {
                const e = Object.create(this.prototype);
                return e.arrayBuffer = t1.arrayBuffer, e.length = t1.length, e.capacity = t1.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;
            }
            _trim() {
                this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
                this.length = 0;
            }
            resize(t1) {
                this.reserve(t1), this.length = t1;
            }
            reserve(t1) {
                if (t1 > this.capacity) {
                    this.capacity = Math.max(t1, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                    const e = this.uint8;
                    this._refreshViews(), e && this.uint8.set(e);
                }
            }
            _refreshViews() {
                throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
            }
            emplace(...t1) {
                throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
            }
            emplaceBack(...t1) {
                throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
            }
            destroy() {
                this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
            }
        }
        function ys(t1, e = 1) {
            let r = 0, n = 0;
            return {
                members: t1.map((t1)=>{
                    const i = fs[t1.type].BYTES_PER_ELEMENT, a = r = gs(r, Math.max(e, i)), s = t1.components || 1;
                    return n = Math.max(n, i), r += i * s, {
                        name: t1.name,
                        type: t1.type,
                        components: s,
                        offset: a
                    };
                }),
                size: gs(r, Math.max(n, e)),
                alignment: e
            };
        }
        function gs(t1, e) {
            return Math.ceil(t1 / e) * e;
        }
        class xs extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e);
            }
            emplace(t1, e, r) {
                const n = 2 * t1;
                return this.int16[n + 0] = e, this.int16[n + 1] = r, t1;
            }
        }
        xs.prototype.bytesPerElement = 4, oa(xs, "StructArrayLayout2i4");
        class vs extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 3 * t1;
                return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t1;
            }
        }
        vs.prototype.bytesPerElement = 6, oa(vs, "StructArrayLayout3i6");
        class bs extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const a = 4 * t1;
                return this.int16[a + 0] = e, this.int16[a + 1] = r, this.int16[a + 2] = n, this.int16[a + 3] = i, t1;
            }
        }
        bs.prototype.bytesPerElement = 8, oa(bs, "StructArrayLayout4i8");
        class _s extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, a) {
                const s = 5 * t1;
                return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, this.int16[s + 4] = a, t1;
            }
        }
        _s.prototype.bytesPerElement = 10, oa(_s, "StructArrayLayout5i10");
        class ws extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, a, s) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, a, s);
            }
            emplace(t1, e, r, n, i, a, s, o) {
                const l = 6 * t1, u = 12 * t1, c = 3 * t1;
                return this.int16[l + 0] = e, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = a, this.uint8[u + 7] = s, this.float32[c + 2] = o, t1;
            }
        }
        ws.prototype.bytesPerElement = 12, oa(ws, "StructArrayLayout2i4ub1f12");
        class Ms extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const a = 4 * t1;
                return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, t1;
            }
        }
        Ms.prototype.bytesPerElement = 16, oa(Ms, "StructArrayLayout4f16");
        class As extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 3 * t1;
                return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t1;
            }
        }
        As.prototype.bytesPerElement = 12, oa(As, "StructArrayLayout3f12");
        class Ss extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, a) {
                const s = 6 * t1, o = 3 * t1;
                return this.uint16[s + 0] = e, this.uint16[s + 1] = r, this.uint16[s + 2] = n, this.uint16[s + 3] = i, this.float32[o + 2] = a, t1;
            }
        }
        Ss.prototype.bytesPerElement = 12, oa(Ss, "StructArrayLayout4ui1f12");
        class Is extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const a = 4 * t1;
                return this.uint16[a + 0] = e, this.uint16[a + 1] = r, this.uint16[a + 2] = n, this.uint16[a + 3] = i, t1;
            }
        }
        Is.prototype.bytesPerElement = 8, oa(Is, "StructArrayLayout4ui8");
        class Ps extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, a) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i, a);
            }
            emplace(t1, e, r, n, i, a, s) {
                const o = 6 * t1;
                return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = a, this.int16[o + 5] = s, t1;
            }
        }
        Ps.prototype.bytesPerElement = 12, oa(Ps, "StructArrayLayout6i12");
        class zs extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, a, s, o, l, u, c, h) {
                const p = this.length;
                return this.resize(p + 1), this.emplace(p, t1, e, r, n, i, a, s, o, l, u, c, h);
            }
            emplace(t1, e, r, n, i, a, s, o, l, u, c, h, p) {
                const f = 12 * t1;
                return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.uint16[f + 4] = a, this.uint16[f + 5] = s, this.uint16[f + 6] = o, this.uint16[f + 7] = l, this.int16[f + 8] = u, this.int16[f + 9] = c, this.int16[f + 10] = h, this.int16[f + 11] = p, t1;
            }
        }
        zs.prototype.bytesPerElement = 24, oa(zs, "StructArrayLayout4i4ui4i24");
        class Es extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, a) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i, a);
            }
            emplace(t1, e, r, n, i, a, s) {
                const o = 10 * t1, l = 5 * t1;
                return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.float32[l + 2] = i, this.float32[l + 3] = a, this.float32[l + 4] = s, t1;
            }
        }
        Es.prototype.bytesPerElement = 20, oa(Es, "StructArrayLayout3i3f20");
        class ks extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.uint32[1 * t1 + 0] = e, t1;
            }
        }
        ks.prototype.bytesPerElement = 4, oa(ks, "StructArrayLayout1ul4");
        class Ts extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e);
            }
            emplace(t1, e, r) {
                const n = 2 * t1;
                return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t1;
            }
        }
        Ts.prototype.bytesPerElement = 4, oa(Ts, "StructArrayLayout2ui4");
        class Bs extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, a, s, o, l, u, c, h, p) {
                const f = this.length;
                return this.resize(f + 1), this.emplace(f, t1, e, r, n, i, a, s, o, l, u, c, h, p);
            }
            emplace(t1, e, r, n, i, a, s, o, l, u, c, h, p, f) {
                const d = 20 * t1, m = 10 * t1;
                return this.int16[d + 0] = e, this.int16[d + 1] = r, this.int16[d + 2] = n, this.int16[d + 3] = i, this.int16[d + 4] = a, this.float32[m + 3] = s, this.float32[m + 4] = o, this.float32[m + 5] = l, this.float32[m + 6] = u, this.int16[d + 14] = c, this.uint32[m + 8] = h, this.uint16[d + 18] = p, this.uint16[d + 19] = f, t1;
            }
        }
        Bs.prototype.bytesPerElement = 40, oa(Bs, "StructArrayLayout5i4f1i1ul2ui40");
        class Vs extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, a, s) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, a, s);
            }
            emplace(t1, e, r, n, i, a, s, o) {
                const l = 8 * t1;
                return this.int16[l + 0] = e, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 4] = i, this.int16[l + 5] = a, this.int16[l + 6] = s, this.int16[l + 7] = o, t1;
            }
        }
        Vs.prototype.bytesPerElement = 16, oa(Vs, "StructArrayLayout3i2i2i16");
        class Cs extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, a) {
                const s = 4 * t1, o = 8 * t1;
                return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = a, t1;
            }
        }
        Cs.prototype.bytesPerElement = 16, oa(Cs, "StructArrayLayout2f1f2i16");
        class Ds extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, a) {
                const s = this.length;
                return this.resize(s + 1), this.emplace(s, t1, e, r, n, i, a);
            }
            emplace(t1, e, r, n, i, a, s) {
                const o = 20 * t1, l = 5 * t1;
                return this.uint8[o + 0] = e, this.uint8[o + 1] = r, this.float32[l + 1] = n, this.float32[l + 2] = i, this.float32[l + 3] = a, this.float32[l + 4] = s, t1;
            }
        }
        Ds.prototype.bytesPerElement = 20, oa(Ds, "StructArrayLayout2ub4f20");
        class Ls extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r) {
                const n = this.length;
                return this.resize(n + 1), this.emplace(n, t1, e, r);
            }
            emplace(t1, e, r, n) {
                const i = 3 * t1;
                return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t1;
            }
        }
        Ls.prototype.bytesPerElement = 6, oa(Ls, "StructArrayLayout3ui6");
        class Rs extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b) {
                const _ = this.length;
                return this.resize(_ + 1), this.emplace(_, t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b);
            }
            emplace(t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _) {
                const w = 30 * t1, M = 15 * t1, A = 60 * t1;
                return this.int16[w + 0] = e, this.int16[w + 1] = r, this.int16[w + 2] = n, this.float32[M + 2] = i, this.float32[M + 3] = a, this.uint16[w + 8] = s, this.uint16[w + 9] = o, this.uint32[M + 5] = l, this.uint32[M + 6] = u, this.uint32[M + 7] = c, this.uint16[w + 16] = h, this.uint16[w + 17] = p, this.uint16[w + 18] = f, this.float32[M + 10] = d, this.float32[M + 11] = m, this.uint8[A + 48] = y, this.uint8[A + 49] = g, this.uint8[A + 50] = x, this.uint32[M + 13] = v, this.int16[w + 28] = b, this.uint8[A + 58] = _, t1;
            }
        }
        Rs.prototype.bytesPerElement = 60, oa(Rs, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
        class Fs extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _, w, M, A, S, I, P, z, E, k, T) {
                const B = this.length;
                return this.resize(B + 1), this.emplace(B, t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _, w, M, A, S, I, P, z, E, k, T);
            }
            emplace(t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _, w, M, A, S, I, P, z, E, k, T, B) {
                const V = 20 * t1, C = 40 * t1, D = 80 * t1;
                return this.float32[V + 0] = e, this.float32[V + 1] = r, this.int16[C + 4] = n, this.int16[C + 5] = i, this.int16[C + 6] = a, this.int16[C + 7] = s, this.int16[C + 8] = o, this.int16[C + 9] = l, this.int16[C + 10] = u, this.int16[C + 11] = c, this.int16[C + 12] = h, this.uint16[C + 13] = p, this.uint16[C + 14] = f, this.uint16[C + 15] = d, this.uint16[C + 16] = m, this.uint16[C + 17] = y, this.uint16[C + 18] = g, this.uint16[C + 19] = x, this.uint16[C + 20] = v, this.uint16[C + 21] = b, this.uint16[C + 22] = _, this.uint16[C + 23] = w, this.uint16[C + 24] = M, this.uint16[C + 25] = A, this.uint16[C + 26] = S, this.uint16[C + 27] = I, this.uint32[V + 14] = P, this.float32[V + 15] = z, this.float32[V + 16] = E, this.float32[V + 17] = k, this.float32[V + 18] = T, this.uint8[D + 76] = B, t1;
            }
        }
        Fs.prototype.bytesPerElement = 80, oa(Fs, "StructArrayLayout2f9i15ui1ul4f1ub80");
        class Os extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.float32[1 * t1 + 0] = e, t1;
            }
        }
        Os.prototype.bytesPerElement = 4, oa(Os, "StructArrayLayout1f4");
        class Ns extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i) {
                const a = this.length;
                return this.resize(a + 1), this.emplace(a, t1, e, r, n, i);
            }
            emplace(t1, e, r, n, i, a) {
                const s = 5 * t1;
                return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, this.float32[s + 4] = a, t1;
            }
        }
        Ns.prototype.bytesPerElement = 20, oa(Ns, "StructArrayLayout5f20");
        class Us extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, a, s) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, a, s);
            }
            emplace(t1, e, r, n, i, a, s, o) {
                const l = 7 * t1;
                return this.float32[l + 0] = e, this.float32[l + 1] = r, this.float32[l + 2] = n, this.float32[l + 3] = i, this.float32[l + 4] = a, this.float32[l + 5] = s, this.float32[l + 6] = o, t1;
            }
        }
        Us.prototype.bytesPerElement = 28, oa(Us, "StructArrayLayout7f28");
        class js extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, a, s, o, l, u, c) {
                const h = this.length;
                return this.resize(h + 1), this.emplace(h, t1, e, r, n, i, a, s, o, l, u, c);
            }
            emplace(t1, e, r, n, i, a, s, o, l, u, c, h) {
                const p = 11 * t1;
                return this.float32[p + 0] = e, this.float32[p + 1] = r, this.float32[p + 2] = n, this.float32[p + 3] = i, this.float32[p + 4] = a, this.float32[p + 5] = s, this.float32[p + 6] = o, this.float32[p + 7] = l, this.float32[p + 8] = u, this.float32[p + 9] = c, this.float32[p + 10] = h, t1;
            }
        }
        js.prototype.bytesPerElement = 44, oa(js, "StructArrayLayout11f44");
        class qs extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, a, s, o, l) {
                const u = this.length;
                return this.resize(u + 1), this.emplace(u, t1, e, r, n, i, a, s, o, l);
            }
            emplace(t1, e, r, n, i, a, s, o, l, u) {
                const c = 9 * t1;
                return this.float32[c + 0] = e, this.float32[c + 1] = r, this.float32[c + 2] = n, this.float32[c + 3] = i, this.float32[c + 4] = a, this.float32[c + 5] = s, this.float32[c + 6] = o, this.float32[c + 7] = l, this.float32[c + 8] = u, t1;
            }
        }
        qs.prototype.bytesPerElement = 36, oa(qs, "StructArrayLayout9f36");
        class $s extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e) {
                const r = this.length;
                return this.resize(r + 1), this.emplace(r, t1, e);
            }
            emplace(t1, e, r) {
                const n = 2 * t1;
                return this.float32[n + 0] = e, this.float32[n + 1] = r, t1;
            }
        }
        $s.prototype.bytesPerElement = 8, oa($s, "StructArrayLayout2f8");
        class Gs extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n) {
                const i = this.length;
                return this.resize(i + 1), this.emplace(i, t1, e, r, n);
            }
            emplace(t1, e, r, n, i) {
                const a = 6 * t1;
                return this.uint32[3 * t1 + 0] = e, this.uint16[a + 2] = r, this.uint16[a + 3] = n, this.uint16[a + 4] = i, t1;
            }
        }
        Gs.prototype.bytesPerElement = 12, oa(Gs, "StructArrayLayout1ul3ui12");
        class Ys extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.uint16[1 * t1 + 0] = e, t1;
            }
        }
        Ys.prototype.bytesPerElement = 2, oa(Ys, "StructArrayLayout1ui2");
        class Xs extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m) {
                const y = this.length;
                return this.resize(y + 1), this.emplace(y, t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m);
            }
            emplace(t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y) {
                const g = 16 * t1;
                return this.float32[g + 0] = e, this.float32[g + 1] = r, this.float32[g + 2] = n, this.float32[g + 3] = i, this.float32[g + 4] = a, this.float32[g + 5] = s, this.float32[g + 6] = o, this.float32[g + 7] = l, this.float32[g + 8] = u, this.float32[g + 9] = c, this.float32[g + 10] = h, this.float32[g + 11] = p, this.float32[g + 12] = f, this.float32[g + 13] = d, this.float32[g + 14] = m, this.float32[g + 15] = y, t1;
            }
        }
        Xs.prototype.bytesPerElement = 64, oa(Xs, "StructArrayLayout16f64");
        class Zs extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t1, e, r, n, i, a, s) {
                const o = this.length;
                return this.resize(o + 1), this.emplace(o, t1, e, r, n, i, a, s);
            }
            emplace(t1, e, r, n, i, a, s, o) {
                const l = 10 * t1, u = 5 * t1;
                return this.uint16[l + 0] = e, this.uint16[l + 1] = r, this.uint16[l + 2] = n, this.uint16[l + 3] = i, this.float32[u + 2] = a, this.float32[u + 3] = s, this.float32[u + 4] = o, t1;
            }
        }
        Zs.prototype.bytesPerElement = 20, oa(Zs, "StructArrayLayout4ui3f20");
        class Hs extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.int16[1 * t1 + 0] = e, t1;
            }
        }
        Hs.prototype.bytesPerElement = 2, oa(Hs, "StructArrayLayout1i2");
        class Ws extends ms {
            _refreshViews() {
                this.uint8 = new Uint8Array(this.arrayBuffer);
            }
            emplaceBack(t1) {
                const e = this.length;
                return this.resize(e + 1), this.emplace(e, t1);
            }
            emplace(t1, e) {
                return this.uint8[1 * t1 + 0] = e, t1;
            }
        }
        Ws.prototype.bytesPerElement = 1, oa(Ws, "StructArrayLayout1ub1");
        class Ks extends ds {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.int16[this._pos2 + 3];
            }
            get tileAnchorY() {
                return this._structArray.int16[this._pos2 + 4];
            }
            get x1() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get y1() {
                return this._structArray.float32[this._pos4 + 4];
            }
            get x2() {
                return this._structArray.float32[this._pos4 + 5];
            }
            get y2() {
                return this._structArray.float32[this._pos4 + 6];
            }
            get padding() {
                return this._structArray.int16[this._pos2 + 14];
            }
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 8];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
        }
        Ks.prototype.size = 40;
        class Js extends Bs {
            get(t1) {
                return new Ks(this, t1);
            }
        }
        oa(Js, "CollisionBoxArray");
        class Qs extends ds {
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 2];
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 3];
            }
            get glyphStartIndex() {
                return this._structArray.uint16[this._pos2 + 8];
            }
            get numGlyphs() {
                return this._structArray.uint16[this._pos2 + 9];
            }
            get vertexStartIndex() {
                return this._structArray.uint32[this._pos4 + 5];
            }
            get lineStartIndex() {
                return this._structArray.uint32[this._pos4 + 6];
            }
            get lineLength() {
                return this._structArray.uint32[this._pos4 + 7];
            }
            get segment() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get lowerSize() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get upperSize() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get lineOffsetX() {
                return this._structArray.float32[this._pos4 + 10];
            }
            get lineOffsetY() {
                return this._structArray.float32[this._pos4 + 11];
            }
            get writingMode() {
                return this._structArray.uint8[this._pos1 + 48];
            }
            get placedOrientation() {
                return this._structArray.uint8[this._pos1 + 49];
            }
            set placedOrientation(t1) {
                this._structArray.uint8[this._pos1 + 49] = t1;
            }
            get hidden() {
                return this._structArray.uint8[this._pos1 + 50];
            }
            set hidden(t1) {
                this._structArray.uint8[this._pos1 + 50] = t1;
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 13];
            }
            set crossTileID(t1) {
                this._structArray.uint32[this._pos4 + 13] = t1;
            }
            get associatedIconIndex() {
                return this._structArray.int16[this._pos2 + 28];
            }
            get flipState() {
                return this._structArray.uint8[this._pos1 + 58];
            }
            set flipState(t1) {
                this._structArray.uint8[this._pos1 + 58] = t1;
            }
        }
        Qs.prototype.size = 60;
        class to extends Rs {
            get(t1) {
                return new Qs(this, t1);
            }
        }
        oa(to, "PlacedSymbolArray");
        class eo extends ds {
            get tileAnchorX() {
                return this._structArray.float32[this._pos4 + 0];
            }
            get tileAnchorY() {
                return this._structArray.float32[this._pos4 + 1];
            }
            get projectedAnchorX() {
                return this._structArray.int16[this._pos2 + 4];
            }
            get projectedAnchorY() {
                return this._structArray.int16[this._pos2 + 5];
            }
            get projectedAnchorZ() {
                return this._structArray.int16[this._pos2 + 6];
            }
            get rightJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 7];
            }
            get centerJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 8];
            }
            get leftJustifiedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 9];
            }
            get verticalPlacedTextSymbolIndex() {
                return this._structArray.int16[this._pos2 + 10];
            }
            get placedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 11];
            }
            get verticalPlacedIconSymbolIndex() {
                return this._structArray.int16[this._pos2 + 12];
            }
            get key() {
                return this._structArray.uint16[this._pos2 + 13];
            }
            get textBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 14];
            }
            get textBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 15];
            }
            get verticalTextBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 16];
            }
            get verticalTextBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 17];
            }
            get iconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 18];
            }
            get iconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 19];
            }
            get verticalIconBoxStartIndex() {
                return this._structArray.uint16[this._pos2 + 20];
            }
            get verticalIconBoxEndIndex() {
                return this._structArray.uint16[this._pos2 + 21];
            }
            get featureIndex() {
                return this._structArray.uint16[this._pos2 + 22];
            }
            get numHorizontalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 23];
            }
            get numVerticalGlyphVertices() {
                return this._structArray.uint16[this._pos2 + 24];
            }
            get numIconVertices() {
                return this._structArray.uint16[this._pos2 + 25];
            }
            get numVerticalIconVertices() {
                return this._structArray.uint16[this._pos2 + 26];
            }
            get useRuntimeCollisionCircles() {
                return this._structArray.uint16[this._pos2 + 27];
            }
            get crossTileID() {
                return this._structArray.uint32[this._pos4 + 14];
            }
            set crossTileID(t1) {
                this._structArray.uint32[this._pos4 + 14] = t1;
            }
            get textOffset0() {
                return this._structArray.float32[this._pos4 + 15];
            }
            get textOffset1() {
                return this._structArray.float32[this._pos4 + 16];
            }
            get collisionCircleDiameter() {
                return this._structArray.float32[this._pos4 + 17];
            }
            get zOffset() {
                return this._structArray.float32[this._pos4 + 18];
            }
            set zOffset(t1) {
                this._structArray.float32[this._pos4 + 18] = t1;
            }
            get hasIconTextFit() {
                return this._structArray.uint8[this._pos1 + 76];
            }
        }
        eo.prototype.size = 80;
        class ro extends Fs {
            get(t1) {
                return new eo(this, t1);
            }
        }
        oa(ro, "SymbolInstanceArray");
        class no extends Os {
            getoffsetX(t1) {
                return this.float32[1 * t1 + 0];
            }
        }
        oa(no, "GlyphOffsetArray");
        class io extends xs {
            getx(t1) {
                return this.int16[2 * t1 + 0];
            }
            gety(t1) {
                return this.int16[2 * t1 + 1];
            }
        }
        oa(io, "SymbolLineVertexArray");
        class ao extends ds {
            get featureIndex() {
                return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
                return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
                return this._structArray.uint16[this._pos2 + 3];
            }
            get layoutVertexArrayOffset() {
                return this._structArray.uint16[this._pos2 + 4];
            }
        }
        ao.prototype.size = 12;
        class so extends Gs {
            get(t1) {
                return new ao(this, t1);
            }
        }
        oa(so, "FeatureIndexArray");
        class oo extends Ts {
            geta_centroid_pos0(t1) {
                return this.uint16[2 * t1 + 0];
            }
            geta_centroid_pos1(t1) {
                return this.uint16[2 * t1 + 1];
            }
        }
        oa(oo, "FillExtrusionCentroidArray");
        class lo extends ds {
            get a_join_normal_inside0() {
                return this._structArray.int16[this._pos2 + 0];
            }
            get a_join_normal_inside1() {
                return this._structArray.int16[this._pos2 + 1];
            }
            get a_join_normal_inside2() {
                return this._structArray.int16[this._pos2 + 2];
            }
        }
        lo.prototype.size = 6;
        class uo extends vs {
            get(t1) {
                return new lo(this, t1);
            }
        }
        oa(uo, "FillExtrusionWallArray");
        const co = ys([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), ho = ys([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ]);
        class po {
            constructor(t1 = []){
                this.segments = t1;
            }
            _prepareSegment(t1, e, r, n) {
                let i = this.segments[this.segments.length - 1];
                return t1 > po.MAX_VERTEX_ARRAY_LENGTH && ft(`Max vertices per segment is ${po.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t1}`), (!i || i.vertexLength + t1 > po.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {
                    vertexOffset: e,
                    primitiveOffset: r,
                    vertexLength: 0,
                    primitiveLength: 0
                }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;
            }
            prepareSegment(t1, e, r, n) {
                return this._prepareSegment(t1, e.length, r.length, n);
            }
            get() {
                return this.segments;
            }
            destroy() {
                for (const t1 of this.segments)for(const e in t1.vaos)t1.vaos[e].destroy();
            }
            static simpleSegment(t1, e, r, n) {
                return new po([
                    {
                        vertexOffset: t1,
                        primitiveOffset: e,
                        vertexLength: r,
                        primitiveLength: n,
                        vaos: {},
                        sortKey: 0
                    }
                ]);
            }
        }
        function fo(t1, e) {
            return 256 * (t1 = Q(Math.floor(t1), 0, 255)) + Q(Math.floor(e), 0, 255);
        }
        po.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, oa(po, "SegmentVector");
        const mo = ys([
            {
                name: "a_pattern",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixel_ratio",
                components: 1,
                type: "Float32"
            }
        ]), yo = ys([
            {
                name: "a_dash",
                components: 4,
                type: "Uint16"
            }
        ]);
        class go {
            constructor(){
                this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = !1;
            }
            add(t1, e, r, n) {
                this.ids.push(xo(t1)), this.positions.push(e, r, n);
            }
            eachPosition(t1, e) {
                const r = xo(t1);
                let n = 0, i = this.ids.length - 1;
                for(; n < i;){
                    const t1 = n + i >> 1;
                    this.ids[t1] >= r ? i = t1 : n = t1 + 1;
                }
                for(; this.ids[n] === r;)e(this.positions[3 * n], this.positions[3 * n + 1], this.positions[3 * n + 2]), n++;
            }
            static serialize(t1, e) {
                const r = new Float64Array(t1.ids), n = new Uint32Array(t1.positions);
                return vo(r, n, 0, r.length - 1), e && (e.add(r.buffer), e.add(n.buffer)), {
                    ids: r,
                    positions: n
                };
            }
            static deserialize(t1) {
                const e = new go;
                let r;
                e.ids = t1.ids, e.positions = t1.positions;
                for (const t1 of e.ids)t1 !== r && e.uniqueIds.push(t1), r = t1;
                return e.indexed = !0, e;
            }
        }
        function xo(t1) {
            const e = +t1;
            return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : ge(String(t1));
        }
        function vo(t1, e, r, n) {
            for(; r < n;){
                const i = t1[r + n >> 1];
                let a = r - 1, s = n + 1;
                for(;;){
                    do {
                        a++;
                    }while (t1[a] < i)
                    do {
                        s--;
                    }while (t1[s] > i)
                    if (a >= s) break;
                    bo(t1, a, s), bo(e, 3 * a, 3 * s), bo(e, 3 * a + 1, 3 * s + 1), bo(e, 3 * a + 2, 3 * s + 2);
                }
                s - r < n - s ? (vo(t1, e, r, s), r = s + 1) : (vo(t1, e, s + 1, n), n = s);
            }
        }
        function bo(t1, e, r) {
            const n = t1[e];
            t1[e] = t1[r], t1[r] = n;
        }
        oa(go, "FeaturePositionMap");
        class _o {
            constructor(t1){
                this.gl = t1.gl, this.initialized = !1;
            }
            fetchUniformLocation(t1, e) {
                return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t1, e), this.initialized = !0), !!this.location;
            }
            set(t1, e, r) {
                throw new Error("Uniform#set() must be implemented by each concrete Uniform");
            }
        }
        class wo extends _o {
            constructor(t1){
                super(t1), this.current = 0;
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));
            }
        }
        class Mo extends _o {
            constructor(t1){
                super(t1), this.current = 0;
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r));
            }
        }
        class Ao extends _o {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0
                ];
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1])));
            }
        }
        class So extends _o {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0,
                    0
                ];
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2])));
            }
        }
        class Io extends _o {
            constructor(t1){
                super(t1), this.current = [
                    0,
                    0,
                    0,
                    0
                ];
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));
            }
        }
        class Po extends _o {
            constructor(t1){
                super(t1), this.current = Ie.transparent.toRenderColor(null);
            }
            set(t1, e, r) {
                this.fetchUniformLocation(t1, e) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));
            }
        }
        const zo = new Float32Array(16);
        class Eo extends _o {
            constructor(t1){
                super(t1), this.current = zo;
            }
            set(t1, e, r) {
                if (this.fetchUniformLocation(t1, e)) {
                    if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);
                    for(let t1 = 1; t1 < 16; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }
        const ko = new Float32Array(9), To = new Float32Array(4);
        class Bo extends _o {
            constructor(t1){
                super(t1), this.current = To;
            }
            set(t1, e, r) {
                if (this.fetchUniformLocation(t1, e)) {
                    for(let t1 = 0; t1 < 4; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix2fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }
        function Vo(t1) {
            return [
                fo(255 * t1.r, 255 * t1.g),
                fo(255 * t1.b, 255 * t1.a)
            ];
        }
        class Co {
            constructor(t1, e, r, n){
                this.value = t1, this.uniformNames = e.map((t1)=>`u_${t1}`), this.type = r, this.context = n;
            }
            setUniform(t1, e, r, n, i) {
                const a = n.constantOr(this.value);
                e.set(t1, i, a instanceof Ie ? a.toRenderColor(this.ignoreLut ? null : this.context.lut) : a);
            }
            getBinding(t1, e) {
                return "color" === this.type ? new Po(t1) : new Mo(t1);
            }
        }
        class Do {
            constructor(t1, e){
                this.uniformNames = e.map((t1)=>`u_${t1}`), this.pattern = null, this.pixelRatio = 1;
            }
            setConstantPatternPositions(t1) {
                this.pixelRatio = t1.pixelRatio || 1, this.pattern = t1.tl.concat(t1.br);
            }
            setUniform(t1, e, r, n, i) {
                const a = "u_pattern" === i || "u_dash" === i ? this.pattern : "u_pixel_ratio" === i ? this.pixelRatio : null;
                a && e.set(t1, i, a);
            }
            getBinding(t1, e) {
                return "u_pattern" === e || "u_dash" === e ? new Io(t1) : new Mo(t1);
            }
        }
        class Lo {
            constructor(t1, e, r, n){
                this.expression = t1, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map((t1)=>({
                        name: `a_${t1}`,
                        type: "Float32",
                        components: "color" === r ? 2 : 1,
                        offset: 0
                    })), this.paintVertexArray = new n;
            }
            populatePaintArray(t1, e, r, n, i, a, s) {
                const o = this.paintVertexArray.length, l = this.expression.evaluate(new Va(0, {
                    brightness: a
                }), e, {}, i, n, s);
                this.paintVertexArray.resize(t1), this._setPaintValue(o, t1, l, this.context);
            }
            updatePaintArray(t1, e, r, n, i, a, s) {
                const o = this.expression.evaluate({
                    zoom: 0,
                    brightness: s
                }, r, n, void 0, i);
                this._setPaintValue(t1, e, o, this.context);
            }
            _setPaintValue(t1, e, r, n) {
                if ("color" === this.type) {
                    const i = Vo(r.toRenderColor(this.ignoreLut ? null : n.lut));
                    for(let r = t1; r < e; r++)this.paintVertexArray.emplace(r, i[0], i[1]);
                } else {
                    for(let n = t1; n < e; n++)this.paintVertexArray.emplace(n, r);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r));
                }
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }
        class Ro {
            constructor(t1, e, r, n, i, a){
                this.expression = t1, this.uniformNames = e.map((t1)=>`u_${t1}_t`), this.type = r, this.useIntegerZoom = n, this.context = i, this.maxValue = 0, this.paintVertexAttributes = e.map((t1)=>({
                        name: `a_${t1}`,
                        type: "Float32",
                        components: "color" === r ? 4 : 2,
                        offset: 0
                    })), this.paintVertexArray = new a;
            }
            populatePaintArray(t1, e, r, n, i, a, s) {
                const o = this.expression.evaluate(new Va(this.context.zoom, {
                    brightness: a
                }), e, {}, i, n, s), l = this.expression.evaluate(new Va(this.context.zoom + 1, {
                    brightness: a
                }), e, {}, i, n, s), u = this.paintVertexArray.length;
                this.paintVertexArray.resize(t1), this._setPaintValue(u, t1, o, l, this.context);
            }
            updatePaintArray(t1, e, r, n, i, a, s) {
                const o = this.expression.evaluate({
                    zoom: this.context.zoom,
                    brightness: s
                }, r, n, void 0, i), l = this.expression.evaluate({
                    zoom: this.context.zoom + 1,
                    brightness: s
                }, r, n, void 0, i);
                this._setPaintValue(t1, e, o, l, this.context);
            }
            _setPaintValue(t1, e, r, n, i) {
                if ("color" === this.type) {
                    const n = Vo(r.toRenderColor(this.ignoreLut ? null : i.lut)), a = Vo(r.toRenderColor(this.ignoreLut ? null : i.lut));
                    for(let r = t1; r < e; r++)this.paintVertexArray.emplace(r, n[0], n[1], a[0], a[1]);
                } else {
                    for(let i = t1; i < e; i++)this.paintVertexArray.emplace(i, r, n);
                    this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));
                }
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t1, e, r, n, i) {
                const a = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom, s = Q(this.expression.interpolationFactor(a, this.context.zoom, this.context.zoom + 1), 0, 1);
                e.set(t1, i, s);
            }
            getBinding(t1, e) {
                return new Mo(t1);
            }
        }
        class Fo {
            constructor(t1, e, r, n, i){
                this.expression = t1, this.layerId = i, this.paintVertexAttributes = ("array" === r ? yo : mo).members;
                for(let t1 = 0; t1 < e.length; ++t1);
                this.paintVertexArray = new n;
            }
            populatePaintArray(t1, e, r, n) {
                const i = this.paintVertexArray.length;
                this.paintVertexArray.resize(t1), this._setPaintValues(i, t1, e.patterns && e.patterns[this.layerId], r);
            }
            updatePaintArray(t1, e, r, n, i, a, s) {
                this._setPaintValues(t1, e, r.patterns && r.patterns[this.layerId], a);
            }
            _setPaintValues(t1, e, r, n) {
                if (!n || !r) return;
                const i = n[r];
                if (!i) return;
                const { tl: a, br: s, pixelRatio: o } = i;
                for(let r = t1; r < e; r++)this.paintVertexArray.emplace(r, a[0], a[1], s[0], s[1], o);
            }
            upload(t1) {
                this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t1.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
            }
            destroy() {
                this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
        }
        class Oo {
            constructor(t1, e, r = ()=>!0){
                this.binders = {}, this._buffers = [], this.context = e;
                const n = [];
                for(const i in t1.paint._values){
                    const a = t1.paint.get(i), s = t1.paint.get(`${i}-use-theme`);
                    if (i.endsWith("-use-theme")) continue;
                    if (!r(i)) continue;
                    if (!(a instanceof Na && Li(a.property.specification))) continue;
                    const o = jo(i, t1.type), l = a.value, u = a.property.specification.type, c = !!a.property.useIntegerZoom, h = "line-dasharray" === i || i.endsWith("pattern"), p = "line-dasharray" === i && "constant" !== t1.layout.get("line-cap").value.kind;
                    if ("constant" !== l.kind || p) if ("source" === l.kind || p || h) {
                        const e = Go(i, u, "source");
                        this.binders[i] = h ? new Fo(l, o, u, e, t1.id) : new Lo(l, o, u, e), n.push(`/a_${i}`);
                    } else {
                        const t1 = Go(i, u, "composite");
                        this.binders[i] = new Ro(l, o, u, c, e, t1), n.push(`/z_${i}`);
                    }
                    else this.binders[i] = h ? new Do(l.value, o) : new Co(l.value, o, u, e), n.push(`/u_${i}`);
                    s && (this.binders[i].ignoreLut = "none" === s.constantOr("default"), this.binders[i].checkUseTheme = !0);
                }
                this.cacheKey = n.sort().join("");
            }
            getMaxValue(t1) {
                const e = this.binders[t1];
                return e instanceof Lo || e instanceof Ro ? e.maxValue : 0;
            }
            populatePaintArrays(t1, e, r, n, i, a, s) {
                for(const o in this.binders){
                    const l = this.binders[o];
                    l.context = this.context, (l instanceof Lo || l instanceof Ro || l instanceof Fo) && l.populatePaintArray(t1, e, r, n, i, a, s);
                }
            }
            setConstantPatternPositions(t1) {
                for(const e in this.binders){
                    const r = this.binders[e];
                    r instanceof Do && r.setConstantPatternPositions(t1);
                }
            }
            updatePaintArrays(t1, e, r, n, i, a, s, o, l) {
                let u = !1;
                const c = Object.keys(t1), h = 0 !== c.length && !o, p = h ? c : e.uniqueIds;
                this.context.lut = i.lut;
                for(const o in this.binders){
                    const c = this.binders[o];
                    if (c.context = this.context, (c instanceof Lo || c instanceof Ro || c instanceof Fo) && (!0 === c.expression.isStateDependent || !1 === c.expression.isLightConstant)) {
                        const f = i.paint.get(o);
                        c.expression = f.value;
                        for (const r of p){
                            const i = t1[r.toString()];
                            e.eachPosition(r, (t1, e, r)=>{
                                const o = n.feature(t1);
                                c.updatePaintArray(e, r, o, i, a, s, l);
                            });
                        }
                        if (!h) for (const e of r.uniqueIds){
                            const i = t1[e.toString()];
                            r.eachPosition(e, (t1, e, r)=>{
                                const o = n.feature(t1);
                                c.updatePaintArray(e, r, o, i, a, s, l);
                            });
                        }
                        u = !0;
                    }
                }
                return u;
            }
            defines() {
                const t1 = [];
                for(const e in this.binders){
                    const r = this.binders[e];
                    (r instanceof Co || r instanceof Do) && t1.push(...r.uniformNames.map((t1)=>`#define HAS_UNIFORM_${t1}`));
                }
                return t1;
            }
            getBinderAttributes() {
                const t1 = [];
                for(const e in this.binders){
                    const r = this.binders[e];
                    if (r instanceof Lo || r instanceof Ro || r instanceof Fo) for(let e = 0; e < r.paintVertexAttributes.length; e++)t1.push(r.paintVertexAttributes[e].name);
                }
                return t1;
            }
            getBinderUniforms() {
                const t1 = [];
                for(const e in this.binders){
                    const r = this.binders[e];
                    if (r instanceof Co || r instanceof Do || r instanceof Ro) for (const e of r.uniformNames)t1.push(e);
                }
                return t1;
            }
            getPaintVertexBuffers() {
                return this._buffers;
            }
            getUniforms(t1) {
                const e = [];
                for(const r in this.binders){
                    const n = this.binders[r];
                    if (n instanceof Co || n instanceof Do || n instanceof Ro) for (const i of n.uniformNames)e.push({
                        name: i,
                        property: r,
                        binding: n.getBinding(t1, i)
                    });
                }
                return e;
            }
            setUniforms(t1, e, r, n, i) {
                for (const { name: e, property: a, binding: s } of r){
                    if (this.binders[a].checkUseTheme && this.binders[a] instanceof Co) {
                        const t1 = n.get(`${a}-use-theme`);
                        t1.isConstant() && (this.binders[a].ignoreLut = "none" === t1.constantOr("default"));
                    }
                    this.binders[a].setUniform(t1, s, i, n.get(a), e);
                }
            }
            updatePaintBuffers() {
                this._buffers = [];
                for(const t1 in this.binders){
                    const e = this.binders[t1];
                    (e instanceof Lo || e instanceof Ro || e instanceof Fo) && e.paintVertexBuffer && this._buffers.push(e.paintVertexBuffer);
                }
            }
            upload(t1) {
                for(const e in this.binders){
                    const r = this.binders[e];
                    (r instanceof Lo || r instanceof Ro || r instanceof Fo) && r.upload(t1);
                }
                this.updatePaintBuffers();
            }
            destroy() {
                for(const t1 in this.binders){
                    const e = this.binders[t1];
                    (e instanceof Lo || e instanceof Ro || e instanceof Fo) && e.destroy();
                }
            }
        }
        class No {
            constructor(t1, e, r = ()=>!0){
                this.programConfigurations = {};
                for (const n of t1)this.programConfigurations[n.id] = new Oo(n, e, r);
                this.needsUpload = !1, this._featureMap = new go, this._featureMapWithoutIds = new go, this._bufferOffset = 0, this._idlessCounter = 0;
            }
            populatePaintArrays(t1, e, r, n, i, a, s, o) {
                for(const r in this.programConfigurations)this.programConfigurations[r].populatePaintArrays(t1, e, n, i, a, s, o);
                void 0 !== e.id ? this._featureMap.add(e.id, r, this._bufferOffset, t1) : (this._featureMapWithoutIds.add(this._idlessCounter, r, this._bufferOffset, t1), this._idlessCounter += 1), this._bufferOffset = t1, this.needsUpload = !0;
            }
            updatePaintArrays(t1, e, r, n, i, a, s) {
                for (const o of r)this.needsUpload = this.programConfigurations[o.id].updatePaintArrays(t1, this._featureMap, this._featureMapWithoutIds, e, o, n, i, a, s || 0) || this.needsUpload;
            }
            get(t1) {
                return this.programConfigurations[t1];
            }
            upload(t1) {
                if (this.needsUpload) {
                    for(const e in this.programConfigurations)this.programConfigurations[e].upload(t1);
                    this.needsUpload = !1;
                }
            }
            destroy() {
                for(const t1 in this.programConfigurations)this.programConfigurations[t1].destroy();
            }
        }
        const Uo = {
            "text-opacity": [
                "opacity"
            ],
            "icon-opacity": [
                "opacity"
            ],
            "text-occlusion-opacity": [
                "occlusion_opacity"
            ],
            "icon-occlusion-opacity": [
                "occlusion_opacity"
            ],
            "text-color": [
                "fill_color"
            ],
            "icon-color": [
                "fill_color"
            ],
            "text-emissive-strength": [
                "emissive_strength"
            ],
            "icon-emissive-strength": [
                "emissive_strength"
            ],
            "text-halo-color": [
                "halo_color"
            ],
            "icon-halo-color": [
                "halo_color"
            ],
            "text-halo-blur": [
                "halo_blur"
            ],
            "icon-halo-blur": [
                "halo_blur"
            ],
            "text-halo-width": [
                "halo_width"
            ],
            "icon-halo-width": [
                "halo_width"
            ],
            "symbol-z-offset": [
                "z_offset"
            ],
            "line-gap-width": [
                "gapwidth"
            ],
            "line-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "fill-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "fill-extrusion-pattern": [
                "pattern",
                "pixel_ratio"
            ],
            "line-dasharray": [
                "dash"
            ]
        };
        function jo(t1, e) {
            return Uo[t1] || [
                t1.replace(`${e}-`, "").replace(/-/g, "_")
            ];
        }
        const qo = {
            "line-pattern": {
                source: Ss,
                composite: Ss
            },
            "fill-pattern": {
                source: Ss,
                composite: Ss
            },
            "fill-extrusion-pattern": {
                source: Ss,
                composite: Ss
            },
            "line-dasharray": {
                source: Is,
                composite: Is
            }
        }, $o = {
            color: {
                source: $s,
                composite: Ms
            },
            number: {
                source: Os,
                composite: $s
            }
        };
        function Go(t1, e, r) {
            const n = qo[t1];
            return n && n[r] || $o[e][r];
        }
        oa(Co, "ConstantBinder"), oa(Do, "PatternConstantBinder"), oa(Lo, "SourceExpressionBinder"), oa(Fo, "PatternCompositeBinder"), oa(Ro, "CompositeExpressionBinder"), oa(Oo, "ProgramConfiguration", {
            omit: [
                "_buffers"
            ]
        }), oa(No, "ProgramConfigurationSet");
        const Yo = Wr / Math.PI / 2, Xo = 5, Zo = 6, Ho = 16383, Wo = 64, Ko = [
            Wo,
            32,
            16
        ], Jo = -Yo, Qo = Yo;
        function tl(t1, e, r, n = Yo) {
            return r = X(r), [
                t1 * Math.sin(r) * n,
                -e * n,
                t1 * Math.cos(r) * n
            ];
        }
        function el(t1, e, r) {
            return tl(Math.cos(X(t1)), Math.sin(X(t1)), e, r);
        }
        const rl = 6371008.8, nl = 2 * Math.PI * rl;
        class il {
            constructor(t1, e){
                if (isNaN(t1) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t1}, ${e})`);
                if (this.lng = +t1, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
                return new il(et(this.lng, -180, 180), this.lat);
            }
            toArray() {
                return [
                    this.lng,
                    this.lat
                ];
            }
            toString() {
                return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t1) {
                const e = Math.PI / 180, r = this.lat * e, n = t1.lat * e, i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t1.lng - this.lng) * e);
                return rl * Math.acos(Math.min(i, 1));
            }
            toBounds(t1 = 0) {
                const e = 360 * t1 / 40075017, r = e / Math.cos(Math.PI / 180 * this.lat);
                return new al({
                    lng: this.lng - r,
                    lat: this.lat - e
                }, {
                    lng: this.lng + r,
                    lat: this.lat + e
                });
            }
            toEcef(t1) {
                return el(this.lat, this.lng, Yo + t1 * Yo / rl);
            }
            static convert(t1) {
                if (t1 instanceof il) return t1;
                if (Array.isArray(t1) && (2 === t1.length || 3 === t1.length)) return new il(Number(t1[0]), Number(t1[1]));
                if (!Array.isArray(t1) && "object" == typeof t1 && null !== t1) return new il(Number("lng" in t1 ? t1.lng : t1.lon), Number(t1.lat));
                throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
        }
        class al {
            constructor(t1, e){
                if (t1) if (e) this.setSouthWest(t1).setNorthEast(e);
                else if (4 === t1.length) {
                    const e = t1;
                    this.setSouthWest([
                        e[0],
                        e[1]
                    ]).setNorthEast([
                        e[2],
                        e[3]
                    ]);
                } else {
                    const e = t1;
                    this.setSouthWest(e[0]).setNorthEast(e[1]);
                }
            }
            setNorthEast(t1) {
                return this._ne = t1 instanceof il ? new il(t1.lng, t1.lat) : il.convert(t1), this;
            }
            setSouthWest(t1) {
                return this._sw = t1 instanceof il ? new il(t1.lng, t1.lat) : il.convert(t1), this;
            }
            extend(t1) {
                const e = this._sw, r = this._ne;
                let n, i;
                if (t1 instanceof il) n = t1, i = t1;
                else {
                    if (!(t1 instanceof al)) return Array.isArray(t1) ? 4 === t1.length || t1.every(Array.isArray) ? this.extend(al.convert(t1)) : this.extend(il.convert(t1)) : "object" == typeof t1 && null !== t1 && t1.hasOwnProperty("lat") && (t1.hasOwnProperty("lon") || t1.hasOwnProperty("lng")) ? this.extend(il.convert(t1)) : this;
                    if (n = t1._sw, i = t1._ne, !n || !i) return this;
                }
                return e || r ? (e.lng = Math.min(n.lng, e.lng), e.lat = Math.min(n.lat, e.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new il(n.lng, n.lat), this._ne = new il(i.lng, i.lat)), this;
            }
            getCenter() {
                return new il((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
                return this._sw;
            }
            getNorthEast() {
                return this._ne;
            }
            getNorthWest() {
                return new il(this.getWest(), this.getNorth());
            }
            getSouthEast() {
                return new il(this.getEast(), this.getSouth());
            }
            getWest() {
                return this._sw.lng;
            }
            getSouth() {
                return this._sw.lat;
            }
            getEast() {
                return this._ne.lng;
            }
            getNorth() {
                return this._ne.lat;
            }
            toArray() {
                return [
                    this._sw.toArray(),
                    this._ne.toArray()
                ];
            }
            toString() {
                return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
                return !(this._sw && this._ne);
            }
            contains(t1) {
                const { lng: e, lat: r } = il.convert(t1);
                let n = this._sw.lng <= e && e <= this._ne.lng;
                return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;
            }
            static convert(t1) {
                if (t1) return t1 instanceof al ? t1 : new al(t1);
            }
        }
        const sl = 0, ol = 25.5;
        function ll(t1) {
            return nl * Math.cos(t1 * Math.PI / 180);
        }
        function ul(t1) {
            return (180 + t1) / 360;
        }
        function cl(t1) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t1 * Math.PI / 360))) / 360;
        }
        function hl(t1, e) {
            return t1 / ll(e);
        }
        function pl(t1) {
            return 360 * t1 - 180;
        }
        function fl(t1) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t1) * Math.PI / 180)) - 90;
        }
        function dl(t1, e) {
            return t1 * ll(fl(e));
        }
        const ml = 85.051129;
        function yl(t1) {
            return Math.cos(X(Q(t1, -ml, ml)));
        }
        function gl(t1, e) {
            const r = Q(e, sl, ol), n = Math.pow(2, r);
            return yl(t1) * nl / (512 * n);
        }
        function xl(t1) {
            return 1 / Math.cos(t1 * Math.PI / 180);
        }
        function vl(t1, e = 0) {
            const r = Math.exp(Math.PI * (1 - (t1.y + e / Wr) / (1 << t1.z) * 2));
            return 80150034 * r / (r * r + 1) / Wr / (1 << t1.z);
        }
        class bl {
            constructor(t1, e, r = 0){
                this.x = +t1, this.y = +e, this.z = +r;
            }
            static fromLngLat(t1, e = 0) {
                const r = il.convert(t1);
                return new bl(ul(r.lng), cl(r.lat), hl(e, r.lat));
            }
            toLngLat() {
                return new il(pl(this.x), fl(this.y));
            }
            toAltitude() {
                return dl(this.z, this.y);
            }
            meterInMercatorCoordinateUnits() {
                return 1 / nl * xl(fl(this.y));
            }
        }
        function _l(t1, e, r, n, i, a, s, o, l) {
            const u = (e + n) / 2, c = (r + i) / 2, h = new q(u, c);
            o(h), function(t1, e, r, n, i, a) {
                const s = r - i, o = n - a;
                return Math.abs((n - e) * s - (r - t1) * o) / Math.hypot(s, o);
            }(h.x, h.y, a.x, a.y, s.x, s.y) >= l ? (_l(t1, e, r, u, c, a, h, o, l), _l(t1, u, c, n, i, h, s, o, l)) : t1.push(s);
        }
        function wl(t1, e, r) {
            let n = t1[0], i = n.x, a = n.y;
            e(n);
            const s = [
                n
            ];
            for(let o = 1; o < t1.length; o++){
                const l = t1[o], { x: u, y: c } = l;
                e(l), _l(s, i, a, u, c, n, l, e, r), i = u, a = c, n = l;
            }
            return s;
        }
        function Ml(t1, e, r, n) {
            if (n(e, r)) {
                const i = e.add(r)._mult(.5);
                Ml(t1, e, i, n), Ml(t1, i, r, n);
            } else t1.push(r);
        }
        function Al(t1, e) {
            let r = t1[0];
            const n = [
                r
            ];
            for(let i = 1; i < t1.length; i++){
                const a = t1[i];
                Ml(n, r, a, e), r = a;
            }
            return n;
        }
        const Sl = Math.pow(2, 14) - 1, Il = -Sl - 1;
        function Pl(t1, e) {
            const r = Math.round(t1.x * e), n = Math.round(t1.y * e);
            return t1.x = Q(r, Il, Sl), t1.y = Q(n, Il, Sl), (r < t1.x || r > t1.x + 1 || n < t1.y || n > t1.y + 1) && ft("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t1;
        }
        function zl(t1, e, r) {
            const n = t1.loadGeometry(), i = t1.extent, a = Wr / i;
            if (e && r && r.projection.isReprojectedInTileSpace) {
                const a = 1 << e.z, { scale: s, x: o, y: l, projection: u } = r, c = (t1)=>{
                    const r = pl((e.x + t1.x / i) / a), n = fl((e.y + t1.y / i) / a), c = u.project(r, n);
                    t1.x = (c.x * s - o) * i, t1.y = (c.y * s - l) * i;
                };
                for(let e = 0; e < n.length; e++)if (1 !== t1.type) n[e] = wl(n[e], c, 1);
                else {
                    const t1 = [];
                    for (const r of n[e])r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (c(r), t1.push(r));
                    n[e] = t1;
                }
            }
            for (const t1 of n)for (const e of t1)Pl(e, a);
            return n;
        }
        function El(t1, e) {
            return {
                type: t1.type,
                id: t1.id,
                properties: t1.properties,
                geometry: e ? zl(t1) : []
            };
        }
        function kl(t1, e, r, n, i) {
            t1.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);
        }
        function Tl(t1, e, r) {
            const n = 16384;
            t1.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);
        }
        class Bl {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.projection = t1.projection, this.layoutVertexArray = new xs, this.indexArray = new Ls, this.segments = new po, this.programConfigurations = new No(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id);
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                const i = this.layers[0], a = [];
                let s = null;
                "circle" === i.type && (s = i.layout.get("circle-sort-key"));
                for (const { feature: e, id: i, index: o, sourceLayerIndex: l } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, u = El(e, t1);
                    if (!this.layers[0]._featureFilter.filter(new Va(this.zoom), u, r)) continue;
                    const c = s ? s.evaluate(u, {}, r) : void 0, h = {
                        id: i,
                        properties: e.properties,
                        type: e.type,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: t1 ? u.geometry : zl(e, r, n),
                        patterns: {},
                        sortKey: c
                    };
                    a.push(h);
                }
                s && a.sort((t1, e)=>t1.sortKey - e.sortKey);
                let o = null;
                "globe" === n.projection.name && (this.globeExtVertexArray = new Ps, o = n.projection);
                for (const n of a){
                    const { geometry: i, index: a, sourceLayerIndex: s } = n, l = t1[a].feature;
                    this.addFeature(n, i, a, e.availableImages, r, o, e.brightness), e.featureIndex.insert(l, i, a, s, this.index);
                }
            }
            update(t1, e, r, n, i, a, s) {
                this.programConfigurations.updatePaintArrays(t1, e, i, r, n, a, s);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, co.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t1.createVertexBuffer(this.globeExtVertexArray, ho.members))), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
            addFeature(t1, e, r, n, i, a, s) {
                for (const r of e)for (const e of r){
                    const r = e.x, n = e.y;
                    if (r < 0 || r >= Wr || n < 0 || n >= Wr) continue;
                    if (a) {
                        const t1 = a.projectTilePoint(r, n, i), e = a.upVector(i, r, n), s = this.globeExtVertexArray;
                        Tl(s, t1, e), Tl(s, t1, e), Tl(s, t1, e), Tl(s, t1, e);
                    }
                    const s = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t1.sortKey), o = s.vertexLength;
                    kl(this.layoutVertexArray, r, n, -1, -1), kl(this.layoutVertexArray, r, n, 1, -1), kl(this.layoutVertexArray, r, n, 1, 1), kl(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(o, o + 1, o + 2), this.indexArray.emplaceBack(o, o + 2, o + 3), s.vertexLength += 4, s.primitiveLength += 2;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, {}, n, i, s);
            }
        }
        function Vl(t1, e) {
            for(let r = 0; r < t1.length; r++)if (jl(e, t1[r])) return !0;
            for(let r = 0; r < e.length; r++)if (jl(t1, e[r])) return !0;
            return !!Rl(t1, e);
        }
        function Cl(t1, e, r) {
            return !!jl(t1, e) || !!Ol(e, t1, r);
        }
        function Dl(t1, e) {
            if (1 === t1.length) return Ul(e, t1[0]);
            for(let r = 0; r < e.length; r++){
                const n = e[r];
                for(let e = 0; e < n.length; e++)if (jl(t1, n[e])) return !0;
            }
            for(let r = 0; r < t1.length; r++)if (Ul(e, t1[r])) return !0;
            for(let r = 0; r < e.length; r++)if (Rl(t1, e[r])) return !0;
            return !1;
        }
        function Ll(t1, e, r) {
            if (t1.length > 1) {
                if (Rl(t1, e)) return !0;
                for(let n = 0; n < e.length; n++)if (Ol(e[n], t1, r)) return !0;
            }
            for(let n = 0; n < t1.length; n++)if (Ol(t1[n], e, r)) return !0;
            return !1;
        }
        function Rl(t1, e) {
            if (0 === t1.length || 0 === e.length) return !1;
            for(let r = 0; r < t1.length - 1; r++){
                const n = t1[r], i = t1[r + 1];
                for(let t1 = 0; t1 < e.length - 1; t1++)if (Fl(n, i, e[t1], e[t1 + 1])) return !0;
            }
            return !1;
        }
        function Fl(t1, e, r, n) {
            return dt(t1, r, n) !== dt(e, r, n) && dt(t1, e, r) !== dt(t1, e, n);
        }
        function Ol(t1, e, r) {
            const n = r * r;
            if (1 === e.length) return t1.distSqr(e[0]) < n;
            for(let r = 1; r < e.length; r++)if (Nl(t1, e[r - 1], e[r]) < n) return !0;
            return !1;
        }
        function Nl(t1, e, r) {
            const n = e.distSqr(r);
            if (0 === n) return t1.distSqr(e);
            const i = ((t1.x - e.x) * (r.x - e.x) + (t1.y - e.y) * (r.y - e.y)) / n;
            return t1.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));
        }
        function Ul(t1, e) {
            let r, n, i, a = !1;
            for(let s = 0; s < t1.length; s++){
                r = t1[s];
                for(let t1 = 0, s = r.length - 1; t1 < r.length; s = t1++)n = r[t1], i = r[s], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (a = !a);
            }
            return a;
        }
        function jl(t1, e) {
            let r = !1;
            for(let n = 0, i = t1.length - 1; n < t1.length; i = n++){
                const a = t1[n], s = t1[i];
                a.y > e.y != s.y > e.y && e.x < (s.x - a.x) * (e.y - a.y) / (s.y - a.y) + a.x && (r = !r);
            }
            return r;
        }
        function ql(t1, e, r, n, i) {
            for (const a of t1)if (e <= a.x && r <= a.y && n >= a.x && i >= a.y) return !0;
            const a = [
                new q(e, r),
                new q(e, i),
                new q(n, i),
                new q(n, r)
            ];
            if (t1.length > 2) {
                for (const e of a)if (jl(t1, e)) return !0;
            }
            for(let e = 0; e < t1.length - 1; e++)if ($l(t1[e], t1[e + 1], a)) return !0;
            return !1;
        }
        function $l(t1, e, r) {
            const n = r[0], i = r[2];
            if (t1.x < n.x && e.x < n.x || t1.x > i.x && e.x > i.x || t1.y < n.y && e.y < n.y || t1.y > i.y && e.y > i.y) return !1;
            const a = dt(t1, e, r[0]);
            return a !== dt(t1, e, r[1]) || a !== dt(t1, e, r[2]) || a !== dt(t1, e, r[3]);
        }
        function Gl(t1, e, r, n, i, a) {
            let s = e.y - t1.y, o = t1.x - e.x;
            if (a = a || 0) {
                const t1 = s * s + o * o;
                if (0 === t1) return !0;
                const e = Math.sqrt(t1);
                s /= e, o /= e;
            }
            return !((r.x - t1.x) * s + (r.y - t1.y) * o - a < 0 || (n.x - t1.x) * s + (n.y - t1.y) * o - a < 0 || (i.x - t1.x) * s + (i.y - t1.y) * o - a < 0);
        }
        function Yl(t1, e, r, n, i, a, s) {
            return !(Gl(t1, e, n, i, a, s) || Gl(e, r, n, i, a, s) || Gl(r, t1, n, i, a, s) || Gl(n, i, t1, e, r, s) || Gl(i, a, t1, e, r, s) || Gl(a, n, t1, e, r, s));
        }
        function Xl(t1, e, r) {
            const n = e.paint.get(t1).value;
            return "constant" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t1);
        }
        function Zl(t1) {
            return Math.sqrt(t1[0] * t1[0] + t1[1] * t1[1]);
        }
        function Hl(t1, e, r, n, i) {
            if (!e[0] && !e[1]) return t1;
            const a = q.convert(e)._mult(i);
            "viewport" === r && a._rotate(-n);
            const s = [];
            for(let e = 0; e < t1.length; e++)s.push(t1[e].sub(a));
            return s;
        }
        function Wl(t1, e, r, n) {
            const i = q.convert(t1)._mult(n);
            return "viewport" === e && i._rotate(-r), i;
        }
        let Kl, Jl;
        oa(Bl, "CircleBucket", {
            omit: [
                "layers"
            ]
        });
        var Ql, tu = {
            exports: {}
        }, eu = (Ql || (Ql = 1, function(t1, e) {
            !function(t1) {
                function e(t1, e, n) {
                    var i = r(256 * t1, 256 * (e = Math.pow(2, n) - e - 1), n), a = r(256 * (t1 + 1), 256 * (e + 1), n);
                    return i[0] + "," + i[1] + "," + a[0] + "," + a[1];
                }
                function r(t1, e, r) {
                    var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);
                    return [
                        t1 * n - 2 * Math.PI * 6378137 / 2,
                        e * n - 2 * Math.PI * 6378137 / 2
                    ];
                }
                t1.getURL = function(t1, r, n, i, a, s) {
                    return s = s || {}, t1 + "?" + [
                        "bbox=" + e(n, i, a),
                        "format=" + (s.format || "image/png"),
                        "service=" + (s.service || "WMS"),
                        "version=" + (s.version || "1.1.1"),
                        "request=" + (s.request || "GetMap"),
                        "srs=" + (s.srs || "EPSG:3857"),
                        "width=" + (s.width || 256),
                        "height=" + (s.height || 256),
                        "layers=" + r
                    ].join("&");
                }, t1.getTileBBox = e, t1.getMercCoords = r, Object.defineProperty(t1, "__esModule", {
                    value: !0
                });
            }(e);
        }(0, tu.exports)), tu.exports);
        class ru {
            constructor(t1, e, r){
                this.z = t1, this.x = e, this.y = r, this.key = au(0, t1, t1, e, r);
            }
            equals(t1) {
                return this.z === t1.z && this.x === t1.x && this.y === t1.y;
            }
            url(t1, e) {
                const r = eu.getTileBBox(this.x, this.y, this.z), n = function(t1, e, r) {
                    let n, i = "";
                    for(let a = t1; a > 0; a--)n = 1 << a - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0);
                    return i;
                }(this.z, this.x, this.y);
                return t1[(this.x + this.y) % t1.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n).replace("{bbox-epsg-3857}", r);
            }
            toString() {
                return `${this.z}/${this.x}/${this.y}`;
            }
        }
        class nu {
            constructor(t1, e){
                this.wrap = t1, this.canonical = e, this.key = au(t1, e.z, e.z, e.x, e.y);
            }
        }
        class iu {
            constructor(t1, e, r, n, i){
                this.overscaledZ = t1, this.wrap = e, this.canonical = new ru(r, +n, +i), this.key = 0 === e && t1 === r ? this.canonical.key : au(e, t1, r, n, i);
            }
            equals(t1) {
                return this.overscaledZ === t1.overscaledZ && this.wrap === t1.wrap && this.canonical.equals(t1.canonical);
            }
            scaledTo(t1) {
                const e = this.canonical.z - t1;
                return t1 > this.canonical.z ? new iu(t1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new iu(t1, this.wrap, t1, this.canonical.x >> e, this.canonical.y >> e);
            }
            calculateScaledKey(t1, e = !0) {
                if (this.overscaledZ === t1 && e) return this.key;
                if (t1 > this.canonical.z) return au(this.wrap * +e, t1, this.canonical.z, this.canonical.x, this.canonical.y);
                {
                    const r = this.canonical.z - t1;
                    return au(this.wrap * +e, t1, t1, this.canonical.x >> r, this.canonical.y >> r);
                }
            }
            isChildOf(t1) {
                if (t1.wrap !== this.wrap) return !1;
                const e = this.canonical.z - t1.canonical.z;
                return 0 === t1.overscaledZ || t1.overscaledZ < this.overscaledZ && t1.canonical.z < this.canonical.z && t1.canonical.x === this.canonical.x >> e && t1.canonical.y === this.canonical.y >> e;
            }
            children(t1) {
                if (this.overscaledZ >= t1) return [
                    new iu(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
                ];
                const e = this.canonical.z + 1, r = 2 * this.canonical.x, n = 2 * this.canonical.y;
                return [
                    new iu(e, this.wrap, e, r, n),
                    new iu(e, this.wrap, e, r + 1, n),
                    new iu(e, this.wrap, e, r, n + 1),
                    new iu(e, this.wrap, e, r + 1, n + 1)
                ];
            }
            isLessThan(t1) {
                return this.wrap < t1.wrap || !(this.wrap > t1.wrap) && (this.overscaledZ < t1.overscaledZ || !(this.overscaledZ > t1.overscaledZ) && (this.canonical.x < t1.canonical.x || !(this.canonical.x > t1.canonical.x) && this.canonical.y < t1.canonical.y));
            }
            wrapped() {
                return new iu(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t1) {
                return new iu(this.overscaledZ, t1, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
                return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
                return new nu(this.wrap, this.canonical);
            }
            toString() {
                return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
        }
        function au(t1, e, r, n, i) {
            const a = 1 << Math.min(r, 22);
            let s = a * (i % a) + n % a;
            return t1 && r < 22 && (s += a * a * ((t1 < 0 ? -2 * t1 - 1 : 2 * t1) % (1 << 2 * (22 - r)))), 16 * (32 * s + r) + (e - r);
        }
        const su = [
            (t1)=>{
                let e = t1.canonical.x - 1, r = t1.wrap;
                return e < 0 && (e = (1 << t1.canonical.z) - 1, r--), new iu(t1.overscaledZ, r, t1.canonical.z, e, t1.canonical.y);
            },
            (t1)=>{
                let e = t1.canonical.x + 1, r = t1.wrap;
                return e === 1 << t1.canonical.z && (e = 0, r++), new iu(t1.overscaledZ, r, t1.canonical.z, e, t1.canonical.y);
            },
            (t1)=>new iu(t1.overscaledZ, t1.wrap, t1.canonical.z, t1.canonical.x, (0 === t1.canonical.y ? 1 << t1.canonical.z : t1.canonical.y) - 1),
            (t1)=>new iu(t1.overscaledZ, t1.wrap, t1.canonical.z, t1.canonical.x, t1.canonical.y === (1 << t1.canonical.z) - 1 ? 0 : t1.canonical.y + 1)
        ];
        oa(ru, "CanonicalTileID"), oa(iu, "OverscaledTileID", {
            omit: [
                "projMatrix",
                "expandedProjMatrix"
            ]
        });
        const ou = ys([
            {
                type: "Float32",
                name: "a_globe_pos",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            }
        ]), { members: lu } = ou, uu = ys([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            }
        ]);
        var cu = ys([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            }
        ]);
        class hu {
            constructor(t1, e){
                this.pos = t1, this.dir = e;
            }
            intersectsPlane(t1, e, r) {
                const n = O.vec3.dot(e, this.dir);
                if (Math.abs(n) < 1e-6) return !1;
                const i = ((t1[0] - this.pos[0]) * e[0] + (t1[1] - this.pos[1]) * e[1] + (t1[2] - this.pos[2]) * e[2]) / n;
                return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, r[2] = this.pos[2] + this.dir[2] * i, !0;
            }
            closestPointOnSphere(t1, e, r) {
                if (O.vec3.equals(this.pos, t1) || 0 === e) return r[0] = r[1] = r[2] = 0, !1;
                const [n, i, a] = this.dir, s = this.pos[0] - t1[0], o = this.pos[1] - t1[1], l = this.pos[2] - t1[2], u = n * n + i * i + a * a, c = 2 * (s * n + o * i + l * a), h = c * c - 4 * u * (s * s + o * o + l * l - e * e);
                if (h < 0) {
                    const t1 = Math.max(-c / 2, 0), u = s + n * t1, h = o + i * t1, p = l + a * t1, f = Math.hypot(u, h, p);
                    return r[0] = u * e / f, r[1] = h * e / f, r[2] = p * e / f, !1;
                }
                {
                    const t1 = (-c - Math.sqrt(h)) / (2 * u);
                    if (t1 < 0) {
                        const t1 = Math.hypot(s, o, l);
                        return r[0] = s * e / t1, r[1] = o * e / t1, r[2] = l * e / t1, !1;
                    }
                    return r[0] = s + n * t1, r[1] = o + i * t1, r[2] = l + a * t1, !0;
                }
            }
        }
        class pu {
            constructor(t1, e, r, n, i){
                this.TL = t1, this.TR = e, this.BR = r, this.BL = n, this.horizon = i;
            }
            static fromInvProjectionMatrix(t1, e, r) {
                const n = [
                    -1,
                    1,
                    1
                ], i = [
                    1,
                    1,
                    1
                ], a = [
                    1,
                    -1,
                    1
                ], s = [
                    -1,
                    -1,
                    1
                ], o = O.vec3.transformMat4(n, n, t1), l = O.vec3.transformMat4(i, i, t1), u = O.vec3.transformMat4(a, a, t1), c = O.vec3.transformMat4(s, s, t1);
                return new pu(o, l, u, c, e / r);
            }
        }
        function fu(t1, e, r) {
            let n = 1 / 0, i = -1 / 0;
            const a = [];
            for (const s of t1){
                O.vec3.sub(a, s, e);
                const t1 = O.vec3.dot(a, r);
                n = Math.min(n, t1), i = Math.max(i, t1);
            }
            return [
                n,
                i
            ];
        }
        function du(t1, e) {
            let r = !0;
            for(let n = 0; n < t1.planes.length; n++){
                const i = t1.planes[n];
                let a = 0;
                for(let t1 = 0; t1 < e.length; t1++)a += O.vec3.dot(i, e[t1]) + i[3] >= 0;
                if (0 === a) return 0;
                a !== e.length && (r = !1);
            }
            return r ? 2 : 1;
        }
        function mu(t1, e) {
            for (const r of t1.projections){
                const n = fu(e, t1.points[0], r.axis);
                if (r.projection[1] < n[0] || r.projection[0] > n[1]) return 0;
            }
            return 1;
        }
        function yu(t1, e) {
            let r = 0;
            const n = [
                0,
                0,
                0,
                0
            ];
            for(let i = 0; i < t1.length; i++)n[0] = t1[i][0], n[1] = t1[i][1], n[2] = t1[i][2], n[3] = 1, O.vec4.dot(n, e) >= 0 && r++;
            return r;
        }
        class gu {
            constructor(t1, e){
                this.points = t1 || new Array(8).fill([
                    0,
                    0,
                    0
                ]), this.planes = e || new Array(6).fill([
                    0,
                    0,
                    0,
                    0
                ]), this.bounds = xu.fromPoints(this.points), this.projections = [], this.frustumEdges = [
                    O.vec3.sub([], this.points[2], this.points[3]),
                    O.vec3.sub([], this.points[0], this.points[3]),
                    O.vec3.sub([], this.points[4], this.points[0]),
                    O.vec3.sub([], this.points[5], this.points[1]),
                    O.vec3.sub([], this.points[6], this.points[2]),
                    O.vec3.sub([], this.points[7], this.points[3])
                ];
                for (const t1 of this.frustumEdges){
                    const e = [
                        0,
                        -t1[2],
                        t1[1]
                    ], r = [
                        t1[2],
                        0,
                        -t1[0]
                    ];
                    this.projections.push({
                        axis: e,
                        projection: fu(this.points, this.points[0], e)
                    }), this.projections.push({
                        axis: r,
                        projection: fu(this.points, this.points[0], r)
                    });
                }
            }
            static fromInvProjectionMatrix(t1, e, r, n) {
                const i = Math.pow(2, r), a = [
                    [
                        -1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        1,
                        -1,
                        1
                    ],
                    [
                        1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        -1,
                        1
                    ],
                    [
                        -1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1,
                        1
                    ],
                    [
                        1,
                        -1,
                        1,
                        1
                    ],
                    [
                        -1,
                        -1,
                        1,
                        1
                    ]
                ].map((r)=>{
                    const a = O.vec4.transformMat4([], r, t1), s = 1 / a[3] / e * i;
                    return O.vec4.mul(a, a, [
                        s,
                        s,
                        n ? 1 / a[3] : s,
                        s
                    ]);
                }), s = [
                    [
                        0,
                        1,
                        2
                    ],
                    [
                        6,
                        5,
                        4
                    ],
                    [
                        0,
                        3,
                        7
                    ],
                    [
                        2,
                        1,
                        5
                    ],
                    [
                        3,
                        2,
                        6
                    ],
                    [
                        0,
                        4,
                        5
                    ]
                ].map((t1)=>{
                    const e = O.vec3.sub([], a[t1[0]], a[t1[1]]), r = O.vec3.sub([], a[t1[2]], a[t1[1]]), n = O.vec3.normalize([], O.vec3.cross([], e, r)), i = -O.vec3.dot(n, a[t1[1]]);
                    return n.concat(i);
                }), o = [];
                for(let t1 = 0; t1 < a.length; t1++)o.push([
                    a[t1][0],
                    a[t1][1],
                    a[t1][2]
                ]);
                return new gu(o, s);
            }
            intersectsPrecise(t1, e, r) {
                for(let r = 0; r < e.length; r++)if (!yu(t1, e[r])) return 0;
                for(let e = 0; e < this.planes.length; e++)if (!yu(t1, this.planes[e])) return 0;
                for (const e of r)for (const r of this.frustumEdges){
                    const n = O.vec3.cross([], e, r), i = O.vec3.length(n);
                    if (0 === i) continue;
                    O.vec3.scale(n, n, 1 / i);
                    const a = fu(this.points, this.points[0], n), s = fu(t1, this.points[0], n);
                    if (a[0] > s[1] || s[0] > a[1]) return 0;
                }
                return 1;
            }
            containsPoint(t1) {
                for (const e of this.planes){
                    const r = e[3];
                    if (O.vec3.dot([
                        e[0],
                        e[1],
                        e[2]
                    ], t1) + r < 0) return !1;
                }
                return !0;
            }
        }
        class xu {
            static fromPoints(t1) {
                const e = [
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], r = [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ];
                for (const n of t1)O.vec3.min(e, e, n), O.vec3.max(r, r, n);
                return new xu(e, r);
            }
            static fromTileIdAndHeight(t1, e, r) {
                const n = 1 << t1.canonical.z, i = t1.canonical.x, a = t1.canonical.y;
                return new xu([
                    i / n,
                    a / n,
                    e
                ], [
                    (i + 1) / n,
                    (a + 1) / n,
                    r
                ]);
            }
            static applyTransform(t1, e) {
                const r = t1.getCorners();
                for(let t1 = 0; t1 < r.length; ++t1)O.vec3.transformMat4(r[t1], r[t1], e);
                return xu.fromPoints(r);
            }
            static applyTransformFast(t1, e) {
                const r = [
                    e[12],
                    e[13],
                    e[14]
                ], n = [
                    ...r
                ];
                for(let i = 0; i < 3; i++)for(let a = 0; a < 3; a++){
                    const s = e[4 * a + i], o = s * t1.min[a], l = s * t1.max[a];
                    r[i] += Math.min(o, l), n[i] += Math.max(o, l);
                }
                return new xu(r, n);
            }
            static projectAabbCorners(t1, e) {
                const r = t1.getCorners();
                for(let t1 = 0; t1 < r.length; ++t1)O.vec3.transformMat4(r[t1], r[t1], e);
                return r;
            }
            constructor(t1, e){
                this.min = t1, this.max = e, this.center = O.vec3.scale([], O.vec3.add([], this.min, this.max), .5);
            }
            quadrant(t1) {
                const e = [
                    t1 % 2 == 0,
                    t1 < 2
                ], r = O.vec3.clone(this.min), n = O.vec3.clone(this.max);
                for(let t1 = 0; t1 < e.length; t1++)r[t1] = e[t1] ? this.min[t1] : this.center[t1], n[t1] = e[t1] ? this.center[t1] : this.max[t1];
                return n[2] = this.max[2], new xu(r, n);
            }
            distanceX(t1) {
                return Math.max(Math.min(this.max[0], t1[0]), this.min[0]) - t1[0];
            }
            distanceY(t1) {
                return Math.max(Math.min(this.max[1], t1[1]), this.min[1]) - t1[1];
            }
            distanceZ(t1) {
                return Math.max(Math.min(this.max[2], t1[2]), this.min[2]) - t1[2];
            }
            getCorners() {
                const t1 = this.min, e = this.max;
                return [
                    [
                        t1[0],
                        t1[1],
                        t1[2]
                    ],
                    [
                        e[0],
                        t1[1],
                        t1[2]
                    ],
                    [
                        e[0],
                        e[1],
                        t1[2]
                    ],
                    [
                        t1[0],
                        e[1],
                        t1[2]
                    ],
                    [
                        t1[0],
                        t1[1],
                        e[2]
                    ],
                    [
                        e[0],
                        t1[1],
                        e[2]
                    ],
                    [
                        e[0],
                        e[1],
                        e[2]
                    ],
                    [
                        t1[0],
                        e[1],
                        e[2]
                    ]
                ];
            }
            intersects(t1) {
                return this.intersectsAabb(t1.bounds) ? du(t1, this.getCorners()) : 0;
            }
            intersectsFlat(t1) {
                return this.intersectsAabb(t1.bounds) ? du(t1, [
                    [
                        this.min[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.max[1],
                        0
                    ],
                    [
                        this.min[0],
                        this.max[1],
                        0
                    ]
                ]) : 0;
            }
            intersectsPrecise(t1, e) {
                return e || this.intersects(t1) ? mu(t1, this.getCorners()) : 0;
            }
            intersectsPreciseFlat(t1, e) {
                return e || this.intersectsFlat(t1) ? mu(t1, [
                    [
                        this.min[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.min[1],
                        0
                    ],
                    [
                        this.max[0],
                        this.max[1],
                        0
                    ],
                    [
                        this.min[0],
                        this.max[1],
                        0
                    ]
                ]) : 0;
            }
            intersectsAabb(t1) {
                for(let e = 0; e < 3; ++e)if (this.min[e] > t1.max[e] || t1.min[e] > this.max[e]) return !1;
                return !0;
            }
            intersectsAabbXY(t1) {
                return !(this.min[0] > t1.max[0] || t1.min[0] > this.max[0] || this.min[1] > t1.max[1] || t1.min[1] > this.max[1]);
            }
            encapsulate(t1) {
                for(let e = 0; e < 3; e++)this.min[e] = Math.min(this.min[e], t1.min[e]), this.max[e] = Math.max(this.max[e], t1.max[e]);
            }
            encapsulatePoint(t1) {
                for(let e = 0; e < 3; e++)this.min[e] = Math.min(this.min[e], t1[e]), this.max[e] = Math.max(this.max[e], t1[e]);
            }
            closestPoint(t1) {
                return [
                    Math.max(Math.min(this.max[0], t1[0]), this.min[0]),
                    Math.max(Math.min(this.max[1], t1[1]), this.min[1]),
                    Math.max(Math.min(this.max[2], t1[2]), this.min[2])
                ];
            }
        }
        function vu(t1) {
            return t1 * Yo / rl;
        }
        oa(xu, "Aabb");
        const bu = [
            new xu([
                Jo,
                Jo,
                Jo
            ], [
                Qo,
                Qo,
                Qo
            ]),
            new xu([
                Jo,
                Jo,
                Jo
            ], [
                0,
                0,
                Qo
            ]),
            new xu([
                0,
                Jo,
                Jo
            ], [
                Qo,
                0,
                Qo
            ]),
            new xu([
                Jo,
                0,
                Jo
            ], [
                0,
                Qo,
                Qo
            ]),
            new xu([
                0,
                0,
                Jo
            ], [
                Qo,
                Qo,
                Qo
            ])
        ];
        function _u(t1, e, r, n = !0) {
            const i = O.vec3.scale([], t1._camera.position, t1.worldSize), a = [
                e,
                r,
                1,
                1
            ];
            O.vec4.transformMat4(a, a, t1.pixelMatrixInverse), O.vec4.scale(a, a, 1 / a[3]);
            const s = O.vec3.sub([], a, i), o = O.vec3.normalize([], s), l = t1.globeMatrix, u = [
                l[12],
                l[13],
                l[14]
            ], c = O.vec3.sub([], u, i), h = O.vec3.length(c), p = O.vec3.normalize([], c), f = t1.worldSize / (2 * Math.PI), d = O.vec3.dot(p, o), m = Math.asin(f / h);
            if (m < Math.acos(d)) {
                if (!n) return null;
                const t1 = [], e = [];
                O.vec3.scale(t1, o, h / d), O.vec3.normalize(e, O.vec3.sub(e, t1, c)), O.vec3.normalize(o, O.vec3.add(o, c, O.vec3.scale(o, e, Math.tan(m) * h)));
            }
            const y = [];
            new hu(i, o).closestPointOnSphere(u, f, y);
            const g = O.vec3.normalize([], bt(l, 0)), x = O.vec3.normalize([], bt(l, 1)), v = O.vec3.normalize([], bt(l, 2)), b = O.vec3.dot(g, y), _ = O.vec3.dot(x, y), w = O.vec3.dot(v, y), M = Z(Math.asin(-_ / f));
            let A = Z(Math.atan2(b, w));
            A = t1.center.lng + function(t1, e) {
                const r = (e - t1 + 180) % 360 - 180;
                return r < -180 ? r + 360 : r;
            }(t1.center.lng, A);
            const S = ul(A), I = Q(cl(M), 0, 1);
            return new bl(S, I);
        }
        class wu {
            constructor(t1, e, r){
                this.a = O.vec3.sub([], t1, r), this.b = O.vec3.sub([], e, r), this.center = r;
                const n = O.vec3.normalize([], this.a), i = O.vec3.normalize([], this.b);
                this.angle = Math.acos(O.vec3.dot(n, i));
            }
        }
        function Mu(t1, e) {
            if (0 === t1.angle) return null;
            let r;
            return r = 0 === t1.a[e] ? 1 / t1.angle * .5 * Math.PI : 1 / t1.angle * Math.atan(t1.b[e] / t1.a[e] / Math.sin(t1.angle) - 1 / Math.tan(t1.angle)), r < 0 || r > 1 ? null : function(t1, e, r, n) {
                const i = Math.sin(r);
                return t1 * (Math.sin((1 - n) * r) / i) + e * (Math.sin(n * r) / i);
            }(t1.a[e], t1.b[e], t1.angle, Q(r, 0, 1)) + t1.center[e];
        }
        function Au(t1) {
            if (t1.z <= 1) return bu[t1.z + 2 * t1.y + t1.x];
            const e = Eu(zu(t1));
            return xu.fromPoints(e);
        }
        function Su(t1, e, r) {
            return O.vec3.scale(t1, t1, 1 - r), O.vec3.scaleAndAdd(t1, t1, e, r);
        }
        function Iu(t1, e, r) {
            for (const n of t1)O.vec3.transformMat4(n, n, e), O.vec3.scale(n, n, r);
        }
        function Pu(t1, e, r, n) {
            const i = e / t1.worldSize, a = t1.globeMatrix;
            if (r.z <= 1) {
                const t1 = Au(r).getCorners();
                return Iu(t1, a, i), xu.fromPoints(t1);
            }
            const s = zu(r, n), o = Eu(s, Yo + vu(t1._tileCoverLift));
            Iu(o, a, i);
            const l = Number.MAX_VALUE, u = [
                -l,
                -l,
                -l
            ], c = [
                l,
                l,
                l
            ];
            if (s.contains(t1.center)) {
                for (const t1 of o)O.vec3.min(c, c, t1), O.vec3.max(u, u, t1);
                u[2] = 0;
                const e = t1.point, r = [
                    e.x * i,
                    e.y * i,
                    0
                ];
                return O.vec3.min(c, c, r), O.vec3.max(u, u, r), new xu(c, u);
            }
            if (t1._tileCoverLift > 0) {
                for (const t1 of o)O.vec3.min(c, c, t1), O.vec3.max(u, u, t1);
                return new xu(c, u);
            }
            const h = [
                a[12] * i,
                a[13] * i,
                a[14] * i
            ], p = s.getCenter(), f = Q(t1.center.lat, -ml, ml), d = Q(p.lat, -ml, ml), m = ul(t1.center.lng), y = cl(f);
            let g = m - ul(p.lng);
            const x = y - cl(d);
            g > .5 ? g -= 1 : g < -.5 && (g += 1);
            let v = 0;
            if (Math.abs(g) > Math.abs(x)) v = g >= 0 ? 1 : 3;
            else {
                v = x >= 0 ? 0 : 2;
                const t1 = [
                    a[4] * i,
                    a[5] * i,
                    a[6] * i
                ], e = -Math.sin(X(x >= 0 ? s.getSouth() : s.getNorth())) * Yo;
                O.vec3.scaleAndAdd(h, h, t1, e);
            }
            const b = o[v], _ = o[(v + 1) % 4], w = new wu(b, _, h), M = [
                Mu(w, 0) || b[0],
                Mu(w, 1) || b[1],
                Mu(w, 2) || b[2]
            ], A = Fu(t1.zoom);
            if (A > 0) {
                const n = function({ x: t1, y: e, z: r }, n, i, a, s) {
                    const o = 1 / (1 << r);
                    let l = t1 * o, u = l + o, c = e * o, h = c + o, p = 0;
                    const f = (l + u) / 2 - a;
                    return f > .5 ? p = -1 : f < -.5 && (p = 1), l = ((l + p) * n - (a *= n)) * i + a, u = ((u + p) * n - a) * i + a, c = (c * n - (s *= n)) * i + s, h = (h * n - s) * i + s, [
                        [
                            l,
                            h,
                            0
                        ],
                        [
                            u,
                            h,
                            0
                        ],
                        [
                            u,
                            c,
                            0
                        ],
                        [
                            l,
                            c,
                            0
                        ]
                    ];
                }(r, e, t1._pixelsPerMercatorPixel, m, y);
                for(let t1 = 0; t1 < o.length; t1++)Su(o[t1], n[t1], A);
                const i = O.vec3.add([], n[v], n[(v + 1) % 4]);
                O.vec3.scale(i, i, .5), Su(M, i, A);
            }
            for (const t1 of o)O.vec3.min(c, c, t1), O.vec3.max(u, u, t1);
            return c[2] = Math.min(b[2], _[2]), O.vec3.min(c, c, M), O.vec3.max(u, u, M), new xu(c, u);
        }
        function zu({ x: t1, y: e, z: r }, n = !1) {
            const i = 1 / (1 << r), a = new il(pl(t1 * i), e === (1 << r) - 1 && n ? -90 : fl((e + 1) * i)), s = new il(pl((t1 + 1) * i), 0 === e && n ? 90 : fl(e * i));
            return new al(a, s);
        }
        function Eu(t1, e = Yo) {
            const r = X(t1.getNorth()), n = X(t1.getSouth()), i = Math.cos(r), a = Math.cos(n), s = Math.sin(r), o = Math.sin(n), l = t1.getWest(), u = t1.getEast();
            return [
                tl(a, o, l, e),
                tl(a, o, u, e),
                tl(i, s, u, e),
                tl(i, s, l, e)
            ];
        }
        function ku(t1, e, r, n) {
            const i = 1 << r.z, a = (t1 / Wr + r.x) / i;
            return el(fl((e / Wr + r.y) / i), pl(a), n);
        }
        function Tu({ min: t1, max: e }) {
            return Ho / Math.max(e[0] - t1[0], e[1] - t1[1], e[2] - t1[2]);
        }
        const Bu = new Float64Array(16);
        function Vu(t1) {
            const e = Tu(t1), r = O.mat4.fromScaling(Bu, [
                e,
                e,
                e
            ]);
            return O.mat4.translate(r, r, O.vec3.negate([], t1.min));
        }
        function Cu(t1) {
            const e = O.mat4.fromTranslation(Bu, t1.min), r = 1 / Tu(t1);
            return O.mat4.scale(e, e, [
                r,
                r,
                r
            ]);
        }
        function Du(t1) {
            const e = Wr / (2 * Math.PI);
            return t1 / (2 * Math.PI) / e;
        }
        function Lu(t1, e) {
            return Wr / (512 * Math.pow(2, t1)) * Tu(Au(e));
        }
        function Ru(t1, e, r, n, i) {
            const a = Du(r), s = [
                t1,
                e,
                -r / (2 * Math.PI)
            ], o = O.mat4.identity(new Float64Array(16));
            return O.mat4.translate(o, o, s), O.mat4.scale(o, o, [
                a,
                a,
                a
            ]), O.mat4.rotateX(o, o, X(-i)), O.mat4.rotateY(o, o, X(-n)), o;
        }
        function Fu(t1) {
            return tt(Xo, Zo, t1);
        }
        function Ou(t1, e) {
            const r = el(e.lat, e.lng), n = function(t1) {
                const e = el(t1._center.lat, t1._center.lng), r = O.vec3.fromValues(0, 1, 0);
                let n = O.vec3.cross([], r, e);
                const i = O.mat4.fromRotation([], -t1.angle, e);
                n = O.vec3.transformMat4(n, n, i), O.mat4.fromRotation(i, -t1._pitch, n);
                const a = O.vec3.normalize([], e);
                return O.vec3.scale(a, a, vu(t1.cameraToCenterDistance / t1.pixelsPerMeter)), O.vec3.transformMat4(a, a, i), O.vec3.add([], e, a);
            }(t1), i = O.vec3.subtract([], n, r);
            return O.vec3.angle(i, r);
        }
        function Nu(t1, e) {
            return Ou(t1, e) > Math.PI / 2 * 1.01;
        }
        const Uu = X(85), ju = Math.cos(Uu), qu = Math.sin(Uu), $u = O.mat4.create(), Gu = (t1)=>{
            const e = [];
            return "map" === t1.paint.get("circle-pitch-alignment") && e.push("PITCH_WITH_MAP"), "map" === t1.paint.get("circle-pitch-scale") && e.push("SCALE_WITH_MAP"), e;
        };
        function Yu(t1, e, r, n, i, a, s, o, l) {
            if (a && t1.queryGeometry.isAboveHorizon) return !1;
            a && (l *= t1.pixelToTileUnitsFactor);
            const u = t1.tileID.canonical, c = r.projection.upVectorScale(u, r.center.lat, r.worldSize).metersToTile;
            for (const h of e)for (const e of h){
                const h = e.add(o), p = i && r.elevation ? r.elevation.exaggeration() * i.getElevationAt(h.x, h.y, !0) : 0, f = r.projection.projectTilePoint(h.x, h.y, u);
                if (p > 0) {
                    const t1 = r.projection.upVector(u, h.x, h.y);
                    f.x += t1[0] * c * p, f.y += t1[1] * c * p, f.z += t1[2] * c * p;
                }
                const d = a ? h : Xu(f.x, f.y, f.z, n), m = a ? t1.tilespaceRays.map((t1)=>Wu(t1, p)) : t1.queryGeometry.screenGeometry, y = O.vec4.transformMat4([], [
                    f.x,
                    f.y,
                    f.z,
                    1
                ], n);
                if (!s && a ? l *= y[3] / r.cameraToCenterDistance : s && !a && (l *= r.cameraToCenterDistance / y[3]), a) {
                    const t1 = fl((e.y / Wr + u.y) / (1 << u.z));
                    l /= r.projection.pixelsPerMeter(t1, 1) / hl(1, t1);
                }
                if (Cl(m, d, l)) return !0;
            }
            return !1;
        }
        function Xu(t1, e, r, n) {
            const i = O.vec4.transformMat4([], [
                t1,
                e,
                r,
                1
            ], n);
            return new q(i[0] / i[3], i[1] / i[3]);
        }
        const Zu = O.vec3.fromValues(0, 0, 0), Hu = O.vec3.fromValues(0, 0, 1);
        function Wu(t1, e) {
            const r = O.vec3.create();
            return Zu[2] = e, t1.intersectsPlane(Zu, Hu, r), new q(r[0], r[1]);
        }
        class Ku extends Bl {
        }
        let Ju, Qu, tc, ec;
        function rc(t1, { width: e, height: r }, n, i) {
            if (i) {
                if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);
                else if (i.length !== e * r * n) throw new RangeError("mismatched image size");
            } else i = new Uint8Array(e * r * n);
            return t1.width = e, t1.height = r, t1.data = i, t1;
        }
        function nc(t1, e, r) {
            const { width: n, height: i } = e;
            n === t1.width && i === t1.height || (ic(t1, e, {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            }, {
                width: Math.min(t1.width, n),
                height: Math.min(t1.height, i)
            }, r, null), t1.width = n, t1.height = i, t1.data = e.data);
        }
        function ic(t1, e, r, n, i, a, s, o) {
            if (0 === i.width || 0 === i.height) return e;
            if (i.width > t1.width || i.height > t1.height || r.x > t1.width - i.width || r.y > t1.height - i.height) throw new RangeError("out of range source coordinates for image copy");
            if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError("out of range destination coordinates for image copy");
            const l = t1.data, u = e.data, c = 4 === a && o;
            for(let o = 0; o < i.height; o++){
                const h = ((r.y + o) * t1.width + r.x) * a, p = ((n.y + o) * e.width + n.x) * a;
                if (c) for(let t1 = 0; t1 < i.width; t1++){
                    const e = h + t1 * a + 3, r = p + t1 * a;
                    u[r + 0] = 255, u[r + 1] = 255, u[r + 2] = 255, u[r + 3] = l[e];
                }
                else if (s) for(let t1 = 0; t1 < i.width; t1++){
                    const e = h + t1 * a, r = p + t1 * a, n = l[e + 3], i = new Ie(l[e + 0] / 255 * n, l[e + 1] / 255 * n, l[e + 2] / 255 * n, n).toRenderColor(s).toArray();
                    u[r + 0] = i[0], u[r + 1] = i[1], u[r + 2] = i[2], u[r + 3] = i[3];
                }
                else for(let t1 = 0; t1 < i.width * a; t1++)u[p + t1] = l[h + t1];
            }
            return e;
        }
        oa(Ku, "HeatmapBucket", {
            omit: [
                "layers"
            ]
        });
        class ac {
            constructor(t1, e){
                rc(this, t1, 1, e);
            }
            resize(t1) {
                nc(this, new ac(t1), 1);
            }
            clone() {
                return new ac({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t1, e, r, n, i) {
                ic(t1, e, r, n, i, 1, null);
            }
        }
        class sc {
            constructor(t1, e){
                rc(this, t1, 4, e);
            }
            resize(t1) {
                nc(this, new sc(t1), 4);
            }
            replace(t1, e) {
                e ? this.data.set(t1) : this.data = t1 instanceof Uint8ClampedArray ? new Uint8Array(t1.buffer) : t1;
            }
            clone() {
                return new sc({
                    width: this.width,
                    height: this.height
                }, new Uint8Array(this.data));
            }
            static copy(t1, e, r, n, i, a, s) {
                ic(t1, e, r, n, i, 4, a, s);
            }
        }
        class oc {
            constructor(t1, e){
                this.width = t1.width, this.height = t1.height, this.data = e instanceof Uint8Array ? new Float32Array(e.buffer) : e;
            }
        }
        function lc(t1) {
            const e = {}, r = t1.resolution || 256, n = t1.clips ? t1.clips.length : 1, i = t1.image || new sc({
                width: r,
                height: n
            }), a = (r, n, a)=>{
                e[t1.evaluationKey] = a;
                const s = t1.expression.evaluate(e);
                s && (i.data[r + n + 0] = Math.floor(255 * s.r / s.a), i.data[r + n + 1] = Math.floor(255 * s.g / s.a), i.data[r + n + 2] = Math.floor(255 * s.b / s.a), i.data[r + n + 3] = Math.floor(255 * s.a));
            };
            if (t1.clips) for(let e = 0, i = 0; e < n; ++e, i += 4 * r)for(let n = 0, s = 0; n < r; n++, s += 4){
                const o = n / (r - 1), { start: l, end: u } = t1.clips[e];
                a(i, s, l * (1 - o) + u * o);
            }
            else for(let t1 = 0, e = 0; t1 < r; t1++, e += 4)a(0, e, t1 / (r - 1));
            return i;
        }
        oa(ac, "AlphaImage"), oa(sc, "RGBAImage");
        const uc = ys([
            {
                name: "a_pos",
                components: 2,
                type: "Int16"
            }
        ], 4), { members: cc } = uc;
        function hc(t1, e, r = 2) {
            const n = e && e.length, i = n ? e[0] * r : t1.length;
            let a = pc(t1, 0, i, r, !0);
            const s = [];
            if (!a || a.next === a.prev) return s;
            let o, l, u;
            if (n && (a = function(t1, e, r, n) {
                const i = [];
                for(let r = 0, a = e.length; r < a; r++){
                    const s = pc(t1, e[r] * n, r < a - 1 ? e[r + 1] * n : t1.length, n, !1);
                    s === s.next && (s.steiner = !0), i.push(Mc(s));
                }
                i.sort(vc);
                for(let t1 = 0; t1 < i.length; t1++)r = bc(i[t1], r);
                return r;
            }(t1, e, a, r)), t1.length > 80 * r) {
                o = 1 / 0, l = 1 / 0;
                let e = -1 / 0, n = -1 / 0;
                for(let a = r; a < i; a += r){
                    const r = t1[a], i = t1[a + 1];
                    r < o && (o = r), i < l && (l = i), r > e && (e = r), i > n && (n = i);
                }
                u = Math.max(e - o, n - l), u = 0 !== u ? 32767 / u : 0;
            }
            return dc(a, s, r, o, l, u, 0), s;
        }
        function pc(t1, e, r, n, i) {
            let a;
            if (i === function(t1, e, r, n) {
                let i = 0;
                for(let a = e, s = r - n; a < r; a += n)i += (t1[s] - t1[a]) * (t1[a + 1] + t1[s + 1]), s = a;
                return i;
            }(t1, e, r, n) > 0) for(let i = e; i < r; i += n)a = Vc(i / n | 0, t1[i], t1[i + 1], a);
            else for(let i = r - n; i >= e; i -= n)a = Vc(i / n | 0, t1[i], t1[i + 1], a);
            return a && Pc(a, a.next) && (Cc(a), a = a.next), a;
        }
        function fc(t1, e) {
            if (!t1) return t1;
            e || (e = t1);
            let r, n = t1;
            do {
                if (r = !1, n.steiner || !Pc(n, n.next) && 0 !== Ic(n.prev, n, n.next)) n = n.next;
                else {
                    if (Cc(n), n = e = n.prev, n === n.next) break;
                    r = !0;
                }
            }while (r || n !== e)
            return e;
        }
        function dc(t1, e, r, n, i, a, s) {
            if (!t1) return;
            !s && a && function(t1, e, r, n) {
                let i = t1;
                do {
                    0 === i.z && (i.z = wc(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
                }while (i !== t1)
                i.prevZ.nextZ = null, i.prevZ = null, function(t1) {
                    let e, r = 1;
                    do {
                        let n, i = t1;
                        t1 = null;
                        let a = null;
                        for(e = 0; i;){
                            e++;
                            let s = i, o = 0;
                            for(let t1 = 0; t1 < r && (o++, s = s.nextZ, s); t1++);
                            let l = r;
                            for(; o > 0 || l > 0 && s;)0 !== o && (0 === l || !s || i.z <= s.z) ? (n = i, i = i.nextZ, o--) : (n = s, s = s.nextZ, l--), a ? a.nextZ = n : t1 = n, n.prevZ = a, a = n;
                            i = s;
                        }
                        a.nextZ = null, r *= 2;
                    }while (e > 1)
                }(i);
            }(t1, n, i, a);
            let o = t1;
            for(; t1.prev !== t1.next;){
                const l = t1.prev, u = t1.next;
                if (a ? yc(t1, n, i, a) : mc(t1)) e.push(l.i, t1.i, u.i), Cc(t1), t1 = u.next, o = u.next;
                else if ((t1 = u) === o) {
                    s ? 1 === s ? dc(t1 = gc(fc(t1), e), e, r, n, i, a, 2) : 2 === s && xc(t1, e, r, n, i, a) : dc(fc(t1), e, r, n, i, a, 1);
                    break;
                }
            }
        }
        function mc(t1) {
            const e = t1.prev, r = t1, n = t1.next;
            if (Ic(e, r, n) >= 0) return !1;
            const i = e.x, a = r.x, s = n.x, o = e.y, l = r.y, u = n.y, c = i < a ? i < s ? i : s : a < s ? a : s, h = o < l ? o < u ? o : u : l < u ? l : u, p = i > a ? i > s ? i : s : a > s ? a : s, f = o > l ? o > u ? o : u : l > u ? l : u;
            let d = n.next;
            for(; d !== e;){
                if (d.x >= c && d.x <= p && d.y >= h && d.y <= f && Ac(i, o, a, l, s, u, d.x, d.y) && Ic(d.prev, d, d.next) >= 0) return !1;
                d = d.next;
            }
            return !0;
        }
        function yc(t1, e, r, n) {
            const i = t1.prev, a = t1, s = t1.next;
            if (Ic(i, a, s) >= 0) return !1;
            const o = i.x, l = a.x, u = s.x, c = i.y, h = a.y, p = s.y, f = o < l ? o < u ? o : u : l < u ? l : u, d = c < h ? c < p ? c : p : h < p ? h : p, m = o > l ? o > u ? o : u : l > u ? l : u, y = c > h ? c > p ? c : p : h > p ? h : p, g = wc(f, d, e, r, n), x = wc(m, y, e, r, n);
            let v = t1.prevZ, b = t1.nextZ;
            for(; v && v.z >= g && b && b.z <= x;){
                if (v.x >= f && v.x <= m && v.y >= d && v.y <= y && v !== i && v !== s && Ac(o, c, l, h, u, p, v.x, v.y) && Ic(v.prev, v, v.next) >= 0) return !1;
                if (v = v.prevZ, b.x >= f && b.x <= m && b.y >= d && b.y <= y && b !== i && b !== s && Ac(o, c, l, h, u, p, b.x, b.y) && Ic(b.prev, b, b.next) >= 0) return !1;
                b = b.nextZ;
            }
            for(; v && v.z >= g;){
                if (v.x >= f && v.x <= m && v.y >= d && v.y <= y && v !== i && v !== s && Ac(o, c, l, h, u, p, v.x, v.y) && Ic(v.prev, v, v.next) >= 0) return !1;
                v = v.prevZ;
            }
            for(; b && b.z <= x;){
                if (b.x >= f && b.x <= m && b.y >= d && b.y <= y && b !== i && b !== s && Ac(o, c, l, h, u, p, b.x, b.y) && Ic(b.prev, b, b.next) >= 0) return !1;
                b = b.nextZ;
            }
            return !0;
        }
        function gc(t1, e) {
            let r = t1;
            do {
                const n = r.prev, i = r.next.next;
                !Pc(n, i) && zc(n, r, r.next, i) && Tc(n, i) && Tc(i, n) && (e.push(n.i, r.i, i.i), Cc(r), Cc(r.next), r = t1 = i), r = r.next;
            }while (r !== t1)
            return fc(r);
        }
        function xc(t1, e, r, n, i, a) {
            let s = t1;
            do {
                let t1 = s.next.next;
                for(; t1 !== s.prev;){
                    if (s.i !== t1.i && Sc(s, t1)) {
                        let o = Bc(s, t1);
                        return s = fc(s, s.next), o = fc(o, o.next), dc(s, e, r, n, i, a, 0), void dc(o, e, r, n, i, a, 0);
                    }
                    t1 = t1.next;
                }
                s = s.next;
            }while (s !== t1)
        }
        function vc(t1, e) {
            return t1.x - e.x;
        }
        function bc(t1, e) {
            const r = function(t1, e) {
                let r = e;
                const n = t1.x, i = t1.y;
                let a, s = -1 / 0;
                do {
                    if (i <= r.y && i >= r.next.y && r.next.y !== r.y) {
                        const t1 = r.x + (i - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                        if (t1 <= n && t1 > s && (s = t1, a = r.x < r.next.x ? r : r.next, t1 === n)) return a;
                    }
                    r = r.next;
                }while (r !== e)
                if (!a) return null;
                const o = a, l = a.x, u = a.y;
                let c = 1 / 0;
                r = a;
                do {
                    if (n >= r.x && r.x >= l && n !== r.x && Ac(i < u ? n : s, i, l, u, i < u ? s : n, i, r.x, r.y)) {
                        const e = Math.abs(i - r.y) / (n - r.x);
                        Tc(r, t1) && (e < c || e === c && (r.x > a.x || r.x === a.x && _c(a, r))) && (a = r, c = e);
                    }
                    r = r.next;
                }while (r !== o)
                return a;
            }(t1, e);
            if (!r) return e;
            const n = Bc(r, t1);
            return fc(n, n.next), fc(r, r.next);
        }
        function _c(t1, e) {
            return Ic(t1.prev, t1, e.prev) < 0 && Ic(e.next, t1, t1.next) < 0;
        }
        function wc(t1, e, r, n, i) {
            return (t1 = 1431655765 & ((t1 = 858993459 & ((t1 = 252645135 & ((t1 = 16711935 & ((t1 = (t1 - r) * i | 0) | t1 << 8)) | t1 << 4)) | t1 << 2)) | t1 << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
        }
        function Mc(t1) {
            let e = t1, r = t1;
            do {
                (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;
            }while (e !== t1)
            return r;
        }
        function Ac(t1, e, r, n, i, a, s, o) {
            return (i - s) * (e - o) >= (t1 - s) * (a - o) && (t1 - s) * (n - o) >= (r - s) * (e - o) && (r - s) * (a - o) >= (i - s) * (n - o);
        }
        function Sc(t1, e) {
            return t1.next.i !== e.i && t1.prev.i !== e.i && !function(t1, e) {
                let r = t1;
                do {
                    if (r.i !== t1.i && r.next.i !== t1.i && r.i !== e.i && r.next.i !== e.i && zc(r, r.next, t1, e)) return !0;
                    r = r.next;
                }while (r !== t1)
                return !1;
            }(t1, e) && (Tc(t1, e) && Tc(e, t1) && function(t1, e) {
                let r = t1, n = !1;
                const i = (t1.x + e.x) / 2, a = (t1.y + e.y) / 2;
                do {
                    r.y > a != r.next.y > a && r.next.y !== r.y && i < (r.next.x - r.x) * (a - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;
                }while (r !== t1)
                return n;
            }(t1, e) && (Ic(t1.prev, t1, e.prev) || Ic(t1, e.prev, e)) || Pc(t1, e) && Ic(t1.prev, t1, t1.next) > 0 && Ic(e.prev, e, e.next) > 0);
        }
        function Ic(t1, e, r) {
            return (e.y - t1.y) * (r.x - e.x) - (e.x - t1.x) * (r.y - e.y);
        }
        function Pc(t1, e) {
            return t1.x === e.x && t1.y === e.y;
        }
        function zc(t1, e, r, n) {
            const i = kc(Ic(t1, e, r)), a = kc(Ic(t1, e, n)), s = kc(Ic(r, n, t1)), o = kc(Ic(r, n, e));
            return i !== a && s !== o || !(0 !== i || !Ec(t1, r, e)) || !(0 !== a || !Ec(t1, n, e)) || !(0 !== s || !Ec(r, t1, n)) || !(0 !== o || !Ec(r, e, n));
        }
        function Ec(t1, e, r) {
            return e.x <= Math.max(t1.x, r.x) && e.x >= Math.min(t1.x, r.x) && e.y <= Math.max(t1.y, r.y) && e.y >= Math.min(t1.y, r.y);
        }
        function kc(t1) {
            return t1 > 0 ? 1 : t1 < 0 ? -1 : 0;
        }
        function Tc(t1, e) {
            return Ic(t1.prev, t1, t1.next) < 0 ? Ic(t1, e, t1.next) >= 0 && Ic(t1, t1.prev, e) >= 0 : Ic(t1, e, t1.prev) < 0 || Ic(t1, t1.next, e) < 0;
        }
        function Bc(t1, e) {
            const r = Dc(t1.i, t1.x, t1.y), n = Dc(e.i, e.x, e.y), i = t1.next, a = e.prev;
            return t1.next = e, e.prev = t1, r.next = i, i.prev = r, n.next = r, r.prev = n, a.next = n, n.prev = a, n;
        }
        function Vc(t1, e, r, n) {
            const i = Dc(t1, e, r);
            return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
        }
        function Cc(t1) {
            t1.next.prev = t1.prev, t1.prev.next = t1.next, t1.prevZ && (t1.prevZ.nextZ = t1.nextZ), t1.nextZ && (t1.nextZ.prevZ = t1.prevZ);
        }
        function Dc(t1, e, r) {
            return {
                i: t1,
                x: e,
                y: r,
                prev: null,
                next: null,
                z: 0,
                prevZ: null,
                nextZ: null,
                steiner: !1
            };
        }
        function Lc(t1, e) {
            const r = t1.length;
            if (r <= 1) return [
                t1
            ];
            const n = [];
            let i, a;
            for(let e = 0; e < r; e++){
                const r = mt(t1[e]);
                0 !== r && (t1[e].area = Math.abs(r), void 0 === a && (a = r < 0), a === r < 0 ? (i && n.push(i), i = [
                    t1[e]
                ]) : i.push(t1[e]));
            }
            if (i && n.push(i), e > 1) for(let t1 = 0; t1 < n.length; t1++)n[t1].length <= e || (vr(n[t1], e, 1, n[t1].length - 1, Rc), n[t1] = n[t1].slice(0, e));
            return n;
        }
        function Rc(t1, e) {
            return e.area - t1.area;
        }
        function Fc(t1, e) {
            if (!t1) return null;
            const r = "string" == typeof t1 ? t1 : t1.getPrimary().id;
            e[r] || (e[r] = []);
            const n = tr.from(t1).getPrimary();
            return e[r].push(n), n.serialize();
        }
        function Oc(t1, e, r) {
            const n = r.patternDependencies;
            let i = !1;
            for (const r of e){
                const e = r.paint.get(`${t1}-pattern`);
                e.isConstant() || (i = !0), Fc(e.constantOr(null), n) && (i = !0);
            }
            return i;
        }
        function Nc(t1, e, r, n, i) {
            const a = i.patternDependencies;
            for (const s of e){
                const e = s.paint.get(`${t1}-pattern`).value;
                if ("constant" !== e.kind) {
                    let t1 = e.evaluate({
                        zoom: n
                    }, r, {}, i.availableImages);
                    t1 = t1 && t1.name ? t1.name : t1;
                    const o = Fc(t1, a);
                    o && (r.patterns[s.id] = o);
                }
            }
            return r;
        }
        class Uc {
            constructor(t1){
                this.zoom = t1.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new xs, this.indexArray = new Ls, this.indexArray2 = new Ts, this.programConfigurations = new No(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }), this.segments = new po, this.segments2 = new po, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.projection = t1.projection;
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                this.hasPattern = Oc("fill", this.layers, e);
                const i = this.layers[0].layout.get("fill-sort-key"), a = [];
                for (const { feature: s, id: o, index: l, sourceLayerIndex: u } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, c = El(s, t1);
                    if (!this.layers[0]._featureFilter.filter(new Va(this.zoom), c, r)) continue;
                    const h = i ? i.evaluate(c, {}, r, e.availableImages) : void 0, p = {
                        id: o,
                        properties: s.properties,
                        type: s.type,
                        sourceLayerIndex: u,
                        index: l,
                        geometry: t1 ? c.geometry : zl(s, r, n),
                        patterns: {},
                        sortKey: h
                    };
                    a.push(p);
                }
                i && a.sort((t1, e)=>t1.sortKey - e.sortKey);
                for (const n of a){
                    const { geometry: i, index: a, sourceLayerIndex: s } = n;
                    if (this.hasPattern) {
                        const t1 = Nc("fill", this.layers, n, this.zoom, e);
                        this.patternFeatures.push(t1);
                    } else this.addFeature(n, i, a, r, {}, e.availableImages, e.brightness);
                    e.featureIndex.insert(t1[a].feature, i, a, s, this.index);
                }
            }
            update(t1, e, r, n, i, a, s) {
                this.programConfigurations.updatePaintArrays(t1, e, i, r, n, a, s);
            }
            addFeatures(t1, e, r, n, i, a) {
                for (const t1 of this.patternFeatures)this.addFeature(t1, t1.geometry, t1.index, e, r, n, a);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, cc), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.indexBuffer2 = t1.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t1, e, r, n, i, a = [], s) {
                for (const t1 of Lc(e, 500)){
                    let e = 0;
                    for (const r of t1)e += r.length;
                    const r = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray), n = r.vertexLength, i = [], a = [];
                    for (const e of t1){
                        if (0 === e.length) continue;
                        e !== t1[0] && a.push(i.length / 2);
                        const r = this.segments2.prepareSegment(e.length, this.layoutVertexArray, this.indexArray2), n = r.vertexLength;
                        this.layoutVertexArray.emplaceBack(e[0].x, e[0].y), this.indexArray2.emplaceBack(n + e.length - 1, n), i.push(e[0].x), i.push(e[0].y);
                        for(let t1 = 1; t1 < e.length; t1++)this.layoutVertexArray.emplaceBack(e[t1].x, e[t1].y), this.indexArray2.emplaceBack(n + t1 - 1, n + t1), i.push(e[t1].x), i.push(e[t1].y);
                        r.vertexLength += e.length, r.primitiveLength += e.length;
                    }
                    const s = hc(i, a);
                    for(let t1 = 0; t1 < s.length; t1 += 3)this.indexArray.emplaceBack(n + s[t1], n + s[t1 + 1], n + s[t1 + 2]);
                    r.vertexLength += e, r.primitiveLength += s.length / 3;
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, a, n, s);
            }
        }
        let jc, qc, $c, Gc;
        oa(Uc, "FillBucket", {
            omit: [
                "layers",
                "patternFeatures"
            ]
        });
        class Yc {
            constructor(t1, e, r, n){
                if (this.triangleCount = e.length / 3, this.min = new q(0, 0), this.max = new q(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t1.length) return;
                const [i, a] = [
                    t1[0].clone(),
                    t1[0].clone()
                ];
                for(let e = 1; e < t1.length; ++e){
                    const r = t1[e];
                    i.x = Math.min(i.x, r.x), i.y = Math.min(i.y, r.y), a.x = Math.max(a.x, r.x), a.y = Math.max(a.y, r.y);
                }
                if (n) {
                    const t1 = Math.ceil(Math.max(a.x - i.x, a.y - i.y) / n);
                    r = Math.max(r, t1);
                }
                if (0 === r) return;
                this.min = i, this.max = a;
                const s = this.max.sub(this.min);
                s.x = Math.max(s.x, 1), s.y = Math.max(s.y, 1);
                const o = Math.max(s.x, s.y) / r;
                this.cellsX = Math.max(1, Math.ceil(s.x / o)), this.cellsY = Math.max(1, Math.ceil(s.y / o)), this.xScale = 1 / o, this.yScale = 1 / o;
                const l = [];
                for(let r = 0; r < this.triangleCount; r++){
                    const n = t1[e[3 * r + 0]].sub(this.min), i = t1[e[3 * r + 1]].sub(this.min), a = t1[e[3 * r + 2]].sub(this.min), s = Xc(Math.floor(Math.min(n.x, i.x, a.x)), this.xScale, this.cellsX), u = Xc(Math.floor(Math.max(n.x, i.x, a.x)), this.xScale, this.cellsX), c = Xc(Math.floor(Math.min(n.y, i.y, a.y)), this.yScale, this.cellsY), h = Xc(Math.floor(Math.max(n.y, i.y, a.y)), this.yScale, this.cellsY), p = new q(0, 0), f = new q(0, 0), d = new q(0, 0), m = new q(0, 0);
                    for(let t1 = c; t1 <= h; ++t1){
                        p.y = f.y = t1 * o, d.y = m.y = (t1 + 1) * o;
                        for(let e = s; e <= u; ++e)p.x = d.x = e * o, f.x = m.x = (e + 1) * o, (Yl(n, i, a, p, f, m) || Yl(n, i, a, p, m, d)) && l.push({
                            cellIdx: t1 * this.cellsX + e,
                            triIdx: r
                        });
                    }
                }
                if (0 === l.length) return;
                l.sort((t1, e)=>t1.cellIdx - e.cellIdx || t1.triIdx - e.triIdx);
                let u = 0;
                for(; u < l.length;){
                    const t1 = l[u].cellIdx, e = {
                        start: this.payload.length,
                        len: 0
                    };
                    for(; u < l.length && l[u].cellIdx === t1;)++e.len, this.payload.push(l[u++].triIdx);
                    this.cells[t1] = e;
                }
            }
            _lazyInitLookup() {
                this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);
            }
            queryPoint(t1, e) {
                if (0 === this.triangleCount || 0 === this.cells.length) return;
                if (t1.x > this.max.x || this.min.x > t1.x || t1.y > this.max.y || this.min.y > t1.y) return;
                const r = Xc(t1.x - this.min.x, this.xScale, this.cellsX), n = Xc(t1.y - this.min.y, this.yScale, this.cellsY), i = this.cells[n * this.cellsX + r];
                if (i) {
                    this._lazyInitLookup();
                    for(let t1 = 0; t1 < i.len; t1++){
                        const r = this.payload[i.start + t1], n = Math.floor(r / 8), a = 1 << r % 8;
                        if (!(this.lookup[n] & a) && (this.lookup[n] |= a, e.push(r), e.length === this.triangleCount)) return;
                    }
                }
            }
            query(t1, e, r) {
                if (0 === this.triangleCount || 0 === this.cells.length) return;
                if (t1.x > this.max.x || this.min.x > e.x) return;
                if (t1.y > this.max.y || this.min.y > e.y) return;
                this._lazyInitLookup();
                const n = Xc(t1.x - this.min.x, this.xScale, this.cellsX), i = Xc(e.x - this.min.x, this.xScale, this.cellsX), a = Xc(t1.y - this.min.y, this.yScale, this.cellsY), s = Xc(e.y - this.min.y, this.yScale, this.cellsY);
                for(let t1 = a; t1 <= s; t1++)for(let e = n; e <= i; e++){
                    const n = this.cells[t1 * this.cellsX + e];
                    if (n) for(let t1 = 0; t1 < n.len; t1++){
                        const e = this.payload[n.start + t1], i = Math.floor(e / 8), a = 1 << e % 8;
                        if (!(this.lookup[i] & a) && (this.lookup[i] |= a, r.push(e), r.length === this.triangleCount)) return;
                    }
                }
            }
        }
        function Xc(t1, e, r) {
            return Math.max(0, Math.min(r - 1, Math.floor(t1 * e)));
        }
        oa(Yc, "TriangleGridIndex");
        class Zc {
            constructor(t1){
                this.zoom = t1.zoom, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.footprints = [];
            }
            updateFootprints(t1, e) {
                for (const r of this.footprints)e.push({
                    footprint: r,
                    id: t1
                });
            }
            populate(t1, e, r, n) {
                const i = [];
                for (const { feature: e, id: a, index: s, sourceLayerIndex: o } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, l = El(e, t1);
                    if (!this.layers[0]._featureFilter.filter(new Va(this.zoom), l, r)) continue;
                    const u = {
                        id: a,
                        properties: e.properties,
                        type: e.type,
                        sourceLayerIndex: o,
                        index: s,
                        geometry: t1 ? l.geometry : zl(e, r, n),
                        patterns: {}
                    };
                    i.push(u);
                }
                for (const n of i){
                    const { geometry: i, index: a, sourceLayerIndex: s } = n;
                    this.addFeature(n, i, a, r, {}, e.availableImages, e.brightness), e.featureIndex.insert(t1[a].feature, i, a, s, this.index);
                }
            }
            isEmpty() {
                return 0 === this.footprints.length;
            }
            uploadPending() {
                return !1;
            }
            upload(t1) {}
            update(t1, e, r, n, i, a, s) {}
            destroy() {}
            addFeature(t1, e, r, n, i, a = [], s) {
                for (const t1 of Lc(e, 2)){
                    const e = [], r = [], n = [], i = new q(1 / 0, 1 / 0), a = new q(-1 / 0, -1 / 0);
                    for (const s of t1)if (0 !== s.length) {
                        s !== t1[0] && n.push(r.length / 2);
                        for(let t1 = 0; t1 < s.length; t1++)r.push(s[t1].x), r.push(s[t1].y), e.push(s[t1]), i.x = Math.min(i.x, s[t1].x), i.y = Math.min(i.y, s[t1].y), a.x = Math.max(a.x, s[t1].x), a.y = Math.max(a.y, s[t1].y);
                    }
                    const s = hc(r, n), o = new Yc(e, s, 8, 256);
                    this.footprints.push({
                        vertices: e,
                        indices: s,
                        grid: o,
                        min: i,
                        max: a
                    });
                }
            }
        }
        oa(Zc, "ClipBucket", {
            omit: [
                "layers"
            ]
        });
        const Hc = ys([
            {
                name: "a_pos_normal_ed",
                components: 4,
                type: "Int16"
            }
        ]), Wc = ys([
            {
                name: "a_pos_end",
                components: 4,
                type: "Int16"
            },
            {
                name: "a_angular_offset_factor",
                components: 1,
                type: "Int16"
            }
        ]), Kc = ys([
            {
                name: "a_centroid_pos",
                components: 2,
                type: "Uint16"
            }
        ]), Jc = ys([
            {
                name: "a_join_normal_inside",
                components: 3,
                type: "Int16"
            }
        ]), Qc = ys([
            {
                name: "a_hidden_by_landmark",
                components: 1,
                type: "Uint8"
            }
        ]), th = ys([
            {
                name: "a_pos_3",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_pos_normal_3",
                components: 3,
                type: "Int16"
            }
        ]), { members: eh } = Hc;
        var rh, nh, ih, ah, sh, oh, lh, uh = {};
        function ch() {
            if (nh) return rh;
            nh = 1;
            var t1 = j();
            function e(t1, e, n, i, a) {
                this.properties = {}, this.extent = n, this.type = 0, this._pbf = t1, this._geometry = -1, this._keys = i, this._values = a, t1.readFields(r, this, e);
            }
            function r(t1, e, r) {
                1 == t1 ? e.id = r.readVarint() : 2 == t1 ? function(t1, e) {
                    for(var r = t1.readVarint() + t1.pos; t1.pos < r;){
                        var n = e._keys[t1.readVarint()], i = e._values[t1.readVarint()];
                        e.properties[n] = i;
                    }
                }(r, e) : 3 == t1 ? e.type = r.readVarint() : 4 == t1 && (e._geometry = r.pos);
            }
            function n(t1) {
                for(var e, r, n = 0, i = 0, a = t1.length, s = a - 1; i < a; s = i++)n += ((r = t1[s]).x - (e = t1[i]).x) * (e.y + r.y);
                return n;
            }
            return rh = e, e.types = [
                "Unknown",
                "Point",
                "LineString",
                "Polygon"
            ], e.prototype.loadGeometry = function() {
                var e = this._pbf;
                e.pos = this._geometry;
                for(var r, n = e.readVarint() + e.pos, i = 1, a = 0, s = 0, o = 0, l = []; e.pos < n;){
                    if (a <= 0) {
                        var u = e.readVarint();
                        i = 7 & u, a = u >> 3;
                    }
                    if (a--, 1 === i || 2 === i) s += e.readSVarint(), o += e.readSVarint(), 1 === i && (r && l.push(r), r = []), r.push(new t1(s, o));
                    else {
                        if (7 !== i) throw new Error("unknown command " + i);
                        r && r.push(r[0].clone());
                    }
                }
                return r && l.push(r), l;
            }, e.prototype.bbox = function() {
                var t1 = this._pbf;
                t1.pos = this._geometry;
                for(var e = t1.readVarint() + t1.pos, r = 1, n = 0, i = 0, a = 0, s = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t1.pos < e;){
                    if (n <= 0) {
                        var c = t1.readVarint();
                        r = 7 & c, n = c >> 3;
                    }
                    if (n--, 1 === r || 2 === r) (i += t1.readSVarint()) < s && (s = i), i > o && (o = i), (a += t1.readSVarint()) < l && (l = a), a > u && (u = a);
                    else if (7 !== r) throw new Error("unknown command " + r);
                }
                return [
                    s,
                    l,
                    o,
                    u
                ];
            }, e.prototype.toGeoJSON = function(t1, r, i) {
                var a, s, o = this.extent * Math.pow(2, i), l = this.extent * t1, u = this.extent * r, c = this.loadGeometry(), h = e.types[this.type];
                function p(t1) {
                    for(var e = 0; e < t1.length; e++){
                        var r = t1[e];
                        t1[e] = [
                            360 * (r.x + l) / o - 180,
                            360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + u) / o) * Math.PI / 180)) - 90
                        ];
                    }
                }
                switch(this.type){
                    case 1:
                        var f = [];
                        for(a = 0; a < c.length; a++)f[a] = c[a][0];
                        p(c = f);
                        break;
                    case 2:
                        for(a = 0; a < c.length; a++)p(c[a]);
                        break;
                    case 3:
                        for(c = function(t1) {
                            var e = t1.length;
                            if (e <= 1) return [
                                t1
                            ];
                            for(var r, i, a = [], s = 0; s < e; s++){
                                var o = n(t1[s]);
                                0 !== o && (void 0 === i && (i = o < 0), i === o < 0 ? (r && a.push(r), r = [
                                    t1[s]
                                ]) : r.push(t1[s]));
                            }
                            return r && a.push(r), a;
                        }(c), a = 0; a < c.length; a++)for(s = 0; s < c[a].length; s++)p(c[a][s]);
                }
                1 === c.length ? c = c[0] : h = "Multi" + h;
                var d = {
                    type: "Feature",
                    geometry: {
                        type: h,
                        coordinates: c
                    },
                    properties: this.properties
                };
                return "id" in this && (d.id = this.id), d;
            }, rh;
        }
        function hh() {
            if (ah) return ih;
            ah = 1;
            var t1 = ch();
            function e(t1, e) {
                this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t1, this._keys = [], this._values = [], this._features = [], t1.readFields(r, this, e), this.length = this._features.length;
            }
            function r(t1, e, r) {
                15 === t1 ? e.version = r.readVarint() : 1 === t1 ? e.name = r.readString() : 5 === t1 ? e.extent = r.readVarint() : 2 === t1 ? e._features.push(r.pos) : 3 === t1 ? e._keys.push(r.readString()) : 4 === t1 && e._values.push(function(t1) {
                    for(var e = null, r = t1.readVarint() + t1.pos; t1.pos < r;){
                        var n = t1.readVarint() >> 3;
                        e = 1 === n ? t1.readString() : 2 === n ? t1.readFloat() : 3 === n ? t1.readDouble() : 4 === n ? t1.readVarint64() : 5 === n ? t1.readVarint() : 6 === n ? t1.readSVarint() : 7 === n ? t1.readBoolean() : null;
                    }
                    return e;
                }(r));
            }
            return ih = e, e.prototype.feature = function(e) {
                if (e < 0 || e >= this._features.length) throw new Error("feature index out of bounds");
                this._pbf.pos = this._features[e];
                var r = this._pbf.readVarint() + this._pbf.pos;
                return new t1(this._pbf, r, this.extent, this._keys, this._values);
            }, ih;
        }
        function ph() {
            return lh || (lh = 1, uh.VectorTile = function() {
                if (oh) return sh;
                oh = 1;
                var t1 = hh();
                function e(e, r, n) {
                    if (3 === e) {
                        var i = new t1(n, n.readVarint() + n.pos);
                        i.length && (r[i.name] = i);
                    }
                }
                return sh = function(t1, r) {
                    this.layers = t1.readFields(e, {}, r);
                }, sh;
            }(), uh.VectorTileFeature = ch(), uh.VectorTileLayer = hh()), uh;
        }
        var fh = ph();
        class dh extends q {
            constructor(t1, e, r){
                super(t1, e), this.z = r;
            }
        }
        class mh extends dh {
            constructor(t1, e, r, n){
                super(t1, e, r), this.w = n;
            }
        }
        function yh(t1, e, r, n) {
            const i = [], a = 0 === n ? (t1, e, r, n, i, a)=>{
                t1.push(new q(a, r + (a - e) / (n - e) * (i - r)));
            } : (t1, e, r, n, i, a)=>{
                t1.push(new q(e + (a - r) / (i - r) * (n - e), a));
            };
            for (const s of t1){
                const t1 = [];
                for (const i of s){
                    if (i.length <= 2) continue;
                    const s = [];
                    for(let t1 = 0; t1 < i.length - 1; t1++){
                        const o = i[t1].x, l = i[t1].y, u = i[t1 + 1].x, c = i[t1 + 1].y, h = 0 === n ? o : l, p = 0 === n ? u : c;
                        h < e ? p > e && a(s, o, l, u, c, e) : h > r ? p < r && a(s, o, l, u, c, r) : s.push(i[t1]), p < e && h >= e && a(s, o, l, u, c, e), p > r && h <= r && a(s, o, l, u, c, r);
                    }
                    let o = i[i.length - 1];
                    const l = 0 === n ? o.x : o.y;
                    l >= e && l <= r && s.push(o), s.length && (o = s[s.length - 1], s[0].x === o.x && s[0].y === o.y || s.push(s[0]), t1.push(s));
                }
                t1.length && i.push(t1);
            }
            return i;
        }
        function gh(t1, e, r, n) {
            const i = "x" === r ? "y" : "x", a = (n - t1[r]) / (e[r] - t1[r]);
            t1[i] = t1[i] + (e[i] - t1[i]) * a, t1[r] = n, t1.hasOwnProperty("z") && (t1.z = ze(t1.z, e.z, a)), t1.hasOwnProperty("w") && (t1.w = ze(t1.w, e.w, a));
        }
        function xh(t1, e, r, n) {
            const i = r, a = n;
            for (const r of [
                "x",
                "y"
            ]){
                let n = t1, s = e;
                n[r] >= s[r] && (n = e, s = t1), n[r] < i && s[r] > i && gh(n, s, r, i), n[r] < a && s[r] > a && gh(s, n, r, a);
            }
        }
        const vh = Number.MAX_SAFE_INTEGER;
        function bh(t1, e, r, n) {
            return t1.order < e || t1.order === vh || !(t1.clipMask & r) || function(t1, e) {
                return 0 !== e.length && void 0 === e.find((e)=>e === t1);
            }(n, t1.clipScope);
        }
        function _h(t1, e) {
            return t1.x - e.x || t1.y - e.y;
        }
        function wh(t1, e) {
            return 0 === _h(t1.min, e.min) && 0 === _h(t1.max, e.max);
        }
        function Mh(t1, e) {
            return !(t1.min.x > e.max.x || t1.max.x < e.min.x || t1.min.y > e.max.y || t1.max.y < e.min.y);
        }
        function Ah(t1, e) {
            if (t1.length !== e.length) return !1;
            for(let r = 0; r < t1.length; r++)if (t1[r].sourceId !== e[r].sourceId || !wh(t1[r], e[r]) || t1[r].order !== e[r].order || t1[r].clipMask !== e[r].clipMask || !$(t1[r].clipScope, e[r].clipScope)) return !1;
            return !0;
        }
        function Sh(t1, e, r) {
            const n = 1 / Wr, i = 1 / (1 << r.canonical.z), a = (e.x * n + r.canonical.x) * i + r.wrap, s = (e.y * n + r.canonical.y) * i;
            return {
                min: new q((t1.x * n + r.canonical.x) * i + r.wrap, (t1.y * n + r.canonical.y) * i),
                max: new q(a, s)
            };
        }
        function Ih(t1, e, r) {
            const n = 1 << r.canonical.z, i = ((e.x - r.wrap) * n - r.canonical.x) * Wr, a = (e.y * n - r.canonical.y) * Wr;
            return {
                min: new q(((t1.x - r.wrap) * n - r.canonical.x) * Wr, (t1.y * n - r.canonical.y) * Wr),
                max: new q(i, a)
            };
        }
        function Ph(t1, e, r, n, i, a, s) {
            const o = t1.indices, l = t1.vertices, u = [];
            for(let c = n; c < n + i; c += 3){
                const n = e[r[c + 0] + a], i = e[r[c + 1] + a], h = e[r[c + 2] + a], p = Math.min(n.x, i.x, h.x), f = Math.max(n.x, i.x, h.x), d = Math.min(n.y, i.y, h.y), m = Math.max(n.y, i.y, h.y);
                u.length = 0, t1.grid.query(new q(p, d), new q(f, m), u);
                for(let t1 = 0; t1 < u.length; t1++){
                    const e = u[t1];
                    if (Yl(l[o[3 * e + 0]], l[o[3 * e + 1]], l[o[3 * e + 2]], n, i, h, s)) return !0;
                }
            }
            return !1;
        }
        function zh(t1, e, r, n) {
            if (!t1 || !r) return !1;
            let i = t1.vertices;
            if (!e.canonical.equals(n.canonical) || e.wrap !== n.wrap) {
                if (r.vertices.length < t1.vertices.length) return zh(r, n, t1, e);
                const a = e.canonical, s = n.canonical, o = Math.pow(2, s.z - a.z);
                i = t1.vertices.map((t1)=>new q((t1.x + a.x * Wr) * o - s.x * Wr, (t1.y + a.y * Wr) * o - s.y * Wr));
            }
            return Ph(r, i, t1.indices, 0, t1.indices.length, 0, 0);
        }
        function Eh(t1, e, r, n) {
            const i = Math.pow(2, n.z - r.z);
            return new q((t1 + r.x * Wr) * i - n.x * Wr, (e + r.y * Wr) * i - n.y * Wr);
        }
        function kh(t1, e) {
            const r = [];
            e.grid.queryPoint(t1, r);
            const n = e.indices, i = e.vertices;
            for(let e = 0; e < r.length; e++){
                const a = r[e];
                if (jl([
                    i[n[3 * a + 0]],
                    i[n[3 * a + 1]],
                    i[n[3 * a + 2]]
                ], t1)) return !0;
            }
            return !1;
        }
        const Th = [
            new q(0, 0),
            new q(Wr, 0),
            new q(Wr, Wr),
            new q(0, Wr)
        ];
        function Bh(t1, e) {
            const r = [];
            let n = [];
            if (!e || t1.length < 2) return [
                t1
            ];
            if (2 === t1.length) return $l(t1[0], t1[1], Th) ? [
                t1
            ] : [];
            for(let e = 0; e < t1.length + 2; e++){
                const i = t1[e % t1.length], a = t1[(e + 1) % t1.length], s = $l(0 === e ? t1[t1.length - 1] : t1[(e - 1) % t1.length], i, Th), o = $l(i, a, Th), l = s || o;
                l && n.push(i), l && o || n.length > 0 && (n.length > 1 && r.push(n), n = []);
            }
            return n.length > 1 && r.push(n), r;
        }
        const Vh = fh.VectorTileFeature.types, Ch = [
            "fill-extrusion-base",
            "fill-extrusion-height",
            "fill-extrusion-color",
            "fill-extrusion-pattern",
            "fill-extrusion-flood-light-wall-radius",
            "fill-extrusion-line-width",
            "fill-extrusion-emissive-strength"
        ], Dh = [
            "fill-extrusion-flood-light-ground-radius"
        ], Lh = Math.pow(2, 13), Rh = Math.pow(2, 15) - 1, Fh = new q(0, 1), Oh = 2147483648;
        function Nh(t1, e, r, n, i, a, s, o) {
            t1.emplaceBack((e << 1) + s, (r << 1) + a, (Math.floor(n * Lh) << 1) + i, Math.round(o));
        }
        function Uh(t1, e, r) {
            t1.emplaceBack(e.x * Wr, e.y * Wr, r ? 1 : 0);
        }
        function jh(t1, e, r, n, i, a) {
            t1.emplaceBack(e.x, e.y, (r.x << 1) + n, (r.y << 1) + i, a);
        }
        function qh(t1, e, r) {
            const n = 16384;
            t1.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);
        }
        class $h {
            constructor(){
                this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
            }
        }
        class Gh {
            constructor(){
                this.centroidXY = new q(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new q(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new q(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;
            }
            span() {
                return new q(this.max.x - this.min.x, this.max.y - this.min.y);
            }
        }
        class Yh {
            constructor(){
                this.acc = new q(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
            }
            startRing(t1, e) {
                t1.min.x === Number.MAX_VALUE && (t1.min.x = t1.max.x = e.x, t1.min.y = t1.max.y = e.y);
            }
            appendEdge(t1, e, r) {
                this.accCount++, this.acc._add(e);
                let n = !!this.borders;
                e.x < t1.min.x ? (t1.min.x = e.x, n = !0) : e.x > t1.max.x && (t1.max.x = e.x, n = !0), e.y < t1.min.y ? (t1.min.y = e.y, n = !0) : e.y > t1.max.y && (t1.max.y = e.y, n = !0), ((0 === e.x || e.x === Wr) && e.x === r.x) != ((0 === e.y || e.y === Wr) && e.y === r.y) && this.processBorderOverlap(e, r), n && this.checkBorderIntersection(e, r);
            }
            checkBorderIntersection(t1, e) {
                e.x < 0 != t1.x < 0 && this.addBorderIntersection(0, ze(e.y, t1.y, (0 - e.x) / (t1.x - e.x))), e.x > Wr != t1.x > Wr && this.addBorderIntersection(1, ze(e.y, t1.y, (Wr - e.x) / (t1.x - e.x))), e.y < 0 != t1.y < 0 && this.addBorderIntersection(2, ze(e.x, t1.x, (0 - e.y) / (t1.y - e.y))), e.y > Wr != t1.y > Wr && this.addBorderIntersection(3, ze(e.x, t1.x, (Wr - e.y) / (t1.y - e.y)));
            }
            addBorderIntersection(t1, e) {
                this.borders || (this.borders = [
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ],
                    [
                        Number.MAX_VALUE,
                        -Number.MAX_VALUE
                    ]
                ]);
                const r = this.borders[t1];
                e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);
            }
            processBorderOverlap(t1, e) {
                if (t1.x === e.x) {
                    if (t1.y === e.y) return;
                    const r = 0 === t1.x ? 0 : 1;
                    this.addBorderIntersection(r, e.y), this.addBorderIntersection(r, t1.y);
                } else {
                    const r = 0 === t1.y ? 2 : 3;
                    this.addBorderIntersection(r, e.x), this.addBorderIntersection(r, t1.x);
                }
            }
            centroid() {
                return 0 === this.accCount ? new q(0, 0) : new q(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
            }
            intersectsCount() {
                return this.borders ? this.borders.reduce((t1, e)=>t1 + +(e[0] !== Number.MAX_VALUE), 0) : 0;
            }
        }
        function Xh(t1, e) {
            const r = t1.add(e)._unit(), n = Q(t1.x * r.x + t1.y * r.y, -1, 1);
            var i, a, s;
            return s = Math.acos(n), Math.min(4, Math.max(-4, Math.tan(s))) / 4 * Rh * ((i = t1).x * (a = e).y - i.y * a.x < 0 ? -1 : 1);
        }
        const Zh = [
            (t1)=>t1.x < 0,
            (t1)=>t1.x > Wr,
            (t1)=>t1.y < 0,
            (t1)=>t1.y > Wr
        ];
        function Hh(t1, e, r, n) {
            const i = [
                4
            ];
            if (0 === n) return i;
            r._mult(n);
            const a = t1.sub(r), s = e.sub(r), o = [
                t1,
                e,
                a,
                s
            ];
            for(let t1 = 0; t1 < 4; t1++)for (const e of o)if (Zh[t1](e)) {
                i.push(t1);
                break;
            }
            return i;
        }
        class Wh {
            constructor(t1){
                this.vertexArray = new _s, this.indexArray = new Ls, this.programConfigurations = new No(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }, (t1)=>Dh.includes(t1)), this._segments = new po, this.hiddenByLandmarkVertexArray = new Ws, this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [
                    0,
                    0,
                    0,
                    0,
                    0
                ], this.regionSegments = {}, this.regionSegments[4] = new po;
            }
            getDefaultSegment() {
                return this.regionSegments[4];
            }
            hasData() {
                return 0 !== this.vertexArray.length;
            }
            addData(t1, e, r, n = !1) {
                const i = t1.length;
                if (i > 2) {
                    let a = Math.max(0, this._segments.get().length - 1);
                    const s = this._segments._prepareSegment(4 * i, this.vertexArray.length, 2 * this._segmentToGroundQuads[a].length);
                    let o;
                    a !== this._segments.get().length - 1 && (a++, this._segmentToGroundQuads[a] = [], this._segmentToRegionTriCounts[a] = [
                        0,
                        0,
                        0,
                        0,
                        0
                    ]);
                    {
                        const e = t1[0], r = t1[1];
                        o = Xh(e.sub(t1[i - 1])._perp()._unit(), r.sub(e)._perp()._unit());
                    }
                    for(let l = 0; l < i; l++){
                        const u = l === i - 1 ? 0 : l + 1, c = t1[l], h = t1[u], p = t1[u === i - 1 ? 0 : u + 1], f = h.sub(c)._perp()._unit(), d = Xh(f, p.sub(h)._perp()._unit()), m = o, y = d;
                        if (ep(c, h, e) || n && rp(c, e) && rp(h, e)) {
                            o = d;
                            continue;
                        }
                        const g = s.vertexLength;
                        jh(this.vertexArray, c, h, 1, 1, m), jh(this.vertexArray, c, h, 1, 0, m), jh(this.vertexArray, c, h, 0, 1, y), jh(this.vertexArray, c, h, 0, 0, y), s.vertexLength += 4;
                        const x = Hh(c, h, f, r);
                        for (const t1 of x)this._segmentToGroundQuads[a].push({
                            id: g,
                            region: t1
                        }), this._segmentToRegionTriCounts[a][t1] += 2, s.primitiveLength += 2;
                        o = d;
                    }
                }
            }
            prepareBorderSegments() {
                if (!this.hasData()) return;
                const t1 = this._segments.get(), e = t1.length;
                for(let t1 = 0; t1 < e; t1++)this._segmentToGroundQuads[t1].sort((t1, e)=>t1.region - e.region);
                for(let r = 0; r < e; r++){
                    const e = this._segmentToGroundQuads[r], n = t1[r], i = this._segmentToRegionTriCounts[r];
                    i.reduce((t1, e)=>t1 + e, 0);
                    let a = 0;
                    for(let t1 = 0; t1 <= 4; t1++){
                        const e = i[t1];
                        if (0 !== e) {
                            let r = this.regionSegments[t1];
                            r || (r = this.regionSegments[t1] = new po);
                            const i = {
                                vertexOffset: n.vertexOffset,
                                primitiveOffset: n.primitiveOffset + a,
                                vertexLength: n.vertexLength,
                                primitiveLength: e
                            };
                            r.get().push(i);
                        }
                        a += e;
                    }
                    for(let t1 = 0; t1 < e.length; t1++){
                        const r = e[t1].id;
                        this.indexArray.emplaceBack(r, r + 1, r + 3), this.indexArray.emplaceBack(r, r + 3, r + 2);
                    }
                }
                this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
            }
            addPaintPropertiesData(t1, e, r, n, i, a) {
                this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t1, e, r, n, i, a);
            }
            upload(t1) {
                this.hasData() && (this.vertexBuffer = t1.createVertexBuffer(this.vertexArray, Wc.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray));
            }
            uploadPaintProperties(t1) {
                this.hasData() && this.programConfigurations.upload(t1);
            }
            update(t1, e, r, n, i, a, s) {
                this.hasData() && this.programConfigurations.updatePaintArrays(t1, e, r, n, i, a, s);
            }
            updateHiddenByLandmark(t1) {
                if (!this.hasData()) return;
                const e = t1.groundVertexCount + t1.groundVertexArrayOffset;
                if (0 === t1.groundVertexCount) return;
                const r = t1.flags & Oh ? 1 : 0;
                for(let n = t1.groundVertexArrayOffset; n < e; ++n)this.hiddenByLandmarkVertexArray.emplace(n, r);
                this._needsHiddenByLandmarkUpdate = !0;
            }
            uploadHiddenByLandmark(t1) {
                this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t1.createVertexBuffer(this.hiddenByLandmarkVertexArray, Qc.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = !1);
            }
            destroy() {
                if (this.vertexBuffer) {
                    this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
                    for(let t1 = 0; t1 <= 4; t1++){
                        const e = this.regionSegments[t1];
                        e && e.destroy();
                    }
                }
            }
        }
        class Kh {
            constructor(t1){
                this.zoom = t1.zoom, this.canonical = t1.canonical, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = t1.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new Ls, this.footprintVertices = new xs, this.footprintSegments = [], this.layoutVertexArray = new bs, this.centroidVertexArray = new oo, this.wallVertexArray = new uo, this.indexArray = new Ls, this.programConfigurations = new No(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }, (t1)=>Ch.includes(t1)), this.segments = new po, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.groundEffect = new Wh(t1), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                this.features = [], this.hasPattern = Oc("fill-extrusion", this.layers, e), this.featuresOnBorder = [], this.borderFeatureIndices = [
                    [],
                    [],
                    [],
                    []
                ], this.borderDoneWithNeighborZ = [
                    -1,
                    -1,
                    -1,
                    -1
                ], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [
                    Number.MAX_VALUE,
                    Number.MAX_VALUE,
                    Number.MAX_VALUE,
                    Number.MAX_VALUE
                ], this.tileToMeter = vl(r), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = 0 !== this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1);
                for (const { feature: i, id: a, index: s, sourceLayerIndex: o } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, l = El(i, t1);
                    if (!this.layers[0]._featureFilter.filter(new Va(this.zoom), l, r)) continue;
                    const u = {
                        id: a,
                        sourceLayerIndex: o,
                        index: s,
                        geometry: t1 ? l.geometry : zl(i, r, n),
                        properties: i.properties,
                        type: i.type,
                        patterns: {}
                    }, c = this.layoutVertexArray.length, h = "Polygon" === Vh[u.type];
                    if (this.hasPattern) this.features.push(Nc("fill-extrusion", this.layers, u, this.zoom, e));
                    else if (this.wallMode) for (const t1 of u.geometry)for (const i of Bh(t1, h))this.addFeature(u, [
                        i
                    ], s, r, {}, e.availableImages, n, e.brightness);
                    else this.addFeature(u, u.geometry, s, r, {}, e.availableImages, n, e.brightness);
                    e.featureIndex.insert(i, u.geometry, s, o, this.index, c);
                }
                this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
            }
            addFeatures(t1, e, r, n, i, a) {
                for (const t1 of this.features){
                    const s = "Polygon" === Vh[t1.type], { geometry: o } = t1;
                    if (this.wallMode) for (const l of o)for (const o of Bh(l, s))this.addFeature(t1, [
                        o
                    ], t1.index, e, r, n, i, a);
                    else this.addFeature(t1, o, t1.index, e, r, n, i, a);
                }
                this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles();
            }
            update(t1, e, r, n, i, a, s) {
                this.programConfigurations.updatePaintArrays(t1, e, i, r, n, a, s), this.groundEffect.update(t1, e, i, r, n, a, s);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, eh), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.wallVertexBuffer = t1.createVertexBuffer(this.wallVertexArray, Jc.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t1.createVertexBuffer(this.layoutVertexExtArray, th.members, !0)), this.groundEffect.upload(t1)), this.groundEffect.uploadPaintProperties(t1), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            uploadCentroid(t1) {
                this.groundEffect.uploadHiddenByLandmark(t1), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t1.createVertexBuffer(this.centroidVertexArray, Kc.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = !1);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t1, e, r, n, i, a, s, o) {
                const l = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(t1, {}) / this.tileToMeter, u = [
                    new q(0, 0),
                    new q(Wr, Wr)
                ], c = s.projection, h = "globe" === c.name, p = this.wallMode || "Polygon" === Vh[t1.type], f = new Yh;
                f.centroidDataIndex = this.centroidData.length;
                const d = new Gh, m = this.layers[0].paint.get("fill-extrusion-base").evaluate(t1, {}, n) <= 0, y = this.layers[0].paint.get("fill-extrusion-height").evaluate(t1, {}, n);
                let g;
                if (d.height = y, d.vertexArrayOffset = this.layoutVertexArray.length, d.groundVertexArrayOffset = this.groundEffect.vertexArray.length, h && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Ps), this.wallMode) {
                    if (h) return void ft("Non zero fill-extrusion-line-width is not yet supported on globe.");
                    if (1 !== e.length) return;
                    g = function(t1) {
                        const e = t1[0].x === t1[t1.length - 1].x && t1[0].y === t1[t1.length - 1].y, r = function(t1) {
                            let e = 0;
                            const r = t1.length;
                            for(let n = 0; n < r; n++)e += (t1[(n + 1) % r].x - t1[n].x) * (t1[(n + 1) % r].y + t1[n].y);
                            return e >= 0;
                        }(t1);
                        r || (t1 = t1.reverse());
                        const n = {
                            geometry: [],
                            joinNormals: [],
                            indices: []
                        }, i = [], a = [], s = [];
                        let o = t1.length;
                        for(; o >= 2 && t1[o - 1].equals(t1[o - 2]);)o--;
                        if (o < (e ? 3 : 2)) return n;
                        let l, u, c, h, p, f = 0;
                        for(; f < o - 1 && t1[f].equals(t1[f + 1]);)f++;
                        e && (l = t1[o - 2], p = t1[f].sub(l)._unit()._perp());
                        for(let r = f; r < o; r++){
                            if (c = r === o - 1 ? e ? t1[f + 1] : void 0 : t1[r + 1], c && t1[r].equals(c)) continue;
                            p && (h = p), l && (u = l), l = t1[r], p = c ? c.sub(l)._unit()._perp() : h, h = h || p;
                            let n = h.add(p);
                            0 === n.x && 0 === n.y || n._unit();
                            const d = n.x * p.x + n.y * p.y, m = 0 !== d ? 1 / d : 1 / 0, y = h.x * p.y - h.y * p.x > 0;
                            let g = "miter";
                            const x = 2;
                            "miter" === g && m > x && (g = "bevel"), "bevel" === g && (m > 100 && (g = "flipbevel"), m < x && (g = "miter"));
                            const v = (t1, e, r, n)=>{
                                const o = new q(t1.x, t1.y), l = new q(t1.x, t1.y);
                                o.x += e.x * n, o.y += e.y * n, l.x -= e.x * Math.max(r, 1), l.y -= e.y * Math.max(r, 1), s.push(e), i.push(o), a.push(l);
                            };
                            if ("miter" === g) n._mult(m), v(l, n, 0, 0);
                            else if ("flipbevel" === g) n = p.mult(-1), v(l, n, 0, 0), v(l, n.mult(-1), 0, 0);
                            else {
                                const t1 = -Math.sqrt(m * m - 1), e = y ? t1 : 0, r = y ? 0 : t1;
                                u && v(l, h, e, r), c && v(l, p, e, r);
                            }
                        }
                        n.geometry = [
                            ...i,
                            ...a.reverse(),
                            i[0]
                        ], n.joinNormals = [
                            ...s,
                            ...s.reverse(),
                            s[s.length - 1]
                        ];
                        const d = n.geometry.length - 1;
                        for(let t1 = 0; t1 < d / 2; t1++)if (t1 + 1 < d / 2) {
                            let e = t1, r = t1 + 1, i = d - 1 - t1, a = d - 2 - t1;
                            e = 0 === e ? d - 1 : e - 1, r = 0 === r ? d - 1 : r - 1, i = 0 === i ? d - 1 : i - 1, a = 0 === a ? d - 1 : a - 1, n.indices.push(i), n.indices.push(r), n.indices.push(e), n.indices.push(i), n.indices.push(a), n.indices.push(r);
                        }
                        return n;
                    }(e[0]), e = [
                        g.geometry
                    ];
                }
                const x = (t1, e)=>t1 < (e.length - 1) / 2 || t1 === e.length - 1, v = this.wallMode ? [
                    e
                ] : Lc(e, 500);
                for(let t1 = v.length - 1; t1 >= 0; t1--){
                    const e = v[t1];
                    (0 === e.length || (b = e[0]).every((t1)=>t1.x <= 0) || b.every((t1)=>t1.x >= Wr) || b.every((t1)=>t1.y <= 0) || b.every((t1)=>t1.y >= Wr)) && v.splice(t1, 1);
                }
                var b;
                let _;
                if (h) _ = sp(v, u, n);
                else {
                    _ = [];
                    for (const t1 of v)_.push({
                        polygon: t1,
                        bounds: u
                    });
                }
                const w = p ? this.edgeRadius : 0, M = w > 0 && this.zoom < 17, A = (t1, e)=>{
                    if (0 === t1.length) return !1;
                    const r = t1[t1.length - 1];
                    return e.x === r.x && e.y === r.y;
                };
                for (const { polygon: t1, bounds: e } of _){
                    let r = 0, i = 0;
                    for (const e of t1)p && !e[0].equals(e[e.length - 1]) && e.push(e[0]), i += p ? e.length - 1 : e.length;
                    const a = this.segments.prepareSegment((p ? 5 : 4) * i, this.layoutVertexArray, this.indexArray);
                    d.footprintSegIdx < 0 && (d.footprintSegIdx = this.footprintSegments.length), d.polygonSegIdx < 0 && (d.polygonSegIdx = this.polygonSegments.length);
                    const s = {
                        triangleArrayOffset: this.indexArray.length,
                        triangleCount: 0,
                        triangleSegIdx: this.segments.segments.length - 1
                    }, o = new $h;
                    if (o.vertexOffset = this.footprintVertices.length, o.indexOffset = 3 * this.footprintIndices.length, o.ringIndices = [], p) {
                        const i = [], s = [];
                        r = a.vertexLength;
                        for(let r = 0; r < t1.length; r++){
                            const u = t1[r];
                            u.length && 0 !== r && s.push(i.length / 2);
                            const p = [];
                            let f, d;
                            f = u[1].sub(u[0])._perp()._unit(), o.ringIndices.push(u.length - 1);
                            for(let t1 = 1; t1 < u.length; t1++){
                                const e = u[t1], r = u[t1 === u.length - 1 ? 1 : t1 + 1], s = e.clone();
                                if (w) {
                                    d = r.sub(e)._perp()._unit();
                                    const t1 = f.add(d)._unit(), n = w * Math.min(4, 1 / (f.x * t1.x + f.y * t1.y));
                                    s.x += n * t1.x, s.y += n * t1.y, s.x = Math.round(s.x), s.y = Math.round(s.y), f = d;
                                }
                                if (!m || 0 !== w && !M || A(p, s) || p.push(s), Nh(this.layoutVertexArray, s.x, s.y, 0, 0, 1, 1, 0), this.wallMode) {
                                    const e = x(t1, u);
                                    Uh(this.wallVertexArray, g.joinNormals[t1], !e);
                                }
                                a.vertexLength++, this.footprintVertices.emplaceBack(e.x, e.y), i.push(e.x, e.y), h && qh(this.layoutVertexExtArray, c.projectTilePoint(s.x, s.y, n), c.upVector(n, s.x, s.y));
                            }
                            m && (0 === w || M) && (0 !== p.length && A(p, p[0]) && p.pop(), this.groundEffect.addData(p, e, l));
                        }
                        const u = this.wallMode ? g.indices : hc(i, s);
                        for(let t1 = 0; t1 < u.length; t1 += 3)this.footprintIndices.emplaceBack(o.vertexOffset + u[t1 + 0], o.vertexOffset + u[t1 + 1], o.vertexOffset + u[t1 + 2]), this.indexArray.emplaceBack(r + u[t1], r + u[t1 + 2], r + u[t1 + 1]), a.primitiveLength++;
                        o.indexCount += u.length, o.vertexCount += this.footprintVertices.length - o.vertexOffset;
                    }
                    for(let i = 0; i < t1.length; i++){
                        const s = t1[i];
                        f.startRing(d, s[0]);
                        let o = s.length > 4 && np(s[s.length - 2], s[0], s[1]), u = w ? Qh(s[s.length - 2], s[0], s[1], w) : 0;
                        const y = [];
                        let v, b, _;
                        b = s[1].sub(s[0])._perp()._unit();
                        let M = !0;
                        for(let t1 = 1, i = 0; t1 < s.length; t1++){
                            let l = s[t1 - 1], p = s[t1];
                            const S = s[t1 === s.length - 1 ? 1 : t1 + 1];
                            if (f.appendEdge(d, p, l), ep(p, l, e)) {
                                w && (b = S.sub(p)._perp()._unit(), M = !M);
                                continue;
                            }
                            const I = p.sub(l)._perp(), P = I.x / (Math.abs(I.x) + Math.abs(I.y)), z = I.y > 0 ? 1 : 0, E = l.dist(p);
                            if (i + E > 32768 && (i = 0), w) {
                                _ = S.sub(p)._perp()._unit();
                                let t1 = tp(l, p, S, Jh(b, _), w);
                                isNaN(t1) && (t1 = 0);
                                const e = p.sub(l)._unit();
                                l = l.add(e.mult(u))._round(), p = p.add(e.mult(-t1))._round(), u = t1, b = _, m && this.zoom >= 17 && (A(y, l) || y.push(l), A(y, p) || y.push(p));
                            }
                            const k = a.vertexLength, T = s.length > 4 && np(l, p, S);
                            let B = ip(i, o, M);
                            if (Nh(this.layoutVertexArray, l.x, l.y, P, z, 0, 0, B), Nh(this.layoutVertexArray, l.x, l.y, P, z, 0, 1, B), this.wallMode) {
                                const e = x(t1 - 1, s), r = g.joinNormals[t1 - 1];
                                Uh(this.wallVertexArray, r, e), Uh(this.wallVertexArray, r, e);
                            }
                            if (i += E, B = ip(i, T, !M), o = T, Nh(this.layoutVertexArray, p.x, p.y, P, z, 0, 0, B), Nh(this.layoutVertexArray, p.x, p.y, P, z, 0, 1, B), this.wallMode) {
                                const e = x(t1, s), r = g.joinNormals[t1];
                                Uh(this.wallVertexArray, r, e), Uh(this.wallVertexArray, r, e);
                            }
                            if (a.vertexLength += 4, this.indexArray.emplaceBack(k + 0, k + 1, k + 2), this.indexArray.emplaceBack(k + 1, k + 3, k + 2), a.primitiveLength += 2, w) {
                                const n = r + (1 === t1 ? s.length - 2 : t1 - 2), i = 1 === t1 ? r : n + 1;
                                if (this.indexArray.emplaceBack(k + 1, n, k + 3), this.indexArray.emplaceBack(n, i, k + 3), a.primitiveLength += 2, void 0 === v && (v = k), !ep(S, s[t1], e)) {
                                    const e = t1 === s.length - 1 ? v : a.vertexLength;
                                    this.indexArray.emplaceBack(k + 2, k + 3, e), this.indexArray.emplaceBack(k + 3, e + 1, e), this.indexArray.emplaceBack(k + 3, i, e + 1), a.primitiveLength += 3;
                                }
                                M = !M;
                            }
                            if (h) {
                                const t1 = this.layoutVertexExtArray, e = c.projectTilePoint(l.x, l.y, n), r = c.projectTilePoint(p.x, p.y, n), i = c.upVector(n, l.x, l.y), a = c.upVector(n, p.x, p.y);
                                qh(t1, e, i), qh(t1, e, i), qh(t1, r, a), qh(t1, r, a);
                            }
                        }
                        p && (r += s.length - 1), m && w && this.zoom >= 17 && (0 !== y.length && A(y, y[0]) && y.pop(), this.groundEffect.addData(y, e, l, w > 0));
                    }
                    this.footprintSegments.push(o), s.triangleCount = this.indexArray.length - s.triangleArrayOffset, this.polygonSegments.push(s), ++d.footprintSegLen, ++d.polygonSegLen;
                }
                if (d.vertexCount = this.layoutVertexArray.length - d.vertexArrayOffset, d.groundVertexCount = this.groundEffect.vertexArray.length - d.groundVertexArrayOffset, 0 !== d.vertexCount) {
                    if (d.centroidXY = f.borders ? Fh : this.encodeCentroid(f, d), this.centroidData.push(d), f.borders) {
                        this.featuresOnBorder.push(f);
                        const t1 = this.featuresOnBorder.length - 1;
                        for(let e = 0; e < f.borders.length; e++)f.borders[e][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e].push(t1);
                    }
                    this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, a, n, o), this.groundEffect.addPaintPropertiesData(t1, r, i, a, n, o), this.maxHeight = Math.max(this.maxHeight, y);
                }
            }
            sortBorders() {
                for(let t1 = 0; t1 < this.borderFeatureIndices.length; t1++)this.borderFeatureIndices[t1].sort((e, r)=>this.featuresOnBorder[e].borders[t1][0] - this.featuresOnBorder[r].borders[t1][0]);
            }
            splitToSubtiles() {
                const t1 = [];
                for(let e = 0; e < this.centroidData.length; e++){
                    const r = this.centroidData[e], n = +(r.min.y + r.max.y > Wr), i = 2 * n + (+(r.min.x + r.max.x > Wr) ^ n);
                    for(let n = 0; n < r.polygonSegLen; n++){
                        const a = r.polygonSegIdx + n;
                        t1.push({
                            centroidIdx: e,
                            subtile: i,
                            polygonSegmentIdx: a,
                            triangleSegmentIdx: this.polygonSegments[a].triangleSegIdx
                        });
                    }
                }
                const e = new Ls;
                t1.sort((t1, e)=>t1.triangleSegmentIdx === e.triangleSegmentIdx ? t1.subtile - e.subtile : t1.triangleSegmentIdx - e.triangleSegmentIdx);
                let r = 0, n = 0, i = 0;
                for (const e of t1){
                    if (e.triangleSegmentIdx !== r) break;
                    i++;
                }
                const a = t1.length;
                for(; n !== t1.length;){
                    r = t1[n].triangleSegmentIdx;
                    let s = 0, o = n, l = n;
                    for(let e = o; e < i && t1[e].subtile === s; e++)l++;
                    for(; o !== i;){
                        const n = t1[o];
                        s = n.subtile;
                        const a = this.centroidData[n.centroidIdx].min.clone(), u = this.centroidData[n.centroidIdx].max.clone(), c = {
                            vertexOffset: this.segments.segments[r].vertexOffset,
                            primitiveOffset: e.length,
                            vertexLength: this.segments.segments[r].vertexLength,
                            primitiveLength: 0,
                            sortKey: void 0,
                            vaos: {}
                        };
                        for(let r = o; r < l; r++){
                            const n = t1[r], i = this.polygonSegments[n.polygonSegmentIdx], s = this.centroidData[n.centroidIdx].min, o = this.centroidData[n.centroidIdx].max, l = this.indexArray.uint16;
                            for(let t1 = i.triangleArrayOffset; t1 < i.triangleArrayOffset + i.triangleCount; t1++)e.emplaceBack(l[3 * t1], l[3 * t1 + 1], l[3 * t1 + 2]);
                            c.primitiveLength += i.triangleCount, a.x = Math.min(a.x, s.x), a.y = Math.min(a.y, s.y), u.x = Math.max(u.x, o.x), u.y = Math.max(u.y, o.y);
                        }
                        c.primitiveLength > 0 && this.triangleSubSegments.push({
                            segment: c,
                            min: a,
                            max: u
                        }), o = l;
                        for(let e = o; e < i && t1[e].subtile === t1[o].subtile; e++)l++;
                    }
                    n = i;
                    for(let e = n; e < a && t1[e].triangleSegmentIdx === t1[n].triangleSegmentIdx; e++)i++;
                }
                e._trim(), this.indexArray = e;
            }
            getVisibleSegments(t1, e, r) {
                const n = new po;
                if (this.wallMode) {
                    for (const t1 of this.triangleSubSegments)n.segments.push(t1.segment);
                    return n;
                }
                let i = 0, a = 0;
                const s = 1 << t1.canonical.z;
                if (e) {
                    const r = e.getMinMaxForTile(t1);
                    r && (i = r.min, a = r.max);
                }
                a += this.maxHeight;
                const o = t1.toUnwrapped();
                let l;
                const u = [
                    o.canonical.x / s + o.wrap,
                    o.canonical.y / s
                ], c = [
                    (o.canonical.x + 1) / s + o.wrap,
                    (o.canonical.y + 1) / s
                ], h = (t1, e, r)=>[
                        t1[0] * (1 - r[0]) + e[0] * r[0],
                        t1[1] * (1 - r[1]) + e[1] * r[1]
                    ], p = [], f = [];
                for (const t1 of this.triangleSubSegments){
                    p[0] = t1.min.x / Wr, p[1] = t1.min.y / Wr, f[0] = t1.max.x / Wr, f[1] = t1.max.y / Wr;
                    const e = h(u, c, p), s = h(u, c, f);
                    if (0 === new xu([
                        e[0],
                        e[1],
                        i
                    ], [
                        s[0],
                        s[1],
                        a
                    ]).intersectsPrecise(r)) {
                        l && (n.segments.push(l), l = void 0);
                        continue;
                    }
                    const o = t1.segment;
                    l && l.vertexOffset !== o.vertexOffset && (n.segments.push(l), l = void 0), l ? (l.vertexLength += o.vertexLength, l.primitiveLength += o.primitiveLength) : l = {
                        vertexOffset: o.vertexOffset,
                        primitiveLength: o.primitiveLength,
                        vertexLength: o.vertexLength,
                        primitiveOffset: o.primitiveOffset,
                        sortKey: void 0,
                        vaos: {}
                    };
                }
                return l && n.segments.push(l), n;
            }
            encodeCentroid(t1, e) {
                const r = t1.centroid(), n = e.span(), i = Math.min(7, Math.round(n.x * this.tileToMeter / 10)), a = Math.min(7, Math.round(n.y * this.tileToMeter / 10));
                return new q(Q(r.x, 1, Wr - 1) << 3 | i, Q(r.y, 1, Wr - 1) << 3 | a);
            }
            encodeBorderCentroid(t1) {
                if (!t1.borders) return new q(0, 0);
                const e = t1.borders, r = Number.MAX_VALUE;
                if (e[0][0] !== r || e[1][0] !== r) {
                    const t1 = e[0][0] !== r ? 0 : 1;
                    return new q(6 | (e[0][0] !== r ? 0 : 65528), (e[t1][0] + e[t1][1]) / 2 << 3 | 6);
                }
                {
                    const t1 = e[2][0] !== r ? 2 : 3;
                    return new q((e[t1][0] + e[t1][1]) / 2 << 3 | 6, 6 | (e[2][0] !== r ? 0 : 65528));
                }
            }
            showCentroid(t1) {
                const e = this.centroidData[t1.centroidDataIndex];
                e.flags &= Oh, e.centroidXY.x = 0, e.centroidXY.y = 0, this.writeCentroidToBuffer(e);
            }
            writeCentroidToBuffer(t1) {
                this.groundEffect.updateHiddenByLandmark(t1);
                const e = t1.vertexArrayOffset, r = t1.vertexCount + t1.vertexArrayOffset, n = t1.flags & Oh ? Fh : t1.centroidXY, i = this.centroidVertexArray.geta_centroid_pos0(e);
                if (this.centroidVertexArray.geta_centroid_pos1(e) !== n.y || i !== n.x) {
                    for(let t1 = e; t1 < r; ++t1)this.centroidVertexArray.emplace(t1, n.x, n.y);
                    this.needsCentroidUpdate = !0;
                }
            }
            createCentroidsBuffer() {
                this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
                for (const t1 of this.centroidData)this.writeCentroidToBuffer(t1);
            }
            updateReplacement(t1, e, r) {
                if (e.updateTime === this.replacementUpdateTime) return;
                this.replacementUpdateTime = e.updateTime;
                const n = e.getReplacementRegionsForTile(t1.toUnwrapped());
                if (Ah(this.activeReplacements, n)) return;
                if (this.activeReplacements = n, 0 === this.centroidVertexArray.length) this.createCentroidsBuffer();
                else for (const t1 of this.centroidData)t1.flags &= 2147483647;
                const i = [];
                for (const e of this.activeReplacements){
                    if (e.order < r) continue;
                    const n = Math.max(1, Math.pow(2, e.footprintTileId.canonical.z - t1.canonical.z));
                    for (const r of this.centroidData)if (!(r.flags & Oh || e.min.x > r.max.x || r.min.x > e.max.x || e.min.y > r.max.y || r.min.y > e.max.y)) for(let a = 0; a < r.footprintSegLen; a++){
                        const s = this.footprintSegments[r.footprintSegIdx + a];
                        if (i.length = 0, op(this.footprintVertices, s.vertexOffset, s.vertexCount, e.footprintTileId.canonical, t1.canonical, i), Ph(e.footprint, i, this.footprintIndices.uint16, s.indexOffset, s.indexCount, -s.vertexOffset, -n)) {
                            r.flags |= Oh;
                            break;
                        }
                    }
                }
                for (const t1 of this.centroidData)this.writeCentroidToBuffer(t1);
                this.borderDoneWithNeighborZ = [
                    -1,
                    -1,
                    -1,
                    -1
                ];
            }
            footprintContainsPoint(t1, e, r) {
                let n = !1;
                for(let i = 0; i < r.footprintSegLen; i++){
                    const a = this.footprintSegments[r.footprintSegIdx + i];
                    let s = 0;
                    for (const r of a.ringIndices){
                        for(let i = s, o = r + s - 1; i < r + s; o = i++){
                            const r = this.footprintVertices.int16[2 * (i + a.vertexOffset) + 0], s = this.footprintVertices.int16[2 * (i + a.vertexOffset) + 1], l = this.footprintVertices.int16[2 * (o + a.vertexOffset) + 1];
                            s > e != l > e && t1 < (this.footprintVertices.int16[2 * (o + a.vertexOffset) + 0] - r) * (e - s) / (l - s) + r && (n = !n);
                        }
                        s = r;
                    }
                }
                return n;
            }
            getHeightAtTileCoord(t1, e) {
                let r = Number.NEGATIVE_INFINITY, n = !0;
                const i = 4 * (t1 + Wr) * Wr + (e + Wr);
                if (this.partLookup.hasOwnProperty(i)) {
                    const t1 = this.partLookup[i];
                    return t1 ? {
                        height: t1.height,
                        hidden: !!(t1.flags & Oh)
                    } : void 0;
                }
                for (const a of this.centroidData)t1 > a.max.x || a.min.x > t1 || e > a.max.y || a.min.y > e || this.footprintContainsPoint(t1, e, a) && a && a.height > r && (r = a.height, this.partLookup[i] = a, n = !!(a.flags & Oh));
                if (r !== Number.NEGATIVE_INFINITY) return {
                    height: r,
                    hidden: n
                };
                this.partLookup[i] = void 0;
            }
        }
        function Jh(t1, e) {
            const r = t1.add(e)._unit();
            return t1.x * r.x + t1.y * r.y;
        }
        function Qh(t1, e, r, n) {
            const i = e.sub(t1)._perp()._unit(), a = r.sub(e)._perp()._unit();
            return tp(t1, e, r, Jh(i, a), n);
        }
        function tp(t1, e, r, n, i) {
            const a = Math.sqrt(1 - n * n);
            return Math.min(t1.dist(e) / 3, e.dist(r) / 3, i * a / n);
        }
        function ep(t1, e, r) {
            return t1.x < r[0].x && e.x < r[0].x || t1.x > r[1].x && e.x > r[1].x || t1.y < r[0].y && e.y < r[0].y || t1.y > r[1].y && e.y > r[1].y;
        }
        function rp(t1, e) {
            return t1.x < e[0].x || t1.x > e[1].x || t1.y < e[0].y || t1.y > e[1].y;
        }
        function np(t1, e, r) {
            if (t1.x < 0 || t1.x >= Wr || e.x < 0 || e.x >= Wr || r.x < 0 || r.x >= Wr) return !1;
            const n = r.sub(e), i = n.perp(), a = t1.sub(e);
            return (n.x * a.x + n.y * a.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (a.x * a.x + a.y * a.y)) > -.866 && i.x * a.x + i.y * a.y < 0;
        }
        function ip(t1, e, r) {
            const n = e ? 2 | t1 : -3 & t1;
            return r ? 1 | n : -2 & n;
        }
        function ap() {
            const t1 = Math.PI / 32, e = Math.tan(t1), r = rl;
            return r * Math.sqrt(1 + 2 * e * e) - r;
        }
        function sp(t1, e, r) {
            const n = 1 << r.z, i = pl(r.x / n), a = pl((r.x + 1) / n), s = fl(r.y / n), o = fl((r.y + 1) / n);
            return function(t1, e, r, n, i = 0, a) {
                const s = [];
                if (!t1.length || !r || !n) return s;
                const o = (t1, e)=>{
                    for (const r of t1)s.push({
                        polygon: r,
                        bounds: e
                    });
                }, l = Math.ceil(Math.log2(r)), u = Math.ceil(Math.log2(n)), c = l - u, h = [];
                for(let t1 = 0; t1 < Math.abs(c); t1++)h.push(c > 0 ? 0 : 1);
                for(let t1 = 0; t1 < Math.min(l, u); t1++)h.push(0), h.push(1);
                let p = t1;
                if (p = yh(p, e[0].y - i, e[1].y + i, 1), p = yh(p, e[0].x - i, e[1].x + i, 0), !p.length) return s;
                const f = [];
                for(h.length ? f.push({
                    polygons: p,
                    bounds: e,
                    depth: 0
                }) : o(p, e); f.length;){
                    const t1 = f.pop(), e = t1.depth, r = h[e], n = t1.bounds[0], s = t1.bounds[1], l = 0 === r ? n.x : n.y, u = 0 === r ? s.x : s.y, c = ("TURBOPACK compile-time truthy", 1) ? a(r, l, u) : ("TURBOPACK unreachable", undefined), p = yh(t1.polygons, l - i, c + i, r), d = yh(t1.polygons, c - i, u + i, r);
                    if (p.length) {
                        const t1 = [
                            n,
                            new q(0 === r ? c : s.x, 1 === r ? c : s.y)
                        ];
                        h.length > e + 1 ? f.push({
                            polygons: p,
                            bounds: t1,
                            depth: e + 1
                        }) : o(p, t1);
                    }
                    if (d.length) {
                        const t1 = [
                            new q(0 === r ? c : n.x, 1 === r ? c : n.y),
                            s
                        ];
                        h.length > e + 1 ? f.push({
                            polygons: d,
                            bounds: t1,
                            depth: e + 1
                        }) : o(d, t1);
                    }
                }
                return s;
            }(t1, e, Math.ceil((a - i) / 11.25), Math.ceil((s - o) / 11.25), 1, (t1, e, i)=>{
                if (0 === t1) return .5 * (e + i);
                {
                    const t1 = fl((r.y + e / Wr) / n);
                    return (cl(.5 * (fl((r.y + i / Wr) / n) + t1)) * n - r.y) * Wr;
                }
            });
        }
        function op(t1, e, r, n, i, a) {
            const s = Math.pow(2, n.z - i.z);
            for(let o = 0; o < r; o++){
                let r = t1.int16[2 * (o + e) + 0], l = t1.int16[2 * (o + e) + 1];
                r = (r + i.x * Wr) * s - n.x * Wr, l = (l + i.y * Wr) * s - n.y * Wr, a.push(new q(r, l));
            }
        }
        let lp, up;
        function cp(t1, e) {
            return t1.x * e.x + t1.y * e.y;
        }
        function hp(t1, e) {
            if (1 === t1.length) {
                let r = 0;
                const n = e[r++];
                let i;
                for(; !i || n.equals(i);)if (i = e[r++], !i) return 1 / 0;
                for(; r < e.length; r++){
                    const a = e[r], s = t1[0], o = i.sub(n), l = a.sub(n), u = s.sub(n), c = cp(o, o), h = cp(o, l), p = cp(l, l), f = cp(u, o), d = cp(u, l), m = c * p - h * h, y = (p * f - h * d) / m, g = (c * d - h * f) / m, x = n.z * (1 - y - g) + i.z * y + a.z * g;
                    if (isFinite(x)) return x;
                }
                return 1 / 0;
            }
            {
                let t1 = 1 / 0;
                for (const r of e)t1 = Math.min(t1, r.z);
                return t1;
            }
        }
        function pp(t1, e, r, n, i, a, s, o) {
            const l = s * i.getElevationAt(t1, e, !0, !0), u = 0 !== a[0], c = u ? 0 === a[1] ? s * (a[0] / 7 - 450) : s * function(t1, e, r) {
                const n = Math.floor(e[0] / 8), i = Math.floor(e[1] / 8), a = 10 * (e[0] - 8 * n), s = 10 * (e[1] - 8 * i), o = t1.getElevationAt(n, i, !0, !0), l = t1.getMeterToDEM(r), u = Math.floor(.5 * (a * l - 1)), c = Math.floor(.5 * (s * l - 1)), h = t1.tileCoordToPixel(n, i), p = 2 * u + 1, f = 2 * c + 1, d = function(t1, e, r, n, i) {
                    return [
                        t1.getElevationAtPixel(e, r, !0),
                        t1.getElevationAtPixel(e + i, r, !0),
                        t1.getElevationAtPixel(e, r + i, !0),
                        t1.getElevationAtPixel(e + n, r + i, !0)
                    ];
                }(t1, h.x - u, h.y - c, p, f), m = Math.abs(d[0] - d[1]), y = Math.abs(d[2] - d[3]), g = Math.abs(d[0] - d[2]) + Math.abs(d[1] - d[3]), x = Math.min(.25, .5 * l * (m + y) / p), v = Math.min(.25, .5 * l * g / f);
                return o + Math.max(x * a, v * s);
            }(i, a, o) : l;
            return {
                base: l + (0 === r ? -1 : r),
                top: u ? Math.max(c + n, l + r + 2) : l + n
            };
        }
        oa(Kh, "FillExtrusionBucket", {
            omit: [
                "layers",
                "features"
            ]
        }), oa(Gh, "PartData"), oa($h, "FootprintSegment"), oa(Yh, "BorderCentroidData"), oa(Wh, "GroundEffect");
        const fp = ys([
            {
                name: "a_pos_normal",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_data",
                components: 4,
                type: "Uint8"
            },
            {
                name: "a_linesofar",
                components: 1,
                type: "Float32"
            }
        ], 4), dp = ys([
            {
                name: "a_z_offset_width",
                components: 2,
                type: "Float32"
            }
        ], 4), { members: mp } = fp, yp = ys([
            {
                name: "a_packed",
                components: 4,
                type: "Float32"
            }
        ]), { members: gp } = yp, xp = ys([
            {
                name: "a_pattern_data",
                components: 3,
                type: "Float32"
            }
        ]), { members: vp } = xp;
        class bp {
            constructor(t1, e){
                this.width = t1, this.height = e, this.nextRow = 0, this.image = new ac({
                    width: t1,
                    height: e
                }), this.positions = {}, this.uploaded = !1;
            }
            getDash(t1, e) {
                const r = this.getKey(t1, e);
                return this.positions[r];
            }
            trim() {
                const t1 = this.width, e = this.height = st(this.nextRow);
                this.image.resize({
                    width: t1,
                    height: e
                });
            }
            getKey(t1, e) {
                return t1.join(",") + e;
            }
            getDashRanges(t1, e, r) {
                const n = [];
                let i = t1.length % 2 == 1 ? -t1[t1.length - 1] * r : 0, a = t1[0] * r, s = !0;
                n.push({
                    left: i,
                    right: a,
                    isDash: s,
                    zeroLength: 0 === t1[0]
                });
                let o = t1[0];
                for(let e = 1; e < t1.length; e++){
                    s = !s;
                    const l = t1[e];
                    i = o * r, o += l, a = o * r, n.push({
                        left: i,
                        right: a,
                        isDash: s,
                        zeroLength: 0 === l
                    });
                }
                return n;
            }
            addRoundDash(t1, e, r) {
                const n = e / 2;
                for(let e = -r; e <= r; e++){
                    const i = this.width * (this.nextRow + r + e);
                    let a = 0, s = t1[a];
                    for(let o = 0; o < this.width; o++){
                        o / s.right > 1 && (s = t1[++a]);
                        const l = Math.abs(o - s.left), u = Math.abs(o - s.right), c = Math.min(l, u);
                        let h;
                        const p = e / r * (n + 1);
                        if (s.isDash) {
                            const t1 = n - Math.abs(p);
                            h = Math.sqrt(c * c + t1 * t1);
                        } else h = n - Math.sqrt(c * c + p * p);
                        this.image.data[i + o] = Math.max(0, Math.min(255, h + 128));
                    }
                }
            }
            addRegularDash(t1, e) {
                for(let e = t1.length - 1; e >= 0; --e){
                    const r = t1[e], n = t1[e + 1];
                    r.zeroLength ? t1.splice(e, 1) : n && n.isDash === r.isDash && (n.left = r.left, t1.splice(e, 1));
                }
                const r = t1[0], n = t1[t1.length - 1];
                r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width);
                const i = this.width * this.nextRow;
                let a = 0, s = t1[a];
                for(let r = 0; r < this.width; r++){
                    r / s.right > 1 && (s = t1[++a]);
                    const n = Math.abs(r - s.left), o = Math.abs(r - s.right), l = Math.min(n, o);
                    this.image.data[i + r] = Math.max(0, Math.min(255, (s.isDash ? l : -l) + e + 128));
                }
            }
            addDash(t1, e) {
                const r = this.getKey(t1, e);
                if (this.positions[r]) return this.positions[r];
                const n = "round" === e, i = n ? 7 : 0, a = 2 * i + 1;
                if (this.nextRow + a > this.height) return ft("LineAtlas out of space"), null;
                0 === t1.length && t1.push(1);
                let s = 0;
                for(let e = 0; e < t1.length; e++)t1[e] < 0 && (ft("Negative value is found in line dasharray, replacing values with 0"), t1[e] = 0), s += t1[e];
                if (0 !== s) {
                    const r = this.width / s, a = this.getDashRanges(t1, this.width, r);
                    n ? this.addRoundDash(a, r, i) : this.addRegularDash(a, "square" === e ? .5 * r : 0);
                }
                const o = this.nextRow + i;
                this.nextRow += a;
                const l = {
                    tl: [
                        o,
                        i
                    ],
                    br: [
                        s,
                        0
                    ]
                };
                return this.positions[r] = l, l;
            }
        }
        oa(bp, "LineAtlas");
        const _p = fh.VectorTileFeature.types, wp = Math.cos(Math.PI / 180 * 37.5), Mp = Math.cos(Math.PI / 180 * 5);
        class Ap {
            constructor(t1){
                this.evaluationGlobals = {
                    zoom: 0,
                    lineProgress: void 0
                }, this.zoom = t1.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.projection = t1.projection, this.hasPattern = !1, this.hasZOffset = !1, this.hasCrossSlope = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t1)=>{
                    this.gradients[t1.id] = {};
                }), this.layoutVertexArray = new ws, this.layoutVertexArray2 = new Ms, this.patternVertexArray = new As, this.indexArray = new Ls, this.programConfigurations = new No(t1.layers, {
                    zoom: t1.zoom,
                    lut: t1.lut
                }), this.segments = new po, this.maxLineLength = 0, this.zOffsetVertexArray = new $s, this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.tessellationStep = t1.tessellationStep ? t1.tessellationStep : Wr / 64;
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                this.hasPattern = Oc("line", this.layers, e);
                const i = this.layers[0].layout.get("line-sort-key");
                this.tileToMeter = vl(r), this.hasZOffset = !this.layers[0].isDraped();
                const a = this.layers[0].layout.get("line-elevation-reference");
                this.hasZOffset && "none" === a && ft(`line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`);
                const s = this.layers[0].layout.get("line-cross-slope");
                this.hasCrossSlope = this.hasZOffset && void 0 !== s;
                const o = [];
                for (const { feature: e, id: a, index: s, sourceLayerIndex: l } of t1){
                    const t1 = this.layers[0]._featureFilter.needGeometry, u = El(e, t1);
                    if (!this.layers[0]._featureFilter.filter(new Va(this.zoom), u, r)) continue;
                    const c = i ? i.evaluate(u, {}, r) : void 0, h = {
                        id: a,
                        properties: e.properties,
                        type: e.type,
                        sourceLayerIndex: l,
                        index: s,
                        geometry: t1 ? u.geometry : zl(e, r, n),
                        patterns: {},
                        sortKey: c
                    };
                    o.push(h);
                }
                i && o.sort((t1, e)=>t1.sortKey - e.sortKey);
                const { lineAtlas: l, featureIndex: u } = e, c = this.addConstantDashes(l);
                for (const n of o){
                    const { geometry: i, index: a, sourceLayerIndex: s } = n;
                    if (c && this.addFeatureDashes(n, l), this.hasPattern) {
                        const t1 = Nc("line", this.layers, n, this.zoom, e);
                        this.patternFeatures.push(t1);
                    } else this.addFeature(n, i, a, r, l.positions, e.availableImages, e.brightness);
                    u.insert(t1[a].feature, i, a, s, this.index);
                }
            }
            addConstantDashes(t1) {
                let e = !1;
                for (const r of this.layers){
                    const n = r.paint.get("line-dasharray").value, i = r.layout.get("line-cap").value;
                    if ("constant" !== n.kind || "constant" !== i.kind) e = !0;
                    else {
                        const e = i.value, r = n.value;
                        if (!r) continue;
                        t1.addDash(r, e);
                    }
                }
                return e;
            }
            addFeatureDashes(t1, e) {
                const r = this.zoom;
                for (const n of this.layers){
                    const i = n.paint.get("line-dasharray").value, a = n.layout.get("line-cap").value;
                    if ("constant" === i.kind && "constant" === a.kind) continue;
                    let s, o;
                    if ("constant" === i.kind) {
                        if (s = i.value, !s) continue;
                    } else s = i.evaluate({
                        zoom: r
                    }, t1);
                    o = "constant" === a.kind ? a.value : a.evaluate({
                        zoom: r
                    }, t1), e.addDash(s, o), t1.patterns[n.id] = e.getKey(s, o);
                }
            }
            update(t1, e, r, n, i, a, s) {
                this.programConfigurations.updatePaintArrays(t1, e, i, r, n, a, s);
            }
            addFeatures(t1, e, r, n, i, a) {
                for (const t1 of this.patternFeatures)this.addFeature(t1, t1.geometry, t1.index, e, r, n, a);
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
                return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t1) {
                this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t1.createVertexBuffer(this.layoutVertexArray2, gp)), 0 !== this.patternVertexArray.length && (this.patternVertexBuffer = t1.createVertexBuffer(this.patternVertexArray, vp)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = t1.createVertexBuffer(this.zOffsetVertexArray, dp.members, !0)), this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, mp), this.indexBuffer = t1.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t1), this.uploaded = !0;
            }
            destroy() {
                this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t1) {
                if (t1.properties && t1.properties.hasOwnProperty("mapbox_clip_start") && t1.properties.hasOwnProperty("mapbox_clip_end")) return {
                    start: +t1.properties.mapbox_clip_start,
                    end: +t1.properties.mapbox_clip_end
                };
            }
            addFeature(t1, e, r, n, i, a, s) {
                const o = this.layers[0].layout, l = o.get("line-join").evaluate(t1, {}), u = o.get("line-cap").evaluate(t1, {}), c = o.get("line-miter-limit"), h = o.get("line-round-limit");
                this.lineClips = this.lineFeatureClips(t1), this.lineFeature = t1, this.zOffsetValue = o.get("line-z-offset").value;
                const p = this.layers[0].paint.get("line-width").value;
                "constant" !== p.kind && !1 === p.isLineProgressConstant && (this.variableWidthValue = p);
                for (const r of e)this.addLine(r, t1, n, l, u, c, h);
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t1, r, i, a, n, s);
            }
            addLine(t1, e, r, n, i, a, s) {
                this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0;
                const o = "none" === n;
                if (this.patternJoinNone = this.hasPattern && o, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [], this.lineClips) {
                    this.lineClipsArray.push(this.lineClips);
                    for(let e = 0; e < t1.length - 1; e++)this.totalDistance += t1[e].dist(t1[e + 1]);
                    this.totalFeatureLength = this.totalDistance / (this.lineClips.end - this.lineClips.start), this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
                }
                const l = "Polygon" === _p[e.type];
                let u = t1.length;
                for(; u >= 2 && t1[u - 1].equals(t1[u - 2]);)u--;
                let c = 0;
                for(; c < u - 1 && t1[c].equals(t1[c + 1]);)c++;
                if (u < (l ? 3 : 2)) return;
                "bevel" === n && (a = 1.05);
                const h = this.segments.prepareSegment(10 * u, this.layoutVertexArray, this.indexArray);
                let p, f, d, m, y, g;
                this.e1 = this.e2 = -1, l && (p = t1[u - 2], y = t1[c].sub(p)._unit()._perp());
                for(let e = c; e < u; e++){
                    if (d = e === u - 1 ? l ? t1[c + 1] : void 0 : t1[e + 1], d && t1[e].equals(d)) continue;
                    y && (m = y), p && (f = p), p = t1[e], g = this.evaluateLineProgressFeatures(f ? f.dist(p) : 0), y = d ? d.sub(p)._unit()._perp() : m, m = m || y;
                    const r = f && d;
                    let x = r ? n : l || o ? "butt" : i;
                    const v = m.x * y.x + m.y * y.y;
                    if (o) {
                        const t1 = function(t1) {
                            if (t1.patternJoinNone) {
                                const e = t1.segmentPoints.length / 2, r = t1.lineSoFar - t1.segmentStart;
                                for(let n = 0; n < e; ++n){
                                    const e = t1.segmentPoints[2 * n + 1], i = Math.round(t1.segmentPoints[2 * n]) + .5 + .25 * e;
                                    t1.patternVertexArray.emplaceBack(i, r, t1.segmentStart), t1.patternVertexArray.emplaceBack(i, r, t1.segmentStart);
                                }
                                t1.segmentPoints.length = 0;
                            }
                            t1.e1 = t1.e2 = -1;
                        };
                        if (r && v < Mp) {
                            this.updateDistance(f, p), this.addCurrentVertex(p, m, 1, 1, h, g), t1(this), this.addCurrentVertex(p, y, -1, -1, h, g);
                            continue;
                        }
                        if (f) {
                            if (!d) {
                                this.updateDistance(f, p), this.addCurrentVertex(p, m, 1, 1, h, g), t1(this);
                                continue;
                            }
                            x = "miter";
                        }
                    }
                    let b = m.add(y);
                    0 === b.x && 0 === b.y || b._unit();
                    const _ = b.x * y.x + b.y * y.y, w = 0 !== _ ? 1 / _ : 1 / 0, M = 2 * Math.sqrt(2 - 2 * _), A = _ < wp && f && d, S = m.x * y.y - m.y * y.x > 0, I = this.overscaling <= 16 ? 15 * Wr / (512 * this.overscaling) : 0;
                    if (r && "round" === x) {
                        if (w < s) x = "miter";
                        else if (w <= 2) {
                            const t1 = Sp(p, -10, Wr + 10);
                            x = this.hasZOffset && (t1 || this.hasCrossSlope) ? "miter" : "fakeround";
                        }
                    }
                    if ("miter" === x && w > a && (x = "bevel"), "bevel" === x && (w > 2 && (x = "flipbevel"), w < a && (x = "miter")), f && !("miter" === x && A) && this.updateDistance(f, p), "miter" === x) if (A) {
                        const t1 = p.dist(f);
                        if (t1 > 2 * I) {
                            const e = p.sub(p.sub(f)._mult(I / t1)._round());
                            this.updateDistance(f, e), this.addCurrentVertex(e, m, 0, 0, h, g), f = e;
                        }
                        this.updateDistance(f, p), b._mult(w), this.addCurrentVertex(p, b, 0, 0, h, g);
                        const e = p.dist(d);
                        if (e > 2 * I) {
                            const t1 = p.add(d.sub(p)._mult(I / e)._round());
                            this.updateDistance(p, t1), this.addCurrentVertex(t1, y, 0, 0, h, g), p = t1;
                        }
                    } else b._mult(w), this.addCurrentVertex(p, b, 0, 0, h, g);
                    else if ("flipbevel" === x) {
                        if (w > 100) b = y.mult(-1);
                        else {
                            const t1 = w * m.add(y).mag() / m.sub(y).mag();
                            b._perp()._mult(t1 * (S ? -1 : 1));
                        }
                        this.addCurrentVertex(p, b, 0, 0, h, g), this.addCurrentVertex(p, b.mult(-1), 0, 0, h, g);
                    } else if ("bevel" === x || "fakeround" === x) {
                        null != g && f && this.addCurrentVertex(p, m, -1, -1, h, g);
                        const t1 = p.dist(f) <= 2 * I && "bevel" !== x, e = b.mult(S ? 1 : -1);
                        e._mult(w);
                        const r = y.mult(S ? -1 : 1), n = m.mult(S ? -1 : 1), i = this.evaluateLineProgressFeatures(this.distance);
                        if (null == g && (this.addHalfVertex(p, e.x, e.y, !1, !S, 0, h, i), t1 || this.addHalfVertex(p, e.x + 2 * n.x, e.y + 2 * n.y, !1, S, 0, h, i)), "fakeround" === x) {
                            const t1 = Math.round(180 * M / Math.PI / 20);
                            this.addHalfVertex(p, n.x, n.y, !1, S, 0, h, i);
                            for(let e = 0; e < t1; e++){
                                let a = e / t1;
                                if (.5 !== a) {
                                    const t1 = a - .5;
                                    a += a * t1 * (a - 1) * ((1.0904 + v * (v * (3.55645 - 1.43519 * v) - 3.2452)) * t1 * t1 + (.848013 + v * (.215638 * v - 1.06021)));
                                }
                                const s = r.sub(n)._mult(a)._add(n)._unit();
                                this.addHalfVertex(p, s.x, s.y, !1, S, 0, h, i);
                            }
                            this.addHalfVertex(p, r.x, r.y, !1, S, 0, h, i);
                        }
                        t1 || null != g || this.addHalfVertex(p, e.x + 2 * r.x, e.y + 2 * r.y, !1, S, 0, h, i), null != g && d && this.addCurrentVertex(p, y, 1, 1, h, g);
                    } else "butt" === x ? this.addCurrentVertex(p, b, 0, 0, h, g) : "square" === x ? (f || this.addCurrentVertex(p, b, -1, -1, h, g), this.addCurrentVertex(p, b, 0, 0, h, g), f && this.addCurrentVertex(p, b, 1, 1, h, g)) : "round" === x && (f && (this.addCurrentVertex(p, m, 0, 0, h, g), this.addCurrentVertex(p, m, 1, 1, h, g, !0)), d && (this.addCurrentVertex(p, y, -1, -1, h, g, !0), this.addCurrentVertex(p, y, 0, 0, h, g)));
                }
            }
            addVerticesTo(t1, e, r, n, i, a, s, o, l, u) {
                const c = (e.w - t1.w) / this.tessellationStep | 0;
                let h = 0;
                const p = this.scaledDistance;
                if (c > 1) {
                    this.lineSoFar = t1.w;
                    const p = (e.x - t1.x) / c, f = (e.y - t1.y) / c, d = (e.z - t1.z) / c, m = (e.w - t1.w) / c;
                    for(let e = 1; e < c; ++e){
                        t1.x += p, t1.y += f, t1.z += d, this.lineSoFar += m, h += m;
                        const e = this.evaluateLineProgressFeatures(this.prevDistance + h);
                        this.scaledDistance = (this.prevDistance + h) / this.totalDistance, this.addHalfVertex(t1, r, n, u, !1, s, l, e), this.addHalfVertex(t1, i, a, u, !0, -o, l, e);
                    }
                }
                this.lineSoFar = e.w, this.scaledDistance = p;
                const f = this.evaluateLineProgressFeatures(this.distance);
                this.addHalfVertex(e, r, n, u, !1, s, l, f), this.addHalfVertex(e, i, a, u, !0, -o, l, f);
            }
            evaluateLineProgressFeatures(t1) {
                if (!this.variableWidthValue && !this.hasZOffset) return null;
                this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + t1) / this.totalFeatureLength) : ft(`line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`);
                let e = 0;
                return this.variableWidthValue && "constant" !== this.variableWidthValue.kind && (e = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), this.hasZOffset ? "constant" === this.zOffsetValue.kind ? {
                    zOffset: this.zOffsetValue.value,
                    variableWidth: e
                } : {
                    zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0,
                    variableWidth: e
                } : {
                    zOffset: 0,
                    variableWidth: e
                };
            }
            addCurrentVertex(t1, e, r, n, i, a, s = !1) {
                const o = e.x + e.y * r, l = e.y - e.x * r, u = e.y * n - e.x, c = -e.y - e.x * n;
                if (null != a) {
                    const e = this.hasZOffset, h = -10, p = Wr + 10, f = a.zOffset, d = new mh(t1.x, t1.y, f, this.lineSoFar), m = !!e && Sp(t1, h, p), y = this.lineSoFar, g = this.distance;
                    if (this.currentVertex) if (m) {
                        const e = this.currentVertexIsOutside, a = this.currentVertex, m = new mh(t1.x, t1.y, f, this.lineSoFar);
                        if (xh(a, m, h, p), !Sp(m, h, p)) {
                            if (e) {
                                this.e1 = this.e2 = -1, this.distance -= a.dist(d), this.lineSoFar = a.w;
                                const t1 = this.evaluateLineProgressFeatures(a.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                                this.addHalfVertex(a, o, l, s, !1, r, i, t1), this.addHalfVertex(a, u, c, s, !0, -n, i, t1), this.prevDistance = this.distance;
                            }
                            this.distance = this.prevDistance + a.dist(m), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(a, m, o, l, u, c, r, n, i, s), this.distance = g, this.scaledDistance = this.distance / this.totalDistance;
                        }
                    } else {
                        const t1 = this.currentVertex;
                        if (this.currentVertexIsOutside) {
                            xh(t1, d, h, p), this.e1 = this.e2 = -1, this.distance -= t1.dist(d), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t1.w;
                            const e = this.evaluateLineProgressFeatures(t1.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                            this.addHalfVertex(t1, o, l, s, !1, r, i, e), this.addHalfVertex(t1, u, c, s, !0, -n, i, e), this.prevDistance = this.distance, this.distance = g, this.scaledDistance = this.distance / this.totalDistance;
                        }
                        this.addVerticesTo(t1, d, o, l, u, c, r, n, i, s);
                    }
                    else m || (this.addHalfVertex(t1, o, l, s, !1, r, i, a), this.addHalfVertex(t1, u, c, s, !0, -n, i, a));
                    this.currentVertex = d, this.currentVertexIsOutside = m, this.lineSoFar = y;
                } else this.addHalfVertex(t1, o, l, s, !1, r, i, a), this.addHalfVertex(t1, u, c, s, !0, -n, i, a);
            }
            addHalfVertex({ x: t1, y: e }, r, n, i, a, s, o, l) {
                this.patternJoinNone && (0 === this.segmentPoints.length && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), a || this.segmentPoints.push(this.lineSoFar - this.segmentStart, s)), this.layoutVertexArray.emplaceBack((t1 << 1) + (i ? 1 : 0), (e << 1) + (a ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === s ? 0 : s < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
                const u = o.vertexLength++;
                this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u), o.primitiveLength++), a ? this.e2 = u : this.e1 = u, null != l && this.zOffsetVertexArray.emplaceBack(l.zOffset, l.variableWidth);
            }
            updateScaledDistance() {
                this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance;
            }
            updateDistance(t1, e) {
                this.prevDistance = this.distance, this.distance += t1.dist(e), this.updateScaledDistance();
            }
        }
        function Sp(t1, e, r) {
            return t1.x < e || t1.x > r || t1.y < e || t1.y > r;
        }
        let Ip, Pp;
        function zp(t1, e, r) {
            return e * (Wr / (t1.tileSize * Math.pow(2, r - t1.tileID.overscaledZ)));
        }
        oa(Ap, "LineBucket", {
            omit: [
                "layers",
                "patternFeatures",
                "currentVertex",
                "currentVertexIsOutside"
            ]
        });
        const Ep = (t1, e, r)=>(1 - r) * t1 + r * e;
        function kp(t1, e) {
            return 1 / zp(t1, 1, e.tileZoom);
        }
        function Tp(t1, e, r, n) {
            return t1.translatePosMatrix(n || e.tileID.projMatrix, e, r.paint.get("line-translate"), r.paint.get("line-translate-anchor"));
        }
        const Bp = (t1)=>{
            const e = [];
            Vp(t1) && e.push("RENDER_LINE_DASH"), t1.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT");
            const r = t1.paint.get("line-trim-offset");
            0 === r[0] && 0 === r[1] || e.push("RENDER_LINE_TRIM_OFFSET"), 0 !== t1.paint.get("line-border-width").constantOr(1) && e.push("RENDER_LINE_BORDER");
            const n = "none" === t1.layout.get("line-join").constantOr("miter"), i = !!t1.paint.get("line-pattern").constantOr(1);
            return n && i && e.push("LINE_JOIN_NONE"), e;
        };
        function Vp(t1) {
            const e = t1.paint.get("line-dasharray").value;
            return e.value || "constant" !== e.kind;
        }
        let Cp;
        const Dp = ()=>Cp || (Cp = {
                layout: Ip || (Ip = new Ga({
                    "line-cap": new qa(Ya.layout_line["line-cap"]),
                    "line-join": new qa(Ya.layout_line["line-join"]),
                    "line-miter-limit": new ja(Ya.layout_line["line-miter-limit"]),
                    "line-round-limit": new ja(Ya.layout_line["line-round-limit"]),
                    "line-sort-key": new qa(Ya.layout_line["line-sort-key"]),
                    "line-z-offset": new qa(Ya.layout_line["line-z-offset"]),
                    "line-elevation-reference": new ja(Ya.layout_line["line-elevation-reference"]),
                    "line-cross-slope": new ja(Ya.layout_line["line-cross-slope"]),
                    visibility: new ja(Ya.layout_line.visibility),
                    "line-width-unit": new ja(Ya.layout_line["line-width-unit"])
                })),
                paint: Pp || (Pp = new Ga({
                    "line-opacity": new qa(Ya.paint_line["line-opacity"]),
                    "line-color": new qa(Ya.paint_line["line-color"]),
                    "line-translate": new ja(Ya.paint_line["line-translate"]),
                    "line-translate-anchor": new ja(Ya.paint_line["line-translate-anchor"]),
                    "line-width": new qa(Ya.paint_line["line-width"]),
                    "line-gap-width": new qa(Ya.paint_line["line-gap-width"]),
                    "line-offset": new qa(Ya.paint_line["line-offset"]),
                    "line-blur": new qa(Ya.paint_line["line-blur"]),
                    "line-dasharray": new qa(Ya.paint_line["line-dasharray"]),
                    "line-pattern": new qa(Ya.paint_line["line-pattern"]),
                    "line-gradient": new $a(Ya.paint_line["line-gradient"]),
                    "line-trim-offset": new ja(Ya.paint_line["line-trim-offset"]),
                    "line-trim-fade-range": new ja(Ya.paint_line["line-trim-fade-range"]),
                    "line-trim-color": new ja(Ya.paint_line["line-trim-color"]),
                    "line-emissive-strength": new ja(Ya.paint_line["line-emissive-strength"]),
                    "line-border-width": new qa(Ya.paint_line["line-border-width"]),
                    "line-border-color": new qa(Ya.paint_line["line-border-color"]),
                    "line-occlusion-opacity": new ja(Ya.paint_line["line-occlusion-opacity"]),
                    "line-color-use-theme": new qa({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "line-gradient-use-theme": new qa({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "line-trim-color-use-theme": new qa({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "line-border-color-use-theme": new qa({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    })
                }))
            }, Cp);
        class Lp extends qa {
            possiblyEvaluate(t1, e) {
                return e = new Va(Math.floor(e.zoom), {
                    now: e.now,
                    fadeDuration: e.fadeDuration,
                    transition: e.transition
                }), super.possiblyEvaluate(t1, e);
            }
            evaluate(t1, e, r, n) {
                return e = nt({}, e, {
                    zoom: Math.floor(e.zoom)
                }), super.evaluate(t1, e, r, n);
            }
        }
        let Rp;
        function Fp(t1, e) {
            return e > 0 ? e + 2 * t1 : t1;
        }
        const Op = ys([
            {
                name: "a_pos_offset",
                components: 4,
                type: "Int16"
            },
            {
                name: "a_tex_size",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_pixeloffset",
                components: 4,
                type: "Int16"
            }
        ], 4), Np = ys([
            {
                name: "a_globe_anchor",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_globe_normal",
                components: 3,
                type: "Float32"
            }
        ], 4), Up = ys([
            {
                name: "a_projected_pos",
                components: 4,
                type: "Float32"
            }
        ], 4);
        ys([
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint32"
            }
        ], 4);
        const jp = ys([
            {
                name: "a_auto_z_offset",
                components: 1,
                type: "Float32"
            }
        ], 4), qp = ys([
            {
                name: "a_texb",
                components: 2,
                type: "Uint16"
            }
        ]), $p = ys([
            {
                name: "a_placed",
                components: 2,
                type: "Uint8"
            },
            {
                name: "a_shift",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_elevation_from_sea",
                components: 2,
                type: "Float32"
            }
        ]), Gp = ys([
            {
                name: "a_size_scale",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_padding",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_auto_z_offset",
                components: 1,
                type: "Float32"
            }
        ]);
        ys([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Int16",
                name: "tileAnchorX"
            },
            {
                type: "Int16",
                name: "tileAnchorY"
            },
            {
                type: "Float32",
                name: "x1"
            },
            {
                type: "Float32",
                name: "y1"
            },
            {
                type: "Float32",
                name: "x2"
            },
            {
                type: "Float32",
                name: "y2"
            },
            {
                type: "Int16",
                name: "padding"
            },
            {
                type: "Uint32",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "sourceLayerIndex"
            },
            {
                type: "Uint16",
                name: "bucketIndex"
            }
        ]);
        const Yp = ys([
            {
                name: "a_pos",
                components: 3,
                type: "Int16"
            },
            {
                name: "a_anchor_pos",
                components: 2,
                type: "Int16"
            },
            {
                name: "a_extrude",
                components: 2,
                type: "Int16"
            }
        ], 4), Xp = ys([
            {
                name: "a_pos_2f",
                components: 2,
                type: "Float32"
            },
            {
                name: "a_radius",
                components: 1,
                type: "Float32"
            },
            {
                name: "a_flags",
                components: 2,
                type: "Int16"
            }
        ], 4);
        ys([
            {
                name: "triangle",
                components: 3,
                type: "Uint16"
            }
        ]), ys([
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Float32",
                name: "tileAnchorX"
            },
            {
                type: "Float32",
                name: "tileAnchorY"
            },
            {
                type: "Uint16",
                name: "glyphStartIndex"
            },
            {
                type: "Uint16",
                name: "numGlyphs"
            },
            {
                type: "Uint32",
                name: "vertexStartIndex"
            },
            {
                type: "Uint32",
                name: "lineStartIndex"
            },
            {
                type: "Uint32",
                name: "lineLength"
            },
            {
                type: "Uint16",
                name: "segment"
            },
            {
                type: "Uint16",
                name: "lowerSize"
            },
            {
                type: "Uint16",
                name: "upperSize"
            },
            {
                type: "Float32",
                name: "lineOffsetX"
            },
            {
                type: "Float32",
                name: "lineOffsetY"
            },
            {
                type: "Uint8",
                name: "writingMode"
            },
            {
                type: "Uint8",
                name: "placedOrientation"
            },
            {
                type: "Uint8",
                name: "hidden"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Int16",
                name: "associatedIconIndex"
            },
            {
                type: "Uint8",
                name: "flipState"
            }
        ]), ys([
            {
                type: "Float32",
                name: "tileAnchorX"
            },
            {
                type: "Float32",
                name: "tileAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorX"
            },
            {
                type: "Int16",
                name: "projectedAnchorY"
            },
            {
                type: "Int16",
                name: "projectedAnchorZ"
            },
            {
                type: "Int16",
                name: "rightJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "centerJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "leftJustifiedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedTextSymbolIndex"
            },
            {
                type: "Int16",
                name: "placedIconSymbolIndex"
            },
            {
                type: "Int16",
                name: "verticalPlacedIconSymbolIndex"
            },
            {
                type: "Uint16",
                name: "key"
            },
            {
                type: "Uint16",
                name: "textBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "textBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalTextBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "iconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxStartIndex"
            },
            {
                type: "Uint16",
                name: "verticalIconBoxEndIndex"
            },
            {
                type: "Uint16",
                name: "featureIndex"
            },
            {
                type: "Uint16",
                name: "numHorizontalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalGlyphVertices"
            },
            {
                type: "Uint16",
                name: "numIconVertices"
            },
            {
                type: "Uint16",
                name: "numVerticalIconVertices"
            },
            {
                type: "Uint16",
                name: "useRuntimeCollisionCircles"
            },
            {
                type: "Uint32",
                name: "crossTileID"
            },
            {
                type: "Float32",
                components: 2,
                name: "textOffset"
            },
            {
                type: "Float32",
                name: "collisionCircleDiameter"
            },
            {
                type: "Float32",
                name: "zOffset"
            },
            {
                type: "Uint8",
                name: "hasIconTextFit"
            }
        ]), ys([
            {
                type: "Float32",
                name: "offsetX"
            }
        ]), ys([
            {
                type: "Int16",
                name: "x"
            },
            {
                type: "Int16",
                name: "y"
            }
        ]);
        var Zp = 24;
        const Hp = 128;
        function Wp(t1, e, r, n, i) {
            if ("camera" === t1.kind) return t1.maxSize;
            if ("composite" === t1.kind) {
                const n = e.possiblyEvaluate(new Va(t1.maxZoom), r).evaluate(i, {}, r), a = e.possiblyEvaluate(new Va(t1.minZoom), r).evaluate(i, {}, r);
                return Math.max(n, a);
            }
            return e.possiblyEvaluate(new Va(n)).evaluate(i, {}, r);
        }
        function Kp(t1, e) {
            const { expression: r } = e;
            if ("constant" === r.kind) return {
                kind: "constant",
                layoutSize: r.evaluate(new Va(t1 + 1))
            };
            if ("source" === r.kind) return {
                kind: "source"
            };
            {
                const { zoomStops: e, interpolationType: n } = r;
                let i = 0;
                for(; i < e.length && e[i] <= t1;)i++;
                i = Math.max(0, i - 1);
                let a = i;
                for(; a < e.length && e[a] < t1 + 1;)a++;
                a = Math.min(e.length - 1, a);
                const s = e[i], o = e[a];
                return "composite" === r.kind ? {
                    kind: "composite",
                    minZoom: s,
                    maxZoom: o,
                    interpolationType: n
                } : {
                    kind: "camera",
                    minZoom: s,
                    maxZoom: o,
                    minSize: r.evaluate(new Va(s)),
                    maxSize: r.evaluate(new Va(o)),
                    interpolationType: n
                };
            }
        }
        function Jp(t1, { uSize: e, uSizeT: r }, { lowerSize: n, upperSize: i }) {
            return "source" === t1.kind ? n / Hp : "composite" === t1.kind ? ze(n / Hp, i / Hp, r) : e;
        }
        function Qp(t1, e, r = 1) {
            let n = 0, i = 0;
            if ("constant" === t1.kind) i = t1.layoutSize * r;
            else if ("source" !== t1.kind) {
                const { interpolationType: a, minZoom: s, maxZoom: o } = t1, l = a ? Q(ai.interpolationFactor(a, e, s, o), 0, 1) : 0;
                "camera" === t1.kind ? i = ze(t1.minSize, t1.maxSize, l) * r : n = l * r;
            }
            return {
                uSizeT: n,
                uSize: i
            };
        }
        var tf = Object.freeze({
            __proto__: null,
            SIZE_PACK_FACTOR: Hp,
            evaluateSizeForFeature: Jp,
            evaluateSizeForZoom: Qp,
            getRasterizedIconSize: Wp,
            getSizeData: Kp
        });
        function ef(t1, e, r) {
            return t1.sections.forEach((t1)=>{
                t1.text = function(t1, e, r) {
                    const n = e.layout.get("text-transform").evaluate(r, {});
                    return "uppercase" === n ? t1 = t1.toLocaleUpperCase() : "lowercase" === n && (t1 = t1.toLocaleLowerCase()), Ba.applyArabicShaping && (t1 = Ba.applyArabicShaping(t1)), t1;
                }(t1.text, e, r);
            }), t1;
        }
        const rf = {
            "!": "ï¸",
            "#": "ï¼",
            $: "ï¼",
            "%": "ï¼",
            "&": "ï¼",
            "(": "ï¸µ",
            ")": "ï¸¶",
            "*": "ï¼",
            "+": "ï¼",
            ",": "ï¸",
            "-": "ï¸²",
            ".": "ã»",
            "/": "ï¼",
            ":": "ï¸",
            ";": "ï¸",
            "<": "ï¸¿",
            "=": "ï¼",
            ">": "ï¹",
            "?": "ï¸",
            "@": "ï¼ ",
            "[": "ï¹",
            "\\": "ï¼¼",
            "]": "ï¹",
            "^": "ï¼¾",
            _: "ï¸³",
            "`": "ï½",
            "{": "ï¸·",
            "|": "â",
            "}": "ï¸¸",
            "~": "ï½",
            "Â¢": "ï¿ ",
            "Â£": "ï¿¡",
            "Â¥": "ï¿¥",
            "Â¦": "ï¿¤",
            "Â¬": "ï¿¢",
            "Â¯": "ï¿£",
            "â": "ï¸²",
            "â": "ï¸±",
            "â": "ï¹",
            "â": "ï¹",
            "â": "ï¹",
            "â": "ï¹",
            "â¦": "ï¸",
            "â§": "ã»",
            "â©": "ï¿¦",
            "ã": "ï¸",
            "ã": "ï¸",
            "ã": "ï¸¿",
            "ã": "ï¹",
            "ã": "ï¸½",
            "ã": "ï¸¾",
            "ã": "ï¹",
            "ã": "ï¹",
            "ã": "ï¹",
            "ã": "ï¹",
            "ã": "ï¸»",
            "ã": "ï¸¼",
            "ã": "ï¸¹",
            "ã": "ï¸º",
            "ã": "ï¸",
            "ã": "ï¸",
            "ï¼": "ï¸",
            "ï¼": "ï¸µ",
            "ï¼": "ï¸¶",
            "ï¼": "ï¸",
            "ï¼": "ï¸²",
            "ï¼": "ã»",
            "ï¼": "ï¸",
            "ï¼": "ï¸",
            "ï¼": "ï¸¿",
            "ï¼": "ï¹",
            "ï¼": "ï¸",
            "ï¼»": "ï¹",
            "ï¼½": "ï¹",
            "ï¼¿": "ï¸³",
            "ï½": "ï¸·",
            "ï½": "â",
            "ï½": "ï¸¸",
            "ï½": "ï¸µ",
            "ï½ ": "ï¸¶",
            "ï½¡": "ï¸",
            "ï½¢": "ï¹",
            "ï½£": "ï¹",
            "â": "â",
            "â": "â"
        };
        function nf(t1) {
            return "ï¸¶" === t1 || "ï¹" === t1 || "ï¸¸" === t1 || "ï¹" === t1 || "ï¹" === t1 || "ï¸¾" === t1 || "ï¸¼" === t1 || "ï¸º" === t1 || "ï¸" === t1 || "ï¹" === t1 || "ï¸" === t1 || "ï¸" === t1 || "ï¸" === t1 || "ï½" === t1 || "ï¿£" === t1 || "ï¸" === t1 || "ï¸" === t1;
        }
        function af(t1) {
            return "ï¸µ" === t1 || "ï¹" === t1 || "ï¸·" === t1 || "ï¹" === t1 || "ï¹" === t1 || "ï¸½" === t1 || "ï¸»" === t1 || "ï¸¹" === t1 || "ï¸" === t1 || "ï¸¿" === t1;
        }
        var sf, of, lf, uf = {};
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ function cf() {
            return sf || (sf = 1, uf.read = function(t1, e, r, n, i) {
                var a, s, o = 8 * i - n - 1, l = (1 << o) - 1, u = l >> 1, c = -7, h = r ? i - 1 : 0, p = r ? -1 : 1, f = t1[e + h];
                for(h += p, a = f & (1 << -c) - 1, f >>= -c, c += o; c > 0; a = 256 * a + t1[e + h], h += p, c -= 8);
                for(s = a & (1 << -c) - 1, a >>= -c, c += n; c > 0; s = 256 * s + t1[e + h], h += p, c -= 8);
                if (0 === a) a = 1 - u;
                else {
                    if (a === l) return s ? NaN : 1 / 0 * (f ? -1 : 1);
                    s += Math.pow(2, n), a -= u;
                }
                return (f ? -1 : 1) * s * Math.pow(2, a - n);
            }, uf.write = function(t1, e, r, n, i, a) {
                var s, o, l, u = 8 * a - i - 1, c = (1 << u) - 1, h = c >> 1, p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : a - 1, d = n ? 1 : -1, m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
                for(e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, s = c) : (s = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -s)) < 1 && (s--, l *= 2), (e += s + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (s++, l /= 2), s + h >= c ? (o = 0, s = c) : s + h >= 1 ? (o = (e * l - 1) * Math.pow(2, i), s += h) : (o = e * Math.pow(2, h - 1) * Math.pow(2, i), s = 0)); i >= 8; t1[r + f] = 255 & o, f += d, o /= 256, i -= 8);
                for(s = s << i | o, u += i; u > 0; t1[r + f] = 255 & s, f += d, s /= 256, u -= 8);
                t1[r + f - d] |= 128 * m;
            }), uf;
        }
        function hf() {
            if (lf) return of;
            lf = 1, of = e;
            var t1 = cf();
            function e(t1) {
                this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t1) ? t1 : new Uint8Array(t1 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
            }
            e.Varint = 0, e.Fixed64 = 1, e.Bytes = 2, e.Fixed32 = 5;
            var r = 4294967296, n = 1 / r, i = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
            function a(t1) {
                return t1.type === e.Bytes ? t1.readVarint() + t1.pos : t1.pos + 1;
            }
            function s(t1, e, r) {
                return r ? 4294967296 * e + (t1 >>> 0) : 4294967296 * (e >>> 0) + (t1 >>> 0);
            }
            function o(t1, e, r) {
                var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
                r.realloc(n);
                for(var i = r.pos - 1; i >= t1; i--)r.buf[i + n] = r.buf[i];
            }
            function l(t1, e) {
                for(var r = 0; r < t1.length; r++)e.writeVarint(t1[r]);
            }
            function u(t1, e) {
                for(var r = 0; r < t1.length; r++)e.writeSVarint(t1[r]);
            }
            function c(t1, e) {
                for(var r = 0; r < t1.length; r++)e.writeFloat(t1[r]);
            }
            function h(t1, e) {
                for(var r = 0; r < t1.length; r++)e.writeDouble(t1[r]);
            }
            function p(t1, e) {
                for(var r = 0; r < t1.length; r++)e.writeBoolean(t1[r]);
            }
            function f(t1, e) {
                for(var r = 0; r < t1.length; r++)e.writeFixed32(t1[r]);
            }
            function d(t1, e) {
                for(var r = 0; r < t1.length; r++)e.writeSFixed32(t1[r]);
            }
            function m(t1, e) {
                for(var r = 0; r < t1.length; r++)e.writeFixed64(t1[r]);
            }
            function y(t1, e) {
                for(var r = 0; r < t1.length; r++)e.writeSFixed64(t1[r]);
            }
            function g(t1, e) {
                return (t1[e] | t1[e + 1] << 8 | t1[e + 2] << 16) + 16777216 * t1[e + 3];
            }
            function x(t1, e, r) {
                t1[r] = e, t1[r + 1] = e >>> 8, t1[r + 2] = e >>> 16, t1[r + 3] = e >>> 24;
            }
            function v(t1, e) {
                return (t1[e] | t1[e + 1] << 8 | t1[e + 2] << 16) + (t1[e + 3] << 24);
            }
            return e.prototype = {
                destroy: function() {
                    this.buf = null;
                },
                readFields: function(t1, e, r) {
                    for(r = r || this.length; this.pos < r;){
                        var n = this.readVarint(), i = n >> 3, a = this.pos;
                        this.type = 7 & n, t1(i, e, this), this.pos === a && this.skip(n);
                    }
                    return e;
                },
                readMessage: function(t1, e) {
                    return this.readFields(t1, e, this.readVarint() + this.pos);
                },
                readFixed32: function() {
                    var t1 = g(this.buf, this.pos);
                    return this.pos += 4, t1;
                },
                readSFixed32: function() {
                    var t1 = v(this.buf, this.pos);
                    return this.pos += 4, t1;
                },
                readFixed64: function() {
                    var t1 = g(this.buf, this.pos) + g(this.buf, this.pos + 4) * r;
                    return this.pos += 8, t1;
                },
                readSFixed64: function() {
                    var t1 = g(this.buf, this.pos) + v(this.buf, this.pos + 4) * r;
                    return this.pos += 8, t1;
                },
                readFloat: function() {
                    var e = t1.read(this.buf, this.pos, !0, 23, 4);
                    return this.pos += 4, e;
                },
                readDouble: function() {
                    var e = t1.read(this.buf, this.pos, !0, 52, 8);
                    return this.pos += 8, e;
                },
                readVarint: function(t1) {
                    var e, r, n = this.buf;
                    return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function(t1, e, r) {
                        var n, i, a = r.buf;
                        if (n = (112 & (i = a[r.pos++])) >> 4, i < 128) return s(t1, n, e);
                        if (n |= (127 & (i = a[r.pos++])) << 3, i < 128) return s(t1, n, e);
                        if (n |= (127 & (i = a[r.pos++])) << 10, i < 128) return s(t1, n, e);
                        if (n |= (127 & (i = a[r.pos++])) << 17, i < 128) return s(t1, n, e);
                        if (n |= (127 & (i = a[r.pos++])) << 24, i < 128) return s(t1, n, e);
                        if (n |= (1 & (i = a[r.pos++])) << 31, i < 128) return s(t1, n, e);
                        throw new Error("Expected varint not more than 10 bytes");
                    }(e |= (15 & (r = n[this.pos])) << 28, t1, this))));
                },
                readVarint64: function() {
                    return this.readVarint(!0);
                },
                readSVarint: function() {
                    var t1 = this.readVarint();
                    return t1 % 2 == 1 ? (t1 + 1) / -2 : t1 / 2;
                },
                readBoolean: function() {
                    return Boolean(this.readVarint());
                },
                readString: function() {
                    var t1 = this.readVarint() + this.pos, e = this.pos;
                    return this.pos = t1, t1 - e >= 12 && i ? function(t1, e, r) {
                        return i.decode(t1.subarray(e, r));
                    }(this.buf, e, t1) : function(t1, e, r) {
                        for(var n = "", i = e; i < r;){
                            var a, s, o, l = t1[i], u = null, c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                            if (i + c > r) break;
                            1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (a = t1[i + 1])) && (u = (31 & l) << 6 | 63 & a) <= 127 && (u = null) : 3 === c ? (s = t1[i + 2], 128 == (192 & (a = t1[i + 1])) && 128 == (192 & s) && ((u = (15 & l) << 12 | (63 & a) << 6 | 63 & s) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (s = t1[i + 2], o = t1[i + 3], 128 == (192 & (a = t1[i + 1])) && 128 == (192 & s) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & a) << 12 | (63 & s) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c;
                        }
                        return n;
                    }(this.buf, e, t1);
                },
                readBytes: function() {
                    var t1 = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t1);
                    return this.pos = t1, e;
                },
                readPackedVarint: function(t1, r) {
                    if (this.type !== e.Bytes) return t1.push(this.readVarint(r));
                    var n = a(this);
                    for(t1 = t1 || []; this.pos < n;)t1.push(this.readVarint(r));
                    return t1;
                },
                readPackedSVarint: function(t1) {
                    if (this.type !== e.Bytes) return t1.push(this.readSVarint());
                    var r = a(this);
                    for(t1 = t1 || []; this.pos < r;)t1.push(this.readSVarint());
                    return t1;
                },
                readPackedBoolean: function(t1) {
                    if (this.type !== e.Bytes) return t1.push(this.readBoolean());
                    var r = a(this);
                    for(t1 = t1 || []; this.pos < r;)t1.push(this.readBoolean());
                    return t1;
                },
                readPackedFloat: function(t1) {
                    if (this.type !== e.Bytes) return t1.push(this.readFloat());
                    var r = a(this);
                    for(t1 = t1 || []; this.pos < r;)t1.push(this.readFloat());
                    return t1;
                },
                readPackedDouble: function(t1) {
                    if (this.type !== e.Bytes) return t1.push(this.readDouble());
                    var r = a(this);
                    for(t1 = t1 || []; this.pos < r;)t1.push(this.readDouble());
                    return t1;
                },
                readPackedFixed32: function(t1) {
                    if (this.type !== e.Bytes) return t1.push(this.readFixed32());
                    var r = a(this);
                    for(t1 = t1 || []; this.pos < r;)t1.push(this.readFixed32());
                    return t1;
                },
                readPackedSFixed32: function(t1) {
                    if (this.type !== e.Bytes) return t1.push(this.readSFixed32());
                    var r = a(this);
                    for(t1 = t1 || []; this.pos < r;)t1.push(this.readSFixed32());
                    return t1;
                },
                readPackedFixed64: function(t1) {
                    if (this.type !== e.Bytes) return t1.push(this.readFixed64());
                    var r = a(this);
                    for(t1 = t1 || []; this.pos < r;)t1.push(this.readFixed64());
                    return t1;
                },
                readPackedSFixed64: function(t1) {
                    if (this.type !== e.Bytes) return t1.push(this.readSFixed64());
                    var r = a(this);
                    for(t1 = t1 || []; this.pos < r;)t1.push(this.readSFixed64());
                    return t1;
                },
                skip: function(t1) {
                    var r = 7 & t1;
                    if (r === e.Varint) for(; this.buf[this.pos++] > 127;);
                    else if (r === e.Bytes) this.pos = this.readVarint() + this.pos;
                    else if (r === e.Fixed32) this.pos += 4;
                    else {
                        if (r !== e.Fixed64) throw new Error("Unimplemented type: " + r);
                        this.pos += 8;
                    }
                },
                writeTag: function(t1, e) {
                    this.writeVarint(t1 << 3 | e);
                },
                realloc: function(t1) {
                    for(var e = this.length || 16; e < this.pos + t1;)e *= 2;
                    if (e !== this.length) {
                        var r = new Uint8Array(e);
                        r.set(this.buf), this.buf = r, this.length = e;
                    }
                },
                finish: function() {
                    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
                },
                writeFixed32: function(t1) {
                    this.realloc(4), x(this.buf, t1, this.pos), this.pos += 4;
                },
                writeSFixed32: function(t1) {
                    this.realloc(4), x(this.buf, t1, this.pos), this.pos += 4;
                },
                writeFixed64: function(t1) {
                    this.realloc(8), x(this.buf, -1 & t1, this.pos), x(this.buf, Math.floor(t1 * n), this.pos + 4), this.pos += 8;
                },
                writeSFixed64: function(t1) {
                    this.realloc(8), x(this.buf, -1 & t1, this.pos), x(this.buf, Math.floor(t1 * n), this.pos + 4), this.pos += 8;
                },
                writeVarint: function(t1) {
                    (t1 = +t1 || 0) > 268435455 || t1 < 0 ? function(t1, e) {
                        var r, n;
                        if (t1 >= 0 ? (r = t1 % 4294967296 | 0, n = t1 / 4294967296 | 0) : (n = ~(-t1 / 4294967296), 4294967295 ^ (r = ~(-t1 % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t1 >= 0x10000000000000000 || t1 < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes");
                        e.realloc(10), function(t1, e, r) {
                            r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, t1 >>>= 7, r.buf[r.pos++] = 127 & t1 | 128, r.buf[r.pos] = 127 & (t1 >>>= 7);
                        }(r, 0, e), function(t1, e) {
                            var r = (7 & t1) << 4;
                            e.buf[e.pos++] |= r | ((t1 >>>= 3) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1 | ((t1 >>>= 7) ? 128 : 0), t1 && (e.buf[e.pos++] = 127 & t1)))));
                        }(n, e);
                    }(t1, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t1 | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = 127 & (t1 >>>= 7) | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = 127 & (t1 >>>= 7) | (t1 > 127 ? 128 : 0), t1 <= 127 || (this.buf[this.pos++] = t1 >>> 7 & 127))));
                },
                writeSVarint: function(t1) {
                    this.writeVarint(t1 < 0 ? 2 * -t1 - 1 : 2 * t1);
                },
                writeBoolean: function(t1) {
                    this.writeVarint(Boolean(t1));
                },
                writeString: function(t1) {
                    t1 = String(t1), this.realloc(4 * t1.length), this.pos++;
                    var e = this.pos;
                    this.pos = function(t1, e, r) {
                        for(var n, i, a = 0; a < e.length; a++){
                            if ((n = e.charCodeAt(a)) > 55295 && n < 57344) {
                                if (!i) {
                                    n > 56319 || a + 1 === e.length ? (t1[r++] = 239, t1[r++] = 191, t1[r++] = 189) : i = n;
                                    continue;
                                }
                                if (n < 56320) {
                                    t1[r++] = 239, t1[r++] = 191, t1[r++] = 189, i = n;
                                    continue;
                                }
                                n = i - 55296 << 10 | n - 56320 | 65536, i = null;
                            } else i && (t1[r++] = 239, t1[r++] = 191, t1[r++] = 189, i = null);
                            n < 128 ? t1[r++] = n : (n < 2048 ? t1[r++] = n >> 6 | 192 : (n < 65536 ? t1[r++] = n >> 12 | 224 : (t1[r++] = n >> 18 | 240, t1[r++] = n >> 12 & 63 | 128), t1[r++] = n >> 6 & 63 | 128), t1[r++] = 63 & n | 128);
                        }
                        return r;
                    }(this.buf, t1, this.pos);
                    var r = this.pos - e;
                    r >= 128 && o(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;
                },
                writeFloat: function(e) {
                    this.realloc(4), t1.write(this.buf, e, this.pos, !0, 23, 4), this.pos += 4;
                },
                writeDouble: function(e) {
                    this.realloc(8), t1.write(this.buf, e, this.pos, !0, 52, 8), this.pos += 8;
                },
                writeBytes: function(t1) {
                    var e = t1.length;
                    this.writeVarint(e), this.realloc(e);
                    for(var r = 0; r < e; r++)this.buf[this.pos++] = t1[r];
                },
                writeRawMessage: function(t1, e) {
                    this.pos++;
                    var r = this.pos;
                    t1(e, this);
                    var n = this.pos - r;
                    n >= 128 && o(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;
                },
                writeMessage: function(t1, r, n) {
                    this.writeTag(t1, e.Bytes), this.writeRawMessage(r, n);
                },
                writePackedVarint: function(t1, e) {
                    e.length && this.writeMessage(t1, l, e);
                },
                writePackedSVarint: function(t1, e) {
                    e.length && this.writeMessage(t1, u, e);
                },
                writePackedBoolean: function(t1, e) {
                    e.length && this.writeMessage(t1, p, e);
                },
                writePackedFloat: function(t1, e) {
                    e.length && this.writeMessage(t1, c, e);
                },
                writePackedDouble: function(t1, e) {
                    e.length && this.writeMessage(t1, h, e);
                },
                writePackedFixed32: function(t1, e) {
                    e.length && this.writeMessage(t1, f, e);
                },
                writePackedSFixed32: function(t1, e) {
                    e.length && this.writeMessage(t1, d, e);
                },
                writePackedFixed64: function(t1, e) {
                    e.length && this.writeMessage(t1, m, e);
                },
                writePackedSFixed64: function(t1, e) {
                    e.length && this.writeMessage(t1, y, e);
                },
                writeBytesField: function(t1, r) {
                    this.writeTag(t1, e.Bytes), this.writeBytes(r);
                },
                writeFixed32Field: function(t1, r) {
                    this.writeTag(t1, e.Fixed32), this.writeFixed32(r);
                },
                writeSFixed32Field: function(t1, r) {
                    this.writeTag(t1, e.Fixed32), this.writeSFixed32(r);
                },
                writeFixed64Field: function(t1, r) {
                    this.writeTag(t1, e.Fixed64), this.writeFixed64(r);
                },
                writeSFixed64Field: function(t1, r) {
                    this.writeTag(t1, e.Fixed64), this.writeSFixed64(r);
                },
                writeVarintField: function(t1, r) {
                    this.writeTag(t1, e.Varint), this.writeVarint(r);
                },
                writeSVarintField: function(t1, r) {
                    this.writeTag(t1, e.Varint), this.writeSVarint(r);
                },
                writeStringField: function(t1, r) {
                    this.writeTag(t1, e.Bytes), this.writeString(r);
                },
                writeFloatField: function(t1, r) {
                    this.writeTag(t1, e.Fixed32), this.writeFloat(r);
                },
                writeDoubleField: function(t1, r) {
                    this.writeTag(t1, e.Fixed64), this.writeDouble(r);
                },
                writeBooleanField: function(t1, e) {
                    this.writeVarintField(t1, Boolean(e));
                }
            }, of;
        }
        var pf = e(hf());
        const ff = 3;
        function df(t1, e, r) {
            e.glyphs = [], 1 === t1 && r.readMessage(mf, e);
        }
        function mf(t1, e, r) {
            if (3 === t1) {
                const { id: t1, bitmap: n, width: i, height: a, left: s, top: o, advance: l } = r.readMessage(yf, {});
                e.glyphs.push({
                    id: t1,
                    bitmap: new ac({
                        width: i + 2 * ff,
                        height: a + 2 * ff
                    }, n),
                    metrics: {
                        width: i,
                        height: a,
                        left: s,
                        top: o,
                        advance: l
                    }
                });
            } else 4 === t1 ? e.ascender = r.readSVarint() : 5 === t1 && (e.descender = r.readSVarint());
        }
        function yf(t1, e, r) {
            1 === t1 ? e.id = r.readVarint() : 2 === t1 ? e.bitmap = r.readBytes() : 3 === t1 ? e.width = r.readVarint() : 4 === t1 ? e.height = r.readVarint() : 5 === t1 ? e.left = r.readSVarint() : 6 === t1 ? e.top = r.readSVarint() : 7 === t1 && (e.advance = r.readVarint());
        }
        const gf = ff, xf = {
            horizontal: 1,
            vertical: 2,
            horizontalOnly: 3
        };
        class vf {
            constructor(){
                this.scale = 1, this.fontStack = "", this.image = null;
            }
            static forText(t1, e) {
                const r = new vf;
                return r.scale = t1 || 1, r.fontStack = e, r;
            }
            static forImage(t1) {
                const e = new vf;
                return e.image = t1, e;
            }
        }
        class bf {
            constructor(){
                this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t1, e) {
                const r = new bf;
                for(let n = 0; n < t1.sections.length; n++){
                    const i = t1.sections[n];
                    i.image ? r.addImageSection(i) : r.addTextSection(i, e);
                }
                return r;
            }
            length() {
                return this.text.length;
            }
            getSection(t1) {
                return this.sections[this.sectionIndex[t1]];
            }
            getSections() {
                return this.sections;
            }
            getSectionIndex(t1) {
                return this.sectionIndex[t1];
            }
            getCodePoint(t1) {
                return this.text.codePointAt(t1);
            }
            verticalizePunctuation(t1) {
                this.text = function(t1, e) {
                    let r = "";
                    for(let n = 0; n < t1.length; n++){
                        const i = t1.charCodeAt(n + 1) || null, a = t1.charCodeAt(n - 1) || null;
                        r += !e && (i && ga(i) && !rf[t1[n + 1]] || a && ga(a) && !rf[t1[n - 1]]) || !rf[t1[n]] ? t1[n] : rf[t1[n]];
                    }
                    return r;
                }(this.text, t1);
            }
            trim() {
                let t1 = 0;
                for(let e = 0; e < this.text.length && wf[this.text.charCodeAt(e)]; e++)t1++;
                let e = this.text.length;
                for(let r = this.text.length - 1; r >= 0 && r >= t1 && wf[this.text.charCodeAt(r)]; r--)e--;
                this.text = this.text.substring(t1, e), this.sectionIndex = this.sectionIndex.slice(t1, e);
            }
            substring(t1, e) {
                const r = new bf;
                return r.text = this.text.substring(t1, e), r.sectionIndex = this.sectionIndex.slice(t1, e), r.sections = this.sections, r;
            }
            toString() {
                return this.text;
            }
            getMaxScale() {
                return this.sectionIndex.reduce((t1, e)=>Math.max(t1, this.sections[e].scale), 0);
            }
            addTextSection(t1, e) {
                this.text += t1.text, this.sections.push(vf.forText(t1.scale, t1.fontStack || e));
                const r = this.sections.length - 1;
                for(let e = 0; e < t1.text.length; ++e)this.sectionIndex.push(r);
            }
            addImageSection(t1) {
                const e = t1.image && t1.image.namePrimary ? t1.image.getPrimary() : null;
                if (!e) return void ft("Can't add FormattedSection with an empty image.");
                const r = this.getNextImageSectionCharCode();
                r ? (this.text += String.fromCodePoint(r), this.sections.push(vf.forImage(e)), this.sectionIndex.push(this.sections.length - 1)) : ft("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
                return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
        }
        function _f(t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d) {
            const m = bf.fromFeature(t1, i);
            h === xf.vertical && m.verticalizePunctuation(p);
            let y = [];
            const g = function(t1, e, r, n, i, a) {
                if (!t1) return [];
                const s = [], o = function(t1, e, r, n, i, a) {
                    let s = 0;
                    for(let r = 0; r < t1.length(); r++){
                        const o = t1.getSection(r);
                        s += Af(t1.getCodePoint(r), o, n, i, e, a);
                    }
                    return s / Math.max(1, Math.ceil(s / r));
                }(t1, e, r, n, i, a), l = t1.text.indexOf("â") >= 0;
                let u = 0;
                for(let r = 0; r < t1.length(); r++){
                    const h = t1.getSection(r), p = t1.getCodePoint(r);
                    if (wf[p] || (u += Af(p, h, n, i, e, a)), r < t1.length() - 1) {
                        const e = !((c = p) < 11904 || !(pa["Bopomofo Extended"](c) || pa.Bopomofo(c) || pa["CJK Compatibility Forms"](c) || pa["CJK Compatibility Ideographs"](c) || pa["CJK Compatibility"](c) || pa["CJK Radicals Supplement"](c) || pa["CJK Strokes"](c) || pa["CJK Symbols and Punctuation"](c) || pa["CJK Unified Ideographs Extension A"](c) || pa["CJK Unified Ideographs"](c) || pa["Enclosed CJK Letters and Months"](c) || pa["Halfwidth and Fullwidth Forms"](c) || pa.Hiragana(c) || pa["Ideographic Description Characters"](c) || pa["Kangxi Radicals"](c) || pa["Katakana Phonetic Extensions"](c) || pa.Katakana(c) || pa["Vertical Forms"](c) || pa["Yi Radicals"](c) || pa["Yi Syllables"](c)));
                        (Mf[p] || e || h.image) && s.push(Pf(r + 1, u, o, s, If(p, t1.getCodePoint(r + 1), e && l), !1));
                    }
                }
                var c;
                return zf(Pf(t1.length(), u, o, s, 0, !0));
            }(m, u, a, e, n, f), { processBidirectionalText: x, processStyledBidirectionalText: v } = Ba;
            if (x && 1 === m.sections.length) {
                const t1 = x(m.toString(), g);
                for (const e of t1){
                    const t1 = new bf;
                    t1.text = e, t1.sections = m.sections;
                    for(let r = 0; r < e.length; r++)t1.sectionIndex.push(0);
                    y.push(t1);
                }
            } else if (v) {
                const t1 = v(m.text, m.sectionIndex, g);
                for (const e of t1){
                    const t1 = new bf;
                    t1.text = e[0], t1.sectionIndex = e[1], t1.sections = m.sections, y.push(t1);
                }
            } else y = function(t1, e) {
                const r = [], n = t1.text;
                let i = 0;
                for (const n of e)r.push(t1.substring(i, n)), i = n;
                return i < n.length && r.push(t1.substring(i, n.length)), r;
            }(m, g);
            const b = [], _ = {
                positionedLines: b,
                text: m.toString(),
                top: c[1],
                bottom: c[1],
                left: c[0],
                right: c[0],
                writingMode: h,
                iconsInText: !1,
                verticalizable: !1,
                hasBaseline: !1
            };
            return function(t1, e, r, n, i, a, s, o, l, u, c, h) {
                let p = 0, f = 0, d = 0;
                const m = "right" === o ? 1 : "left" === o ? 0 : .5;
                let y = !1;
                for (const t1 of i){
                    const r = t1.getSections();
                    for (const t1 of r){
                        if (t1.image) continue;
                        const r = e[t1.fontStack];
                        if (r && (y = void 0 !== r.ascender && void 0 !== r.descender, !y)) break;
                    }
                    if (!y) break;
                }
                let g = 0;
                for (const s of i){
                    s.trim();
                    const i = s.getMaxScale(), o = (i - 1) * Zp, v = {
                        positionedGlyphs: [],
                        lineOffset: 0
                    };
                    t1.positionedLines[g] = v;
                    const b = v.positionedGlyphs;
                    let _ = 0;
                    if (!s.length()) {
                        f += a, ++g;
                        continue;
                    }
                    let w = 0, M = 0;
                    for(let a = 0; a < s.length(); a++){
                        const o = s.getSection(a), d = s.getSectionIndex(a), m = s.getCodePoint(a);
                        let g = o.scale, v = null, A = null, S = null, I = Zp, P = 0;
                        const z = !(l === xf.horizontal || !c && !ya(m) || c && (wf[m] || (x = m, pa.Arabic(x) || pa["Arabic Supplement"](x) || pa["Arabic Extended-A"](x) || pa["Arabic Presentation Forms-A"](x) || pa["Arabic Presentation Forms-B"](x))));
                        if (o.image) {
                            const e = n[o.image.serialize()];
                            if (!e) continue;
                            S = o.image.id, t1.iconsInText = t1.iconsInText || !0, A = e.paddedRect;
                            const r = e.displaySize;
                            g = g * Zp / h, v = {
                                width: r[0],
                                height: r[1],
                                left: 0,
                                top: -gf,
                                advance: z ? r[1] : r[0],
                                localGlyph: !1
                            }, P = y ? -v.height * g : i * Zp - 17 - r[1] * g, I = v.advance;
                            const a = (z ? r[0] : r[1]) * g - Zp * i;
                            a > 0 && a > _ && (_ = a);
                        } else {
                            const t1 = r[o.fontStack];
                            if (!t1) continue;
                            t1[m] && (A = t1[m]);
                            const n = e[o.fontStack];
                            if (!n) continue;
                            const a = n.glyphs[m];
                            if (!a) continue;
                            if (v = a.metrics, I = 8203 !== m ? Zp : 0, y) {
                                const t1 = void 0 !== n.ascender ? Math.abs(n.ascender) : 0, e = void 0 !== n.descender ? Math.abs(n.descender) : 0, r = (t1 + e) * g;
                                w < r && (w = r, M = (t1 - e) / 2 * g), P = -t1 * g;
                            } else P = (i - g) * Zp - 17;
                        }
                        z ? (t1.verticalizable = !0, b.push({
                            glyph: m,
                            imageName: S,
                            x: p,
                            y: f + P,
                            vertical: z,
                            scale: g,
                            localGlyph: v.localGlyph,
                            fontStack: o.fontStack,
                            sectionIndex: d,
                            metrics: v,
                            rect: A
                        }), p += I * g + u) : (b.push({
                            glyph: m,
                            imageName: S,
                            x: p,
                            y: f + P,
                            vertical: z,
                            scale: g,
                            localGlyph: v.localGlyph,
                            fontStack: o.fontStack,
                            sectionIndex: d,
                            metrics: v,
                            rect: A
                        }), p += v.advance * g + u);
                    }
                    0 !== b.length && (d = Math.max(p - u, d), y ? kf(b, m, _, M, a * i / 2) : kf(b, m, _, 0, a / 2)), p = 0;
                    const A = a * i + _;
                    v.lineOffset = Math.max(_, o), f += A, ++g;
                }
                var x;
                const v = f, { horizontalAlign: b, verticalAlign: _ } = Ef(s);
                (function(t1, e, r, n, i, a) {
                    const s = (e - r) * i, o = -a * n;
                    for (const e of t1)for (const t1 of e.positionedGlyphs)t1.x += s, t1.y += o;
                })(t1.positionedLines, m, b, _, d, v), t1.top += -_ * v, t1.bottom = t1.top + v, t1.left += -b * d, t1.right = t1.left + d, t1.hasBaseline = y;
            }(_, e, r, n, y, s, o, l, h, u, p, d), !function(t1) {
                for (const e of t1)if (0 !== e.positionedGlyphs.length) return !1;
                return !0;
            }(b) && _;
        }
        const wf = {
            9: !0,
            10: !0,
            11: !0,
            12: !0,
            13: !0,
            32: !0
        }, Mf = {
            10: !0,
            32: !0,
            38: !0,
            40: !0,
            41: !0,
            43: !0,
            45: !0,
            47: !0,
            173: !0,
            183: !0,
            8203: !0,
            8208: !0,
            8211: !0,
            8231: !0
        };
        function Af(t1, e, r, n, i, a) {
            if (e.image) {
                const t1 = n[e.image.serialize()];
                return t1 ? t1.displaySize[0] * e.scale * Zp / a + i : 0;
            }
            {
                const n = r[e.fontStack], a = n && n.glyphs[t1];
                return a ? a.metrics.advance * e.scale + i : 0;
            }
        }
        function Sf(t1, e, r, n) {
            const i = Math.pow(t1 - e, 2);
            return n ? t1 < e ? i / 2 : 2 * i : i + Math.abs(r) * r;
        }
        function If(t1, e, r) {
            let n = 0;
            return 10 === t1 && (n -= 1e4), r && (n += 150), 40 !== t1 && 65288 !== t1 || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;
        }
        function Pf(t1, e, r, n, i, a) {
            let s = null, o = Sf(e, r, i, a);
            for (const t1 of n){
                const n = Sf(e - t1.x, r, i, a) + t1.badness;
                n <= o && (s = t1, o = n);
            }
            return {
                index: t1,
                x: e,
                priorBreak: s,
                badness: o
            };
        }
        function zf(t1) {
            return t1 ? zf(t1.priorBreak).concat(t1.index) : [];
        }
        function Ef(t1) {
            let e = .5, r = .5;
            switch(t1){
                case "right":
                case "top-right":
                case "bottom-right":
                    e = 1;
                    break;
                case "left":
                case "top-left":
                case "bottom-left":
                    e = 0;
            }
            switch(t1){
                case "bottom":
                case "bottom-right":
                case "bottom-left":
                    r = 1;
                    break;
                case "top":
                case "top-right":
                case "top-left":
                    r = 0;
            }
            return {
                horizontalAlign: e,
                verticalAlign: r
            };
        }
        function kf(t1, e, r, n, i) {
            if (!(e || r || n || i)) return;
            const a = t1.length - 1, s = t1[a], o = (s.x + s.metrics.advance * s.scale) * e;
            for(let e = 0; e <= a; e++)t1[e].x -= o, t1[e].y += r + n + i;
        }
        function Tf(t1, e, r, n) {
            const { horizontalAlign: i, verticalAlign: a } = Ef(n), s = r[0] - t1.displaySize[0] * i, o = r[1] - t1.displaySize[1] * a;
            return {
                imagePrimary: t1,
                imageSecondary: e,
                top: o,
                bottom: o + t1.displaySize[1],
                left: s,
                right: s + t1.displaySize[0]
            };
        }
        function Bf(t1, e, r, n, i, a) {
            const s = t1.imagePrimary;
            let o;
            if (s.content) {
                const t1 = s.content, e = s.pixelRatio || 1;
                o = [
                    t1[0] / e,
                    t1[1] / e,
                    s.displaySize[0] - t1[2] / e,
                    s.displaySize[1] - t1[3] / e
                ];
            }
            const l = e.left * a, u = e.right * a;
            let c, h, p, f;
            "width" === r || "both" === r ? (f = i[0] + l - n[3], h = i[0] + u + n[1]) : (f = i[0] + (l + u - s.displaySize[0]) / 2, h = f + s.displaySize[0]);
            const d = e.top * a, m = e.bottom * a;
            return "height" === r || "both" === r ? (c = i[1] + d - n[0], p = i[1] + m + n[2]) : (c = i[1] + (d + m - s.displaySize[1]) / 2, p = c + s.displaySize[1]), {
                imagePrimary: s,
                imageSecondary: void 0,
                top: c,
                right: h,
                bottom: p,
                left: f,
                collisionPadding: o
            };
        }
        class Vf extends q {
            constructor(t1, e, r, n, i){
                super(t1, e), this.angle = n, this.z = r, void 0 !== i && (this.segment = i);
            }
            clone() {
                return new Vf(this.x, this.y, this.z, this.angle, this.segment);
            }
        }
        function Cf(t1, e, r, n, i) {
            if (void 0 === e.segment) return !0;
            let a = e, s = e.segment + 1, o = 0;
            for(; o > -r / 2;){
                if (s--, s < 0) return !1;
                o -= t1[s].dist(a), a = t1[s];
            }
            o += t1[s].dist(t1[s + 1]), s++;
            const l = [];
            let u = 0;
            for(; o < r / 2;){
                const e = t1[s], r = t1[s + 1];
                if (!r) return !1;
                let a = t1[s - 1].angleTo(e) - e.angleTo(r);
                for(a = Math.abs((a + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({
                    distance: o,
                    angleDelta: a
                }), u += a; o - l[0].distance > n;)u -= l.shift().angleDelta;
                if (u > i) return !1;
                s++, o += e.dist(r);
            }
            return !0;
        }
        function Df(t1) {
            let e = 0;
            for(let r = 0; r < t1.length - 1; r++)e += t1[r].dist(t1[r + 1]);
            return e;
        }
        function Lf(t1, e, r) {
            return t1 ? .6 * e * r : 0;
        }
        function Rf(t1, e) {
            return Math.max(t1 ? t1.right - t1.left : 0, e ? e.right - e.left : 0);
        }
        function Ff(t1, e, r, n, i, a) {
            const s = Lf(r, i, a), o = Rf(r, n) * a;
            let l = 0;
            const u = Df(t1) / 2;
            for(let r = 0; r < t1.length - 1; r++){
                const n = t1[r], i = t1[r + 1], a = n.dist(i);
                if (l + a > u) {
                    const c = (u - l) / a, h = ze(n.x, i.x, c), p = ze(n.y, i.y, c), f = new Vf(h, p, 0, i.angleTo(n), r);
                    return !s || Cf(t1, f, o, s, e) ? f : void 0;
                }
                l += a;
            }
        }
        function Of(t1, e, r, n, i, a, s, o, l) {
            const u = Lf(n, a, s), c = Rf(n, i), h = c * s, p = 0 === t1[0].x || t1[0].x === l || 0 === t1[0].y || t1[0].y === l;
            return e - h < e / 4 && (e = h + e / 4), Nf(t1, p ? e / 2 * o % e : (c / 2 + 2 * a) * s * o % e, e, u, r, h, p, !1, l);
        }
        function Nf(t1, e, r, n, i, a, s, o, l) {
            const u = a / 2, c = Df(t1);
            let h = 0, p = e - r, f = [];
            for(let e = 0; e < t1.length - 1; e++){
                const s = t1[e], o = t1[e + 1], d = s.dist(o), m = o.angleTo(s);
                for(; p + r < h + d;){
                    p += r;
                    const y = (p - h) / d, g = ze(s.x, o.x, y), x = ze(s.y, o.y, y);
                    if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {
                        const r = new Vf(g, x, 0, m, e);
                        n && !Cf(t1, r, a, n, i) || f.push(r);
                    }
                }
                h += d;
            }
            return o || f.length || s || (f = Nf(t1, h / 2, r, n, i, a, s, !0, l)), f;
        }
        function Uf(t1, e, r, n, i) {
            const a = [];
            for(let s = 0; s < t1.length; s++){
                const o = t1[s];
                let l;
                for(let t1 = 0; t1 < o.length - 1; t1++){
                    let s = o[t1], u = o[t1 + 1];
                    s.x < e && u.x < e || (s.x < e ? s = new q(e, s.y + (e - s.x) / (u.x - s.x) * (u.y - s.y))._round() : u.x < e && (u = new q(e, s.y + (e - s.x) / (u.x - s.x) * (u.y - s.y))._round()), s.y < r && u.y < r || (s.y < r ? s = new q(s.x + (r - s.y) / (u.y - s.y) * (u.x - s.x), r)._round() : u.y < r && (u = new q(s.x + (r - s.y) / (u.y - s.y) * (u.x - s.x), r)._round()), s.x >= n && u.x >= n || (s.x >= n ? s = new q(n, s.y + (n - s.x) / (u.x - s.x) * (u.y - s.y))._round() : u.x >= n && (u = new q(n, s.y + (n - s.x) / (u.x - s.x) * (u.y - s.y))._round()), s.y >= i && u.y >= i || (s.y >= i ? s = new q(s.x + (i - s.y) / (u.y - s.y) * (u.x - s.x), i)._round() : u.y >= i && (u = new q(s.x + (i - s.y) / (u.y - s.y) * (u.x - s.x), i)._round()), l && s.equals(l[l.length - 1]) || (l = [
                        s
                    ], a.push(l)), l.push(u)))));
                }
            }
            return a;
        }
        function jf(t1) {
            let e = 0, r = 0;
            for (const n of t1)e += n.w * n.h, r = Math.max(r, n.w);
            t1.sort((t1, e)=>e.h - t1.h);
            const n = [
                {
                    x: 0,
                    y: 0,
                    w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),
                    h: 1 / 0
                }
            ];
            let i = 0, a = 0;
            for (const e of t1)for(let t1 = n.length - 1; t1 >= 0; t1--){
                const r = n[t1];
                if (!(e.w > r.w || e.h > r.h)) {
                    if (e.x = r.x, e.y = r.y, a = Math.max(a, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) {
                        const e = n.pop();
                        t1 < n.length && (n[t1] = e);
                    } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({
                        x: r.x + e.w,
                        y: r.y,
                        w: r.w - e.w,
                        h: e.h
                    }), r.y += e.h, r.h -= e.h);
                    break;
                }
            }
            return {
                w: i,
                h: a,
                fill: e / (i * a) || 0
            };
        }
        oa(Vf, "Anchor");
        const qf = 1;
        class $f {
            constructor(t1, { pixelRatio: e, version: r, stretchX: n, stretchY: i, content: a }, s){
                this.paddedRect = t1, this.pixelRatio = e, this.stretchX = n, this.stretchY = i, this.content = a, this.version = r, this.padding = s;
            }
            get tl() {
                return [
                    this.paddedRect.x + this.padding,
                    this.paddedRect.y + this.padding
                ];
            }
            get br() {
                return [
                    this.paddedRect.x + this.paddedRect.w - this.padding,
                    this.paddedRect.y + this.paddedRect.h - this.padding
                ];
            }
            get displaySize() {
                return [
                    (this.paddedRect.w - 2 * this.padding) / this.pixelRatio,
                    (this.paddedRect.h - 2 * this.padding) / this.pixelRatio
                ];
            }
        }
        class Gf {
            constructor(t1, e, r){
                const n = {}, i = {};
                this.haveRenderCallbacks = [];
                const a = [];
                this.addImages(t1, n, qf, a), this.addImages(e, i, 2, a);
                const { w: s, h: o } = jf(a), l = new sc({
                    width: s || 1,
                    height: o || 1
                });
                for(const e in t1){
                    const i = t1[e], a = n[e].paddedRect;
                    sc.copy(i.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: a.x + qf,
                        y: a.y + qf
                    }, i.data, r, i.sdf);
                }
                for(const t1 in e){
                    const n = e[t1], a = i[t1].paddedRect;
                    let s = i[t1].padding;
                    const o = a.x + s, u = a.y + s, c = n.data.width, h = n.data.height;
                    s = s > 1 ? s - 1 : s, sc.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: o,
                        y: u
                    }, n.data, r), sc.copy(n.data, l, {
                        x: 0,
                        y: h - s
                    }, {
                        x: o,
                        y: u - s
                    }, {
                        width: c,
                        height: s
                    }, r), sc.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: o,
                        y: u + h
                    }, {
                        width: c,
                        height: s
                    }, r), sc.copy(n.data, l, {
                        x: c - s,
                        y: 0
                    }, {
                        x: o - s,
                        y: u
                    }, {
                        width: s,
                        height: h
                    }, r), sc.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: o + c,
                        y: u
                    }, {
                        width: s,
                        height: h
                    }, r), sc.copy(n.data, l, {
                        x: c - s,
                        y: h - s
                    }, {
                        x: o - s,
                        y: u - s
                    }, {
                        width: s,
                        height: s
                    }, r), sc.copy(n.data, l, {
                        x: 0,
                        y: h - s
                    }, {
                        x: o + c,
                        y: u - s
                    }, {
                        width: s,
                        height: s
                    }, r), sc.copy(n.data, l, {
                        x: 0,
                        y: 0
                    }, {
                        x: o + c,
                        y: u + h
                    }, {
                        width: s,
                        height: s
                    }, r), sc.copy(n.data, l, {
                        x: c - s,
                        y: 0
                    }, {
                        x: o - s,
                        y: u + h
                    }, {
                        width: s,
                        height: s
                    }, r);
                }
                this.image = l, this.iconPositions = n, this.patternPositions = i;
            }
            addImages(t1, e, r, n) {
                for(const i in t1){
                    const a = t1[i], s = {
                        x: 0,
                        y: 0,
                        w: a.data.width + 2 * r,
                        h: a.data.height + 2 * r
                    };
                    n.push(s), e[i] = new $f(s, a, r), a.hasRenderCallback && this.haveRenderCallbacks.push(Qe.deserializeId(i));
                }
            }
            patchUpdatedImages(t1, e, r) {
                this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e)=>t1.hasImage(e, r)), t1.dispatchRenderCallbacks(this.haveRenderCallbacks, r);
                for(const n in t1.getUpdatedImages(r)){
                    for (const i of Object.keys(this.iconPositions))Qe.deserializeId(i) === n && this.patchUpdatedImage(this.iconPositions[i], t1.getImage(n, r), e);
                    for (const i of Object.keys(this.patternPositions))Qe.deserializeId(i) === n && this.patchUpdatedImage(this.patternPositions[i], t1.getImage(n, r), e);
                }
            }
            patchUpdatedImage(t1, e, r) {
                if (!t1 || !e) return;
                if (t1.version === e.version) return;
                t1.version = e.version;
                const [n, i] = t1.tl;
                r.update(e.data, {
                    position: {
                        x: n,
                        y: i
                    }
                });
            }
        }
        oa($f, "ImagePosition"), oa(Gf, "ImageAtlas");
        const Yf = 1e20;
        function Xf(t1, e, r, n, i, a, s, o, l) {
            for(let u = e; u < e + n; u++)Zf(t1, r * a + u, a, i, s, o, l);
            for(let u = r; u < r + i; u++)Zf(t1, u * a + e, 1, n, s, o, l);
        }
        function Zf(t1, e, r, n, i, a, s) {
            a[0] = 0, s[0] = -Yf, s[1] = Yf, i[0] = t1[e];
            for(let o = 1, l = 0, u = 0; o < n; o++){
                i[o] = t1[e + o * r];
                const n = o * o;
                do {
                    const t1 = a[l];
                    u = (i[o] - i[t1] + n - t1 * t1) / (o - t1) / 2;
                }while (u <= s[l] && --l > -1)
                l++, a[l] = o, s[l] = u, s[l + 1] = Yf;
            }
            for(let o = 0, l = 0; o < n; o++){
                for(; s[l + 1] < o;)l++;
                const n = a[l], u = o - n;
                t1[e + o * r] = i[n] + u * u;
            }
        }
        const Hf = 2, Wf = {
            none: 0,
            ideographs: 1,
            all: 2
        };
        class Kf {
            constructor(t1, e, r){
                this.requestManager = t1, this.localGlyphMode = e, this.localFontFamily = r, this.urls = {}, this.entries = {}, this.localGlyphs = {
                    200: {},
                    400: {},
                    500: {},
                    900: {}
                };
            }
            setURL(t1, e) {
                this.urls[e] = t1;
            }
            getGlyphs(t1, e, r) {
                const n = [], i = this.urls[e] || St.GLYPHS_URL;
                for(const e in t1)for (const r of t1[e])n.push({
                    stack: e,
                    id: r
                });
                rt(n, ({ stack: t1, id: e }, r)=>{
                    let n = this.entries[t1];
                    n || (n = this.entries[t1] = {
                        glyphs: {},
                        requests: {},
                        ranges: {},
                        ascender: void 0,
                        descender: void 0
                    });
                    let a = n.glyphs[e];
                    if (void 0 !== a) return void r(null, {
                        stack: t1,
                        id: e,
                        glyph: a
                    });
                    if (a = this._tinySDF(n, t1, e), a) return n.glyphs[e] = a, void r(null, {
                        stack: t1,
                        id: e,
                        glyph: a
                    });
                    const s = Math.floor(e / 256);
                    if (256 * s > 65535) return ft("glyphs > 65535 not supported"), void r(null, {
                        stack: t1,
                        id: e,
                        glyph: a
                    });
                    if (n.ranges[s]) return void r(null, {
                        stack: t1,
                        id: e,
                        glyph: a
                    });
                    let o = n.requests[s];
                    o || (o = n.requests[s] = [], Kf.loadGlyphRange(t1, s, i, this.requestManager, (t1, e)=>{
                        if (e) {
                            n.ascender = e.ascender, n.descender = e.descender;
                            for(const t1 in e.glyphs)this._doesCharSupportLocalGlyph(+t1) || (n.glyphs[+t1] = e.glyphs[+t1]);
                            n.ranges[s] = !0;
                        }
                        for (const r of o)r(t1, e);
                        delete n.requests[s];
                    })), o.push((n, i)=>{
                        n ? r(n) : i && r(null, {
                            stack: t1,
                            id: e,
                            glyph: i.glyphs[e] || null
                        });
                    });
                }, (t1, e)=>{
                    if (t1) r(t1);
                    else if (e) {
                        const t1 = {};
                        for (const { stack: r, id: n, glyph: i } of e)void 0 === t1[r] && (t1[r] = {}), void 0 === t1[r].glyphs && (t1[r].glyphs = {}), t1[r].glyphs[n] = i && {
                            id: i.id,
                            bitmap: i.bitmap.clone(),
                            metrics: i.metrics
                        }, t1[r].ascender = this.entries[r].ascender, t1[r].descender = this.entries[r].descender;
                        r(null, t1);
                    }
                });
            }
            _doesCharSupportLocalGlyph(t1) {
                return this.localGlyphMode !== Wf.none && (this.localGlyphMode === Wf.all ? !!this.localFontFamily : !!this.localFontFamily && (pa["CJK Unified Ideographs"](t1) || pa["Hangul Syllables"](t1) || pa.Hiragana(t1) || pa.Katakana(t1) || pa["CJK Symbols and Punctuation"](t1) || pa["CJK Unified Ideographs Extension A"](t1) || pa["CJK Unified Ideographs Extension B"](t1) || pa.Osage(t1)));
            }
            _tinySDF(t1, e, r) {
                const n = this.localFontFamily;
                if (!n || !this._doesCharSupportLocalGlyph(r)) return;
                let i = t1.tinySDF;
                if (!i) {
                    let r = "400";
                    /bold/i.test(e) ? r = "900" : /medium/i.test(e) ? r = "500" : /light/i.test(e) && (r = "200"), i = t1.tinySDF = new Kf.TinySDF({
                        fontFamily: n,
                        fontWeight: r,
                        fontSize: 24 * Hf,
                        buffer: 3 * Hf,
                        radius: 8 * Hf
                    }), i.fontWeight = r;
                }
                if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r];
                const a = String.fromCodePoint(r), { data: s, width: o, height: l, glyphWidth: u, glyphHeight: c, glyphLeft: h, glyphTop: p, glyphAdvance: f } = i.draw(a);
                return this.localGlyphs[i.fontWeight][r] = {
                    id: r,
                    bitmap: new ac({
                        width: o,
                        height: l
                    }, s),
                    metrics: {
                        width: u / Hf,
                        height: c / Hf,
                        left: h / Hf,
                        top: p / Hf - 27,
                        advance: f / Hf,
                        localGlyph: !0
                    }
                };
            }
        }
        Kf.loadGlyphRange = function(t1, e, r, n, i) {
            const a = 256 * e, s = a + 255, o = n.transformRequest(n.normalizeGlyphsURL(r).replace("{fontstack}", t1).replace("{range}", `${a}-${s}`), te.Glyphs);
            ie(o, (t1, e)=>{
                if (t1) i(t1);
                else if (e) {
                    const t1 = {}, r = function(t1) {
                        return new pf(t1).readFields(df, {});
                    }(e);
                    for (const e of r.glyphs)t1[e.id] = e;
                    i(null, {
                        glyphs: t1,
                        ascender: r.ascender,
                        descender: r.descender
                    });
                }
            });
        }, Kf.TinySDF = class {
            constructor({ fontSize: t1 = 24, buffer: e = 3, radius: r = 8, cutoff: n = .25, fontFamily: i = "sans-serif", fontWeight: a = "normal", fontStyle: s = "normal" } = {}){
                this.buffer = e, this.cutoff = n, this.radius = r;
                const o = this.size = t1 + 4 * e, l = this._createCanvas(o), u = this.ctx = l.getContext("2d", {
                    willReadFrequently: !0
                });
                u.font = `${s} ${a} ${t1}px ${i}`, u.textBaseline = "alphabetic", u.textAlign = "left", u.fillStyle = "black", this.gridOuter = new Float64Array(o * o), this.gridInner = new Float64Array(o * o), this.f = new Float64Array(o), this.z = new Float64Array(o + 1), this.v = new Uint16Array(o);
            }
            _createCanvas(t1) {
                const e = document.createElement("canvas");
                return e.width = e.height = t1, e;
            }
            draw(t1) {
                const { width: e, actualBoundingBoxAscent: r, actualBoundingBoxDescent: n, actualBoundingBoxLeft: i, actualBoundingBoxRight: a } = this.ctx.measureText(t1), s = Math.ceil(r), o = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a - i))), l = Math.min(this.size - this.buffer, s + Math.ceil(n)), u = o + 2 * this.buffer, c = l + 2 * this.buffer, h = Math.max(u * c, 0), p = new Uint8ClampedArray(h), f = {
                    data: p,
                    width: u,
                    height: c,
                    glyphWidth: o,
                    glyphHeight: l,
                    glyphTop: s,
                    glyphLeft: 0,
                    glyphAdvance: e
                };
                if (0 === o || 0 === l) return f;
                const { ctx: d, buffer: m, gridInner: y, gridOuter: g } = this;
                d.clearRect(m, m, o, l), d.fillText(t1, m, m + s);
                const x = d.getImageData(m, m, o, l);
                g.fill(Yf, 0, h), y.fill(0, 0, h);
                for(let t1 = 0; t1 < l; t1++)for(let e = 0; e < o; e++){
                    const r = x.data[4 * (t1 * o + e) + 3] / 255;
                    if (0 === r) continue;
                    const n = (t1 + m) * u + e + m;
                    if (1 === r) g[n] = 0, y[n] = Yf;
                    else {
                        const t1 = .5 - r;
                        g[n] = t1 > 0 ? t1 * t1 : 0, y[n] = t1 < 0 ? t1 * t1 : 0;
                    }
                }
                Xf(g, 0, 0, u, c, u, this.f, this.v, this.z), Xf(y, m, m, o, l, u, this.f, this.v, this.z);
                for(let t1 = 0; t1 < h; t1++){
                    const e = Math.sqrt(g[t1]) - Math.sqrt(y[t1]);
                    p[t1] = Math.round(255 - 255 * (e / this.radius + this.cutoff));
                }
                return f;
            }
        };
        const Jf = qf;
        function Qf(t1, e) {
            return t1 + e[1] - e[0];
        }
        function td(t1, e, r, n, i = 1) {
            const a = [], s = t1.imagePrimary, o = s.pixelRatio, l = s.paddedRect.w - 2 * Jf, u = s.paddedRect.h - 2 * Jf, c = (t1.right - t1.left) * i, h = (t1.bottom - t1.top) * i, p = s.stretchX || [
                [
                    0,
                    l
                ]
            ], f = s.stretchY || [
                [
                    0,
                    u
                ]
            ], d = p.reduce(Qf, 0), m = f.reduce(Qf, 0), y = l - d, g = u - m;
            let x = 0, v = d, b = 0, _ = m, w = 0, M = y, A = 0, S = g;
            if (s.content && n) {
                const t1 = s.content;
                x = ed(p, 0, t1[0]), b = ed(f, 0, t1[1]), v = ed(p, t1[0], t1[2]), _ = ed(f, t1[1], t1[3]), w = t1[0] - x, A = t1[1] - b, M = t1[2] - t1[0] - v, S = t1[3] - t1[1] - _;
            }
            const I = (n, a, l, u)=>{
                const p = nd(n.stretch - x, v, c, t1.left * i), f = id(n.fixed - w, M, n.stretch, d), y = nd(a.stretch - b, _, h, t1.top * i), g = id(a.fixed - A, S, a.stretch, m), I = nd(l.stretch - x, v, c, t1.left * i), P = id(l.fixed - w, M, l.stretch, d), z = nd(u.stretch - b, _, h, t1.top * i), E = id(u.fixed - A, S, u.stretch, m), k = new q(p, y), T = new q(I, y), B = new q(I, z), V = new q(p, z), C = new q(f / o, g / o), D = new q(P / o, E / o), L = e * Math.PI / 180;
                if (L) {
                    const t1 = Math.sin(L), e = Math.cos(L), r = [
                        e,
                        -t1,
                        t1,
                        e
                    ];
                    k._matMult(r), T._matMult(r), V._matMult(r), B._matMult(r);
                }
                const R = n.stretch + n.fixed, F = l.stretch + l.fixed, O = a.stretch + a.fixed, N = u.stretch + u.fixed, U = t1.imageSecondary;
                return {
                    tl: k,
                    tr: T,
                    bl: V,
                    br: B,
                    texPrimary: {
                        x: s.paddedRect.x + Jf + R,
                        y: s.paddedRect.y + Jf + O,
                        w: F - R,
                        h: N - O
                    },
                    texSecondary: U ? {
                        x: U.paddedRect.x + Jf + R,
                        y: U.paddedRect.y + Jf + O,
                        w: F - R,
                        h: N - O
                    } : void 0,
                    writingMode: void 0,
                    glyphOffset: [
                        0,
                        0
                    ],
                    sectionIndex: 0,
                    pixelOffsetTL: C,
                    pixelOffsetBR: D,
                    minFontScaleX: M / o / c,
                    minFontScaleY: S / o / h,
                    isSDF: r
                };
            };
            if (n && (s.stretchX || s.stretchY)) {
                const t1 = rd(p, y, d), e = rd(f, g, m);
                for(let r = 0; r < t1.length - 1; r++){
                    const n = t1[r], i = t1[r + 1];
                    for(let t1 = 0; t1 < e.length - 1; t1++)a.push(I(n, e[t1], i, e[t1 + 1]));
                }
            } else a.push(I({
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: -1
            }, {
                fixed: 0,
                stretch: l + 1
            }, {
                fixed: 0,
                stretch: u + 1
            }));
            return a;
        }
        function ed(t1, e, r) {
            let n = 0;
            for (const i of t1)n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));
            return n;
        }
        function rd(t1, e, r) {
            const n = [
                {
                    fixed: -Jf,
                    stretch: 0
                }
            ];
            for (const [e, r] of t1){
                const t1 = n[n.length - 1];
                n.push({
                    fixed: e - t1.stretch,
                    stretch: t1.stretch
                }), n.push({
                    fixed: e - t1.stretch,
                    stretch: t1.stretch + (r - e)
                });
            }
            return n.push({
                fixed: e + Jf,
                stretch: r
            }), n;
        }
        function nd(t1, e, r, n) {
            return t1 / e * r + n;
        }
        function id(t1, e, r, n) {
            return t1 - e * r / n;
        }
        function ad(t1, e, r, n) {
            const i = e + t1.positionedLines[n].lineOffset;
            return 0 === n ? r + i / 2 : r + (i + (e + t1.positionedLines[n - 1].lineOffset)) / 2;
        }
        function sd(t1, e = 1, r = !1) {
            let n = 1 / 0, i = 1 / 0, a = -1 / 0, s = -1 / 0;
            const o = t1[0];
            for(let t1 = 0; t1 < o.length; t1++){
                const e = o[t1];
                (!t1 || e.x < n) && (n = e.x), (!t1 || e.y < i) && (i = e.y), (!t1 || e.x > a) && (a = e.x), (!t1 || e.y > s) && (s = e.y);
            }
            const l = Math.min(a - n, s - i);
            let u = l / 2;
            const c = new Hr([], od);
            if (0 === l) return new q(n, i);
            for(let e = n; e < a; e += l)for(let r = i; r < s; r += l)c.push(new ld(e + u, r + u, u, t1));
            let h = function(t1) {
                let e = 0, r = 0, n = 0;
                const i = t1[0];
                for(let t1 = 0, a = i.length, s = a - 1; t1 < a; s = t1++){
                    const a = i[t1], o = i[s], l = a.x * o.y - o.x * a.y;
                    r += (a.x + o.x) * l, n += (a.y + o.y) * l, e += 3 * l;
                }
                return new ld(r / e, n / e, 0, t1);
            }(t1), p = c.length;
            for(; c.length;){
                const n = c.pop();
                (n.d > h.d || !h.d) && (h = n, r && console.log("found best %d after %d probes", Math.round(1e4 * n.d) / 1e4, p)), n.max - h.d <= e || (u = n.h / 2, c.push(new ld(n.p.x - u, n.p.y - u, u, t1)), c.push(new ld(n.p.x + u, n.p.y - u, u, t1)), c.push(new ld(n.p.x - u, n.p.y + u, u, t1)), c.push(new ld(n.p.x + u, n.p.y + u, u, t1)), p += 4);
            }
            return r && (console.log(`num probes: ${p}`), console.log(`best distance: ${h.d}`)), h.p;
        }
        function od(t1, e) {
            return e.max - t1.max;
        }
        class ld {
            constructor(t1, e, r, n){
                this.p = new q(t1, e), this.h = r, this.d = function(t1, e) {
                    let r = !1, n = 1 / 0;
                    for(let i = 0; i < e.length; i++){
                        const a = e[i];
                        for(let e = 0, i = a.length, s = i - 1; e < i; s = e++){
                            const i = a[e], o = a[s];
                            i.y > t1.y != o.y > t1.y && t1.x < (o.x - i.x) * (t1.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, Nl(t1, i, o));
                        }
                    }
                    return (r ? 1 : -1) * Math.sqrt(n);
                }(this.p, n), this.max = this.d + this.h * Math.SQRT2;
            }
        }
        const ud = Number.POSITIVE_INFINITY, cd = Math.sqrt(2);
        function hd(t1, [e, r]) {
            let n = 0, i = 0;
            if (r === ud) {
                e < 0 && (e = 0);
                const r = e / cd;
                switch(t1){
                    case "top-right":
                    case "top-left":
                        i = r - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                        i = 7 - r;
                        break;
                    case "bottom":
                        i = 7 - e;
                        break;
                    case "top":
                        i = e - 7;
                }
                switch(t1){
                    case "top-right":
                    case "bottom-right":
                        n = -r;
                        break;
                    case "top-left":
                    case "bottom-left":
                        n = r;
                        break;
                    case "left":
                        n = e;
                        break;
                    case "right":
                        n = -e;
                }
            } else {
                switch(e = Math.abs(e), r = Math.abs(r), t1){
                    case "top-right":
                    case "top-left":
                    case "top":
                        i = r - 7;
                        break;
                    case "bottom-right":
                    case "bottom-left":
                    case "bottom":
                        i = 7 - r;
                }
                switch(t1){
                    case "top-right":
                    case "bottom-right":
                    case "right":
                        n = -e;
                        break;
                    case "top-left":
                    case "bottom-left":
                    case "left":
                        n = e;
                }
            }
            return [
                n,
                i
            ];
        }
        function pd(t1) {
            switch(t1){
                case "right":
                case "top-right":
                case "bottom-right":
                    return "right";
                case "left":
                case "top-left":
                case "bottom-left":
                    return "left";
            }
            return "center";
        }
        function fd(t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m) {
            let y = a.textMaxSize.evaluate(e, {}, p);
            void 0 === y ? y = s * a.textScaleFactor : y *= a.textScaleFactor;
            const g = t1.layers[0].layout, x = g.get("icon-offset").evaluate(e, {}, p), v = gd(r.horizontal) || r.vertical, b = "globe" === f.name, _ = Zp, w = s * a.textScaleFactor / _, M = t1.tilePixelRatio * y / _, A = (B = t1.overscaling, t1.zoom > 18 && B > 2 && (B >>= 1), Math.max(Wr / (512 * B), 1) * g.get("symbol-spacing")), S = g.get("text-padding") * t1.tilePixelRatio, I = g.get("icon-padding") * t1.tilePixelRatio, P = X(g.get("text-max-angle")), z = "map" === g.get("text-rotation-alignment") && "point" !== g.get("symbol-placement"), E = "map" === g.get("icon-rotation-alignment") && "point" !== g.get("symbol-placement"), k = g.get("symbol-placement"), T = A / 2;
            var B;
            const V = g.get("icon-text-fit").evaluate(e, {}, p), C = g.get("icon-text-fit-padding").evaluate(e, {}, p), D = "none" !== V;
            let L;
            !1 === t1.hasAnyIconTextFit && D && (t1.hasAnyIconTextFit = !0), n && D && (t1.allowVerticalPlacement && r.vertical && (L = Bf(n, r.vertical, V, C, x, w)), v && (n = Bf(n, v, V, C, x, w)));
            const R = (s, o, y)=>{
                if (o.x < 0 || o.x >= Wr || o.y < 0 || o.y >= Wr) return;
                let g = null;
                if (b) {
                    const { x: t1, y: e, z: r } = f.projectTilePoint(o.x, o.y, y);
                    g = {
                        anchor: new Vf(t1, e, r, 0, void 0),
                        up: f.upVector(y, o.x, o.y)
                    };
                }
                !function(t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _, w, M, A, S, I, P) {
                    const z = t1.addToLineVertexArray(e, n);
                    let E, k, T, B, V, C, D, L = 0, R = 0, F = 0, O = 0, N = -1, U = -1;
                    const j = {};
                    let q = ge("");
                    const $ = r ? r.anchor : e, G = "none" !== l.layout.get("icon-text-fit").evaluate(b, {}, S);
                    let Y = 0, X = 0;
                    if (void 0 === l._unevaluatedLayout.getValue("text-radial-offset") ? [Y, X] = l.layout.get("text-offset").evaluate(b, {}, S).map((t1)=>t1 * Zp) : (Y = l.layout.get("text-radial-offset").evaluate(b, {}, S) * Zp, X = ud), t1.allowVerticalPlacement && i.vertical) {
                        const t1 = i.vertical;
                        if (d) C = vd(t1), o && (D = vd(o));
                        else {
                            const r = l.layout.get("text-rotate").evaluate(b, {}, S) + 90;
                            T = xd(u, $, e, c, h, p, t1, f, r, m), o && (B = xd(u, $, e, c, h, p, o, g, r));
                        }
                    }
                    if (a) {
                        const n = t1.iconSizeData, i = M ? Wp(t1.iconSizeData, t1.layers[0]._unevaluatedLayout._values["icon-size"], S, t1.zoom, b) : 1, s = l.layout.get("icon-rotate").evaluate(b, {}, S), f = td(a, s, w, G, M ? 1 / i : _.iconScaleFactor), d = o ? td(o, s, w, G, _.iconScaleFactor) : void 0;
                        k = xd(u, $, e, c, h, p, a, g, s, null, M ? _.iconScaleFactor * i : 1), L = 4 * f.length;
                        let m = null;
                        "source" === n.kind ? (m = [
                            Hp * l.layout.get("icon-size").evaluate(b, {}, S) * _.iconScaleFactor
                        ], m[0] > md && ft(`${t1.layerIds[0]}: Value for "icon-size" is >= ${dd}. Reduce your "icon-size".`)) : "composite" === n.kind && (m = [
                            Hp * _.compositeIconSizes[0].evaluate(b, {}, S) * _.iconScaleFactor,
                            Hp * _.compositeIconSizes[1].evaluate(b, {}, S) * _.iconScaleFactor
                        ], (m[0] > md || m[1] > md) && ft(`${t1.layerIds[0]}: Value for "icon-size" is >= ${dd}. Reduce your "icon-size".`)), t1.addSymbols(t1.icon, f, m, v, x, b, !1, r, e, z.lineStartIndex, z.lineLength, -1, A, S, I, P), N = t1.icon.placedSymbolArray.length - 1, d && (R = 4 * d.length, t1.addSymbols(t1.icon, d, m, v, x, b, xf.vertical, r, e, z.lineStartIndex, z.lineLength, -1, A, S, I, P), U = t1.icon.placedSymbolArray.length - 1);
                    }
                    for(const n in i.horizontal){
                        const a = i.horizontal[n];
                        E || (q = ge(a.text), d ? V = vd(a) : E = xd(u, $, e, c, h, p, a, f, l.layout.get("text-rotate").evaluate(b, {}, S), m));
                        const o = 1 === a.positionedLines.length;
                        if (F += yd(t1, r, e, a, s, l, d, b, m, z, i.vertical ? xf.horizontal : xf.horizontalOnly, o ? Object.keys(i.horizontal) : [
                            n
                        ], j, N, _, A, S, I), o) break;
                    }
                    i.vertical && (O += yd(t1, r, e, i.vertical, s, l, d, b, m, z, xf.vertical, [
                        "vertical"
                    ], j, U, _, A, S, I));
                    let Z = -1;
                    const H = (t1, e)=>t1 ? Math.max(t1, e) : e;
                    Z = H(V, Z), Z = H(C, Z), Z = H(D, Z);
                    const W = Z > -1 ? 1 : 0;
                    t1.glyphOffsetArray.length >= 65535 && ft("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b.sortKey && t1.addToSortKeyRanges(t1.symbolInstances.length, b.sortKey), t1.symbolInstances.emplaceBack(e.x, e.y, $.x, $.y, $.z, j.right >= 0 ? j.right : -1, j.center >= 0 ? j.center : -1, j.left >= 0 ? j.left : -1, j.vertical >= 0 ? j.vertical : -1, N, U, q, void 0 !== E ? E : t1.collisionBoxArray.length, void 0 !== E ? E + 1 : t1.collisionBoxArray.length, void 0 !== T ? T : t1.collisionBoxArray.length, void 0 !== T ? T + 1 : t1.collisionBoxArray.length, void 0 !== k ? k : t1.collisionBoxArray.length, void 0 !== k ? k + 1 : t1.collisionBoxArray.length, B || t1.collisionBoxArray.length, B ? B + 1 : t1.collisionBoxArray.length, c, F, O, L, R, W, 0, Y, X, Z, 0, G ? 1 : 0);
                }(t1, o, g, s, r, n, i, L, t1.layers[0], t1.collisionBoxArray, e.index, e.sourceLayerIndex, t1.index, S, z, l, 0, I, E, x, e, a, u, c, h, p, d, m);
            };
            if ("line" === k) for (const i of Uf(e.geometry, 0, 0, Wr, Wr)){
                const e = Of(i, A, P, r.vertical || v, n, _, M, t1.overscaling, Wr);
                for (const r of e)v && bd(t1, v.text, T, r) || R(i, r, p);
            }
            else if ("line-center" === k) {
                for (const t1 of e.geometry)if (t1.length > 1) {
                    const e = Ff(t1, P, r.vertical || v, n, _, M);
                    e && R(t1, e, p);
                }
            } else if ("Polygon" === e.type) for (const t1 of Lc(e.geometry, 0)){
                const e = sd(t1, 16);
                R(t1[0], new Vf(e.x, e.y, 0, 0, void 0), p);
            }
            else if ("LineString" === e.type) for (const t1 of e.geometry)R(t1, new Vf(t1[0].x, t1[0].y, 0, 0, void 0), p);
            else if ("Point" === e.type) for (const t1 of e.geometry)for (const e of t1)R([
                e
            ], new Vf(e.x, e.y, 0, 0, void 0), p);
        }
        const dd = 255, md = dd * Hp;
        function yd(t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m, y, g) {
            const x = function(t1, e, r, n, i, a, s, o) {
                const l = [];
                if (0 === e.positionedLines.length) return l;
                const u = n.layout.get("text-rotate").evaluate(a, {}) * Math.PI / 180, c = function(t1) {
                    const e = t1[0], r = t1[1], n = e * r;
                    return n > 0 ? [
                        e,
                        -r
                    ] : n < 0 ? [
                        -e,
                        r
                    ] : 0 === e ? [
                        r,
                        e
                    ] : [
                        r,
                        -e
                    ];
                }(r);
                let h = Math.abs(e.top - e.bottom);
                for (const t1 of e.positionedLines)h -= t1.lineOffset;
                const p = e.positionedLines.length, f = h / p;
                let d = e.top - r[1];
                for(let t1 = 0; t1 < p; ++t1){
                    const n = e.positionedLines[t1];
                    d = ad(e, f, d, t1);
                    for (const t1 of n.positionedGlyphs){
                        if (!t1.rect) continue;
                        const n = t1.rect || {};
                        let a = gf + 1, h = !0, p = 1, f = 0;
                        if (t1.imageName) {
                            const e = s[tr.build(t1.imageName).getSerializedPrimary()];
                            if (!e) continue;
                            if (e.sdf) {
                                ft("SDF images are not supported in formatted text and will be ignored.");
                                continue;
                            }
                            h = !1, p = e.pixelRatio, a = qf / p;
                        }
                        const m = (i || o) && t1.vertical, y = t1.metrics.advance * t1.scale / 2, g = t1.metrics, x = t1.rect;
                        if (null === x) continue;
                        o && e.verticalizable && (f = t1.imageName ? y - t1.metrics.width * t1.scale / 2 : 0);
                        const v = i ? [
                            t1.x + y,
                            t1.y
                        ] : [
                            0,
                            0
                        ];
                        let b = [
                            0,
                            0
                        ], _ = [
                            0,
                            0
                        ], w = !1;
                        i || (m ? (_ = [
                            t1.x + y + c[0],
                            t1.y + c[1] - f
                        ], w = !0) : b = [
                            t1.x + y + r[0],
                            t1.y + r[1] - f
                        ]);
                        const M = x.w * t1.scale / (p * (t1.localGlyph ? Hf : 1)), A = x.h * t1.scale / (p * (t1.localGlyph ? Hf : 1));
                        let S, I, P, z;
                        if (m) {
                            const e = t1.y - d, r = new q(-y, y - e), n = -Math.PI / 2, i = new q(..._);
                            S = new q(-y + b[0], b[1]), S._rotateAround(n, r)._add(i), S.x += -e + y, S.y -= (g.left - a) * t1.scale;
                            const s = t1.imageName ? g.advance * t1.scale : Zp * t1.scale, o = String.fromCodePoint(t1.glyph);
                            nf(o) ? S.x += (1 - a) * t1.scale : af(o) ? S.x += s - g.height * t1.scale + (-a - 1) * t1.scale : S.x += t1.imageName || g.width + 2 * a === x.w && g.height + 2 * a === x.h ? (s - A) / 2 : (s - (g.height + 2 * a) * t1.scale) / 2, I = new q(S.x, S.y - M), P = new q(S.x + A, S.y), z = new q(S.x + A, S.y - M);
                        } else {
                            const e = (g.left - a) * t1.scale - y + b[0], r = (-g.top - a) * t1.scale + b[1], n = e + M, i = r + A;
                            S = new q(e, r), I = new q(n, r), P = new q(e, i), z = new q(n, i);
                        }
                        if (u) {
                            let t1;
                            t1 = i ? new q(0, 0) : w ? new q(c[0], c[1]) : new q(r[0], r[1]), S._rotateAround(u, t1), I._rotateAround(u, t1), P._rotateAround(u, t1), z._rotateAround(u, t1);
                        }
                        const E = new q(0, 0), k = new q(0, 0);
                        l.push({
                            tl: S,
                            tr: I,
                            bl: P,
                            br: z,
                            texPrimary: n,
                            texSecondary: void 0,
                            writingMode: e.writingMode,
                            glyphOffset: v,
                            sectionIndex: t1.sectionIndex,
                            isSDF: h,
                            pixelOffsetTL: E,
                            pixelOffsetBR: k,
                            minFontScaleX: 0,
                            minFontScaleY: 0
                        });
                    }
                }
                return l;
            }(0, n, l, a, s, o, i, t1.allowVerticalPlacement), v = t1.textSizeData;
            let b = null;
            "source" === v.kind ? (b = [
                Hp * a.layout.get("text-size").evaluate(o, {}, y) * d.textScaleFactor
            ], b[0] > md && ft(`${t1.layerIds[0]}: Value for "text-size" is >= ${dd}. Reduce your "text-size".`)) : "composite" === v.kind && (b = [
                Hp * d.compositeTextSizes[0].evaluate(o, {}, y) * d.textScaleFactor,
                Hp * d.compositeTextSizes[1].evaluate(o, {}, y) * d.textScaleFactor
            ], (b[0] > md || b[1] > md) && ft(`${t1.layerIds[0]}: Value for "text-size" is >= ${dd}. Reduce your "text-size".`)), t1.addSymbols(t1.text, x, b, l, s, o, c, e, r, u.lineStartIndex, u.lineLength, f, m, y, g, !1);
            for (const e of h)p[e] = t1.text.placedSymbolArray.length - 1;
            return 4 * x.length;
        }
        function gd(t1) {
            for(const e in t1)return t1[e];
            return null;
        }
        function xd(t1, e, r, n, i, a, s, o, l, u, c = 1) {
            let h = s.top / c, p = s.bottom / c, f = s.left / c, d = s.right / c;
            const m = s.collisionPadding;
            if (m && (f -= m[0], h -= m[1], d += m[2], p += m[3]), l) {
                const t1 = new q(f, h), e = new q(d, h), r = new q(f, p), n = new q(d, p), i = X(l);
                let a = new q(0, 0);
                u && (a = new q(u[0], u[1])), t1._rotateAround(i, a), e._rotateAround(i, a), r._rotateAround(i, a), n._rotateAround(i, a), f = Math.min(t1.x, e.x, r.x, n.x), d = Math.max(t1.x, e.x, r.x, n.x), h = Math.min(t1.y, e.y, r.y, n.y), p = Math.max(t1.y, e.y, r.y, n.y);
            }
            return t1.emplaceBack(e.x, e.y, e.z, r.x, r.y, f, h, d, p, o, n, i, a), t1.length - 1;
        }
        function vd(t1) {
            t1.collisionPadding && (t1.top -= t1.collisionPadding[1], t1.bottom += t1.collisionPadding[3]);
            const e = t1.bottom - t1.top;
            return e > 0 ? Math.max(10, e) : null;
        }
        function bd(t1, e, r, n) {
            const i = t1.compareText;
            if (e in i) {
                const t1 = i[e];
                for(let e = t1.length - 1; e >= 0; e--)if (n.dist(t1[e]) < r) return !0;
            } else i[e] = [];
            return i[e].push(n), !1;
        }
        function _d(t1, e) {
            const r = t1.fovAboveCenter, n = t1.elevation ? t1.elevation.getMinElevationBelowMSL() * e : 0, i = (t1._camera.position[2] * t1.worldSize - n) / Math.cos(t1._pitch), a = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t1._pitch - r, .01));
            let s = Math.sin(t1._pitch) * a + i;
            const o = i * (1 / t1._horizonShift);
            return t1.elevation && 0 !== t1.elevation.exaggeration() || (s *= 1 + Math.max(t1.zoom - 17, 0)), Math.min(1.01 * s, o);
        }
        function wd(t1, e) {
            if (!e.isReprojectedInTileSpace) return {
                scale: 1 << t1.z,
                x: t1.x,
                y: t1.y,
                x2: t1.x + 1,
                y2: t1.y + 1,
                projection: e
            };
            const r = Math.pow(2, -t1.z), n = t1.x * r, i = (t1.x + 1) * r, a = t1.y * r, s = (t1.y + 1) * r, o = pl(n), l = pl(i), u = fl(a), c = fl(s), h = e.project(o, u), p = e.project(l, u), f = e.project(l, c), d = e.project(o, c);
            let m = Math.min(h.x, p.x, f.x, d.x), y = Math.min(h.y, p.y, f.y, d.y), g = Math.max(h.x, p.x, f.x, d.x), x = Math.max(h.y, p.y, f.y, d.y);
            const v = r / 16;
            function b(t1, r, n, i, a, s) {
                const o = (n + a) / 2, l = (i + s) / 2, u = e.project(pl(o), fl(l)), c = Math.max(0, m - u.x, y - u.y, u.x - g, u.y - x);
                m = Math.min(m, u.x), g = Math.max(g, u.x), y = Math.min(y, u.y), x = Math.max(x, u.y), c > v && (b(t1, u, n, i, o, l), b(u, r, o, l, a, s));
            }
            b(h, p, n, a, i, a), b(p, f, i, a, i, s), b(f, d, i, s, n, s), b(d, h, n, s, n, a), m -= v, y -= v, g += v, x += v;
            const _ = 1 / Math.max(g - m, x - y);
            return {
                scale: _,
                x: m * _,
                y: y * _,
                x2: g * _,
                y2: x * _,
                projection: e
            };
        }
        function Md(t1, { x: e, y: r }, n = 0) {
            return new q(((e - n) * t1.scale - t1.x) * Wr, (r * t1.scale - t1.y) * Wr);
        }
        const Ad = O.mat4.identity(new Float32Array(16));
        class Sd {
            constructor(t1){
                this.spec = t1, this.name = t1.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = [
                    "custom"
                ], this.center = [
                    0,
                    0
                ], this.range = [
                    3.5,
                    7
                ];
            }
            project(t1, e) {
                return {
                    x: 0,
                    y: 0,
                    z: 0
                };
            }
            unproject(t1, e) {
                return new il(0, 0);
            }
            projectTilePoint(t1, e, r) {
                return {
                    x: t1,
                    y: e,
                    z: 0
                };
            }
            locationPoint(t1, e, r = !0) {
                return t1._coordinatePoint(t1.locationCoordinate(e), r);
            }
            pixelsPerMeter(t1, e) {
                return hl(1, t1) * e;
            }
            pixelSpaceConversion(t1, e, r) {
                return 1;
            }
            farthestPixelDistance(t1) {
                return _d(t1, t1.pixelsPerMeter);
            }
            pointCoordinate(t1, e, r, n) {
                const i = t1.horizonLineFromTop(!1), a = new q(e, Math.max(i, r));
                return t1.rayIntersectionCoordinate(t1.pointRayIntersection(a, n));
            }
            pointCoordinate3D(t1, e, r) {
                const n = new q(e, r);
                if (t1.elevation) return t1.elevation.pointCoordinate(n);
                {
                    const e = this.pointCoordinate(t1, n.x, n.y, 0);
                    return [
                        e.x,
                        e.y,
                        e.z
                    ];
                }
            }
            isPointAboveHorizon(t1, e) {
                if (t1.elevation && t1.elevation.visibleDemTiles.length) return !this.pointCoordinate3D(t1, e.x, e.y);
                const r = t1.horizonLineFromTop();
                return e.y < r;
            }
            createInversionMatrix(t1, e) {
                return Ad;
            }
            createTileMatrix(t1, e, r) {
                let n, i, a;
                const s = r.canonical, o = O.mat4.identity(new Float64Array(16));
                if (this.isReprojectedInTileSpace) {
                    const l = wd(s, this);
                    n = 1, i = l.x + r.wrap * l.scale, a = l.y, O.mat4.scale(o, o, [
                        n / l.scale,
                        n / l.scale,
                        t1.pixelsPerMeter / e
                    ]);
                } else n = e / t1.zoomScale(s.z), i = (s.x + Math.pow(2, s.z) * r.wrap) * n, a = s.y * n;
                return O.mat4.translate(o, o, [
                    i,
                    a,
                    0
                ]), O.mat4.scale(o, o, [
                    n / Wr,
                    n / Wr,
                    1
                ]), o;
            }
            upVector(t1, e, r) {
                return [
                    0,
                    0,
                    1
                ];
            }
            upVectorScale(t1, e, r) {
                return {
                    metersToTile: 1
                };
            }
        }
        class Id extends Sd {
            constructor(t1){
                super(t1), this.range = [
                    4,
                    7
                ], this.center = t1.center || [
                    -96,
                    37.5
                ];
                const [e, r] = this.parallels = t1.parallels || [
                    29.5,
                    45.5
                ], n = Math.sin(X(e));
                this.n = (n + Math.sin(X(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n;
            }
            project(t1, e) {
                const { n: r, c: n, r0: i } = this, a = X(t1 - this.center[0]), s = X(e), o = Math.sqrt(n - 2 * r * Math.sin(s)) / r;
                return {
                    x: o * Math.sin(a * r),
                    y: o * Math.cos(a * r) - i,
                    z: 0
                };
            }
            unproject(t1, e) {
                const { n: r, c: n, r0: i } = this, a = i + e;
                let s = Math.atan2(t1, Math.abs(a)) * Math.sign(a);
                a * r < 0 && (s -= Math.PI * Math.sign(t1) * Math.sign(a));
                const o = X(this.center[0]) * r;
                s = et(s, -Math.PI - o, Math.PI - o);
                const l = Q(Z(s / r) + this.center[0], -180, 180), u = Math.asin(Q((n - (t1 * t1 + a * a) * r * r) / (2 * r), -1, 1)), c = Q(Z(u), -ml, ml);
                return new il(l, c);
            }
        }
        const Pd = 1.340264, zd = -.081106, Ed = 893e-6, kd = .003796, Td = Math.sqrt(3) / 2;
        class Bd extends Sd {
            project(t1, e) {
                e = e / 180 * Math.PI, t1 = t1 / 180 * Math.PI;
                const r = Math.asin(Td * Math.sin(e)), n = r * r, i = n * n * n;
                return {
                    x: .5 * (t1 * Math.cos(r) / (Td * (Pd + 3 * zd * n + i * (7 * Ed + 9 * kd * n))) / Math.PI + .5),
                    y: 1 - .5 * (r * (Pd + zd * n + i * (Ed + kd * n)) / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e) {
                t1 = (2 * t1 - .5) * Math.PI;
                let r = e = (2 * (1 - e) - 1) * Math.PI, n = r * r, i = n * n * n;
                for(let t1, a, s, o = 0; o < 12 && (a = r * (Pd + zd * n + i * (Ed + kd * n)) - e, s = Pd + 3 * zd * n + i * (7 * Ed + 9 * kd * n), t1 = a / s, r = Q(r - t1, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(t1) < 1e-12)); ++o);
                const a = Td * t1 * (Pd + 3 * zd * n + i * (7 * Ed + 9 * kd * n)) / Math.cos(r), s = Math.asin(Math.sin(r) / Td), o = Q(180 * a / Math.PI, -180, 180), l = Q(180 * s / Math.PI, -ml, ml);
                return new il(o, l);
            }
        }
        class Vd extends Sd {
            constructor(t1){
                super(t1), this.wrap = !0, this.supportsWorldCopies = !0;
            }
            project(t1, e) {
                return {
                    x: .5 + t1 / 360,
                    y: .5 - e / 360,
                    z: 0
                };
            }
            unproject(t1, e) {
                const r = 360 * (t1 - .5), n = Q(360 * (.5 - e), -ml, ml);
                return new il(r, n);
            }
        }
        const Cd = Math.PI / 2;
        function Dd(t1) {
            return Math.tan((Cd + t1) / 2);
        }
        class Ld extends Sd {
            constructor(t1){
                super(t1), this.center = t1.center || [
                    0,
                    30
                ];
                const [e, r] = this.parallels = t1.parallels || [
                    30,
                    30
                ];
                let n = X(e), i = X(r);
                this.southernCenter = n + i < 0, this.southernCenter && (n = -n, i = -i);
                const a = Math.cos(n), s = Dd(n);
                this.n = n === i ? Math.sin(n) : Math.log(a / Math.cos(i)) / Math.log(Dd(i) / s), this.f = a * Math.pow(Dd(n), this.n) / this.n;
            }
            project(t1, e) {
                e = X(e), this.southernCenter && (e = -e), t1 = X(t1 - this.center[0]);
                const r = 1e-6, { n, f: i } = this;
                i > 0 ? e < -Cd + r && (e = -Cd + r) : e > Cd - r && (e = Cd - r);
                const a = i / Math.pow(Dd(e), n);
                let s = a * Math.sin(n * t1), o = i - a * Math.cos(n * t1);
                return s = .5 * (s / Math.PI + .5), o = .5 * (o / Math.PI + .5), {
                    x: s,
                    y: this.southernCenter ? o : 1 - o,
                    z: 0
                };
            }
            unproject(t1, e) {
                t1 = (2 * t1 - .5) * Math.PI, this.southernCenter && (e = 1 - e), e = (2 * (1 - e) - .5) * Math.PI;
                const { n: r, f: n } = this, i = n - e, a = Math.sign(i), s = Math.sign(r) * Math.sqrt(t1 * t1 + i * i);
                let o = Math.atan2(t1, Math.abs(i)) * a;
                i * r < 0 && (o -= Math.PI * Math.sign(t1) * a);
                const l = Q(Z(o / r) + this.center[0], -180, 180), u = Q(Z(2 * Math.atan(Math.pow(n / s, 1 / r)) - Cd), -ml, ml);
                return new il(l, this.southernCenter ? -u : u);
            }
        }
        class Rd extends Sd {
            constructor(t1){
                super(t1), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;
            }
            project(t1, e) {
                return {
                    x: ul(t1),
                    y: cl(e),
                    z: 0
                };
            }
            unproject(t1, e) {
                const r = pl(t1), n = fl(e);
                return new il(r, n);
            }
        }
        const Fd = X(ml);
        class Od extends Sd {
            project(t1, e) {
                const r = (e = X(e)) * e, n = r * r;
                return {
                    x: .5 * ((t1 = X(t1)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5),
                    y: 1 - .5 * (e * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e) {
                t1 = (2 * t1 - .5) * Math.PI;
                let r = e = (2 * (1 - e) - 1) * Math.PI, n = 25, i = 0, a = r * r;
                do {
                    a = r * r;
                    const t1 = a * a;
                    i = (r * (1.007226 + a * (.015085 + t1 * (.028874 * a - .044475 - .005916 * t1))) - e) / (1.007226 + a * (.045255 + t1 * (.259866 * a - .311325 - .005916 * 11 * t1))), r = Q(r - i, -Fd, Fd);
                }while (Math.abs(i) > 1e-6 && --n > 0)
                a = r * r;
                const s = Q(Z(t1 / (.8707 + a * (a * (a * a * a * (.003971 - .001529 * a) - .013791) - .131979))), -180, 180), o = Z(r);
                return new il(s, o);
            }
        }
        const Nd = X(ml);
        class Ud extends Sd {
            project(t1, e) {
                e = X(e), t1 = X(t1);
                const r = Math.cos(e), n = 2 / Math.PI, i = Math.acos(r * Math.cos(t1 / 2)), a = Math.sin(i) / i, s = .5 * (t1 * n + 2 * r * Math.sin(t1 / 2) / a) || 0, o = .5 * (e + Math.sin(e) / a) || 0;
                return {
                    x: .5 * (s / Math.PI + .5),
                    y: 1 - .5 * (o / Math.PI + 1),
                    z: 0
                };
            }
            unproject(t1, e) {
                let r = t1 = (2 * t1 - .5) * Math.PI, n = e = (2 * (1 - e) - 1) * Math.PI, i = 25;
                const a = 1e-6;
                let s = 0, o = 0;
                do {
                    const i = Math.cos(n), a = Math.sin(n), l = 2 * a * i, u = a * a, c = i * i, h = Math.cos(r / 2), p = Math.sin(r / 2), f = 2 * h * p, d = p * p, m = 1 - c * h * h, y = m ? 1 / m : 0, g = m ? Math.acos(i * h) * Math.sqrt(1 / m) : 0, x = .5 * (2 * g * i * p + 2 * r / Math.PI) - t1, v = .5 * (g * a + n) - e, b = .5 * y * (c * d + g * i * h * u) + 1 / Math.PI, _ = y * (f * l / 4 - g * a * p), w = .125 * y * (l * p - g * a * c * f), M = .5 * y * (u * h + g * d * i) + .5, A = _ * w - M * b;
                    s = (v * _ - x * M) / A, o = (x * w - v * b) / A, r = Q(r - s, -Math.PI, Math.PI), n = Q(n - o, -Nd, Nd);
                }while ((Math.abs(s) > a || Math.abs(o) > a) && --i > 0)
                return new il(Z(r), Z(n));
            }
        }
        class jd extends Sd {
            constructor(t1){
                super(t1), this.center = t1.center || [
                    0,
                    0
                ], this.parallels = t1.parallels || [
                    0,
                    0
                ], this.cosPhi = Math.max(.01, Math.cos(X(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;
            }
            project(t1, e) {
                const { scale: r, cosPhi: n } = this;
                return {
                    x: X(t1) * n * r + .5,
                    y: -Math.sin(X(e)) / n * r + .5,
                    z: 0
                };
            }
            unproject(t1, e) {
                const { scale: r, cosPhi: n } = this, i = -(e - .5) / r, a = Q(Z((t1 - .5) / r) / n, -180, 180), s = Math.asin(Q(i * n, -1, 1)), o = Q(Z(s), -ml, ml);
                return new il(a, o);
            }
        }
        class qd extends Rd {
            constructor(t1){
                super(t1), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = "pixels", this.unsupportedLayers = [
                    "debug"
                ], this.range = [
                    3,
                    5
                ];
            }
            projectTilePoint(t1, e, r) {
                const n = ku(t1, e, r), i = Vu(Au(r));
                return O.vec3.transformMat4(n, n, i), {
                    x: n[0],
                    y: n[1],
                    z: n[2]
                };
            }
            locationPoint(t1, e) {
                const r = el(e.lat, e.lng), n = O.vec3.normalize([], r), i = t1.elevation ? t1.elevation.getAtPointOrZero(t1.locationCoordinate(e), t1._centerAltitude) : t1._centerAltitude, a = hl(1, 0) * Wr * i;
                O.vec3.scaleAndAdd(r, r, n, a);
                const s = O.mat4.identity(new Float64Array(16));
                return O.mat4.multiply(s, t1.pixelMatrix, t1.globeMatrix), O.vec3.transformMat4(r, r, s), new q(r[0], r[1]);
            }
            pixelsPerMeter(t1, e) {
                return hl(1, 0) * e;
            }
            pixelSpaceConversion(t1, e, r) {
                const n = hl(1, t1) * e, i = ze(hl(1, 45) * e, n, r);
                return this.pixelsPerMeter(t1, e) / i;
            }
            createTileMatrix(t1, e, r) {
                const n = Cu(Au(r.canonical));
                return O.mat4.multiply(new Float64Array(16), t1.globeMatrix, n);
            }
            createInversionMatrix(t1, e) {
                const { center: r } = t1, n = Vu(Au(e));
                return O.mat4.rotateY(n, n, X(r.lng)), O.mat4.rotateX(n, n, X(r.lat)), O.mat4.scale(n, n, [
                    t1._pixelsPerMercatorPixel,
                    t1._pixelsPerMercatorPixel,
                    1
                ]), Float32Array.from(n);
            }
            pointCoordinate(t1, e, r, n) {
                return _u(t1, e, r, !0) || new bl(0, 0);
            }
            pointCoordinate3D(t1, e, r) {
                const n = this.pointCoordinate(t1, e, r, 0);
                return [
                    n.x,
                    n.y,
                    n.z
                ];
            }
            isPointAboveHorizon(t1, e) {
                return !_u(t1, e.x, e.y, !1);
            }
            farthestPixelDistance(t1) {
                const e = function(t1, e) {
                    const r = t1.cameraToCenterDistance, n = t1._centerAltitude * e, i = t1._camera, a = t1._camera.forward(), s = O.vec3.add([], O.vec3.scale([], a, -r), [
                        0,
                        0,
                        n
                    ]), o = t1.worldSize / (2 * Math.PI), l = [
                        0,
                        0,
                        -o
                    ], u = t1.width / t1.height, c = Math.tan(t1.fovAboveCenter), h = O.vec3.scale([], i.up(), c), p = O.vec3.scale([], i.right(), c * u), f = O.vec3.normalize([], O.vec3.add([], O.vec3.add([], a, h), p)), d = [];
                    let m;
                    if (new hu(s, f).closestPointOnSphere(l, o, d)) {
                        const e = O.vec3.add([], d, l), r = O.vec3.sub([], e, s);
                        m = Math.cos(t1.fovAboveCenter) * O.vec3.length(r);
                    } else {
                        const t1 = O.vec3.sub([], s, l), e = O.vec3.sub([], l, s);
                        O.vec3.normalize(e, e);
                        const r = O.vec3.length(t1) - o;
                        m = Math.sqrt(r * (r + 2 * o));
                        const n = Math.acos(m / (o + r)) - Math.acos(O.vec3.dot(a, e));
                        m *= Math.cos(n);
                    }
                    return 1.01 * m;
                }(t1, this.pixelsPerMeter(t1.center.lat, t1.worldSize)), r = Fu(t1.zoom);
                if (r > 0) {
                    const n = _d(t1, hl(1, t1.center.lat) * t1.worldSize), i = t1.worldSize / (2 * Math.PI), a = Math.max(t1.width, t1.height) / t1.worldSize * Math.PI;
                    return ze(e, n + i * (1 - Math.cos(a)), Math.pow(r, 10));
                }
                return e;
            }
            upVector(t1, e, r) {
                return ku(e, r, t1, 1);
            }
            upVectorScale(t1) {
                return {
                    metersToTile: vu(Tu(Au(t1)))
                };
            }
        }
        function $d(t1) {
            const e = t1.parallels, r = !!e && Math.abs(e[0] + e[1]) < .01;
            switch(t1.name){
                case "mercator":
                    return new Rd(t1);
                case "equirectangular":
                    return new Vd(t1);
                case "naturalEarth":
                    return new Od(t1);
                case "equalEarth":
                    return new Bd(t1);
                case "winkelTripel":
                    return new Ud(t1);
                case "albers":
                    return r ? new jd(t1) : new Id(t1);
                case "lambertConformalConic":
                    return r ? new jd(t1) : new Ld(t1);
                case "globe":
                    return new qd(t1);
            }
            throw new Error(`Invalid projection name: ${t1.name}`);
        }
        const Gd = fh.VectorTileFeature.types, Yd = [
            {
                name: "a_fade_opacity",
                components: 1,
                type: "Uint8",
                offset: 0
            }
        ];
        function Xd(t1, e, r, n, i, a, s, o, l, u, c, h, p) {
            const f = o ? Math.min(md, Math.round(o[0])) : 0, d = o ? Math.min(md, Math.round(o[1])) : 0;
            t1.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), a, s, (f << 1) + (l ? 1 : 0), d, 16 * u, 16 * c, 256 * h, 256 * p);
        }
        function Zd(t1, e, r) {
            t1.emplaceBack(e, r);
        }
        function Hd(t1, e, r, n, i, a, s) {
            t1.emplaceBack(e, r, n, i, a, s);
        }
        function Wd(t1, e, r, n, i) {
            t1.emplaceBack(e, r, n, i), t1.emplaceBack(e, r, n, i), t1.emplaceBack(e, r, n, i), t1.emplaceBack(e, r, n, i);
        }
        function Kd(t1) {
            for (const e of t1.sections)if (ba(e.text)) return !0;
            return !1;
        }
        class Jd {
            constructor(t1){
                this.layoutVertexArray = new zs, this.indexArray = new Ls, this.programConfigurations = t1, this.segments = new po, this.dynamicLayoutVertexArray = new Ms, this.opacityVertexArray = new ks, this.placedSymbolArray = new to, this.iconTransitioningVertexArray = new Ts, this.globeExtVertexArray = new Es, this.zOffsetVertexArray = new Os;
            }
            isEmpty() {
                return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;
            }
            upload(t1, e, r, n, i) {
                this.isEmpty() || (r && (this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, Op.members), this.indexBuffer = t1.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t1.createVertexBuffer(this.dynamicLayoutVertexArray, Up.members, !0), this.opacityVertexBuffer = t1.createVertexBuffer(this.opacityVertexArray, Yd, !0), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t1.createVertexBuffer(this.iconTransitioningVertexArray, qp.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t1.createVertexBuffer(this.globeExtVertexArray, Np.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i) && (this.zOffsetVertexBuffer = t1.createVertexBuffer(this.zOffsetVertexArray, jp.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t1));
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
            }
        }
        oa(Jd, "SymbolBuffers");
        class Qd {
            constructor(t1, e, r){
                this.layoutVertexArray = new t1, this.layoutAttributes = e, this.indexArray = new r, this.segments = new po, this.collisionVertexArray = new Ds, this.collisionVertexArrayExt = new Ms;
            }
            upload(t1) {
                this.layoutVertexBuffer = t1.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t1.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t1.createVertexBuffer(this.collisionVertexArray, $p.members, !0), this.collisionVertexBufferExt = t1.createVertexBuffer(this.collisionVertexArrayExt, Gp.members, !0);
            }
            destroy() {
                this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
            }
        }
        oa(Qd, "CollisionBuffers");
        class tm {
            constructor(t1){
                this.collisionBoxArray = t1.collisionBoxArray, this.zoom = t1.zoom, this.lut = t1.lut, this.overscaling = t1.overscaling, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.index = t1.index, this.pixelRatio = t1.pixelRatio, this.sourceLayerIndex = t1.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.hasAnyIconTextFit = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = O.mat4.identity([]), this.placementViewportMatrix = O.mat4.identity([]);
                const e = this.layers[0]._unevaluatedLayout._values;
                this.textSizeData = Kp(this.zoom, e["text-size"]), this.iconSizeData = Kp(this.zoom, e["icon-size"]);
                const r = this.layers[0].layout, n = r.get("symbol-sort-key"), i = r.get("symbol-z-order");
                this.canOverlap = r.get("text-allow-overlap") || r.get("icon-allow-overlap") || r.get("text-ignore-placement") || r.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i || "auto" === i && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r.get("text-writing-mode").map((t1)=>xf[t1]), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.sourceID = t1.sourceID, this.projection = t1.projection, this.hasAnyZOffset = !1, this.zOffsetSortDirty = !1, this.zOffsetBuffersNeedUpload = r.get("symbol-z-elevate"), this.activeReplacements = [], this.replacementUpdateTime = 0;
            }
            createArrays() {
                this.text = new Jd(new No(this.layers, {
                    zoom: this.zoom,
                    lut: this.lut
                }, (t1)=>t1.startsWith("text") || t1.startsWith("symbol"))), this.icon = new Jd(new No(this.layers, {
                    zoom: this.zoom,
                    lut: this.lut
                }, (t1)=>t1.startsWith("icon") || t1.startsWith("symbol"))), this.glyphOffsetArray = new no, this.lineVertexArray = new io, this.symbolInstances = new ro;
            }
            calculateGlyphDependencies(t1, e, r, n, i) {
                for (const r of t1){
                    const t1 = r.codePointAt(0);
                    if (void 0 === t1) break;
                    if (e[t1] = !0, n && i && t1 <= 65535) {
                        const t1 = rf[r];
                        t1 && (e[t1.charCodeAt(0)] = !0);
                    }
                }
            }
            updateFootprints(t1, e) {}
            updateReplacement(t1, e) {
                if (e.updateTime === this.replacementUpdateTime) return !1;
                this.replacementUpdateTime = e.updateTime;
                const r = e.getReplacementRegionsForTile(t1.toUnwrapped(), !0);
                return !Ah(this.activeReplacements, r) && (this.activeReplacements = r, !0);
            }
            populate(t1, e, r, n) {
                const i = this.layers[0], a = i.layout, s = "globe" === this.projection.name, o = a.get("text-font"), l = a.get("text-field"), u = a.get("icon-image"), [c, h] = a.get("icon-size-scale-range"), p = Q(e.scaleFactor || 1, c, h), f = ("constant" !== l.value.kind || l.value.value instanceof Je && !l.value.value.isEmpty() || l.value.value.toString().length > 0) && ("constant" !== o.value.kind || o.value.value.length > 0), d = "constant" !== u.value.kind || !!u.value.value || Object.keys(u.parameters).length > 0, m = a.get("symbol-sort-key");
                if (this.features = [], !f && !d) return;
                const y = e.iconDependencies, g = e.glyphDependencies, x = e.availableImages, v = new Va(this.zoom);
                for (const { feature: e, id: l, index: u, sourceLayerIndex: c } of t1){
                    const t1 = i._featureFilter.needGeometry, h = El(e, t1);
                    if (!i._featureFilter.filter(v, h, r)) continue;
                    if (t1 || (h.geometry = zl(e, r, n)), s && 1 !== e.type && r.z <= 5) {
                        const t1 = h.geometry, e = .98078528056, n = (t1, n)=>{
                            const i = ku(t1.x, t1.y, r, 1), a = ku(n.x, n.y, r, 1);
                            return O.vec3.dot(i, a) < e;
                        };
                        for(let e = 0; e < t1.length; e++)t1[e] = Al(t1[e], n);
                    }
                    let b, _;
                    if (f) {
                        const t1 = i.getValueAndResolveTokens("text-field", h, r, x), e = Je.factory(t1);
                        Kd(e) && (this.hasRTLText = !0), (!this.hasRTLText || "unavailable" === ka() || this.hasRTLText && Ba.isParsed()) && (b = ef(e, i, h));
                    }
                    if (d) {
                        const t1 = i.getValueAndResolveTokens("icon-image", h, r, x);
                        _ = t1 instanceof tr ? t1 : tr.build(t1);
                    }
                    if (!b && !_) continue;
                    const w = this.sortFeaturesByKey ? m.evaluate(h, {}, r) : void 0, M = {
                        id: l,
                        text: b,
                        icon: _,
                        index: u,
                        sourceLayerIndex: c,
                        geometry: h.geometry,
                        properties: e.properties,
                        type: Gd[e.type],
                        sortKey: w
                    };
                    if (this.features.push(M), _) {
                        const t1 = Wp(this.iconSizeData, this.layers[0]._unevaluatedLayout._values["icon-size"], r, this.zoom, M) * p * this.pixelRatio, e = _.getPrimary().scaleSelf(t1);
                        if (y[e.id] = y[e.id] || [], y[e.id].push(e), _.nameSecondary) {
                            const e = _.getSecondary().scaleSelf(t1);
                            y[e.id] = y[e.id] || [], y[e.id].push(e);
                        }
                    }
                    if (b) {
                        const t1 = o.evaluate(h, {}, r).join(","), e = "map" === a.get("text-rotation-alignment") && "point" !== a.get("symbol-placement");
                        this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(xf.vertical) >= 0;
                        for (const r of b.sections)if (r.image) {
                            const t1 = r.image.getPrimary().scaleSelf(this.pixelRatio);
                            y[t1.id] = y[t1.id] || [], y[t1.id].push(t1);
                        } else {
                            const n = fa(b.toString()), i = r.fontStack || t1, a = g[i] = g[i] || {};
                            this.calculateGlyphDependencies(r.text, a, e, this.allowVerticalPlacement, n);
                        }
                    }
                }
                "line" === a.get("symbol-placement") && (this.features = function(t1) {
                    const e = {}, r = {}, n = [];
                    let i = 0;
                    function a(e) {
                        n.push(t1[e]), i++;
                    }
                    function s(t1, e, i) {
                        const a = r[t1];
                        return delete r[t1], r[e] = a, n[a].geometry[0].pop(), n[a].geometry[0] = n[a].geometry[0].concat(i[0]), a;
                    }
                    function o(t1, r, i) {
                        const a = e[r];
                        return delete e[r], e[t1] = a, n[a].geometry[0].shift(), n[a].geometry[0] = i[0].concat(n[a].geometry[0]), a;
                    }
                    function l(t1, e, r) {
                        const n = r ? e[0][e[0].length - 1] : e[0][0];
                        return `${t1}:${n.x}:${n.y}`;
                    }
                    for(let u = 0; u < t1.length; u++){
                        const c = t1[u], h = c.geometry, p = c.text ? c.text.toString() : null;
                        if (!p) {
                            a(u);
                            continue;
                        }
                        const f = l(p, h), d = l(p, h, !0);
                        if (f in r && d in e && r[f] !== e[d]) {
                            const t1 = o(f, d, h), i = s(f, d, n[t1].geometry);
                            delete e[f], delete r[d], r[l(p, n[i].geometry, !0)] = i, n[t1].geometry = null;
                        } else f in r ? s(f, d, h) : d in e ? o(f, d, h) : (a(u), e[f] = i - 1, r[d] = i - 1);
                    }
                    return n.filter((t1)=>t1.geometry);
                }(this.features)), this.sortFeaturesByKey && this.features.sort((t1, e)=>t1.sortKey - e.sortKey);
            }
            update(t1, e, r, n, i, a, s) {
                this.text.programConfigurations.updatePaintArrays(t1, e, i, r, n, a, s), this.icon.programConfigurations.updatePaintArrays(t1, e, i, r, n, a, s);
            }
            updateZOffset() {
                const t1 = (t1, e, n)=>{
                    r += e, r > t1.length && t1.resize(r);
                    for(let i = -e; i < 0; i++)t1.emplace(i + r, n);
                }, e = (t1, e, r)=>{
                    n += e, n > t1.length && t1.resize(n);
                    for(let i = -e; i < 0; i++)t1.emplace(i + n, r);
                };
                if (!this.zOffsetBuffersNeedUpload) return;
                this.zOffsetBuffersNeedUpload = !1;
                let r = 0, n = 0;
                for(let r = 0; r < this.symbolInstances.length; r++){
                    const n = this.symbolInstances.get(r), { numHorizontalGlyphVertices: i, numVerticalGlyphVertices: a, numIconVertices: s } = n, o = n.zOffset, l = s > 0;
                    if ((i > 0 || a > 0) && (t1(this.text.zOffsetVertexArray, i, o), t1(this.text.zOffsetVertexArray, a, o)), l) {
                        const { placedIconSymbolIndex: t1, verticalPlacedIconSymbolIndex: r } = n;
                        t1 >= 0 && e(this.icon.zOffsetVertexArray, s, o), r >= 0 && e(this.icon.zOffsetVertexArray, n.numVerticalIconVertices, o);
                    }
                }
                this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
            }
            isEmpty() {
                return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
                return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t1) {
                !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t1), this.iconCollisionBox.upload(t1)), this.text.upload(t1, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(t1, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = !0;
            }
            destroyDebugData() {
                this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            getProjection() {
                return this.projectionInstance || (this.projectionInstance = $d(this.projection)), this.projectionInstance;
            }
            destroy() {
                this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t1, e) {
                const r = this.lineVertexArray.length;
                if (void 0 !== t1.segment) for (const { x: t1, y: r } of e)this.lineVertexArray.emplaceBack(t1, r);
                return {
                    lineStartIndex: r,
                    lineLength: this.lineVertexArray.length - r
                };
            }
            addSymbols(t1, e, r, n, i, a, s, o, l, u, c, h, p, f, d, m) {
                const y = t1.indexArray, g = t1.layoutVertexArray, x = t1.globeExtVertexArray, v = t1.segments.prepareSegment(4 * e.length, g, y, this.canOverlap ? a.sortKey : void 0), b = this.glyphOffsetArray.length, _ = v.vertexLength, w = this.allowVerticalPlacement && s === xf.vertical ? Math.PI / 2 : 0, M = a.text && a.text.sections;
                for(let n = 0; n < e.length; n++){
                    const { tl: i, tr: s, bl: u, br: c, texPrimary: h, texSecondary: b, pixelOffsetTL: _, pixelOffsetBR: A, minFontScaleX: S, minFontScaleY: I, glyphOffset: P, isSDF: z, sectionIndex: E } = e[n], k = v.vertexLength, T = P[1];
                    if (Xd(g, l.x, l.y, i.x, T + i.y, h.x, h.y, r, z, _.x, _.y, S, I), Xd(g, l.x, l.y, s.x, T + s.y, h.x + h.w, h.y, r, z, A.x, _.y, S, I), Xd(g, l.x, l.y, u.x, T + u.y, h.x, h.y + h.h, r, z, _.x, A.y, S, I), Xd(g, l.x, l.y, c.x, T + c.y, h.x + h.w, h.y + h.h, r, z, A.x, A.y, S, I), o) {
                        const { x: e, y: r, z: n } = o.anchor, [i, a, s] = o.up;
                        Hd(x, e, r, n, i, a, s), Hd(x, e, r, n, i, a, s), Hd(x, e, r, n, i, a, s), Hd(x, e, r, n, i, a, s), Wd(t1.dynamicLayoutVertexArray, e, r, n, w);
                    } else Wd(t1.dynamicLayoutVertexArray, l.x, l.y, l.z, w);
                    if (m) {
                        const e = b || h;
                        Zd(t1.iconTransitioningVertexArray, e.x, e.y), Zd(t1.iconTransitioningVertexArray, e.x + e.w, e.y), Zd(t1.iconTransitioningVertexArray, e.x, e.y + e.h), Zd(t1.iconTransitioningVertexArray, e.x + e.w, e.y + e.h);
                    }
                    y.emplaceBack(k, k + 1, k + 2), y.emplaceBack(k + 1, k + 2, k + 3), v.vertexLength += 4, v.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P[0]), n !== e.length - 1 && E === e[n + 1].sectionIndex || t1.programConfigurations.populatePaintArrays(g.length, a, a.index, {}, p, f, d, M && M[E]);
                }
                const A = o ? o.anchor : l;
                t1.placedSymbolArray.emplaceBack(A.x, A.y, A.z, l.x, l.y, b, this.glyphOffsetArray.length - b, _, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], s, 0, !1, 0, h, 0);
            }
            _commitLayoutVertex(t1, e, r, n, i, a, s) {
                t1.emplaceBack(e, r, n, i, a, Math.round(s.x), Math.round(s.y));
            }
            _addCollisionDebugVertices(t1, e, r, n, i, a, s) {
                const o = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray), l = o.vertexLength, u = s.tileAnchorX, c = s.tileAnchorY;
                for(let t1 = 0; t1 < 4; t1++)r.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
                this._commitDebugCollisionVertexUpdate(r.collisionVertexArrayExt, e, t1.padding, s.zOffset), this._commitLayoutVertex(r.layoutVertexArray, n, i, a, u, c, new q(t1.x1, t1.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, a, u, c, new q(t1.x2, t1.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, a, u, c, new q(t1.x2, t1.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, i, a, u, c, new q(t1.x1, t1.y2)), o.vertexLength += 4;
                const h = r.indexArray;
                h.emplaceBack(l, l + 1), h.emplaceBack(l + 1, l + 2), h.emplaceBack(l + 2, l + 3), h.emplaceBack(l + 3, l), o.primitiveLength += 4;
            }
            _addTextDebugCollisionBoxes(t1, e, r, n, i, a) {
                for(let s = n; s < i; s++){
                    const n = r.get(s), i = this.getSymbolInstanceTextSize(t1, a, e, s);
                    this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, a);
                }
            }
            _addIconDebugCollisionBoxes(t1, e, r, n, i, a) {
                for(let s = n; s < i; s++){
                    const n = r.get(s), i = this.getSymbolInstanceIconSize(t1, e, a.placedIconSymbolIndex);
                    this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, a);
                }
            }
            generateCollisionDebugBuffers(t1, e, r) {
                this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Qd(Vs, Yp.members, Ts), this.iconCollisionBox = new Qd(Vs, Yp.members, Ts);
                const n = Qp(this.iconSizeData, t1), i = Qp(this.textSizeData, t1, r);
                for(let r = 0; r < this.symbolInstances.length; r++){
                    const a = this.symbolInstances.get(r);
                    this._addTextDebugCollisionBoxes(i, t1, e, a.textBoxStartIndex, a.textBoxEndIndex, a), this._addTextDebugCollisionBoxes(i, t1, e, a.verticalTextBoxStartIndex, a.verticalTextBoxEndIndex, a), this._addIconDebugCollisionBoxes(n, t1, e, a.iconBoxStartIndex, a.iconBoxEndIndex, a), this._addIconDebugCollisionBoxes(n, t1, e, a.verticalIconBoxStartIndex, a.verticalIconBoxEndIndex, a);
                }
            }
            getSymbolInstanceTextSize(t1, e, r, n) {
                const i = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n), a = Jp(this.textSizeData, t1, i) / Zp;
                return this.tilePixelRatio * a;
            }
            getSymbolInstanceIconSize(t1, e, r) {
                const n = this.icon.placedSymbolArray.get(r), i = Jp(this.iconSizeData, t1, n);
                return this.tilePixelRatio * i;
            }
            _commitDebugCollisionVertexUpdate(t1, e, r, n) {
                t1.emplaceBack(e, -r, -r, n), t1.emplaceBack(e, r, -r, n), t1.emplaceBack(e, r, r, n), t1.emplaceBack(e, -r, r, n);
            }
            _updateTextDebugCollisionBoxes(t1, e, r, n, i, a, s) {
                for(let s = n; s < i; s++){
                    const n = r.get(s), i = this.getSymbolInstanceTextSize(t1, a, e, s);
                    this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding, a.zOffset);
                }
            }
            _updateIconDebugCollisionBoxes(t1, e, r, n, i, a, s) {
                for(let s = n; s < i; s++){
                    const n = r.get(s), i = this.getSymbolInstanceIconSize(t1, e, a.placedIconSymbolIndex);
                    this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding, a.zOffset);
                }
            }
            updateCollisionDebugBuffers(t1, e, r, n) {
                if (!this.hasDebugData()) return;
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
                const i = Qp(this.iconSizeData, t1, n), a = Qp(this.textSizeData, t1, r);
                for(let s = 0; s < this.symbolInstances.length; s++){
                    const o = this.symbolInstances.get(s);
                    this._updateTextDebugCollisionBoxes(a, t1, e, o.textBoxStartIndex, o.textBoxEndIndex, o, r), this._updateTextDebugCollisionBoxes(a, t1, e, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o, r), this._updateIconDebugCollisionBoxes(i, t1, e, o.iconBoxStartIndex, o.iconBoxEndIndex, o, n), this._updateIconDebugCollisionBoxes(i, t1, e, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex, o, n);
                }
                this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
            }
            _deserializeCollisionBoxesForSymbol(t1, e, r, n, i, a, s, o, l) {
                const u = {};
                if (e < r) {
                    const { x1: r, y1: n, x2: i, y2: a, padding: s, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: f } = t1.get(e);
                    u.textBox = {
                        x1: r,
                        y1: n,
                        x2: i,
                        y2: a,
                        padding: s,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.textFeatureIndex = f;
                }
                if (n < i) {
                    const { x1: e, y1: r, x2: i, y2: a, padding: s, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: f } = t1.get(n);
                    u.verticalTextBox = {
                        x1: e,
                        y1: r,
                        x2: i,
                        y2: a,
                        padding: s,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.verticalTextFeatureIndex = f;
                }
                if (a < s) {
                    const { x1: e, y1: r, x2: n, y2: i, padding: s, projectedAnchorX: o, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: f } = t1.get(a);
                    u.iconBox = {
                        x1: e,
                        y1: r,
                        x2: n,
                        y2: i,
                        padding: s,
                        projectedAnchorX: o,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.iconFeatureIndex = f;
                }
                if (o < l) {
                    const { x1: e, y1: r, x2: n, y2: i, padding: a, projectedAnchorX: s, projectedAnchorY: l, projectedAnchorZ: c, tileAnchorX: h, tileAnchorY: p, featureIndex: f } = t1.get(o);
                    u.verticalIconBox = {
                        x1: e,
                        y1: r,
                        x2: n,
                        y2: i,
                        padding: a,
                        projectedAnchorX: s,
                        projectedAnchorY: l,
                        projectedAnchorZ: c,
                        tileAnchorX: h,
                        tileAnchorY: p
                    }, u.verticalIconFeatureIndex = f;
                }
                return u;
            }
            deserializeCollisionBoxes(t1) {
                this.collisionArrays = [];
                for(let e = 0; e < this.symbolInstances.length; e++){
                    const r = this.symbolInstances.get(e);
                    this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t1, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));
                }
            }
            hasTextData() {
                return this.text.segments.get().length > 0;
            }
            hasIconData() {
                return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
                return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
                return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
                return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            hasIconTextFit() {
                return this.hasAnyIconTextFit;
            }
            addIndicesForPlacedSymbol(t1, e) {
                const r = t1.placedSymbolArray.get(e), n = r.vertexStartIndex + 4 * r.numGlyphs;
                for(let e = r.vertexStartIndex; e < n; e += 4)t1.indexArray.emplaceBack(e, e + 1, e + 2), t1.indexArray.emplaceBack(e + 1, e + 2, e + 3);
            }
            getSortedSymbolIndexes(t1) {
                if (this.sortedAngle === t1 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
                const e = Math.sin(t1), r = Math.cos(t1), n = [], i = [], a = [];
                for(let t1 = 0; t1 < this.symbolInstances.length; ++t1){
                    a.push(t1);
                    const s = this.symbolInstances.get(t1);
                    n.push(0 | Math.round(e * s.tileAnchorX + r * s.tileAnchorY)), i.push(s.featureIndex);
                }
                return a.sort((t1, e)=>n[t1] - n[e] || i[e] - i[t1]), a;
            }
            getSortedIndexesByZOffset() {
                if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;
                if (!this.symbolInstanceIndexesSortedZOffset) {
                    this.symbolInstanceIndexesSortedZOffset = [];
                    for(let t1 = 0; t1 < this.symbolInstances.length; ++t1)this.symbolInstanceIndexesSortedZOffset.push(t1);
                }
                return this.zOffsetSortDirty = !1, this.symbolInstanceIndexesSortedZOffset.sort((t1, e)=>this.symbolInstances.get(e).zOffset - this.symbolInstances.get(t1).zOffset);
            }
            addToSortKeyRanges(t1, e) {
                const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                r && r.sortKey === e ? r.symbolInstanceEnd = t1 + 1 : this.sortKeyRanges.push({
                    sortKey: e,
                    symbolInstanceStart: t1,
                    symbolInstanceEnd: t1 + 1
                });
            }
            sortFeatures(t1) {
                if (this.sortFeaturesByY && this.sortedAngle !== t1 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                    this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t1), this.sortedAngle = t1, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                    for (const t1 of this.symbolInstanceIndexes){
                        const e = this.symbolInstances.get(t1);
                        this.featureSortOrder.push(e.featureIndex);
                        const { rightJustifiedTextSymbolIndex: r, centerJustifiedTextSymbolIndex: n, leftJustifiedTextSymbolIndex: i, verticalPlacedTextSymbolIndex: a, placedIconSymbolIndex: s, verticalPlacedIconSymbolIndex: o } = e;
                        r >= 0 && this.addIndicesForPlacedSymbol(this.text, r), n >= 0 && n !== r && this.addIndicesForPlacedSymbol(this.text, n), i >= 0 && i !== n && i !== r && this.addIndicesForPlacedSymbol(this.text, i), a >= 0 && this.addIndicesForPlacedSymbol(this.text, a), s >= 0 && this.addIndicesForPlacedSymbol(this.icon, s), o >= 0 && this.addIndicesForPlacedSymbol(this.icon, o);
                    }
                    this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
                }
            }
        }
        let em, rm, nm;
        oa(tm, "SymbolBucket", {
            omit: [
                "layers",
                "collisionBoxArray",
                "features",
                "compareText"
            ]
        }), tm.addDynamicAttributes = Wd;
        class im {
            constructor(t1){
                this.type = t1.property.overrides ? t1.property.overrides.runtimeType : Ce, this.defaultValue = t1;
            }
            evaluate(t1) {
                if (t1.formattedSection) {
                    const e = this.defaultValue.property.overrides;
                    if (e && e.hasOverride(t1.formattedSection)) return e.getOverride(t1.formattedSection);
                }
                return t1.feature && t1.featureState ? this.defaultValue.evaluate(t1.feature, t1.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t1) {
                this.defaultValue.isConstant() || t1(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
                return !1;
            }
            serialize() {
                return null;
            }
        }
        oa(im, "FormatSectionOverride", {
            omit: [
                "defaultValue"
            ]
        });
        const am = ()=>nm || (nm = {
                layout: em || (em = new Ga({
                    "symbol-placement": new ja(Ya.layout_symbol["symbol-placement"]),
                    "symbol-spacing": new ja(Ya.layout_symbol["symbol-spacing"]),
                    "symbol-avoid-edges": new ja(Ya.layout_symbol["symbol-avoid-edges"]),
                    "symbol-sort-key": new qa(Ya.layout_symbol["symbol-sort-key"]),
                    "symbol-z-order": new ja(Ya.layout_symbol["symbol-z-order"]),
                    "symbol-z-elevate": new ja(Ya.layout_symbol["symbol-z-elevate"]),
                    "symbol-elevation-reference": new ja(Ya.layout_symbol["symbol-elevation-reference"]),
                    "icon-allow-overlap": new ja(Ya.layout_symbol["icon-allow-overlap"]),
                    "icon-ignore-placement": new ja(Ya.layout_symbol["icon-ignore-placement"]),
                    "icon-optional": new ja(Ya.layout_symbol["icon-optional"]),
                    "icon-rotation-alignment": new ja(Ya.layout_symbol["icon-rotation-alignment"]),
                    "icon-size": new qa(Ya.layout_symbol["icon-size"]),
                    "icon-size-scale-range": new ja(Ya.layout_symbol["icon-size-scale-range"]),
                    "icon-text-fit": new qa(Ya.layout_symbol["icon-text-fit"]),
                    "icon-text-fit-padding": new qa(Ya.layout_symbol["icon-text-fit-padding"]),
                    "icon-image": new qa(Ya.layout_symbol["icon-image"]),
                    "icon-rotate": new qa(Ya.layout_symbol["icon-rotate"]),
                    "icon-padding": new ja(Ya.layout_symbol["icon-padding"]),
                    "icon-keep-upright": new ja(Ya.layout_symbol["icon-keep-upright"]),
                    "icon-offset": new qa(Ya.layout_symbol["icon-offset"]),
                    "icon-anchor": new qa(Ya.layout_symbol["icon-anchor"]),
                    "icon-pitch-alignment": new ja(Ya.layout_symbol["icon-pitch-alignment"]),
                    "text-pitch-alignment": new ja(Ya.layout_symbol["text-pitch-alignment"]),
                    "text-rotation-alignment": new ja(Ya.layout_symbol["text-rotation-alignment"]),
                    "text-field": new qa(Ya.layout_symbol["text-field"]),
                    "text-font": new qa(Ya.layout_symbol["text-font"]),
                    "text-size": new qa(Ya.layout_symbol["text-size"]),
                    "text-size-scale-range": new ja(Ya.layout_symbol["text-size-scale-range"]),
                    "text-max-width": new qa(Ya.layout_symbol["text-max-width"]),
                    "text-line-height": new qa(Ya.layout_symbol["text-line-height"]),
                    "text-letter-spacing": new qa(Ya.layout_symbol["text-letter-spacing"]),
                    "text-justify": new qa(Ya.layout_symbol["text-justify"]),
                    "text-radial-offset": new qa(Ya.layout_symbol["text-radial-offset"]),
                    "text-variable-anchor": new ja(Ya.layout_symbol["text-variable-anchor"]),
                    "text-anchor": new qa(Ya.layout_symbol["text-anchor"]),
                    "text-max-angle": new ja(Ya.layout_symbol["text-max-angle"]),
                    "text-writing-mode": new ja(Ya.layout_symbol["text-writing-mode"]),
                    "text-rotate": new qa(Ya.layout_symbol["text-rotate"]),
                    "text-padding": new ja(Ya.layout_symbol["text-padding"]),
                    "text-keep-upright": new ja(Ya.layout_symbol["text-keep-upright"]),
                    "text-transform": new qa(Ya.layout_symbol["text-transform"]),
                    "text-offset": new qa(Ya.layout_symbol["text-offset"]),
                    "text-allow-overlap": new ja(Ya.layout_symbol["text-allow-overlap"]),
                    "text-ignore-placement": new ja(Ya.layout_symbol["text-ignore-placement"]),
                    "text-optional": new ja(Ya.layout_symbol["text-optional"]),
                    visibility: new ja(Ya.layout_symbol.visibility)
                })),
                paint: rm || (rm = new Ga({
                    "icon-opacity": new qa(Ya.paint_symbol["icon-opacity"]),
                    "icon-occlusion-opacity": new qa(Ya.paint_symbol["icon-occlusion-opacity"]),
                    "icon-emissive-strength": new qa(Ya.paint_symbol["icon-emissive-strength"]),
                    "text-emissive-strength": new qa(Ya.paint_symbol["text-emissive-strength"]),
                    "icon-color": new qa(Ya.paint_symbol["icon-color"]),
                    "icon-halo-color": new qa(Ya.paint_symbol["icon-halo-color"]),
                    "icon-halo-width": new qa(Ya.paint_symbol["icon-halo-width"]),
                    "icon-halo-blur": new qa(Ya.paint_symbol["icon-halo-blur"]),
                    "icon-translate": new ja(Ya.paint_symbol["icon-translate"]),
                    "icon-translate-anchor": new ja(Ya.paint_symbol["icon-translate-anchor"]),
                    "icon-image-cross-fade": new qa(Ya.paint_symbol["icon-image-cross-fade"]),
                    "text-opacity": new qa(Ya.paint_symbol["text-opacity"]),
                    "text-occlusion-opacity": new qa(Ya.paint_symbol["text-occlusion-opacity"]),
                    "text-color": new qa(Ya.paint_symbol["text-color"], {
                        runtimeType: Fe,
                        getOverride: (t1)=>t1.textColor,
                        hasOverride: (t1)=>!!t1.textColor
                    }),
                    "text-halo-color": new qa(Ya.paint_symbol["text-halo-color"]),
                    "text-halo-width": new qa(Ya.paint_symbol["text-halo-width"]),
                    "text-halo-blur": new qa(Ya.paint_symbol["text-halo-blur"]),
                    "text-translate": new ja(Ya.paint_symbol["text-translate"]),
                    "text-translate-anchor": new ja(Ya.paint_symbol["text-translate-anchor"]),
                    "icon-color-saturation": new ja(Ya.paint_symbol["icon-color-saturation"]),
                    "icon-color-contrast": new ja(Ya.paint_symbol["icon-color-contrast"]),
                    "icon-color-brightness-min": new ja(Ya.paint_symbol["icon-color-brightness-min"]),
                    "icon-color-brightness-max": new ja(Ya.paint_symbol["icon-color-brightness-max"]),
                    "symbol-z-offset": new qa(Ya.paint_symbol["symbol-z-offset"]),
                    "icon-color-use-theme": new qa({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "icon-halo-color-use-theme": new qa({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "text-color-use-theme": new qa({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    }),
                    "text-halo-color-use-theme": new qa({
                        type: "string",
                        default: "default",
                        "property-type": "data-driven"
                    })
                }))
            }, nm);
        class sm extends ps {
            constructor(t1, e, r, n){
                super(t1, am(), e, r, n), this._colorAdjustmentMatrix = O.mat4.identity([]), this.hasInitialOcclusionOpacityProperties = void 0 !== t1.paint && ("icon-occlusion-opacity" in t1.paint || "text-occlusion-opacity" in t1.paint);
            }
            recalculate(t1, e) {
                super.recalculate(t1, e), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
                const r = this.layout.get("text-writing-mode");
                if (r) {
                    const t1 = [];
                    for (const e of r)t1.indexOf(e) < 0 && t1.push(e);
                    this.layout._values["text-writing-mode"] = t1;
                } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? [
                    "horizontal"
                ] : [
                    "horizontal",
                    "vertical"
                ];
                this._setPaintOverrides();
            }
            getColorAdjustmentMatrix(t1, e, r, n) {
                return this._saturation === t1 && this._contrast === e && this._brightnessMin === r && this._brightnessMax === n || (this._colorAdjustmentMatrix = function(t1, e, r, n) {
                    t1 = At(t1), e = Mt(e);
                    const i = O.mat4.create(), a = t1 / 3, s = 1 - 2 * a, o = [
                        s,
                        a,
                        a,
                        0,
                        a,
                        s,
                        a,
                        0,
                        a,
                        a,
                        s,
                        0,
                        0,
                        0,
                        0,
                        1
                    ], l = .5 - .5 * e, u = n - r;
                    return O.mat4.multiply(i, [
                        u,
                        0,
                        0,
                        0,
                        0,
                        u,
                        0,
                        0,
                        0,
                        0,
                        u,
                        0,
                        r,
                        r,
                        r,
                        1
                    ], [
                        e,
                        0,
                        0,
                        0,
                        0,
                        e,
                        0,
                        0,
                        0,
                        0,
                        e,
                        0,
                        l,
                        l,
                        l,
                        1
                    ]), O.mat4.multiply(i, i, o), i;
                }(t1, e, r, n), this._saturation = t1, this._contrast = e, this._brightnessMin = r, this._brightnessMax = n), this._colorAdjustmentMatrix;
            }
            getValueAndResolveTokens(t1, e, r, n) {
                const i = this.layout.get(t1).evaluate(e, {}, r, n), a = this._unevaluatedLayout._values[t1];
                return a.isDataDriven() || Hi(a.value) || !i ? i : function(t1, e) {
                    return e.replace(/{([^{}]+)}/g, (e, r)=>r in t1 ? String(t1[r]) : "");
                }(e.properties, i);
            }
            createBucket(t1) {
                return new tm(t1);
            }
            queryRadius() {
                return 0;
            }
            queryIntersectsFeature() {
                return !1;
            }
            _setPaintOverrides() {
                for (const t1 of am().paint.overridableProperties){
                    if (!sm.hasPaintOverride(this.layout, t1)) continue;
                    const e = this.paint.get(t1), r = new im(e), n = new Zi(r, e.property.specification, this.scope, this.options);
                    let i = null;
                    i = "constant" === e.value.kind || "source" === e.value.kind ? new Ki("source", n) : new Ji("composite", n, e.value.zoomStops, e.value._interpolationType), this.paint._values[t1] = new Na(e.property, i, e.parameters);
                }
            }
            _handleOverridablePaintPropertyUpdate(t1, e, r) {
                return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && sm.hasPaintOverride(this.layout, t1);
            }
            static hasPaintOverride(t1, e) {
                const r = t1.get("text-field"), n = am().paint.properties[e];
                let i = !1;
                const a = (t1)=>{
                    for (const e of t1)if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0);
                };
                if ("constant" === r.value.kind && r.value.value instanceof Je) a(r.value.value.sections);
                else if ("source" === r.value.kind) {
                    const t1 = (e)=>{
                        i || (e instanceof ar && nr(e.value) === je ? a(e.value.sections) : e instanceof ur ? a(e.sections) : e.eachChild(t1));
                    }, e = r.value;
                    e._styleExpression && t1(e._styleExpression.expression);
                }
                return i;
            }
            getProgramIds() {
                return [
                    "symbol"
                ];
            }
            getDefaultProgramParams(t1, e, r) {
                return {
                    config: new Oo(this, {
                        zoom: e,
                        lut: r
                    }),
                    overrideFog: !1
                };
            }
        }
        let om, lm, um, cm;
        var hm = ys([
            {
                name: "a_pos",
                type: "Int16",
                components: 2
            },
            {
                name: "a_texture_pos",
                type: "Int16",
                components: 2
            }
        ]);
        function pm(t1) {
            switch(t1){
                case WebGL2RenderingContext.RGBA8:
                    return WebGL2RenderingContext.RGBA;
                case WebGL2RenderingContext.DEPTH_COMPONENT16:
                    return WebGL2RenderingContext.DEPTH_COMPONENT;
                case WebGL2RenderingContext.DEPTH24_STENCIL8:
                    return WebGL2RenderingContext.DEPTH_STENCIL;
                case WebGL2RenderingContext.R8:
                case WebGL2RenderingContext.R32F:
                    return WebGL2RenderingContext.RED;
            }
        }
        function fm(t1) {
            switch(t1){
                case WebGL2RenderingContext.RGBA8:
                    return WebGL2RenderingContext.UNSIGNED_BYTE;
                case WebGL2RenderingContext.DEPTH_COMPONENT16:
                    return WebGL2RenderingContext.UNSIGNED_SHORT;
                case WebGL2RenderingContext.DEPTH24_STENCIL8:
                    return WebGL2RenderingContext.UNSIGNED_INT_24_8;
                case WebGL2RenderingContext.R8:
                    return WebGL2RenderingContext.UNSIGNED_BYTE;
                case WebGL2RenderingContext.R32F:
                    return WebGL2RenderingContext.FLOAT;
            }
        }
        class dm {
            constructor(t1, e, r, n){
                this.context = t1, this.format = r, this.useMipmap = n && n.useMipmap, this.texture = t1.gl.createTexture(), this.update(e, {
                    premultiply: n && n.premultiply
                });
            }
            update(t1, e) {
                const r = t1 && t1 instanceof HTMLVideoElement && 0 === t1.width ? t1.videoWidth : t1.width, n = t1 && t1 instanceof HTMLVideoElement && 0 === t1.height ? t1.videoHeight : t1.height, { context: i } = this, { gl: a } = i, { x: s, y: o } = e && e.position ? e.position : {
                    x: 0,
                    y: 0
                }, l = s + r, u = o + n;
                !this.size || this.size[0] === l && this.size[1] === u || (a.bindTexture(a.TEXTURE_2D, null), a.deleteTexture(this.texture), this.texture = a.createTexture(), this.size = null), a.bindTexture(a.TEXTURE_2D, this.texture), i.pixelStoreUnpackFlipY.set(!1), i.pixelStoreUnpack.set(1), i.pixelStoreUnpackPremultiplyAlpha.set(this.format === a.RGBA8 && (!e || !1 !== e.premultiply));
                const c = t1 instanceof HTMLImageElement || t1 instanceof HTMLCanvasElement || t1 instanceof HTMLVideoElement || t1 instanceof ImageData || ImageBitmap && t1 instanceof ImageBitmap;
                if (!this.size && l > 0 && u > 0) {
                    const t1 = this.useMipmap ? Math.floor(Math.log2(Math.max(l, u))) + 1 : 1;
                    a.texStorage2D(a.TEXTURE_2D, t1, this.format, l, u), this.size = [
                        l,
                        u
                    ];
                }
                if (this.size) if (c) a.texSubImage2D(a.TEXTURE_2D, 0, s, o, pm(this.format), fm(this.format), t1);
                else {
                    const e = t1.data;
                    e && a.texSubImage2D(a.TEXTURE_2D, 0, s, o, r, n, pm(this.format), fm(this.format), e);
                }
                this.useMipmap && a.generateMipmap(a.TEXTURE_2D);
            }
            bind(t1, e, r = !1) {
                const { context: n } = this, { gl: i } = n;
                i.bindTexture(i.TEXTURE_2D, this.texture), t1 !== this.minFilter && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, t1), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, this.useMipmap && !r ? t1 === i.NEAREST ? i.NEAREST_MIPMAP_NEAREST : i.LINEAR_MIPMAP_LINEAR : t1), this.minFilter = t1), e !== this.wrapS && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, e), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, e), this.wrapS = e);
            }
            bindExtraParam(t1, e, r, n) {
                const { context: i } = this, { gl: a } = i;
                a.bindTexture(a.TEXTURE_2D, this.texture), e !== this.magFilter && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, e), this.magFilter = e), t1 !== this.minFilter && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, this.useMipmap ? t1 === a.NEAREST ? a.NEAREST_MIPMAP_NEAREST : a.LINEAR_MIPMAP_LINEAR : t1), this.minFilter = t1), r !== this.wrapS && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, r), this.wrapS = r), n !== this.wrapT && (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, n), this.wrapT = n);
            }
            destroy() {
                const { gl: t1 } = this.context;
                t1.deleteTexture(this.texture), this.texture = null;
            }
        }
        class mm {
            constructor(t1, e){
                this.context = t1, this.texture = e;
            }
            bind(t1, e) {
                const { context: r } = this, { gl: n } = r;
                n.bindTexture(n.TEXTURE_2D, this.texture), t1 !== this.minFilter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t1), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, t1), this.minFilter = t1), e !== this.wrapS && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrapS = e);
            }
        }
        function ym(t1, e, r, n, i, a, s, o) {
            const l = [
                t1,
                e,
                1,
                r,
                n,
                1,
                i,
                a,
                1
            ], u = [
                s,
                o,
                1
            ], c = O.mat3.adjoint([], l), [h, p, f] = O.vec3.transformMat3(u, u, c);
            return O.mat3.multiply(l, l, [
                h,
                0,
                0,
                0,
                p,
                0,
                0,
                0,
                f
            ]);
        }
        function gm(t1, e, r, n, i, a, s, o) {
            const l = function(t1, e, r, n, i, a, s, o) {
                const l = ym(0, 0, 1, 0, 1, 1, 0, 1), u = ym(t1, e, r, n, i, a, s, o), c = O.mat3.adjoint([], l);
                return O.mat3.multiply(u, u, c);
            }(t1, e, r, n, i, a, s, o);
            return [
                l[2] / l[8] / Wr,
                l[5] / l[8] / Wr
            ];
        }
        function xm(t1) {
            return [
                t1[0],
                Math.min(Math.max(t1[1], -ml), ml)
            ];
        }
        class vm extends we {
            constructor(t1, e, r, n){
                super(), this.id = t1, this.dispatcher = r, this.coordinates = e.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.onNorthPole = !1, this.onSouthPole = !1, this.setEventedParent(n), this.options = e, this._dirty = !1;
            }
            load(t1, e) {
                if (this._loaded = e || !1, this.fire(new xe("dataloading", {
                    dataType: "source"
                })), this.url = this.options.url, !this.url) return t1 && (this.coordinates = t1), this._loaded = !0, void this._finishLoading();
                this._imageRequest = ue(this.map._requestManager.transformRequest(this.url, te.Image), (e, r)=>{
                    this._imageRequest = null, this._loaded = !0, e ? this.fire(new ve(e)) : r && (this.image = r instanceof HTMLImageElement ? Dt.getImageData(r) : r, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t1 && (this.coordinates = t1), this._finishLoading());
                });
            }
            loaded() {
                return this._loaded;
            }
            updateImage(t1) {
                return t1.url ? (this._imageRequest && t1.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t1.url, this.load(t1.coordinates, this._loaded), this) : this;
            }
            setTexture(t1) {
                if (!(t1.handle instanceof WebGLTexture)) throw new Error("The provided handle is not a WebGLTexture instance");
                return this.texture = new mm(this.map.painter.context, t1.handle), this.width = t1.dimensions[0], this.height = t1.dimensions[1], this._dirty = !1, this._loaded = !0, this._finishLoading(), this;
            }
            _finishLoading() {
                this.map && (this.setCoordinates(this.coordinates), this.fire(new xe("data", {
                    dataType: "source",
                    sourceDataType: "metadata"
                })));
            }
            onAdd(t1) {
                this.map = t1, this.load();
            }
            onRemove(t1) {
                this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof mm || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
            }
            setCoordinates(t1) {
                if (this.coordinates = t1, this._boundsArray = void 0, this._unsupportedCoords = !1, !t1.length) return this;
                this.onNorthPole = !1, this.onSouthPole = !1;
                let e = t1[0][1], r = t1[0][1];
                for (const n of t1)n[1] > r && (r = n[1]), n[1] < e && (e = n[1]);
                const n = (r + e) / 2;
                if (n > ml ? this.onNorthPole = !0 : n < -ml && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole) {
                    const e = t1.map(bl.fromLngLat);
                    this.tileID = function(t1) {
                        let e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0;
                        for (const a of t1)e = Math.min(e, a.x), r = Math.min(r, a.y), n = Math.max(n, a.x), i = Math.max(i, a.y);
                        const a = Math.max(n - e, i - r), s = Math.max(0, Math.floor(-Math.log(a) / Math.LN2)), o = Math.pow(2, s);
                        let l = Math.floor((e + n) / 2 * o);
                        return l > 1 && (l -= 1), new ru(s, l, Math.floor((r + i) / 2 * o));
                    }(e), this.minzoom = this.maxzoom = this.tileID.z;
                }
                return this.fire(new xe("data", {
                    dataType: "source",
                    sourceDataType: "content"
                })), this;
            }
            _clear() {
                this._boundsArray = void 0, this._unsupportedCoords = !1;
            }
            _prepareData(t1) {
                for(const t1 in this.tiles){
                    const e = this.tiles[t1];
                    "loaded" !== e.state && (e.state = "loaded", e.texture = this.texture);
                }
                if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;
                const e = wd(new ru(0, 0, 0), this.map.transform.projection), r = [
                    e.projection.project(this.coordinates[0][0], this.coordinates[0][1]),
                    e.projection.project(this.coordinates[1][0], this.coordinates[1][1]),
                    e.projection.project(this.coordinates[2][0], this.coordinates[2][1]),
                    e.projection.project(this.coordinates[3][0], this.coordinates[3][1])
                ];
                if (!function(t1) {
                    const e = t1[1].x - t1[0].x, r = t1[1].y - t1[0].y, n = t1[2].x - t1[1].x, i = t1[2].y - t1[1].y, a = t1[3].x - t1[2].x, s = t1[3].y - t1[2].y, o = t1[0].x - t1[3].x, l = t1[0].y - t1[3].y, u = e * i - n * r, c = n * s - a * i, h = a * l - o * s, p = o * r - e * l;
                    return u > 0 && c > 0 && h > 0 && p > 0 || u < 0 && c < 0 && h < 0 && p < 0;
                }(r)) return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = !0);
                const n = wd(this.tileID, this.map.transform.projection), [i, a, s, o] = this.coordinates.map((t1)=>{
                    const e = n.projection.project(t1[0], t1[1]);
                    return Md(n, e)._round();
                });
                this.perspectiveTransform = gm(i.x, i.y, a.x, a.y, s.x, s.y, o.x, o.y);
                const l = this._boundsArray = new bs;
                l.emplaceBack(i.x, i.y, 0, 0), l.emplaceBack(a.x, a.y, Wr, 0), l.emplaceBack(o.x, o.y, 0, Wr), l.emplaceBack(s.x, s.y, Wr, Wr), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = t1.createVertexBuffer(l, hm.members), this.boundsSegments = po.simpleSegment(0, 0, 4, 2);
                const u = [], c = [
                    xm((h = this.coordinates)[0]),
                    xm(h[1]),
                    xm(h[2]),
                    xm(h[3])
                ];
                var h;
                const [p, f, d, m] = function(t1) {
                    let e = t1[0][0], r = e, n = t1[0][1], i = n;
                    for(let a = 1; a < t1.length; a++)t1[a][0] < e ? e = t1[a][0] : t1[a][0] > r && (r = t1[a][0]), t1[a][1] < n ? n = t1[a][1] : t1[a][1] > i && (i = t1[a][1]);
                    return [
                        e,
                        n,
                        r - e,
                        i - n
                    ];
                }(c);
                {
                    const n = new bs, [i, a, s, o] = function(t1) {
                        let e = t1[0].x, r = e, n = t1[0].y, i = n;
                        for(let a = 1; a < t1.length; a++)t1[a].x < e ? e = t1[a].x : t1[a].x > r && (r = t1[a].x), t1[a].y < n ? n = t1[a].y : t1[a].y > i && (i = t1[a].y);
                        return [
                            e,
                            n,
                            r - e,
                            i - n
                        ];
                    }(r), l = (t1)=>[
                            (t1.x - i) / s,
                            (t1.y - a) / o
                        ], [c, h, y, g] = r.map(l), x = function(t1, e, r, n, i, a, s, o) {
                        const l = ym(0, 0, 1, 0, 1, 1, 0, 1), u = ym(t1, e, r, n, i, a, s, o), c = O.mat3.adjoint([], u);
                        return O.mat3.multiply(l, l, c);
                    }(c[0], c[1], h[0], h[1], y[0], y[1], g[0], g[1]);
                    this.elevatedGlobePerspectiveTransform = gm(c[0], c[1], h[0], h[1], y[0], y[1], g[0], g[1]);
                    const v = (t1, e)=>{
                        u.push(t1.lng);
                        const r = Math.round((t1.lng - p) / d * Wr), i = Math.round((t1.lat - f) / m * Wr), a = l(e), s = O.vec3.transformMat3([], [
                            a[0],
                            a[1],
                            1
                        ], x), o = Math.round(s[0] / s[2] * Wr), c = Math.round(s[1] / s[2] * Wr);
                        n.emplaceBack(r, i, o, c);
                    }, b = r[3].x - r[0].x, _ = r[3].y - r[0].y, w = r[2].x - r[1].x, M = r[2].y - r[1].y;
                    for(let t1 = 0; t1 < 65; t1++){
                        const n = t1 / 64, i = [
                            r[0].x + n * b,
                            r[0].y + n * _
                        ], a = [
                            r[1].x + n * w,
                            r[1].y + n * M
                        ], s = a[0] - i[0], o = a[1] - i[1];
                        for(let t1 = 0; t1 < 65; t1++){
                            const r = t1 / 64, n = {
                                x: i[0] + s * r,
                                y: i[1] + o * r,
                                z: 0
                            };
                            v(e.projection.unproject(n.x, n.y), n);
                        }
                    }
                    this.elevatedGlobeVertexBuffer = t1.createVertexBuffer(n, hm.members);
                }
                {
                    this.maxLongitudeTriangleSize = 0;
                    let e = [], r = new Ls;
                    const n = (t1, n, i)=>{
                        r.emplaceBack(t1, n, i);
                        const a = u[t1], s = u[n], o = u[i], l = Math.min(Math.min(a, s), o), c = Math.max(Math.max(a, s), o) - l;
                        c > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = c), e.push(l + c / 2);
                    };
                    for(let t1 = 0; t1 < 64; t1++)for(let e = 0; e < 64; e++){
                        const r = 65 * t1 + e, i = r + 1, a = r + 65, s = a + 1;
                        n(r, a, i), n(i, a, s);
                    }
                    [e, r] = function(t1, e) {
                        const r = Array.from({
                            length: t1.length
                        }, (t1, e)=>e);
                        r.sort((e, r)=>t1[e] - t1[r]);
                        const n = [], i = new Ls;
                        for(let a = 0; a < r.length; a++){
                            const s = r[a];
                            n.push(t1[s]);
                            const o = 3 * s, l = o + 1;
                            i.emplaceBack(e.uint16[o], e.uint16[l], e.uint16[l + 1]);
                        }
                        return [
                            n,
                            i
                        ];
                    }(e, r), this.elevatedGlobeTrianglesCenterLongitudes = e, this.elevatedGlobeIndexBuffer = t1.createIndexBuffer(r);
                }
                this.elevatedGlobeSegments = po.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([
                    0,
                    d / Wr,
                    0,
                    m / Wr,
                    0,
                    0,
                    f,
                    p,
                    0
                ]);
            }
            prepare() {
                const t1 = 0 !== Object.keys(this.tiles).length;
                if (this.tileID && !t1) return;
                const e = this.map.painter.context, r = e.gl;
                !this._dirty || this.texture instanceof mm || (this.texture ? this.texture.update(this.image) : (this.texture = new dm(e, this.image, r.RGBA8), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE)), this._dirty = !1), t1 && this._prepareData(e);
            }
            loadTile(t1, e) {
                this.tileID && this.tileID.equals(t1.tileID.canonical) ? (this.tiles[String(t1.tileID.wrap)] = t1, t1.buckets = {}, e(null)) : (t1.state = "errored", e(null));
            }
            serialize() {
                return {
                    type: "image",
                    url: this.options.url,
                    coordinates: this.coordinates
                };
            }
            hasTransition() {
                return !1;
            }
            getSegmentsForLongitude(t1) {
                const e = this.elevatedGlobeSegments;
                if (!this.elevatedGlobeTrianglesCenterLongitudes || !e) return null;
                const r = this.elevatedGlobeTrianglesCenterLongitudes;
                let n = (i = t1 + 180) + 360 * Math.round((r[0] - i) / 360);
                var i;
                const a = new po, s = (t1, r)=>{
                    a.segments.push({
                        vertexOffset: 0,
                        primitiveOffset: t1,
                        vertexLength: e.segments[0].vertexLength,
                        primitiveLength: r,
                        sortKey: void 0,
                        vaos: {}
                    });
                }, o = .51 * this.maxLongitudeTriangleSize;
                if (Math.abs(r[0] - n) <= o) {
                    const t1 = wt(r, 0, r.length, n + o);
                    return t1 === r.length || s(t1, _t(r, t1 + 1, r.length, n + 360 - o) - t1), a;
                }
                n < r[0] && (n += 360);
                const l = _t(r, 0, r.length, n - o);
                if (l === r.length) return s(0, r.length), a;
                s(0, l - 0);
                const u = wt(r, l + 1, r.length, n + o);
                return u !== r.length && s(u, r.length - u), a;
            }
        }
        const bm = (Math.pow(256, 2) - 1) / 16907520;
        class _m extends ps {
            constructor(t1, e, r, n){
                super(t1, {
                    layout: um || (um = new Ga({
                        visibility: new ja(Ya.layout_raster.visibility)
                    })),
                    paint: cm || (cm = new Ga({
                        "raster-opacity": new ja(Ya.paint_raster["raster-opacity"]),
                        "raster-color": new $a(Ya.paint_raster["raster-color"]),
                        "raster-color-mix": new ja(Ya.paint_raster["raster-color-mix"]),
                        "raster-color-range": new ja(Ya.paint_raster["raster-color-range"]),
                        "raster-hue-rotate": new ja(Ya.paint_raster["raster-hue-rotate"]),
                        "raster-brightness-min": new ja(Ya.paint_raster["raster-brightness-min"]),
                        "raster-brightness-max": new ja(Ya.paint_raster["raster-brightness-max"]),
                        "raster-saturation": new ja(Ya.paint_raster["raster-saturation"]),
                        "raster-contrast": new ja(Ya.paint_raster["raster-contrast"]),
                        "raster-resampling": new ja(Ya.paint_raster["raster-resampling"]),
                        "raster-fade-duration": new ja(Ya.paint_raster["raster-fade-duration"]),
                        "raster-emissive-strength": new ja(Ya.paint_raster["raster-emissive-strength"]),
                        "raster-array-band": new ja(Ya.paint_raster["raster-array-band"]),
                        "raster-elevation": new ja(Ya.paint_raster["raster-elevation"]),
                        "raster-color-use-theme": new qa({
                            type: "string",
                            default: "default",
                            "property-type": "data-driven"
                        })
                    }))
                }, e, r, n), this.updateColorRamp(), this._curRampRange = [
                    NaN,
                    NaN
                ];
            }
            getProgramIds() {
                return [
                    "raster"
                ];
            }
            hasColorMap() {
                return !!this._transitionablePaint._values["raster-color"].value.value;
            }
            tileCoverLift() {
                return this.paint.get("raster-elevation");
            }
            isDraped(t1) {
                return !(t1 && t1._source instanceof vm && (t1._source.onNorthPole || t1._source.onSouthPole)) && 0 === this.paint.get("raster-elevation");
            }
            _handleSpecialPaintPropertyUpdate(t1) {
                "raster-color" !== t1 && "raster-color-range" !== t1 || (this._curRampRange = [
                    NaN,
                    NaN
                ], this.updateColorRamp());
            }
            updateColorRamp(t1) {
                if (!this.hasColorMap()) return;
                if (!this._curRampRange) return;
                const e = this._transitionablePaint._values["raster-color"].value.expression, [r, n] = t1 || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({
                    zoom: 0
                }) || [
                    NaN,
                    NaN
                ];
                isNaN(r) && isNaN(n) || r === this._curRampRange[0] && n === this._curRampRange[1] || (this.colorRamp = lc({
                    expression: e,
                    evaluationKey: "rasterValue",
                    image: this.colorRamp,
                    clips: [
                        {
                            start: r,
                            end: n
                        }
                    ],
                    resolution: 256
                }), this.colorRampTexture = null, this._curRampRange = [
                    r,
                    n
                ]);
            }
        }
        let wm, Mm, Am, Sm, Im;
        class Pm extends ps {
            constructor(t1, e, r, n){
                super(t1, {
                    layout: wm || (wm = new Ga({
                        visibility: new ja(Ya["layout_raster-particle"].visibility)
                    })),
                    paint: Mm || (Mm = new Ga({
                        "raster-particle-array-band": new ja(Ya["paint_raster-particle"]["raster-particle-array-band"]),
                        "raster-particle-count": new ja(Ya["paint_raster-particle"]["raster-particle-count"]),
                        "raster-particle-color": new $a(Ya["paint_raster-particle"]["raster-particle-color"]),
                        "raster-particle-max-speed": new ja(Ya["paint_raster-particle"]["raster-particle-max-speed"]),
                        "raster-particle-speed-factor": new ja(Ya["paint_raster-particle"]["raster-particle-speed-factor"]),
                        "raster-particle-fade-opacity-factor": new ja(Ya["paint_raster-particle"]["raster-particle-fade-opacity-factor"]),
                        "raster-particle-reset-rate-factor": new ja(Ya["paint_raster-particle"]["raster-particle-reset-rate-factor"]),
                        "raster-particle-elevation": new ja(Ya["paint_raster-particle"]["raster-particle-elevation"]),
                        "raster-particle-color-use-theme": new qa({
                            type: "string",
                            default: "default",
                            "property-type": "data-driven"
                        })
                    }))
                }, e, r, n), this._updateColorRamp(), this.lastInvalidatedAt = Dt.now();
            }
            onRemove(t1) {
                this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
            }
            hasColorMap() {
                return !!this._transitionablePaint._values["raster-particle-color"].value.value;
            }
            getProgramIds() {
                return [
                    "rasterParticle"
                ];
            }
            hasOffscreenPass() {
                return "none" !== this.visibility;
            }
            isDraped(t1) {
                return !1;
            }
            _handleSpecialPaintPropertyUpdate(t1) {
                "raster-particle-color" !== t1 && "raster-particle-max-speed" !== t1 || (this._updateColorRamp(), this._invalidateAnimationState()), "raster-particle-count" === t1 && this._invalidateAnimationState();
            }
            _updateColorRamp() {
                if (!this.hasColorMap()) return;
                const t1 = this._transitionablePaint._values["raster-particle-color"].value.expression, e = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({
                    zoom: 0
                });
                this.colorRamp = lc({
                    expression: t1,
                    evaluationKey: "rasterParticleSpeed",
                    image: this.colorRamp,
                    clips: [
                        {
                            start: 0,
                            end: e
                        }
                    ],
                    resolution: 256
                }), this.colorRampTexture = null;
            }
            _invalidateAnimationState() {
                this.lastInvalidatedAt = Dt.now();
            }
            tileCoverLift() {
                return this.paint.get("raster-particle-elevation");
            }
        }
        class zm extends ps {
            constructor(t1, e){
                super(t1, {}, e, null), this.implementation = t1, t1.slot && (this.slot = t1.slot);
            }
            is3D() {
                return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
                return void 0 !== this.implementation.prerender;
            }
            isDraped(t1) {
                return void 0 !== this.implementation.renderToTile;
            }
            shouldRedrape() {
                return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
            }
            recalculate() {}
            updateTransitions() {}
            hasTransition() {
                return !1;
            }
            serialize() {}
            onAdd(t1) {
                this.implementation.onAdd && this.implementation.onAdd(t1, t1.painter.context.gl);
            }
            onRemove(t1) {
                this.implementation.onRemove && this.implementation.onRemove(t1, t1.painter.context.gl);
            }
        }
        function Em(t1, e, r) {
            const n = [
                0,
                0,
                1
            ], i = O.quat.identity([]);
            return O.quat.rotateY(i, i, r ? -X(t1) + Math.PI : X(t1)), O.quat.rotateX(i, i, -X(e)), O.vec3.transformQuat(n, n, i), O.vec3.normalize(n, n);
        }
        function km(t1, e) {
            const r = Bm(t1.projection, t1.zoom, t1.width, t1.height), n = function(t1, e, r, n, i) {
                const a = new il(r.lng - 180 * Vm, r.lat), s = new il(r.lng + 180 * Vm, r.lat), o = t1.project(a.lng, a.lat), l = t1.project(s.lng, s.lat), u = -Math.atan2(l.y - o.y, l.x - o.x), c = bl.fromLngLat(r);
                c.y = Q(c.y, -1 + Vm, 1 - Vm);
                const h = c.toLngLat(), p = t1.project(h.lng, h.lat), f = bl.fromLngLat(h);
                f.x += Vm;
                const d = f.toLngLat(), m = t1.project(d.lng, d.lat), y = Dm(m.x - p.x, m.y - p.y, u), g = bl.fromLngLat(h);
                g.y += Vm;
                const x = g.toLngLat(), v = t1.project(x.lng, x.lat), b = Dm(v.x - p.x, v.y - p.y, u), _ = Math.abs(y.x) / Math.abs(b.y), w = O.mat4.identity([]);
                O.mat4.rotateZ(w, w, -u * (1 - (i ? 0 : n)));
                const M = O.mat4.identity([]);
                return O.mat4.scale(M, M, [
                    1,
                    1 - (1 - _) * n,
                    1
                ]), M[4] = -b.x / b.y * n, O.mat4.rotateZ(M, M, u), O.mat4.multiply(M, w, M), M;
            }(t1.projection, 0, t1.center, r, e), i = Tm(t1);
            return O.mat4.scale(n, n, [
                i,
                i,
                1
            ]), n;
        }
        function Tm(t1) {
            const e = t1.projection, r = Bm(t1.projection, t1.zoom, t1.width, t1.height), n = Cm(e, t1.center), i = Cm(e, il.convert(e.center));
            return Math.pow(2, n * r + (1 - r) * i);
        }
        function Bm(t1, e, r, n, i = 1 / 0) {
            const a = t1.range;
            if (!a) return 0;
            const s = Math.min(i, Math.max(r, n)), o = Math.log(s / 1024) / Math.LN2;
            return tt(a[0] + o, a[1] + o, e);
        }
        const Vm = 1 / 4e4;
        function Cm(t1, e) {
            const r = Q(e.lat, -ml, ml), n = new il(e.lng - 180 * Vm, r), i = new il(e.lng + 180 * Vm, r), a = t1.project(n.lng, r), s = t1.project(i.lng, r), o = bl.fromLngLat(n), l = bl.fromLngLat(i), u = s.x - a.x, c = s.y - a.y, h = l.x - o.x, p = l.y - o.y, f = Math.sqrt((h * h + p * p) / (u * u + c * c));
            return Math.log(f) / Math.LN2;
        }
        function Dm(t1, e, r) {
            const n = Math.cos(r), i = Math.sin(r);
            return {
                x: t1 * n - e * i,
                y: t1 * i + e * n
            };
        }
        function Lm(t1, e, r) {
            O.mat4.identity(t1), O.mat4.rotateZ(t1, t1, X(e[2])), O.mat4.rotateX(t1, t1, X(e[0])), O.mat4.rotateY(t1, t1, X(e[1])), O.mat4.scale(t1, t1, r), O.mat4.multiply(t1, t1, [
                1,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                1
            ]);
        }
        function Rm(t1, e, r, n, i, a, s, o) {
            const l = [
                r[0] - e[0],
                r[1] - e[1],
                0
            ], u = [
                n[0] - e[0],
                n[1] - e[1],
                0
            ];
            if (O.vec3.length(l) < 1e-12 || O.vec3.length(u) < 1e-12) return O.quat.identity(t1);
            const c = O.vec3.cross([], l, u);
            O.vec3.normalize(c, c), O.vec3.subtract(u, n, e), l[2] = (a - i) * o, u[2] = (s - i) * o;
            const h = l;
            return O.vec3.cross(h, l, u), O.vec3.normalize(h, h), O.quat.rotationTo(t1, c, h);
        }
        function Fm(t1, e, r = !1) {
            const n = Fu(e.zoom), i = function(t1, e, r) {
                const n = e.worldSize, i = [
                    t1[12],
                    t1[13],
                    t1[14]
                ], a = fl(i[1] / n), s = pl(i[0] / n), o = O.mat4.identity([]), l = hl(1, a) * n, u = hl(1, 0) * n * gl(a, e.zoom), c = 1 / Du(n);
                let h = u * c;
                if (r) {
                    const t1 = Bm(e.projection, e.zoom, e.width, e.height, 1024);
                    h = c * e.projection.pixelSpaceConversion(e.center.lat, n, t1);
                }
                const p = el(a, s);
                O.vec3.add(p, p, O.vec3.scale([], O.vec3.normalize([], p), l * h * i[2]));
                const f = function(t1) {
                    const e = [
                        t1[0],
                        t1[1],
                        t1[2]
                    ];
                    let r = [
                        0,
                        1,
                        0
                    ];
                    const n = O.vec3.cross([], r, e);
                    return O.vec3.cross(r, e, n), 0 === O.vec3.squaredLength(r) && (r = [
                        0,
                        1,
                        0
                    ], O.vec3.cross(n, e, r)), O.vec3.normalize(n, n), O.vec3.normalize(r, r), O.vec3.normalize(e, e), [
                        n[0],
                        n[1],
                        n[2],
                        0,
                        r[0],
                        r[1],
                        r[2],
                        0,
                        e[0],
                        e[1],
                        e[2],
                        0,
                        t1[0],
                        t1[1],
                        t1[2],
                        1
                    ];
                }(p);
                O.mat4.scale(o, o, [
                    h,
                    h,
                    h * l
                ]), O.mat4.translate(o, o, [
                    -i[0],
                    -i[1],
                    -i[2]
                ]);
                const d = O.mat4.multiply([], e.globeMatrix, f);
                return O.mat4.multiply(d, d, o), O.mat4.multiply(d, d, t1), d;
            }(t1, e, r);
            if (n > 0) {
                const r = function(t1, e) {
                    const r = e.worldSize, n = hl(1, 0) * r * gl(e.center.lat, e.zoom) / Du(r), i = hl(1, e.center.lat) * r, a = O.mat4.identity([]);
                    return O.mat4.rotateY(a, a, X(e.center.lng)), O.mat4.rotateX(a, a, X(e.center.lat)), O.mat4.translate(a, a, [
                        0,
                        0,
                        Yo
                    ]), O.mat4.scale(a, a, [
                        n,
                        n,
                        n * i
                    ]), O.mat4.translate(a, a, [
                        e.point.x - .5 * r,
                        e.point.y - .5 * r,
                        0
                    ]), O.mat4.multiply(a, a, t1), O.mat4.multiply(a, e.globeMatrix, a);
                }(t1, e);
                return function(t1, e, r) {
                    const n = (t1, e, r)=>{
                        const n = O.vec3.length(t1), i = O.vec3.length(e), a = Su(t1, e, r);
                        return O.vec3.scale(a, a, 1 / O.vec3.length(a) * ze(n, i, r));
                    }, i = n([
                        t1[0],
                        t1[1],
                        t1[2]
                    ], [
                        e[0],
                        e[1],
                        e[2]
                    ], r), a = n([
                        t1[4],
                        t1[5],
                        t1[6]
                    ], [
                        e[4],
                        e[5],
                        e[6]
                    ], r), s = n([
                        t1[8],
                        t1[9],
                        t1[10]
                    ], [
                        e[8],
                        e[9],
                        e[10]
                    ], r), o = Su([
                        t1[12],
                        t1[13],
                        t1[14]
                    ], [
                        e[12],
                        e[13],
                        e[14]
                    ], r);
                    return [
                        i[0],
                        i[1],
                        i[2],
                        0,
                        a[0],
                        a[1],
                        a[2],
                        0,
                        s[0],
                        s[1],
                        s[2],
                        0,
                        o[0],
                        o[1],
                        o[2],
                        1
                    ];
                }(i, r, n);
            }
            return i;
        }
        function Om(t1, e, r, n) {
            const i = xu.projectAabbCorners(n, r);
            let a = Number.MAX_VALUE, s = -1;
            for(let t1 = 0; t1 < i.length; ++t1){
                const r = i[t1];
                r[0] = (.5 * r[0] + .5) * e.width, r[1] = (.5 - .5 * r[1]) * e.height, r[2] < a && (s = t1, a = r[2]);
            }
            const o = (t1)=>new q(i[t1][0], i[t1][1]);
            let l;
            switch(s){
                case 0:
                case 6:
                    l = [
                        o(1),
                        o(5),
                        o(4),
                        o(7),
                        o(3),
                        o(2),
                        o(1)
                    ];
                    break;
                case 1:
                case 7:
                    l = [
                        o(0),
                        o(4),
                        o(5),
                        o(6),
                        o(2),
                        o(3),
                        o(0)
                    ];
                    break;
                case 3:
                case 5:
                    l = [
                        o(1),
                        o(0),
                        o(4),
                        o(7),
                        o(6),
                        o(2),
                        o(1)
                    ];
                    break;
                default:
                    l = [
                        o(1),
                        o(5),
                        o(6),
                        o(7),
                        o(3),
                        o(0),
                        o(1)
                    ];
            }
            if (Vl(t1, l)) return a;
        }
        const Nm = ys([
            {
                name: "a_pos_3f",
                components: 3,
                type: "Float32"
            }
        ]), Um = ys([
            {
                name: "a_color_3f",
                components: 3,
                type: "Float32"
            }
        ]), jm = ys([
            {
                name: "a_color_4f",
                components: 4,
                type: "Float32"
            }
        ]), qm = ys([
            {
                name: "a_uv_2f",
                components: 2,
                type: "Float32"
            }
        ]), $m = ys([
            {
                name: "a_normal_3f",
                components: 3,
                type: "Float32"
            }
        ]), Gm = ys([
            {
                name: "a_normal_matrix0",
                components: 4,
                type: "Float32"
            },
            {
                name: "a_normal_matrix1",
                components: 4,
                type: "Float32"
            },
            {
                name: "a_normal_matrix2",
                components: 4,
                type: "Float32"
            },
            {
                name: "a_normal_matrix3",
                components: 4,
                type: "Float32"
            }
        ]), Ym = ys([
            {
                name: "a_pbr",
                components: 4,
                type: "Uint16"
            },
            {
                name: "a_heightBasedEmissiveStrength",
                components: 3,
                type: "Float32"
            }
        ]), Xm = {
            None: 0,
            Model: 1,
            Symbol: 2,
            FillExtrusion: 4,
            All: 7
        };
        class Zm {
            constructor(t1, e, r, n){
                this.message = (t1 ? `${t1}: ` : "") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);
            }
        }
        function Hm(t1, e) {
            const r = -1 === t1.indexOf("://");
            try {
                return new URL(t1, r && e ? "http://example.com" : void 0), !0;
            } catch (t1) {
                return !1;
            }
        }
        class Wm {
            constructor(t1, e){
                this.feature = t1, this.instancedDataOffset = e, this.instancedDataCount = 0, this.rotation = [
                    0,
                    0,
                    0
                ], this.scale = [
                    1,
                    1,
                    1
                ], this.translation = [
                    0,
                    0,
                    0
                ];
            }
        }
        class Km {
            constructor(){
                this.instancedDataArray = new Xs, this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
            }
        }
        class Jm {
            constructor(t1){
                this.zoom = t1.zoom, this.canonical = t1.canonical, this.layers = t1.layers, this.layerIds = this.layers.map((t1)=>t1.fqid), this.projection = t1.projection, this.index = t1.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.hasPattern = !1, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = {
                    id: null,
                    timestamp: 0
                }, this.modelUris = [], this.modelsRequested = !1, this.activeReplacements = [], this.replacementUpdateTime = 0;
            }
            updateFootprints(t1, e) {}
            populate(t1, e, r, n) {
                this.tileToMeter = vl(r);
                const i = this.layers[0]._featureFilter.needGeometry;
                this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
                for (const { feature: a, id: s, index: o, sourceLayerIndex: l } of t1){
                    const t1 = null != s ? s : a.properties && a.properties.hasOwnProperty("id") ? a.properties.id : void 0, u = El(a, i);
                    if (!this.layers[0]._featureFilter.filter(new Va(this.zoom), u, r)) continue;
                    const c = {
                        id: t1,
                        sourceLayerIndex: l,
                        index: o,
                        geometry: i ? u.geometry : zl(a, r, n),
                        properties: a.properties,
                        type: a.type,
                        patterns: {}
                    }, h = this.addFeature(c, c.geometry, u);
                    h && e.featureIndex.insert(a, c.geometry, o, l, this.index, this.instancesPerModel[h].instancedDataArray.length, Wr / 32);
                }
                this.lookup = null;
            }
            update(t1, e, r, n) {
                for(const e in this.instancesPerModel){
                    const r = this.instancesPerModel[e];
                    for(const e in t1)r.idToFeaturesIndex.hasOwnProperty(e) && (this.evaluate(r.features[r.idToFeaturesIndex[e]], t1[e], r, !0), this.uploaded = !1);
                }
                this.maxHeight = 0;
            }
            updateZoomBasedPaintProperties() {
                if (!this.hasZoomDependentProperties) return !1;
                let t1 = !1;
                for(const e in this.instancesPerModel){
                    const r = this.instancesPerModel[e];
                    for (const e of r.features){
                        const n = this.layers[0], i = e.feature, a = this.canonical, s = n.paint.get("model-rotation").evaluate(i, {}, a), o = n.paint.get("model-scale").evaluate(i, {}, a), l = n.paint.get("model-translation").evaluate(i, {}, a);
                        O.vec3.exactEquals(e.rotation, s) && O.vec3.exactEquals(e.scale, o) && O.vec3.exactEquals(e.translation, l) || (this.evaluate(e, e.featureStates, r, !0), t1 = !0);
                    }
                }
                return t1;
            }
            updateReplacement(t1, e, r, n) {
                if (e.updateTime === this.replacementUpdateTime) return !1;
                this.replacementUpdateTime = e.updateTime;
                const i = e.getReplacementRegionsForTile(t1.toUnwrapped(), !0);
                if (Ah(this.activeReplacements, i)) return !1;
                this.activeReplacements = i;
                let a = !1;
                for(const e in this.instancesPerModel){
                    const i = this.instancesPerModel[e], s = i.instancedDataArray;
                    for (const e of i.features){
                        const i = e.instancedDataOffset, o = e.instancedDataCount;
                        for(let e = 0; e < o; e++){
                            const o = 16 * (e + i);
                            let l = s.float32[o + 0];
                            const u = l > Wr;
                            l = u ? l - Wr : l;
                            const c = Math.floor(l), h = s.float32[o + 1];
                            let p = !1;
                            for (const e of this.activeReplacements)if (!bh(e, r, Xm.Model, n) && !(e.min.x > c || c > e.max.x || e.min.y > h || h > e.max.y) && (p = kh(Eh(c, h, t1.canonical, e.footprintTileId.canonical), e.footprint), p)) break;
                            s.float32[o] = p ? l + Wr : l, a = a || p !== u;
                        }
                    }
                }
                return a;
            }
            isEmpty() {
                for(const t1 in this.instancesPerModel)if (0 !== this.instancesPerModel[t1].instancedDataArray.length) return !1;
                return !0;
            }
            uploadPending() {
                return !this.uploaded;
            }
            upload(t1) {
                if (!this.uploaded) for(const e in this.instancesPerModel){
                    const r = this.instancesPerModel[e];
                    r.instancedDataArray.length < 0 || 0 === r.instancedDataArray.length || (r.instancedDataBuffer ? r.instancedDataBuffer.updateData(r.instancedDataArray) : r.instancedDataBuffer = t1.createVertexBuffer(r.instancedDataArray, Gm.members, !0, void 0, this.instanceCount));
                }
                this.uploaded = !0;
            }
            destroy() {
                for(const t1 in this.instancesPerModel){
                    const e = this.instancesPerModel[t1];
                    0 !== e.instancedDataArray.length && e.instancedDataBuffer && e.instancedDataBuffer.destroy();
                }
                const t1 = this.layers[0].modelManager;
                if (t1 && this.modelUris) for (const e of this.modelUris)t1.removeModel(e, "");
            }
            addFeature(t1, e, r) {
                const n = this.layers[0], i = n.layout.get("model-id").evaluate(r, {}, this.canonical);
                if (!i) return ft(`modelId is not evaluated for layer ${n.id} and it is not going to get rendered.`), i;
                Hm(i, !1) && (this.modelUris.includes(i) || this.modelUris.push(i)), this.instancesPerModel[i] || (this.instancesPerModel[i] = new Km);
                const a = this.instancesPerModel[i], s = a.instancedDataArray, o = new Wm(r, s.length);
                for (const t1 of e)for (const e of t1){
                    if (e.x < 0 || e.x >= Wr || e.y < 0 || e.y >= Wr) continue;
                    const t1 = (this.lookupDim - 1) / Wr, r = this.lookupDim * (e.y * t1 | 0) + e.x * t1 | 0;
                    if (this.lookup) {
                        if (0 !== this.lookup[r]) continue;
                        this.lookup[r] = 1;
                    }
                    this.instanceCount++;
                    const n = s.length;
                    s.resize(n + 1), a.instancesEvaluatedElevation.push(0), s.float32[16 * n] = e.x, s.float32[16 * n + 1] = e.y;
                }
                return o.instancedDataCount = a.instancedDataArray.length - o.instancedDataOffset, o.instancedDataCount > 0 && (t1.id && (a.idToFeaturesIndex[t1.id] = a.features.length), a.features.push(o), this.evaluate(o, {}, a, !1)), i;
            }
            getModelUris() {
                return this.modelUris;
            }
            evaluate(t1, e, r, n) {
                const i = this.layers[0], a = t1.feature, s = this.canonical, o = t1.rotation = i.paint.get("model-rotation").evaluate(a, e, s), l = t1.scale = i.paint.get("model-scale").evaluate(a, e, s), u = t1.translation = i.paint.get("model-translation").evaluate(a, e, s), c = i.paint.get("model-color").evaluate(a, e, s);
                c.a = i.paint.get("model-color-mix-intensity").evaluate(a, e, s);
                const h = [];
                this.maxVerticalOffset < u[2] && (this.maxVerticalOffset = u[2]), this.maxScale = Math.max(Math.max(this.maxScale, l[0]), Math.max(l[1], l[2])), Lm(h, o, l);
                const p = Math.round(100 * c.a) + c.b / 1.05;
                for(let e = 0; e < t1.instancedDataCount; ++e){
                    const i = t1.instancedDataOffset + e, a = 16 * i, o = r.instancedDataArray.float32;
                    let l = 0;
                    n && (l = o[a + 6] - r.instancesEvaluatedElevation[i]);
                    const f = 0 | o[a + 1];
                    o[a] = (0 | o[a]) + c.r / 1.05, o[a + 1] = f + c.g / 1.05, o[a + 2] = p, o[a + 3] = 1 / (s.z > 10 ? this.tileToMeter : vl(s, f)), o[a + 4] = u[0], o[a + 5] = u[1], o[a + 6] = u[2] + l, o[a + 7] = h[0], o[a + 8] = h[1], o[a + 9] = h[2], o[a + 10] = h[4], o[a + 11] = h[5], o[a + 12] = h[6], o[a + 13] = h[8], o[a + 14] = h[9], o[a + 15] = h[10], r.instancesEvaluatedElevation[i] = u[2];
                }
            }
        }
        let Qm, ty;
        oa(Jm, "ModelBucket", {
            omit: [
                "layers"
            ]
        }), oa(Km, "PerModelAttributes"), oa(Wm, "ModelFeature");
        const ey = 64, ry = {
            CoordinateSpaceTile: 1,
            CoordinateSpaceYUp: 2,
            HasMapboxMeshFeatures: 4,
            HasMeshoptCompression: 8
        };
        function ny(t1, e, r, n, i, a, s, o, l, u = !1) {
            const c = r.zoom, h = r.project(n), p = gl(n.lat, c), f = 1 / p;
            O.mat4.identity(t1), O.mat4.translate(t1, t1, [
                h.x + s[0] * f,
                h.y + s[1] * f,
                s[2]
            ]);
            let d = 1, m = 1;
            const y = r.worldSize;
            if (u) {
                if ("mercator" === r.projection.name) {
                    let t1 = 0;
                    r.elevation && (t1 = r.elevation.getAtPointOrZero(new bl(h.x / y, h.y / y), 0));
                    const e = O.vec4.transformMat4([], [
                        h.x,
                        h.y,
                        t1,
                        1
                    ], r.projMatrix)[3] / r.cameraToCenterDistance;
                    d = e, m = e * gl(r.center.lat, c);
                } else if ("globe" === r.projection.name) {
                    const e = Fm(t1, r), i = O.mat4.multiply([], r.projMatrix, e), a = [
                        0,
                        0,
                        0,
                        1
                    ];
                    O.vec4.transformMat4(a, a, i);
                    const s = a[3] / r.cameraToCenterDistance, o = Fu(c), l = r.projection.pixelsPerMeter(n.lat, y) * gl(n.lat, c), u = r.projection.pixelsPerMeter(r.center.lat, y) * gl(r.center.lat, c);
                    d = s / ze(l, yl(r.center.lat), o), m = s * p / l, d *= u, m *= u;
                }
            } else d = f;
            O.mat4.scale(t1, t1, [
                d,
                d,
                m
            ]);
            const g = [
                ...t1
            ], x = e.orientation, v = [];
            if (Lm(v, [
                x[0] + i[0],
                x[1] + i[1],
                x[2] + i[2]
            ], a), O.mat4.multiply(t1, g, v), o && r.elevation) {
                let i = 0;
                const a = [];
                if (l && r.elevation) {
                    i = function(t1, e, r, n, i) {
                        const a = e.elevation;
                        if (!a) return 0;
                        const s = xu.projectAabbCorners(r, n), o = hl(1, i.lat) * e.worldSize, l = function(t1, e) {
                            const r = [
                                0,
                                0,
                                1
                            ], n = [
                                {
                                    corners: [
                                        0,
                                        1,
                                        3,
                                        2
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        1,
                                        5,
                                        2,
                                        6
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        0,
                                        4,
                                        1,
                                        5
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        2,
                                        6,
                                        3,
                                        7
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        4,
                                        7,
                                        5,
                                        6
                                    ],
                                    dotProductWithUp: 0
                                },
                                {
                                    corners: [
                                        0,
                                        3,
                                        4,
                                        7
                                    ],
                                    dotProductWithUp: 0
                                }
                            ];
                            for (const i of n){
                                const n = t1[i.corners[0]], a = t1[i.corners[1]], s = t1[i.corners[2]], o = [
                                    a[0] - n[0],
                                    a[1] - n[1],
                                    e * (a[2] - n[2])
                                ], l = O.vec3.cross(o, o, [
                                    s[0] - n[0],
                                    s[1] - n[1],
                                    e * (s[2] - n[2])
                                ]);
                                O.vec3.normalize(l, l), i.dotProductWithUp = O.vec3.dot(l, r);
                            }
                            return n.sort((t1, e)=>t1.dotProductWithUp - e.dotProductWithUp), n[0].corners;
                        }(s, o), u = s[l[0]], c = s[l[1]], h = s[l[2]], p = s[l[3]], f = a.getAtPointOrZero(new bl(u[0] / e.worldSize, u[1] / e.worldSize), 0), d = a.getAtPointOrZero(new bl(c[0] / e.worldSize, c[1] / e.worldSize), 0), m = a.getAtPointOrZero(new bl(h[0] / e.worldSize, h[1] / e.worldSize), 0), y = a.getAtPointOrZero(new bl(p[0] / e.worldSize, p[1] / e.worldSize), 0), g = (f + y) / 2, x = (d + m) / 2;
                        return g > x ? d < m ? Rm(t1, c, p, u, d, y, f, o) : Rm(t1, h, u, p, m, f, y, o) : f < y ? Rm(t1, u, c, h, f, d, m, o) : Rm(t1, p, h, c, y, m, d, o), Math.max(g, x);
                    }(a, r, e.aabb, t1, n);
                    const s = O.mat4.fromQuat([], a), o = O.mat4.multiply([], s, v);
                    O.mat4.multiply(t1, g, o);
                } else i = r.elevation.getAtPointOrZero(new bl(h.x / y, h.y / y), 0);
                0 !== i && (t1[14] += i);
            }
        }
        function iy(t1, e, r = !1) {
            t1.uploaded || (t1.gfxTexture = new dm(e, t1.image, r ? e.gl.R8 : e.gl.RGBA8, {
                useMipmap: t1.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST
            }), t1.uploaded = !0, t1.image = null);
        }
        function ay(t1, e, r) {
            t1.indexBuffer = e.createIndexBuffer(t1.indexArray, !1, !0), t1.vertexBuffer = e.createVertexBuffer(t1.vertexArray, Nm.members, !1, !0), t1.normalArray && (t1.normalBuffer = e.createVertexBuffer(t1.normalArray, $m.members, !1, !0)), t1.texcoordArray && (t1.texcoordBuffer = e.createVertexBuffer(t1.texcoordArray, qm.members, !1, !0)), t1.colorArray && (t1.colorBuffer = e.createVertexBuffer(t1.colorArray, (12 === t1.colorArray.bytesPerElement ? Um : jm).members, !1, !0)), t1.featureArray && (t1.pbrBuffer = e.createVertexBuffer(t1.featureArray, Ym.members, !0)), t1.segments = po.simpleSegment(0, 0, t1.vertexArray.length, t1.indexArray.length);
            const n = t1.material;
            n.pbrMetallicRoughness.baseColorTexture && iy(n.pbrMetallicRoughness.baseColorTexture, e), n.pbrMetallicRoughness.metallicRoughnessTexture && iy(n.pbrMetallicRoughness.metallicRoughnessTexture, e), n.normalTexture && iy(n.normalTexture, e), n.occlusionTexture && iy(n.occlusionTexture, e, r), n.emissionTexture && iy(n.emissionTexture, e);
        }
        function sy(t1, e, r) {
            if (t1.meshes) for (const n of t1.meshes)ay(n, e, r);
            if (t1.children) for (const n of t1.children)sy(n, e, r);
        }
        function oy(t1) {
            if (t1.meshes) for (const e of t1.meshes)e.indexArray.destroy(), e.vertexArray.destroy(), e.colorArray && e.colorArray.destroy(), e.normalArray && e.normalArray.destroy(), e.texcoordArray && e.texcoordArray.destroy(), e.featureArray && e.featureArray.destroy();
            if (t1.children) for (const e of t1.children)oy(e);
        }
        function ly(t1) {
            if (t1.meshes) for (const r of t1.meshes)r.vertexBuffer && (r.vertexBuffer.destroy(), r.indexBuffer.destroy(), r.normalBuffer && r.normalBuffer.destroy(), r.texcoordBuffer && r.texcoordBuffer.destroy(), r.colorBuffer && r.colorBuffer.destroy(), r.pbrBuffer && r.pbrBuffer.destroy(), r.segments.destroy(), r.material && ((e = r.material).pbrMetallicRoughness.baseColorTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e.pbrMetallicRoughness.metallicRoughnessTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e.normalTexture && e.normalTexture.gfxTexture && e.normalTexture.gfxTexture.destroy(), e.emissionTexture && e.emissionTexture.gfxTexture && e.emissionTexture.gfxTexture.destroy(), e.occlusionTexture && e.occlusionTexture.gfxTexture && e.occlusionTexture.gfxTexture.destroy()));
            var e;
            if (t1.children) for (const e of t1.children)ly(e);
        }
        class uy {
            constructor(t1, e, r){
                this._demTile = t1, this._dem = this._demTile.dem, this._scale = e, this._offset = r;
            }
            static create(t1, e, r) {
                const n = r || t1.findDEMTileFor(e);
                if (!n || !n.dem) return;
                const i = n.dem, a = n.tileID, s = 1 << e.canonical.z - a.canonical.z;
                return new uy(n, i.dim / Wr / s, [
                    (e.canonical.x / s - a.canonical.x) * i.dim,
                    (e.canonical.y / s - a.canonical.y) * i.dim
                ]);
            }
            tileCoordToPixel(t1, e) {
                const r = e * this._scale + this._offset[1], n = Math.floor(t1 * this._scale + this._offset[0]), i = Math.floor(r);
                return new q(n, i);
            }
            getElevationAt(t1, e, r, n) {
                const i = t1 * this._scale + this._offset[0], a = e * this._scale + this._offset[1], s = Math.floor(i), o = Math.floor(a), l = this._dem;
                return n = !!n, r ? ze(ze(l.get(s, o, n), l.get(s, o + 1, n), a - o), ze(l.get(s + 1, o, n), l.get(s + 1, o + 1, n), a - o), i - s) : l.get(s, o, n);
            }
            getElevationAtPixel(t1, e, r) {
                return this._dem.get(t1, e, !!r);
            }
            getMeterToDEM(t1) {
                return (1 << this._demTile.tileID.canonical.z) * hl(1, t1) * this._dem.stride;
            }
        }
        const cy = new Float32Array(262144), hy = new Uint8Array(262144);
        function py(t1) {
            let e = 0;
            if (t1.meshes) for (const r of t1.meshes)e = Math.max(e, r.aabb.max[2]);
            if (t1.children) for (const r of t1.children)e = Math.max(e, py(r));
            return e;
        }
        function fy(t1, e, r) {
            if (t1.meshes) for (const n of t1.meshes){
                if (n.aabb.min[0] === 1 / 0) continue;
                const i = xu.applyTransform(n.aabb, t1.matrix);
                r.insert(e, i.min[0], i.min[1], i.max[0], i.max[1]);
            }
            if (t1.children) for (const n of t1.children)fy(n, e, r);
        }
        const dy = [
            "",
            "wall",
            "door",
            "roof",
            "window",
            "lamp",
            "logo"
        ];
        class my {
            constructor(t1){
                this.node = t1, this.evaluatedRMEA = [
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        .4,
                        1,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ],
                    [
                        1,
                        0,
                        0,
                        1
                    ]
                ], this.hiddenByReplacement = !1, this.evaluatedScale = [
                    1,
                    1,
                    1
                ], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = {
                    type: "Point",
                    id: t1.id,
                    geometry: [],
                    properties: {
                        height: py(t1)
                    }
                }, this.aabb = this._getLocalBounds(), this.state = null;
            }
            _getLocalBounds() {
                if (!this.node.meshes) return new xu([
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ]);
                if (!this.aabb) {
                    let t1 = 0;
                    const e = new xu([
                        1 / 0,
                        1 / 0,
                        1 / 0
                    ], [
                        -1 / 0,
                        -1 / 0,
                        -1 / 0
                    ]);
                    for (const r of this.node.meshes)this.node.lightMeshIndex !== t1 && (r.transformedAabb = xu.applyTransformFast(r.aabb, this.node.matrix), e.encapsulate(r.transformedAabb)), t1++;
                    this.aabb = e;
                }
                return this.aabb;
            }
        }
        class yy {
            constructor(t1, e, r, n, i, a, s){
                this.id = r, this.layers = t1, this.layerIds = this.layers.map((t1)=>t1.fqid), this.stateDependentLayerIds = this.layers.filter((t1)=>t1.isStateDependent()).map((t1)=>t1.id), this.modelTraits |= ry.CoordinateSpaceTile, this.uploaded = !1, this.hasPattern = !1, n && (this.modelTraits |= ry.HasMapboxMeshFeatures), i && (this.modelTraits |= ry.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = {
                    name: "mercator"
                }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = a, this.dirty = !0, this.needsUpload = !1, this.nodesInfo = [];
                for (const t1 of e)this.nodesInfo.push(new my(t1)), fy(t1, s.featureIndexArray.length, s.grid), s.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, s.bucketLayerIDs.length - 1, 0);
                this.states = {};
            }
            updateFootprints(t1, e) {
                for (const r of this.getNodesInfo()){
                    const n = r.node;
                    n.footprint && e.push({
                        footprint: n.footprint,
                        id: t1
                    });
                }
            }
            update(t1) {
                const e = 0 !== Object.keys(t1).length;
                if (e && !this.stateDependentLayers.length) return;
                const r = e ? this.stateDependentLayers : this.layers;
                if (!$(t1, this.states)) for (const e of r)this.evaluate(e, t1);
                this.states = structuredClone(t1);
            }
            populate() {
                console.log("populate 3D model bucket");
            }
            uploadPending() {
                return !this.uploaded || this.needsUpload;
            }
            upload(t1) {
                if (!this.needsUpload) return;
                const e = this.getNodesInfo();
                for (const r of e){
                    const e = r.node;
                    this.uploaded ? this.updatePbrBuffer(e) : sy(e, t1, !0);
                }
                for (const t1 of e)oy(t1.node);
                this.uploaded = !0, this.needsUpload = !1;
            }
            updatePbrBuffer(t1) {
                let e = !1;
                if (!t1.meshes) return e;
                for (const r of t1.meshes)r.pbrBuffer && (r.pbrBuffer.updateData(r.featureArray), e = !0);
                return e;
            }
            needsReEvaluation(t1, e, r) {
                const n = t1.transform.projectionOptions, i = t1.style.getBrightness(), a = this.brightness !== i;
                if (!this.uploaded || this.dirty || n.name !== this.projection.name || gy(r.paint.get("model-color").value, a) || gy(r.paint.get("model-color-mix-intensity").value, a) || gy(r.paint.get("model-roughness").value, a) || gy(r.paint.get("model-emissive-strength").value, a) || gy(r.paint.get("model-height-based-emissive-strength-multiplier").value, a)) {
                    this.projection = n, this.brightness = i;
                    const t1 = this.getNodesInfo();
                    for (const e of t1)e.state = null;
                    return !0;
                }
                return !1;
            }
            evaluateScale(t1, e) {
                if (t1.transform.zoom === this.zoom) return;
                this.zoom = t1.transform.zoom;
                const r = this.getNodesInfo(), n = this.id.canonical;
                for (const t1 of r){
                    const r = t1.feature;
                    t1.evaluatedScale = e.paint.get("model-scale").evaluate(r, {}, n);
                }
            }
            evaluate(t1, e) {
                const r = this.getNodesInfo();
                for (const n of r){
                    if (!n.node.meshes) continue;
                    const r = n.feature, i = e && e[r.id];
                    if ($(i, n.state)) continue;
                    n.state = structuredClone(i);
                    const a = n.node.meshes && n.node.meshes[0].featureData, s = n.evaluatedColor[2], o = n.evaluatedRMEA[2], l = this.id.canonical;
                    if (n.hasTranslucentParts = !1, a) {
                        for(let e = 0; e < dy.length; e++){
                            const a = dy[e];
                            a.length && (r.properties.part = a);
                            const s = t1.paint.get("model-color").evaluate(r, i, l).toRenderColor(null), o = t1.paint.get("model-color-mix-intensity").evaluate(r, i, l);
                            n.evaluatedColor[e] = [
                                s.r,
                                s.g,
                                s.b,
                                o
                            ], n.evaluatedRMEA[e][0] = t1.paint.get("model-roughness").evaluate(r, i, l), n.evaluatedRMEA[e][2] = t1.paint.get("model-emissive-strength").evaluate(r, i, l), n.evaluatedRMEA[e][3] = s.a, n.emissionHeightBasedParams[e] = t1.paint.get("model-height-based-emissive-strength-multiplier").evaluate(r, i, l), !n.hasTranslucentParts && s.a < 1 && (n.hasTranslucentParts = !0);
                        }
                        delete r.properties.part, vy(n, s !== n.evaluatedColor[2] || o !== n.evaluatedRMEA[2], this.modelTraits);
                    } else n.evaluatedRMEA[0][2] = t1.paint.get("model-emissive-strength").evaluate(r, i, l);
                    n.evaluatedScale = t1.paint.get("model-scale").evaluate(r, i, l), this.updatePbrBuffer(n.node) || (this.needsUpload = !0);
                }
                this.dirty = !1;
            }
            elevationUpdate(t1, e, r, n) {
                const i = t1.findDEMTileFor(r);
                if (i && (i.tileID.canonical !== this.terrainTile || e !== this.terrainExaggeration)) {
                    if (i.dem && i.tileID.overscaledZ !== this.elevationReadFromZ) {
                        this.elevationReadFromZ = i.tileID.overscaledZ;
                        const e = uy.create(t1, r, i);
                        if (!e) return;
                        this.modelTraits & ry.HasMapboxMeshFeatures && this.updateDEM(t1, e, r, n);
                        for (const t1 of this.getNodesInfo()){
                            const r = t1.node;
                            if (!r.footprint || !r.footprint.vertices || !r.footprint.vertices.length) continue;
                            const n = r.footprint.vertices;
                            let i = e.getElevationAt(n[0].x, n[0].y, !0, !0);
                            for(let t1 = 1; t1 < n.length; t1++)i = Math.min(i, e.getElevationAt(n[t1].x, n[t1].y, !0, !0));
                            r.elevation = i;
                        }
                    }
                    this.terrainTile = i.tileID.canonical, this.terrainExaggeration = e;
                }
            }
            updateDEM(t1, e, r, n) {
                let i = e._dem._modifiedForSources[n];
                if (void 0 === i && (e._dem._modifiedForSources[n] = [], i = e._dem._modifiedForSources[n]), i.includes(r.canonical)) return;
                const a = e._dem.dim;
                i.push(r.canonical);
                let s = !1;
                for (const t1 of this.getNodesInfo()){
                    const r = t1.node;
                    if (!r.footprint || !r.footprint.grid) continue;
                    const n = r.footprint.grid, i = e.tileCoordToPixel(n.min.x, n.min.y), o = e.tileCoordToPixel(n.max.x, n.max.y), l = Math.min(Math.min(a - o.y, i.x), Math.min(i.y, a - o.x));
                    if (l < 0) continue;
                    const u = Q(l, 2, 5);
                    let c = Math.max(0, i.x - u), h = Math.max(0, i.y - u), p = Math.min(o.x + u, a - 1), f = Math.min(o.y + u, a - 1);
                    for(let t1 = h; t1 <= f; ++t1)for(let e = c; e <= p; ++e)hy[t1 * a + e] = 255;
                    let d = 0, m = 0;
                    for(let t1 = 0; t1 < n.cellsY; ++t1)for(let r = 0; r < n.cellsX; ++r){
                        if (!n.cells[t1 * n.cellsX + r]) continue;
                        const i = e.tileCoordToPixel(n.min.x + r / n.xScale, n.min.y + t1 / n.yScale), s = e.tileCoordToPixel(n.min.x + (r + 1) / n.xScale, n.min.y + (t1 + 1) / n.yScale);
                        for(let t1 = i.y; t1 <= Math.min(s.y + 1, a - 1); ++t1)for(let r = i.x; r <= Math.min(s.x + 1, a - 1); ++r)255 === hy[t1 * a + r] && (hy[t1 * a + r] = 0, d += e.getElevationAtPixel(r, t1), m++);
                    }
                    const y = d / m;
                    c = Math.max(1, i.x - u), h = Math.max(1, i.y - u), p = Math.min(o.x + u, a - 2), f = Math.min(o.y + u, a - 2), s = !0;
                    for(let t1 = h; t1 <= f; ++t1)for(let r = c; r <= p; ++r)0 === hy[t1 * a + r] && (cy[t1 * a + r] = e._dem.set(r, t1, y));
                    for(let t1 = 1; t1 < u; ++t1){
                        c = Math.max(1, i.x - t1), h = Math.max(1, i.y - t1), p = Math.min(o.x + t1, a - 2), f = Math.min(o.y + t1, a - 2);
                        for(let r = h; r <= f; ++r)for(let n = c; n <= p; ++n){
                            const i = r * a + n;
                            if (255 === hy[i]) {
                                let s = 0, o = 0, l = -1, c = -1;
                                for(let e = -1; e <= 1; ++e)for(let i = -1; i <= 1; ++i){
                                    const u = (r + e) * a + n + i;
                                    if (hy[u] >= t1) continue;
                                    const h = cy[u], p = Math.abs(h);
                                    p > o && (s = h, o = p, l = i, c = e);
                                }
                                if (o > .1) {
                                    const a = 1 - (t1 + .5 * Math.abs(l * c)) / u;
                                    let o = e._dem.get(n, r) + s * a;
                                    const h = e._dem.get(n + l, r + c), p = e._dem.get(n - l, r - c, !0);
                                    (o - h) * (o - p) > 0 && (o = (h + p) / 2), cy[i] = e._dem.set(n, r, o), hy[i] = t1;
                                }
                            }
                        }
                    }
                }
                s && (e._demTile.needsDEMTextureUpload = !0, e._dem._timestamp = Dt.now());
            }
            getNodesInfo() {
                return this.nodesInfo;
            }
            destroy() {
                const t1 = this.getNodesInfo();
                for (const e of t1)oy(e.node), ly(e.node);
            }
            isEmpty() {
                return !this.nodesInfo.length;
            }
            updateReplacement(t1, e) {
                if (e.updateTime === this.replacementUpdateTime) return;
                this.replacementUpdateTime = e.updateTime;
                const r = e.getReplacementRegionsForTile(t1.toUnwrapped()), n = this.getNodesInfo();
                for(let t1 = 0; t1 < this.nodesInfo.length; t1++){
                    const e = n[t1].node;
                    n[t1].hiddenByReplacement = !!e.footprint && !r.find((t1)=>t1.footprint === e.footprint);
                }
            }
            getHeightAtTileCoord(t1, e) {
                const r = this.getNodesInfo(), n = [], i = [
                    0,
                    0,
                    0
                ], a = O.mat4.identity([]);
                for(let s = 0; s < this.nodesInfo.length; s++){
                    const o = r[s], l = o.node.meshes[0], u = l.transformedAabb;
                    if (t1 < u.min[0] || e < u.min[1] || t1 > u.max[0] || e > u.max[1]) continue;
                    if (!0 === o.node.hidden) return {
                        height: 1 / 0,
                        maxHeight: o.feature.properties.height,
                        hidden: !1,
                        verticalScale: o.evaluatedScale[2]
                    };
                    O.mat4.invert(a, o.node.matrix), i[0] = t1, i[1] = e, O.vec3.transformMat4(i, i, a);
                    const c = (i[0] - l.aabb.min[0]) / (l.aabb.max[0] - l.aabb.min[0]) * ey | 0, h = Math.min(63, (i[1] - l.aabb.min[1]) / (l.aabb.max[1] - l.aabb.min[1]) * ey | 0) * ey + Math.min(63, c), p = l.heightmap[h];
                    if (!(p < 0 && o.node.footprint)) {
                        if (o.hiddenByReplacement) return;
                        return {
                            height: p,
                            maxHeight: o.feature.properties.height,
                            hidden: !1,
                            verticalScale: o.evaluatedScale[2]
                        };
                    }
                    if (o.node.footprint.grid.query(new q(t1, e), new q(t1, e), n), n.length > 0) return {
                        height: void 0,
                        maxHeight: o.feature.properties.height,
                        hidden: o.hiddenByReplacement,
                        verticalScale: o.evaluatedScale[2]
                    };
                }
            }
        }
        function gy(t1, e) {
            return !t1.isLightConstant && e;
        }
        function xy(t1, e, r, n, i, a, s, o) {
            let l = (61440 & e | (61440 & e) >> 4) >> 8, u = (3840 & e | (3840 & e) >> 4) >> 4, c = 240 & e | (240 & e) >> 4;
            r[3] > 0 && (l = ze(l, 255 * r[0], r[3]), u = ze(u, 255 * r[1], r[3]), c = ze(c, 255 * r[2], r[3]));
            const h = l << 8 | u, p = c << 8 | Math.floor(255 * n[3]), f = function(t1) {
                const e = Q(t1, 0, 2);
                return Math.min(Math.round(.5 * e * 255), 255);
            }(n[2]) << 8 | 15 * n[0] << 4 | 15 * n[1], d = Q(i[0], 0, 1), m = Q(i[1], 0, 1), y = Q(i[2], 0, 1), g = Q(i[3], 0, 1);
            let x, v, b, _;
            if (d !== m && s !== a && m !== d) {
                const t1 = s - a;
                v = 1 / (t1 * (m - d)), b = -(a + t1 * d) / (t1 * (m - d));
                const e = Q(i[4], -1, 1);
                _ = Math.pow(10, e), x = 255 * y << 8 | 255 * g;
            } else x = 65535, v = 0, b = 1, _ = 1;
            if (t1.emplaceBack(h, p, f, x, v, b, _), o) {
                const t1 = o.length;
                o.clear();
                for(let e = 0; e < t1; e++)o.emplaceBack(h, p, f, x, v, b, _);
            }
        }
        function vy(t1, e, r) {
            const n = t1.node;
            let i = 0;
            const a = r & ry.HasMeshoptCompression;
            for (const r of n.meshes){
                if (n.lights && n.lightMeshIndex === i) continue;
                if (!r.featureData) continue;
                r.featureArray = new Zs, r.featureArray.reserve(r.featureData.length);
                let s = e;
                for (const e of r.featureData){
                    const i = a ? 65535 & e : e >> 16 & 65535, o = a ? e >> 16 & 65535 : 65535 & e, l = (15 & o) < 8 ? 15 & o : 0, u = t1.evaluatedRMEA[l], c = t1.evaluatedColor[l], h = t1.emissionHeightBasedParams[l];
                    let p;
                    if (s && 2 === l && n.lights && (p = new Zs, p.resize(10 * n.lights.length)), xy(r.featureArray, i, c, u, h, r.aabb.min[2], r.aabb.max[2], p), p && s) {
                        s = !1;
                        const t1 = n.meshes[n.lightMeshIndex];
                        t1.featureArray = p, t1.featureArray._trim();
                    }
                }
                r.featureArray._trim(), i++;
            }
        }
        function by(t1, e, r, n) {
            const i = 1 << t1.z;
            e.lat = fl((n / Wr + t1.y) / i), e.lng = pl((r / Wr + t1.x) / i);
        }
        oa(yy, "Tiled3dModelBucket", {
            omit: [
                "layers"
            ]
        }), oa(my, "Tiled3dModelFeature");
        const _y = {
            circle: class extends ps {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: Kl || (Kl = new Ga({
                            "circle-sort-key": new qa(Ya.layout_circle["circle-sort-key"]),
                            visibility: new ja(Ya.layout_circle.visibility)
                        })),
                        paint: Jl || (Jl = new Ga({
                            "circle-radius": new qa(Ya.paint_circle["circle-radius"]),
                            "circle-color": new qa(Ya.paint_circle["circle-color"]),
                            "circle-blur": new qa(Ya.paint_circle["circle-blur"]),
                            "circle-opacity": new qa(Ya.paint_circle["circle-opacity"]),
                            "circle-translate": new ja(Ya.paint_circle["circle-translate"]),
                            "circle-translate-anchor": new ja(Ya.paint_circle["circle-translate-anchor"]),
                            "circle-pitch-scale": new ja(Ya.paint_circle["circle-pitch-scale"]),
                            "circle-pitch-alignment": new ja(Ya.paint_circle["circle-pitch-alignment"]),
                            "circle-stroke-width": new qa(Ya.paint_circle["circle-stroke-width"]),
                            "circle-stroke-color": new qa(Ya.paint_circle["circle-stroke-color"]),
                            "circle-stroke-opacity": new qa(Ya.paint_circle["circle-stroke-opacity"]),
                            "circle-emissive-strength": new ja(Ya.paint_circle["circle-emissive-strength"]),
                            "circle-color-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "circle-stroke-color-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n);
                }
                createBucket(t1) {
                    return new Bl(t1);
                }
                queryRadius(t1) {
                    const e = t1;
                    return Xl("circle-radius", this, e) + Xl("circle-stroke-width", this, e) + Zl(this.paint.get("circle-translate"));
                }
                queryIntersectsFeature(t1, e, r, n, i, a, s, o) {
                    const l = Wl(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a.angle, t1.pixelToTileUnitsFactor), u = this.paint.get("circle-radius").evaluate(e, r) + this.paint.get("circle-stroke-width").evaluate(e, r);
                    return Yu(t1, n, a, s, o, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l, u);
                }
                getProgramIds() {
                    return [
                        "circle"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    const n = Gu(this);
                    return {
                        config: new Oo(this, {
                            zoom: e,
                            lut: r
                        }),
                        defines: n,
                        overrideFog: !1
                    };
                }
            },
            heatmap: class extends ps {
                createBucket(t1) {
                    return new Ku(t1);
                }
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: Ju || (Ju = new Ga({
                            visibility: new ja(Ya.layout_heatmap.visibility)
                        })),
                        paint: Qu || (Qu = new Ga({
                            "heatmap-radius": new qa(Ya.paint_heatmap["heatmap-radius"]),
                            "heatmap-weight": new qa(Ya.paint_heatmap["heatmap-weight"]),
                            "heatmap-intensity": new ja(Ya.paint_heatmap["heatmap-intensity"]),
                            "heatmap-color": new $a(Ya.paint_heatmap["heatmap-color"]),
                            "heatmap-opacity": new ja(Ya.paint_heatmap["heatmap-opacity"]),
                            "heatmap-color-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    "heatmap-color" === t1 && this._updateColorRamp();
                }
                _updateColorRamp() {
                    this.colorRamp = lc({
                        expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                        evaluationKey: "heatmapDensity",
                        image: this.colorRamp
                    }), this.colorRampTexture = null;
                }
                resize() {
                    this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
                }
                queryRadius(t1) {
                    return Xl("heatmap-radius", this, t1);
                }
                queryIntersectsFeature(t1, e, r, n, i, a, s, o) {
                    const l = this.paint.get("heatmap-radius").evaluate(e, r);
                    return Yu(t1, n, a, s, o, !0, !0, new q(0, 0), l);
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
                }
                getProgramIds() {
                    return [
                        "heatmap",
                        "heatmapTexture"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    return "heatmap" === t1 ? {
                        config: new Oo(this, {
                            zoom: e,
                            lut: r
                        }),
                        overrideFog: !1
                    } : {};
                }
            },
            hillshade: class extends ps {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: tc || (tc = new Ga({
                            visibility: new ja(Ya.layout_hillshade.visibility)
                        })),
                        paint: ec || (ec = new Ga({
                            "hillshade-illumination-direction": new ja(Ya.paint_hillshade["hillshade-illumination-direction"]),
                            "hillshade-illumination-anchor": new ja(Ya.paint_hillshade["hillshade-illumination-anchor"]),
                            "hillshade-exaggeration": new ja(Ya.paint_hillshade["hillshade-exaggeration"]),
                            "hillshade-shadow-color": new ja(Ya.paint_hillshade["hillshade-shadow-color"]),
                            "hillshade-highlight-color": new ja(Ya.paint_hillshade["hillshade-highlight-color"]),
                            "hillshade-accent-color": new ja(Ya.paint_hillshade["hillshade-accent-color"]),
                            "hillshade-emissive-strength": new ja(Ya.paint_hillshade["hillshade-emissive-strength"]),
                            "hillshade-shadow-color-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "hillshade-highlight-color-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "hillshade-accent-color-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n);
                }
                shouldRedrape() {
                    return this.hasOffscreenPass() && "viewport" === this.paint.get("hillshade-illumination-anchor");
                }
                hasOffscreenPass() {
                    return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
                }
                getProgramIds() {
                    return [
                        "hillshade",
                        "hillshadePrepare"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    return {
                        overrideFog: !1
                    };
                }
            },
            fill: class extends ps {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: jc || (jc = new Ga({
                            "fill-sort-key": new qa(Ya.layout_fill["fill-sort-key"]),
                            visibility: new ja(Ya.layout_fill.visibility),
                            "fill-elevation-reference": new ja(Ya.layout_fill["fill-elevation-reference"])
                        })),
                        paint: qc || (qc = new Ga({
                            "fill-antialias": new ja(Ya.paint_fill["fill-antialias"]),
                            "fill-opacity": new qa(Ya.paint_fill["fill-opacity"]),
                            "fill-color": new qa(Ya.paint_fill["fill-color"]),
                            "fill-outline-color": new qa(Ya.paint_fill["fill-outline-color"]),
                            "fill-translate": new ja(Ya.paint_fill["fill-translate"]),
                            "fill-translate-anchor": new ja(Ya.paint_fill["fill-translate-anchor"]),
                            "fill-pattern": new qa(Ya.paint_fill["fill-pattern"]),
                            "fill-emissive-strength": new ja(Ya.paint_fill["fill-emissive-strength"]),
                            "fill-z-offset": new qa(Ya.paint_fill["fill-z-offset"]),
                            "fill-color-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "fill-outline-color-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n);
                }
                getProgramIds() {
                    const t1 = this.paint.get("fill-pattern"), e = t1 && t1.constantOr(1), r = [
                        e ? "fillPattern" : "fill"
                    ];
                    return this.paint.get("fill-antialias") && r.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r;
                }
                getDefaultProgramParams(t1, e, r) {
                    return {
                        config: new Oo(this, {
                            zoom: e,
                            lut: r
                        }),
                        overrideFog: !1
                    };
                }
                recalculate(t1, e) {
                    super.recalculate(t1, e);
                    const r = this.paint._values["fill-outline-color"];
                    "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
                }
                createBucket(t1) {
                    return new Uc(t1);
                }
                queryRadius() {
                    return Zl(this.paint.get("fill-translate"));
                }
                queryIntersectsFeature(t1, e, r, n, i, a) {
                    return !t1.queryGeometry.isAboveHorizon && Dl(Hl(t1.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a.angle, t1.pixelToTileUnitsFactor), n);
                }
                isTileClipped() {
                    return !0;
                }
                is3D() {
                    return 0 !== this.paint.get("fill-z-offset").constantOr(1);
                }
            },
            "fill-extrusion": class extends ps {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: lp || (lp = new Ga({
                            visibility: new ja(Ya["layout_fill-extrusion"].visibility),
                            "fill-extrusion-edge-radius": new ja(Ya["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
                        })),
                        paint: up || (up = new Ga({
                            "fill-extrusion-opacity": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                            "fill-extrusion-color": new qa(Ya["paint_fill-extrusion"]["fill-extrusion-color"]),
                            "fill-extrusion-translate": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-translate"]),
                            "fill-extrusion-translate-anchor": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                            "fill-extrusion-pattern": new qa(Ya["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                            "fill-extrusion-height": new qa(Ya["paint_fill-extrusion"]["fill-extrusion-height"]),
                            "fill-extrusion-base": new qa(Ya["paint_fill-extrusion"]["fill-extrusion-base"]),
                            "fill-extrusion-height-alignment": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-height-alignment"]),
                            "fill-extrusion-base-alignment": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-base-alignment"]),
                            "fill-extrusion-vertical-gradient": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
                            "fill-extrusion-ambient-occlusion-intensity": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
                            "fill-extrusion-ambient-occlusion-radius": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]),
                            "fill-extrusion-ambient-occlusion-wall-radius": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]),
                            "fill-extrusion-ambient-occlusion-ground-radius": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]),
                            "fill-extrusion-ambient-occlusion-ground-attenuation": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]),
                            "fill-extrusion-flood-light-color": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]),
                            "fill-extrusion-flood-light-intensity": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]),
                            "fill-extrusion-flood-light-wall-radius": new qa(Ya["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]),
                            "fill-extrusion-flood-light-ground-radius": new qa(Ya["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]),
                            "fill-extrusion-flood-light-ground-attenuation": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]),
                            "fill-extrusion-vertical-scale": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]),
                            "fill-extrusion-rounded-roof": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]),
                            "fill-extrusion-cutoff-fade-range": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]),
                            "fill-extrusion-emissive-strength": new qa(Ya["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]),
                            "fill-extrusion-line-width": new qa(Ya["paint_fill-extrusion"]["fill-extrusion-line-width"]),
                            "fill-extrusion-cast-shadows": new ja(Ya["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]),
                            "fill-extrusion-color-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "fill-extrusion-flood-light-color-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n), this._stats = {
                        numRenderedVerticesInShadowPass: 0,
                        numRenderedVerticesInTransparentPass: 0
                    };
                }
                createBucket(t1) {
                    return new Kh(t1);
                }
                queryRadius() {
                    return Zl(this.paint.get("fill-extrusion-translate"));
                }
                is3D() {
                    return !0;
                }
                hasShadowPass() {
                    return this.paint.get("fill-extrusion-cast-shadows");
                }
                cutoffRange() {
                    return this.paint.get("fill-extrusion-cutoff-fade-range");
                }
                canCastShadows() {
                    return !0;
                }
                getProgramIds() {
                    return [
                        this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"
                    ];
                }
                queryIntersectsFeature(t1, e, r, n, i, a, s, o, l) {
                    const u = Wl(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a.angle, t1.pixelToTileUnitsFactor), c = this.paint.get("fill-extrusion-height").evaluate(e, r), h = this.paint.get("fill-extrusion-base").evaluate(e, r), p = [
                        0,
                        0
                    ], f = o && a.elevation, d = a.elevation ? a.elevation.exaggeration() : 1, m = t1.tile.getBucket(this);
                    if (f && m instanceof Kh) {
                        const t1 = m.centroidVertexArray, e = l + 1;
                        e < t1.length && (p[0] = t1.geta_centroid_pos0(e), p[1] = t1.geta_centroid_pos1(e));
                    }
                    if (0 === p[0] && 1 === p[1]) return !1;
                    "globe" === a.projection.name && (n = sp([
                        n
                    ], [
                        new q(0, 0),
                        new q(Wr, Wr)
                    ], t1.tileID.canonical).map((t1)=>t1.polygon).flat());
                    const y = f ? o : null, [g, x] = function(t1, e, r, n, i, a, s, o, l, u, c) {
                        return "globe" === t1.projection.name ? function(t1, e, r, n, i, a, s, o, l, u, c) {
                            const h = [], p = [], f = t1.projection.upVectorScale(c, t1.center.lat, t1.worldSize).metersToTile, d = [
                                0,
                                0,
                                0,
                                1
                            ], m = [
                                0,
                                0,
                                0,
                                1
                            ], y = (t1, e, r, n)=>{
                                t1[0] = e, t1[1] = r, t1[2] = n, t1[3] = 1;
                            }, g = ap();
                            r > 0 && (r += g), n += g;
                            for (const g of e){
                                const e = [], x = [];
                                for (const h of g){
                                    const p = h.x + i.x, g = h.y + i.y, v = t1.projection.projectTilePoint(p, g, c), b = t1.projection.upVector(c, h.x, h.y);
                                    let _ = r, w = n;
                                    if (s) {
                                        const t1 = pp(p, g, r, n, s, o, l, u);
                                        _ += t1.base, w += t1.top;
                                    }
                                    0 !== r ? y(d, v.x + b[0] * f * _, v.y + b[1] * f * _, v.z + b[2] * f * _) : y(d, v.x, v.y, v.z), y(m, v.x + b[0] * f * w, v.y + b[1] * f * w, v.z + b[2] * f * w), O.vec3.transformMat4(d, d, a), O.vec3.transformMat4(m, m, a), e.push(new dh(d[0], d[1], d[2])), x.push(new dh(m[0], m[1], m[2]));
                                }
                                h.push(e), p.push(x);
                            }
                            return [
                                h,
                                p
                            ];
                        }(t1, e, r, n, i, a, s, o, l, u, c) : s ? function(t1, e, r, n, i, a, s, o, l) {
                            const u = [], c = [], h = [
                                0,
                                0,
                                0,
                                1
                            ];
                            for (const p of t1){
                                const t1 = [], f = [];
                                for (const u of p){
                                    const c = u.x + n.x, p = u.y + n.y, d = pp(c, p, e, r, a, s, o, l);
                                    h[0] = c, h[1] = p, h[2] = d.base, h[3] = 1, O.vec4.transformMat4(h, h, i), h[3] = Math.max(h[3], 1e-5);
                                    const m = new dh(h[0] / h[3], h[1] / h[3], h[2] / h[3]);
                                    h[0] = c, h[1] = p, h[2] = d.top, h[3] = 1, O.vec4.transformMat4(h, h, i), h[3] = Math.max(h[3], 1e-5);
                                    const y = new dh(h[0] / h[3], h[1] / h[3], h[2] / h[3]);
                                    t1.push(m), f.push(y);
                                }
                                u.push(t1), c.push(f);
                            }
                            return [
                                u,
                                c
                            ];
                        }(e, r, n, i, a, s, o, l, u) : function(t1, e, r, n, i) {
                            const a = [], s = [], o = i[8] * e, l = i[9] * e, u = i[10] * e, c = i[11] * e, h = i[8] * r, p = i[9] * r, f = i[10] * r, d = i[11] * r;
                            for (const e of t1){
                                const t1 = [], r = [];
                                for (const a of e){
                                    const e = a.x + n.x, s = a.y + n.y, m = i[0] * e + i[4] * s + i[12], y = i[1] * e + i[5] * s + i[13], g = i[2] * e + i[6] * s + i[14], x = i[3] * e + i[7] * s + i[15], v = m + o, b = y + l, _ = g + u, w = Math.max(x + c, 1e-5), M = m + h, A = y + p, S = g + f, I = Math.max(x + d, 1e-5);
                                    t1.push(new dh(v / w, b / w, _ / w)), r.push(new dh(M / I, A / I, S / I));
                                }
                                a.push(t1), s.push(r);
                            }
                            return [
                                a,
                                s
                            ];
                        }(e, r, n, i, a);
                    }(a, n, h, c, u, s, y, p, d, a.center.lat, t1.tileID.canonical), v = t1.queryGeometry;
                    return function(t1, e, r) {
                        let n = 1 / 0;
                        Dl(r, e) && (n = hp(r, e[0]));
                        for(let i = 0; i < e.length; i++){
                            const a = e[i], s = t1[i];
                            for(let t1 = 0; t1 < a.length - 1; t1++){
                                const e = a[t1], i = [
                                    e,
                                    a[t1 + 1],
                                    s[t1 + 1],
                                    s[t1],
                                    e
                                ];
                                Vl(r, i) && (n = Math.min(n, hp(r, i)));
                            }
                        }
                        return n !== 1 / 0 && n;
                    }(g, x, v.isPointQuery() ? v.screenBounds : v.screenGeometry);
                }
            },
            line: class extends ps {
                constructor(t1, e, r, n){
                    const i = Dp();
                    super(t1, i, e, r, n), i.layout && (this.layout = new Ua(i.layout)), this.gradientVersion = 0;
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    if ("line-gradient" === t1) {
                        const t1 = this._transitionablePaint._values["line-gradient"].value.expression;
                        this.stepInterpolant = t1._styleExpression && t1._styleExpression.expression instanceof Nn, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
                    }
                }
                gradientExpression() {
                    return this._transitionablePaint._values["line-gradient"].value.expression;
                }
                widthExpression() {
                    return this._transitionablePaint._values["line-width"].value.expression;
                }
                recalculate(t1, e) {
                    super.recalculate(t1, e), this.paint._values["line-floorwidth"] = (()=>{
                        if (Rp) return Rp;
                        const t1 = Dp();
                        return Rp = new Lp(t1.paint.properties["line-width"].specification), Rp.useIntegerZoom = !0, Rp;
                    })().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t1);
                }
                createBucket(t1) {
                    return new Ap(t1);
                }
                getProgramIds() {
                    return [
                        this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    const n = Bp(this);
                    return {
                        config: new Oo(this, {
                            zoom: e,
                            lut: r
                        }),
                        defines: n,
                        overrideFog: !1
                    };
                }
                queryRadius(t1) {
                    const e = t1, r = Fp(Xl("line-width", this, e), Xl("line-gap-width", this, e)), n = Xl("line-offset", this, e);
                    return r / 2 + Math.abs(n) + Zl(this.paint.get("line-translate"));
                }
                queryIntersectsFeature(t1, e, r, n, i, a) {
                    if (t1.queryGeometry.isAboveHorizon) return !1;
                    const s = Hl(t1.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a.angle, t1.pixelToTileUnitsFactor), o = t1.pixelToTileUnitsFactor / 2 * Fp(this.paint.get("line-width").evaluate(e, r), this.paint.get("line-gap-width").evaluate(e, r)), l = this.paint.get("line-offset").evaluate(e, r);
                    return l && (n = function(t1, e) {
                        const r = [], n = new q(0, 0);
                        for(let i = 0; i < t1.length; i++){
                            const a = t1[i], s = [];
                            for(let t1 = 0; t1 < a.length; t1++){
                                const r = a[t1], i = a[t1 + 1], o = 0 === t1 ? n : r.sub(a[t1 - 1])._unit()._perp(), l = t1 === a.length - 1 ? n : i.sub(r)._unit()._perp(), u = o._add(l)._unit();
                                u._mult(1 / (u.x * l.x + u.y * l.y)), s.push(u._mult(e)._add(r));
                            }
                            r.push(s);
                        }
                        return r;
                    }(n, l * t1.pixelToTileUnitsFactor)), function(t1, e, r) {
                        for(let n = 0; n < e.length; n++){
                            const i = e[n];
                            if (t1.length >= 3) {
                                for(let e = 0; e < i.length; e++)if (jl(t1, i[e])) return !0;
                            }
                            if (Ll(t1, i, r)) return !0;
                        }
                        return !1;
                    }(s, n, o);
                }
                isTileClipped() {
                    return !0;
                }
                isDraped(t1) {
                    const e = this.layout.get("line-z-offset"), r = e.isConstant() && !e.constantOr(0), n = this.layout.get("line-elevation-reference");
                    return !("sea" === n || "ground" === n) && (r || "none" !== n);
                }
            },
            symbol: sm,
            background: class extends ps {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: om || (om = new Ga({
                            visibility: new ja(Ya.layout_background.visibility)
                        })),
                        paint: lm || (lm = new Ga({
                            "background-pitch-alignment": new ja(Ya.paint_background["background-pitch-alignment"]),
                            "background-color": new ja(Ya.paint_background["background-color"]),
                            "background-pattern": new ja(Ya.paint_background["background-pattern"]),
                            "background-opacity": new ja(Ya.paint_background["background-opacity"]),
                            "background-emissive-strength": new ja(Ya.paint_background["background-emissive-strength"]),
                            "background-color-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n);
                }
                getProgramIds() {
                    return [
                        this.paint.get("background-pattern") ? "backgroundPattern" : "background"
                    ];
                }
                getDefaultProgramParams(t1, e, r) {
                    return {
                        overrideFog: !1
                    };
                }
                is3D() {
                    return "viewport" === this.paint.get("background-pitch-alignment");
                }
            },
            raster: _m,
            "raster-particle": Pm,
            sky: class extends ps {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: Am || (Am = new Ga({
                            visibility: new ja(Ya.layout_sky.visibility)
                        })),
                        paint: Sm || (Sm = new Ga({
                            "sky-type": new ja(Ya.paint_sky["sky-type"]),
                            "sky-atmosphere-sun": new ja(Ya.paint_sky["sky-atmosphere-sun"]),
                            "sky-atmosphere-sun-intensity": new ja(Ya.paint_sky["sky-atmosphere-sun-intensity"]),
                            "sky-gradient-center": new ja(Ya.paint_sky["sky-gradient-center"]),
                            "sky-gradient-radius": new ja(Ya.paint_sky["sky-gradient-radius"]),
                            "sky-gradient": new $a(Ya.paint_sky["sky-gradient"]),
                            "sky-atmosphere-halo-color": new ja(Ya.paint_sky["sky-atmosphere-halo-color"]),
                            "sky-atmosphere-color": new ja(Ya.paint_sky["sky-atmosphere-color"]),
                            "sky-opacity": new ja(Ya.paint_sky["sky-opacity"]),
                            "sky-gradient-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "sky-atmosphere-halo-color-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            }),
                            "sky-atmosphere-color-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n), this._updateColorRamp();
                }
                _handleSpecialPaintPropertyUpdate(t1) {
                    "sky-gradient" === t1 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t1 && "sky-atmosphere-halo-color" !== t1 && "sky-atmosphere-color" !== t1 && "sky-atmosphere-sun-intensity" !== t1 || (this._skyboxInvalidated = !0);
                }
                _updateColorRamp() {
                    this.colorRamp = lc({
                        expression: this._transitionablePaint._values["sky-gradient"].value.expression,
                        evaluationKey: "skyRadialProgress"
                    }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
                }
                needsSkyboxCapture(t1) {
                    if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
                    if (!this.paint.get("sky-atmosphere-sun")) {
                        const e = t1.style.light.properties.get("position");
                        return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;
                    }
                    return !1;
                }
                getCenter(t1, e) {
                    if ("atmosphere" === this.paint.get("sky-type")) {
                        const r = this.paint.get("sky-atmosphere-sun"), n = !r, i = t1.style.light, a = i.properties.get("position");
                        return n && "viewport" === i.properties.get("anchor") && ft("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n ? Em(a.azimuthal, 90 - a.polar, e) : Em(r[0], 90 - r[1], e);
                    }
                    const r = this.paint.get("sky-gradient-center");
                    return Em(r[0], 90 - r[1], e);
                }
                isSky() {
                    return !0;
                }
                markSkyboxValid(t1) {
                    this._skyboxInvalidated = !1, this._lightPosition = t1.style.light.properties.get("position");
                }
                hasOffscreenPass() {
                    return !0;
                }
                getProgramIds() {
                    const t1 = this.paint.get("sky-type");
                    return "atmosphere" === t1 ? [
                        "skyboxCapture",
                        "skybox"
                    ] : "gradient" === t1 ? [
                        "skyboxGradient"
                    ] : null;
                }
            },
            slot: class extends ps {
                constructor(t1, e, r, n){
                    super(t1, {
                        paint: Im || (Im = new Ga({}))
                    }, e, null);
                }
            },
            model: class extends ps {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: Qm || (Qm = new Ga({
                            visibility: new ja(Ya.layout_model.visibility),
                            "model-id": new qa(Ya.layout_model["model-id"])
                        })),
                        paint: ty || (ty = new Ga({
                            "model-opacity": new qa(Ya.paint_model["model-opacity"]),
                            "model-rotation": new qa(Ya.paint_model["model-rotation"]),
                            "model-scale": new qa(Ya.paint_model["model-scale"]),
                            "model-translation": new qa(Ya.paint_model["model-translation"]),
                            "model-color": new qa(Ya.paint_model["model-color"]),
                            "model-color-mix-intensity": new qa(Ya.paint_model["model-color-mix-intensity"]),
                            "model-type": new ja(Ya.paint_model["model-type"]),
                            "model-cast-shadows": new ja(Ya.paint_model["model-cast-shadows"]),
                            "model-receive-shadows": new ja(Ya.paint_model["model-receive-shadows"]),
                            "model-ambient-occlusion-intensity": new ja(Ya.paint_model["model-ambient-occlusion-intensity"]),
                            "model-emissive-strength": new qa(Ya.paint_model["model-emissive-strength"]),
                            "model-roughness": new qa(Ya.paint_model["model-roughness"]),
                            "model-height-based-emissive-strength-multiplier": new qa(Ya.paint_model["model-height-based-emissive-strength-multiplier"]),
                            "model-cutoff-fade-range": new ja(Ya.paint_model["model-cutoff-fade-range"]),
                            "model-front-cutoff": new ja(Ya.paint_model["model-front-cutoff"]),
                            "model-color-use-theme": new qa({
                                type: "string",
                                default: "default",
                                "property-type": "data-driven"
                            })
                        }))
                    }, e, r, n), this._stats = {
                        numRenderedVerticesInShadowPass: 0,
                        numRenderedVerticesInTransparentPass: 0
                    };
                }
                createBucket(t1) {
                    return new Jm(t1);
                }
                getProgramIds() {
                    return [
                        "model"
                    ];
                }
                is3D() {
                    return !0;
                }
                hasShadowPass() {
                    return !0;
                }
                canCastShadows() {
                    return !0;
                }
                hasLightBeamPass() {
                    return !0;
                }
                cutoffRange() {
                    return this.paint.get("model-cutoff-fade-range");
                }
                queryRadius(t1) {
                    return t1 instanceof yy ? Wr - 1 : 0;
                }
                queryIntersectsFeature(t1, e, r, n, i, a) {
                    if (!this.modelManager) return !1;
                    const s = this.modelManager, o = t1.tile.getBucket(this);
                    if (!(o && o instanceof Jm)) return !1;
                    for(const r in o.instancesPerModel){
                        const n = o.instancesPerModel[r], i = void 0 !== e.id ? e.id : e.properties && e.properties.hasOwnProperty("id") ? e.properties.id : void 0;
                        if (n.idToFeaturesIndex.hasOwnProperty(i)) {
                            const e = n.features[n.idToFeaturesIndex[i]], l = s.getModel(r, this.scope);
                            if (!l) return !1;
                            let u = O.mat4.create();
                            const c = new il(0, 0), h = o.canonical;
                            let p = Number.MAX_VALUE;
                            for(let r = 0; r < e.instancedDataCount; ++r){
                                const i = 16 * (e.instancedDataOffset + r), s = n.instancedDataArray.float32, o = [
                                    s[i + 4],
                                    s[i + 5],
                                    s[i + 6]
                                ];
                                by(h, c, s[i], 0 | s[i + 1]), ny(u, l, a, c, e.rotation, e.scale, o, !1, !1, !1), "globe" === a.projection.name && (u = Fm(u, a));
                                const f = O.mat4.multiply([], a.projMatrix, u), d = t1.queryGeometry, m = Om(d.isPointQuery() ? d.screenBounds : d.screenGeometry, a, f, l.aabb);
                                null != m && (p = Math.min(m, p));
                            }
                            return p !== Number.MAX_VALUE && p;
                        }
                    }
                    return !1;
                }
                _handleOverridablePaintPropertyUpdate(t1, e, r) {
                    return !(!this.layout || e.isDataDriven() || r.isDataDriven() || "model-color" !== t1 && "model-color-mix-intensity" !== t1 && "model-rotation" !== t1 && "model-scale" !== t1 && "model-translation" !== t1 && "model-emissive-strength" !== t1);
                }
                _isPropertyZoomDependent(t1) {
                    const e = this._transitionablePaint._values[t1];
                    return null != e && null != e.value && null != e.value.expression && e.value.expression instanceof Ji;
                }
                isZoomDependent() {
                    return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
                }
            },
            clip: class extends ps {
                constructor(t1, e, r, n){
                    super(t1, {
                        layout: $c || ($c = new Ga({
                            "clip-layer-types": new ja(Ya.layout_clip["clip-layer-types"]),
                            "clip-layer-scope": new ja(Ya.layout_clip["clip-layer-scope"])
                        })),
                        paint: Gc || (Gc = new Ga({}))
                    }, e, r, n);
                }
                recalculate(t1, e) {
                    super.recalculate(t1, e);
                }
                createBucket(t1) {
                    return new Zc(t1);
                }
                isTileClipped() {
                    return !0;
                }
                is3D() {
                    return !0;
                }
            }
        };
        class wy {
            constructor(t1){
                this._callback = t1, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel, this._channel.port2.onmessage = ()=>{
                    this._triggered = !1, this._callback();
                });
            }
            trigger() {
                this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(()=>{
                    this._triggered = !1, this._callback();
                }, 0));
            }
            remove() {
                this._channel = void 0, this._callback = ()=>{};
            }
        }
        class My {
            constructor(){
                this.tasks = {}, this.taskQueue = [], ot([
                    "process"
                ], this), this.invoker = new wy(this.process), this.nextId = 0;
            }
            add(t1, e) {
                const r = this.nextId++, n = function({ type: t1, isSymbolTile: e, zoom: r }) {
                    return r = r || 0, "message" === t1 ? 0 : "maybePrepare" !== t1 || e ? "parseTile" !== t1 || e ? "parseTile" === t1 && e ? 300 - r : "maybePrepare" === t1 && e ? 400 - r : 500 : 200 - r : 100 - r;
                }(e);
                if (0 === n) {
                    try {
                        t1();
                    } finally{}
                    return null;
                }
                return this.tasks[r] = {
                    fn: t1,
                    metadata: e,
                    priority: n,
                    id: r
                }, this.taskQueue.push(r), this.invoker.trigger(), {
                    cancel: ()=>{
                        delete this.tasks[r];
                    }
                };
            }
            process() {
                try {
                    if (this.taskQueue = this.taskQueue.filter((t1)=>!!this.tasks[t1]), !this.taskQueue.length) return;
                    const t1 = this.pick();
                    if (null === t1) return;
                    const e = this.tasks[t1];
                    if (delete this.tasks[t1], this.taskQueue.length && this.invoker.trigger(), !e) return;
                    e.fn();
                } finally{}
            }
            pick() {
                let t1 = null, e = 1 / 0;
                for(let r = 0; r < this.taskQueue.length; r++){
                    const n = this.tasks[this.taskQueue[r]];
                    n.priority < e && (e = n.priority, t1 = r);
                }
                if (null === t1) return null;
                const r = this.taskQueue[t1];
                return this.taskQueue.splice(t1, 1), r;
            }
            remove() {
                this.invoker.remove();
            }
        }
        class Ay {
            constructor(t1, e, r){
                this.target = t1, this.parent = e, this.mapId = r, this.callbacks = {}, this.cancelCallbacks = {}, ot([
                    "receive"
                ], this), this.target.addEventListener("message", this.receive, !1), this.scheduler = new My;
            }
            send(t1, e, r, n, i = !1, a) {
                const s = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                r && (r.metadata = a, this.callbacks[s] = r);
                const o = new Set;
                return this.target.postMessage({
                    id: s,
                    type: t1,
                    hasCallback: !!r,
                    targetMapId: n,
                    mustQueue: i,
                    sourceMapId: this.mapId,
                    data: ca(e, o)
                }, o), {
                    cancel: ()=>{
                        r && delete this.callbacks[s], this.target.postMessage({
                            id: s,
                            type: "<cancel>",
                            targetMapId: n,
                            sourceMapId: this.mapId
                        });
                    }
                };
            }
            receive(t1) {
                const e = t1.data, r = e.id;
                if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if ("<cancel>" === e.type) {
                    const t1 = this.cancelCallbacks[r];
                    delete this.cancelCallbacks[r], t1 && t1.cancel();
                } else if (e.mustQueue || gt()) {
                    const t1 = this.callbacks[r], n = this.scheduler.add(()=>this.processTask(r, e), t1 && t1.metadata || {
                        type: "message"
                    });
                    n && (this.cancelCallbacks[r] = n);
                } else this.processTask(r, e);
            }
            processTask(t1, e) {
                if (delete this.cancelCallbacks[t1], "<response>" === e.type) {
                    const r = this.callbacks[t1];
                    delete this.callbacks[t1], r && (e.error ? r(ha(e.error)) : r(null, ha(e.data)));
                } else {
                    const r = new Set, n = e.hasCallback ? (e, n)=>{
                        this.target.postMessage({
                            id: t1,
                            type: "<response>",
                            sourceMapId: this.mapId,
                            error: e ? ca(e) : null,
                            data: ca(n, r)
                        }, r);
                    } : ()=>{}, i = ha(e.data);
                    if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, i, n);
                    else if (this.parent.getWorkerSource) {
                        const t1 = e.type.split(".");
                        this.parent.getWorkerSource(e.sourceMapId, t1[0], i.source, i.scope)[t1[1]](i, n);
                    } else n(new Error(`Could not find function ${e.type}`));
                }
            }
            remove() {
                this.scheduler.remove(), this.target.removeEventListener("message", this.receive, !1);
            }
        }
        var Sy = {
            workerUrl: "",
            workerClass: null,
            workerParams: void 0
        };
        const Iy = "mapboxgl_preloaded_worker_pool";
        class Py {
            constructor(){
                this.active = {};
            }
            acquire(t1, e = Py.workerCount) {
                if (!this.workers) for(this.workers = []; this.workers.length < e;)this.workers.push(null != Sy.workerClass ? new Sy.workerClass : new self.Worker(Sy.workerUrl, Sy.workerParams));
                return this.active[t1] = !0, this.workers.slice();
            }
            release(t1) {
                delete this.active[t1], this.workers && 0 === this.numActive() && (this.workers.forEach((t1)=>{
                    t1.terminate();
                }), this.workers = null);
            }
            isPreloaded() {
                return !!this.active[Iy];
            }
            numActive() {
                return Object.keys(this.active).length;
            }
        }
        Py.workerCount = 2;
        class zy {
            constructor(t1, e, r = "Worker", n = Py.workerCount){
                this.workerPool = t1, this.actors = [], this.currentActor = 0, this.id = at();
                const i = this.workerPool.acquire(this.id, n);
                for(let t1 = 0; t1 < i.length; t1++){
                    const n = new zy.Actor(i[t1], e, this.id);
                    n.name = `${r} ${t1}`, this.actors.push(n);
                }
                this.ready = !1, this.broadcast("checkIfReady", null, ()=>{
                    this.ready = !0;
                });
            }
            broadcast(t1, e, r) {
                rt(this.actors, (r, n)=>{
                    r.send(t1, e, n);
                }, r = r || function() {});
            }
            getActor() {
                return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove() {
                this.actors.forEach((t1)=>{
                    t1.remove();
                }), this.actors = [], this.workerPool.release(this.id);
            }
        }
        let Ey, ky;
        function Ty() {
            return Ey || (Ey = new Py), Ey;
        }
        zy.Actor = Ay;
        const By = new Ie(0, 0, 0);
        var Vy = ((t1)=>(t1[t1.PATH_RULE_UNSPECIFIED = 0] = "PATH_RULE_UNSPECIFIED", t1[t1.PATH_RULE_NON_ZERO = 1] = "PATH_RULE_NON_ZERO", t1[t1.PATH_RULE_EVEN_ODD = 2] = "PATH_RULE_EVEN_ODD", t1))(Vy || {}), Cy = ((t1)=>(t1[t1.LINE_CAP_UNSPECIFIED = 0] = "LINE_CAP_UNSPECIFIED", t1[t1.LINE_CAP_BUTT = 1] = "LINE_CAP_BUTT", t1[t1.LINE_CAP_ROUND = 2] = "LINE_CAP_ROUND", t1[t1.LINE_CAP_SQUARE = 3] = "LINE_CAP_SQUARE", t1))(Cy || {}), Dy = ((t1)=>(t1[t1.LINE_JOIN_UNSPECIFIED = 0] = "LINE_JOIN_UNSPECIFIED", t1[t1.LINE_JOIN_MITER = 1] = "LINE_JOIN_MITER", t1[t1.LINE_JOIN_MITER_CLIP = 2] = "LINE_JOIN_MITER_CLIP", t1[t1.LINE_JOIN_ROUND = 3] = "LINE_JOIN_ROUND", t1[t1.LINE_JOIN_BEVEL = 4] = "LINE_JOIN_BEVEL", t1))(Dy || {}), Ly = ((t1)=>(t1[t1.PAINT_ORDER_UNSPECIFIED = 0] = "PAINT_ORDER_UNSPECIFIED", t1[t1.PAINT_ORDER_FILL_AND_STROKE = 1] = "PAINT_ORDER_FILL_AND_STROKE", t1[t1.PAINT_ORDER_STROKE_AND_FILL = 2] = "PAINT_ORDER_STROKE_AND_FILL", t1))(Ly || {}), Ry = ((t1)=>(t1[t1.PATH_COMMAND_UNSPECIFIED = 0] = "PATH_COMMAND_UNSPECIFIED", t1[t1.PATH_COMMAND_MOVE = 1] = "PATH_COMMAND_MOVE", t1[t1.PATH_COMMAND_LINE = 2] = "PATH_COMMAND_LINE", t1[t1.PATH_COMMAND_QUAD = 3] = "PATH_COMMAND_QUAD", t1[t1.PATH_COMMAND_CUBIC = 4] = "PATH_COMMAND_CUBIC", t1[t1.PATH_COMMAND_CLOSE = 5] = "PATH_COMMAND_CLOSE", t1))(Ry || {}), Fy = ((t1)=>(t1[t1.MASK_TYPE_UNSPECIFIED = 0] = "MASK_TYPE_UNSPECIFIED", t1[t1.MASK_TYPE_LUMINANCE = 1] = "MASK_TYPE_LUMINANCE", t1[t1.MASK_TYPE_ALPHA = 2] = "MASK_TYPE_ALPHA", t1))(Fy || {});
        function Oy(t1, e, r) {
            1 === t1 && e.icons.push(function(t1, e) {
                return function(t1) {
                    if (t1.usvg_tree.height || (t1.usvg_tree.height = t1.usvg_tree.width), !t1.metadata) return t1;
                    const { metadata: e } = t1;
                    if (e.content_area) {
                        const { content_area: r } = e;
                        null == r.top && (r.top = r.left), null == r.width && (r.width = t1.usvg_tree.width), null == r.height && (r.height = r.width);
                    }
                    return e.stretch_x && e.stretch_x.length && Ny(e, "x"), e.stretch_y && e.stretch_y.length && Ny(e, "y"), t1;
                }(t1.readFields(Uy, {
                    name: void 0
                }, e));
            }(r, r.readVarint() + r.pos));
        }
        function Ny(t1, e) {
            const r = [], n = t1[`stretch_${e}`];
            let i = null;
            for(let t1 = 0; t1 < n.length; t1++)null === i ? i = 0 === r.length ? n[0] : r[r.length - 1][1] + n[t1] : (r.push([
                i,
                i + n[t1]
            ]), i = null);
            t1[`stretch_${e}_areas`] = r;
        }
        function Uy(t1, e, r) {
            1 === t1 ? e.name = r.readString() : 2 === t1 ? e.metadata = function(t1, e) {
                return t1.readFields(jy, {
                    stretch_x: null,
                    stretch_y: null,
                    stretch_x_areas: null,
                    stretch_y_areas: null,
                    variables: []
                }, e);
            }(r, r.readVarint() + r.pos) : 3 === t1 && (e.usvg_tree = function(t1, e) {
                return t1.readFields(Gy, {
                    width: 20,
                    children: [],
                    linear_gradients: [],
                    radial_gradients: [],
                    clip_paths: [],
                    masks: []
                }, e);
            }(r, r.readVarint() + r.pos), e.data = "usvg_tree");
        }
        function jy(t1, e, r) {
            1 === t1 ? e.stretch_x = r.readPackedVarint() : 2 === t1 ? e.stretch_y = r.readPackedVarint() : 3 === t1 ? e.content_area = function(t1, e) {
                return t1.readFields(qy, {
                    left: 0
                }, e);
            }(r, r.readVarint() + r.pos) : 4 === t1 && e.variables.push(function(t1, e) {
                return t1.readFields($y, {
                    name: void 0
                }, e);
            }(r, r.readVarint() + r.pos));
        }
        function qy(t1, e, r) {
            1 === t1 ? e.left = r.readVarint() : 2 === t1 ? e.width = r.readVarint() : 3 === t1 ? e.top = r.readVarint() : 4 === t1 && (e.height = r.readVarint());
        }
        function $y(t1, e, r) {
            1 === t1 ? e.name = r.readString() : 2 === t1 && (e.rgb_color = Qy(r.readVarint()), e.value = "rgb_color");
        }
        function Gy(t1, e, r) {
            1 === t1 ? e.width = e.height = r.readVarint() : 2 === t1 ? e.height = r.readVarint() : 3 === t1 ? e.children.push(Yy(r, r.readVarint() + r.pos)) : 4 === t1 ? e.linear_gradients.push(function(t1, e) {
                return t1.readFields(eg, {
                    spread_method: 1,
                    stops: [],
                    x1: 0,
                    y1: 0,
                    x2: 1,
                    y2: 0
                }, e);
            }(r, r.readVarint() + r.pos)) : 5 === t1 ? e.radial_gradients.push(function(t1, e) {
                return t1.readFields(ig, {
                    spread_method: 1,
                    stops: [],
                    cx: .5,
                    cy: .5,
                    r: .5,
                    fx: .5,
                    fy: .5,
                    fr: 0
                }, e);
            }(r, r.readVarint() + r.pos)) : 7 === t1 ? e.clip_paths.push(function(t1, e) {
                return t1.readFields(ag, {
                    children: []
                }, e);
            }(r, r.readVarint() + r.pos)) : 8 === t1 && e.masks.push(function(t1, e) {
                const r = t1.readFields(sg, {
                    left: 0,
                    width: 20,
                    mask_type: 1,
                    children: []
                }, e);
                return null == r.height && (r.height = r.width), null == r.top && (r.top = r.left), r;
            }(r, r.readVarint() + r.pos));
        }
        function Yy(t1, e) {
            return t1.readFields(Xy, {}, e);
        }
        function Xy(t1, e, r) {
            1 === t1 ? (e.group = function(t1, e) {
                return t1.readFields(Zy, {
                    opacity: 255,
                    children: []
                }, e);
            }(r, r.readVarint() + r.pos), e.node = "group") : 2 === t1 && (e.path = function(t1, e) {
                return t1.readFields(Ky, {
                    paint_order: 1,
                    commands: [],
                    step: 1,
                    diffs: [],
                    rule: 1
                }, e);
            }(r, r.readVarint() + r.pos), e.node = "path");
        }
        function Zy(t1, e, r) {
            1 === t1 ? e.transform = Hy(r, r.readVarint() + r.pos) : 2 === t1 ? e.opacity = r.readVarint() : 5 === t1 ? e.clip_path_idx = r.readVarint() : 6 === t1 ? e.mask_idx = r.readVarint() : 7 === t1 && e.children.push(Yy(r, r.readVarint() + r.pos));
        }
        function Hy(t1, e) {
            return t1.readFields(Wy, {
                sx: 1,
                ky: 0,
                kx: 0,
                sy: 1,
                tx: 0,
                ty: 0
            }, e);
        }
        function Wy(t1, e, r) {
            1 === t1 ? e.sx = r.readFloat() : 2 === t1 ? e.ky = r.readFloat() : 3 === t1 ? e.kx = r.readFloat() : 4 === t1 ? e.sy = r.readFloat() : 5 === t1 ? e.tx = r.readFloat() : 6 === t1 && (e.ty = r.readFloat());
        }
        function Ky(t1, e, r) {
            1 === t1 ? e.fill = function(t1, e) {
                return t1.readFields(Jy, {
                    rgb_color: By,
                    paint: "rgb_color",
                    opacity: 255
                }, e);
            }(r, r.readVarint() + r.pos) : 2 === t1 ? e.stroke = function(t1, e) {
                return t1.readFields(tg, {
                    rgb_color: By,
                    paint: "rgb_color",
                    dasharray: [],
                    dashoffset: 0,
                    miterlimit: 4,
                    opacity: 255,
                    width: 1,
                    linecap: 1,
                    linejoin: 1
                }, e);
            }(r, r.readVarint() + r.pos) : 3 === t1 ? e.paint_order = r.readVarint() : 5 === t1 ? r.readPackedVarint(e.commands) : 6 === t1 ? e.step = r.readFloat() : 7 === t1 ? r.readPackedSVarint(e.diffs) : 8 === t1 && (e.rule = r.readVarint());
        }
        function Jy(t1, e, r) {
            1 === t1 ? (e.rgb_color = Qy(r.readVarint()), e.paint = "rgb_color") : 2 === t1 ? (e.linear_gradient_idx = r.readVarint(), e.paint = "linear_gradient_idx") : 3 === t1 ? (e.radial_gradient_idx = r.readVarint(), e.paint = "radial_gradient_idx") : 5 === t1 && (e.opacity = r.readVarint());
        }
        function Qy(t1) {
            return new Ie((t1 >> 16 & 255) / 255, (t1 >> 8 & 255) / 255, (255 & t1) / 255, 1);
        }
        function tg(t1, e, r) {
            1 === t1 ? (e.rgb_color = Qy(r.readVarint()), e.paint = "rgb_color") : 2 === t1 ? (e.linear_gradient_idx = r.readVarint(), e.paint = "linear_gradient_idx") : 3 === t1 ? (e.radial_gradient_idx = r.readVarint(), e.paint = "radial_gradient_idx") : 5 === t1 ? r.readPackedFloat(e.dasharray) : 6 === t1 ? e.dashoffset = r.readFloat() : 7 === t1 ? e.miterlimit = r.readFloat() : 8 === t1 ? e.opacity = r.readVarint() : 9 === t1 ? e.width = r.readFloat() : 10 === t1 ? e.linecap = r.readVarint() : 11 === t1 && (e.linejoin = r.readVarint());
        }
        function eg(t1, e, r) {
            1 === t1 ? e.transform = Hy(r, r.readVarint() + r.pos) : 2 === t1 ? e.spread_method = r.readVarint() : 3 === t1 ? e.stops.push(rg(r, r.readVarint() + r.pos)) : 4 === t1 ? e.x1 = r.readFloat() : 5 === t1 ? e.y1 = r.readFloat() : 6 === t1 ? e.x2 = r.readFloat() : 7 === t1 && (e.y2 = r.readFloat());
        }
        function rg(t1, e) {
            return t1.readFields(ng, {
                offset: 0,
                opacity: 255,
                rgb_color: By
            }, e);
        }
        function ng(t1, e, r) {
            1 === t1 ? e.offset = r.readFloat() : 2 === t1 ? e.opacity = r.readVarint() : 3 === t1 && (e.rgb_color = Qy(r.readVarint()));
        }
        function ig(t1, e, r) {
            1 === t1 ? e.transform = Hy(r, r.readVarint() + r.pos) : 2 === t1 ? e.spread_method = r.readVarint() : 3 === t1 ? e.stops.push(rg(r, r.readVarint() + r.pos)) : 4 === t1 ? e.cx = r.readFloat() : 5 === t1 ? e.cy = r.readFloat() : 6 === t1 ? e.r = r.readFloat() : 7 === t1 ? e.fx = r.readFloat() : 8 === t1 ? e.fy = r.readFloat() : 9 === t1 && (e.fr = r.readFloat());
        }
        function ag(t1, e, r) {
            1 === t1 ? e.transform = Hy(r, r.readVarint() + r.pos) : 2 === t1 ? e.clip_path_idx = r.readVarint() : 3 === t1 && e.children.push(Yy(r, r.readVarint() + r.pos));
        }
        function sg(t1, e, r) {
            1 === t1 ? e.left = e.top = r.readFloat() : 2 === t1 ? e.width = e.height = r.readFloat() : 3 === t1 ? e.top = r.readFloat() : 4 === t1 ? e.height = r.readFloat() : 5 === t1 ? e.mask_type = r.readVarint() : 6 === t1 ? e.mask_idx = r.readVarint() : 7 === t1 && e.children.push(Yy(r, r.readVarint() + r.pos));
        }
        class og {
            static calculate(t1, e) {
                const r = new Map, n = new Map;
                if (0 === Object.keys(t1).length) return r;
                e.forEach((t1)=>{
                    n.set(t1.name, t1.rgb_color || new Ie(0, 0, 0));
                });
                for (const [e, i] of Object.entries(t1))n.has(e) ? r.set(n.get(e).toStringPremultipliedAlpha(), i) : console.warn(`Ignoring unknown image variable "${e}"`);
                return r;
            }
        }
        function lg(t1, e = 255, r) {
            const n = e / 255, i = t1.toStringPremultipliedAlpha(), a = r.has(i) ? r.get(i).clone() : t1.clone();
            return a.a = n, a.toString();
        }
        function ug(t1, e) {
            if (!Ct()) {
                const r = document.createElement("canvas");
                return r.width = t1, r.height = e, r;
            }
            return new OffscreenCanvas(t1, e);
        }
        function cg(t1, e) {
            const r = og.calculate(e.params, t1.metadata ? t1.metadata.variables : []), n = t1.usvg_tree, i = n.width, a = n.height, s = e.transform ? e.transform : new DOMMatrix, o = Math.max(1, Math.round(i * s.a)), l = Math.max(1, Math.round(a * s.d)), u = new DOMMatrix([
                o / i,
                0,
                0,
                l / a,
                0,
                0
            ]), c = ug(o, l).getContext("2d");
            return hg(c, u, n, n, r), c.getImageData(0, 0, o, l);
        }
        function hg(t1, e, r, n, i) {
            for (const a of n.children)pg(t1, e, r, a, i);
        }
        function pg(t1, e, r, n, i) {
            n.group ? (t1.save(), function(t1, e, r, n, i) {
                const a = null != n.mask_idx ? r.masks[n.mask_idx] : null, s = null != n.clip_path_idx ? r.clip_paths[n.clip_path_idx] : null;
                if (n.transform && (e = vg(n.transform).preMultiplySelf(e)), !function(t1, e, r) {
                    return 255 !== t1.opacity || e || r;
                }(n, null != s, null != a)) return void hg(t1, e, r, n, i);
                const o = ug(t1.canvas.width, t1.canvas.height), l = o.getContext("2d");
                s && gg(l, e, r, s), hg(l, e, r, n, i), a && xg(l, e, r, a, i), t1.globalAlpha = n.opacity / 255, t1.drawImage(o, 0, 0);
            }(t1, e, r, n.group, i), t1.restore()) : n.path && (t1.save(), function(t1, e, r, n, i) {
                const a = bg(n);
                t1.setTransform(e), n.paint_order === Ly.PAINT_ORDER_FILL_AND_STROKE ? (fg(t1, r, n, a, i), dg(t1, r, n, a, i)) : (dg(t1, r, n, a, i), fg(t1, r, n, a, i));
            }(t1, e, r, n.path, i), t1.restore());
        }
        function fg(t1, e, r, n, i) {
            const a = r.fill;
            if (!a) return;
            const s = a.opacity / 255;
            switch(a.paint){
                case "rgb_color":
                    t1.fillStyle = lg(a.rgb_color, a.opacity, i);
                    break;
                case "linear_gradient_idx":
                    t1.fillStyle = mg(t1, e.linear_gradients[a.linear_gradient_idx], s, i);
                    break;
                case "radial_gradient_idx":
                    t1.fillStyle = yg(t1, e.radial_gradients[a.radial_gradient_idx], s, i);
            }
            let o;
            switch(r.rule){
                case Vy.PATH_RULE_NON_ZERO:
                    o = "nonzero";
                    break;
                case Vy.PATH_RULE_EVEN_ODD:
                    o = "evenodd";
            }
            t1.fill(n, o);
        }
        function dg(t1, e, r, n, i) {
            const a = r.stroke;
            if (!a) return;
            t1.lineWidth = a.width, t1.miterLimit = a.miterlimit, t1.setLineDash(a.dasharray), t1.lineDashOffset = a.dashoffset;
            const s = a.opacity / 255;
            switch(a.paint){
                case "rgb_color":
                    t1.strokeStyle = lg(a.rgb_color, a.opacity, i);
                    break;
                case "linear_gradient_idx":
                    t1.strokeStyle = mg(t1, e.linear_gradients[a.linear_gradient_idx], s, i);
                    break;
                case "radial_gradient_idx":
                    t1.strokeStyle = yg(t1, e.radial_gradients[a.radial_gradient_idx], s, i);
            }
            switch(a.linejoin){
                case Dy.LINE_JOIN_MITER_CLIP:
                case Dy.LINE_JOIN_MITER:
                    t1.lineJoin = "miter";
                    break;
                case Dy.LINE_JOIN_ROUND:
                    t1.lineJoin = "round";
                    break;
                case Dy.LINE_JOIN_BEVEL:
                    t1.lineJoin = "bevel";
            }
            switch(a.linecap){
                case Cy.LINE_CAP_BUTT:
                    t1.lineCap = "butt";
                    break;
                case Cy.LINE_CAP_ROUND:
                    t1.lineCap = "round";
                    break;
                case Cy.LINE_CAP_SQUARE:
                    t1.lineCap = "square";
            }
            t1.stroke(n);
        }
        function mg(t1, e, r, n) {
            if (1 === e.stops.length) {
                const t1 = e.stops[0];
                return lg(t1.rgb_color, t1.opacity * r, n);
            }
            const i = vg(e.transform), { x1: a, y1: s, x2: o, y2: l } = e, u = i.transformPoint(new DOMPoint(a, s)), c = i.transformPoint(new DOMPoint(o, l)), h = t1.createLinearGradient(u.x, u.y, c.x, c.y);
            for (const t1 of e.stops)h.addColorStop(t1.offset, lg(t1.rgb_color, t1.opacity * r, n));
            return h;
        }
        function yg(t1, e, r, n) {
            if (1 === e.stops.length) {
                const t1 = e.stops[0];
                return lg(t1.rgb_color, t1.opacity * r, n);
            }
            const i = vg(e.transform), { fx: a, fy: s, cx: o, cy: l } = e, u = i.transformPoint(new DOMPoint(a, s)), c = i.transformPoint(new DOMPoint(o, l)), h = t1.createRadialGradient(u.x, u.y, 0, c.x, c.y, e.r * ((i.a + i.d) / 2));
            for (const t1 of e.stops)h.addColorStop(t1.offset, lg(t1.rgb_color, t1.opacity * r, n));
            return h;
        }
        function gg(t1, e, r, n) {
            const i = vg(n.transform).preMultiplySelf(e), a = null != n.clip_path_idx ? r.clip_paths[n.clip_path_idx] : null;
            a && gg(t1, i, r, a);
            const s = new Path2D;
            let o;
            function l(t1, e) {
                if (t1.path) {
                    const r = t1.path;
                    s.addPath(bg(r), e), r.rule === Vy.PATH_RULE_EVEN_ODD && (o = "evenodd");
                } else if (t1.group) {
                    const r = t1.group.transform ? vg(t1.group.transform).preMultiplySelf(e) : e;
                    for (const e of t1.group.children)l(e, r);
                }
            }
            for (const t1 of n.children)l(t1, i);
            t1.clip(s, o);
        }
        function xg(t1, e, r, n, i) {
            if (0 === n.children.length) return;
            const a = null != n.mask_idx ? r.masks[n.mask_idx] : null;
            a && xg(t1, e, r, a, i);
            const s = t1.canvas.width, o = t1.canvas.height, l = ug(s, o), u = l.getContext("2d"), c = n.width, h = n.height, p = n.left, f = n.top, d = new Path2D, m = new Path2D;
            m.rect(p, f, c, h), d.addPath(m, e), u.clip(d);
            for (const t1 of n.children)pg(u, e, r, t1, i);
            const y = u.getImageData(0, 0, s, o), g = y.data;
            if (n.mask_type === Fy.MASK_TYPE_LUMINANCE) for(let t1 = 0; t1 < g.length; t1 += 4)g[t1 + 3] = g[t1 + 3] / 255 * (.2126 * g[t1] + .7152 * g[t1 + 1] + .0722 * g[t1 + 2]);
            u.putImageData(y, 0, 0), t1.globalCompositeOperation = "destination-in", t1.drawImage(l, 0, 0);
        }
        function vg(t1) {
            return t1 ? new DOMMatrix([
                t1.sx,
                t1.ky,
                t1.kx,
                t1.sy,
                t1.tx,
                t1.ty
            ]) : new DOMMatrix;
        }
        function bg(t1) {
            const e = new Path2D, r = t1.step;
            let n = t1.diffs[0] * r, i = t1.diffs[1] * r;
            e.moveTo(n, i);
            for(let a = 0, s = 2; a < t1.commands.length; a++)switch(t1.commands[a]){
                case Ry.PATH_COMMAND_MOVE:
                    n += t1.diffs[s++] * r, i += t1.diffs[s++] * r, e.moveTo(n, i);
                    break;
                case Ry.PATH_COMMAND_LINE:
                    n += t1.diffs[s++] * r, i += t1.diffs[s++] * r, e.lineTo(n, i);
                    break;
                case Ry.PATH_COMMAND_QUAD:
                    {
                        const a = n + t1.diffs[s++] * r, o = i + t1.diffs[s++] * r;
                        n = a + t1.diffs[s++] * r, i = o + t1.diffs[s++] * r, e.quadraticCurveTo(a, o, n, i);
                        break;
                    }
                case Ry.PATH_COMMAND_CUBIC:
                    {
                        const a = n + t1.diffs[s++] * r, o = i + t1.diffs[s++] * r, l = a + t1.diffs[s++] * r, u = o + t1.diffs[s++] * r;
                        n = l + t1.diffs[s++] * r, i = u + t1.diffs[s++] * r, e.bezierCurveTo(a, o, l, u, n, i);
                        break;
                    }
                case Ry.PATH_COMMAND_CLOSE:
                    e.closePath();
            }
            return e;
        }
        class _g {
            constructor(t1){
                this.capacity = t1, this.cache = new Map;
            }
            get(t1) {
                if (!this.cache.has(t1)) return;
                const e = this.cache.get(t1);
                return this.cache.delete(t1), this.cache.set(t1, e), e;
            }
            put(t1, e) {
                this.cache.has(t1) ? this.cache.delete(t1) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(t1, e);
            }
            delete(t1) {
                this.cache.delete(t1);
            }
        }
        class wg {
            constructor(){
                this.cacheMap = new Map, this.cacheDependenciesMap = new Map;
            }
            static _getImage(t1) {
                return new sc(t1, t1.data);
            }
            getFromCache(t1, e, r) {
                return this.cacheMap.has(r) || this.cacheMap.set(r, new _g(150)), this.cacheMap.get(r).get(us(t1.serialize(), e));
            }
            setInCache(t1, e, r, n) {
                this.cacheDependenciesMap.has(n) || this.cacheDependenciesMap.set(n, new Map), this.cacheMap.has(n) || this.cacheMap.set(n, new _g(150));
                const i = this.cacheDependenciesMap.get(n);
                i.get(us(t1.id, r)) || i.set(us(t1.id, r), new Set);
                const a = this.cacheMap.get(n), s = t1.serialize();
                i.get(us(t1.id, r)).add(s), a.put(us(t1.serialize(), r), e);
            }
            removeImagesFromCacheByIds(t1, e, r = "") {
                if (!this.cacheMap.has(r) || !this.cacheDependenciesMap.has(r)) return;
                const n = this.cacheMap.get(r), i = this.cacheDependenciesMap.get(r);
                for (const r of t1)if (i.has(us(r, e))) {
                    for (const t1 of i.get(us(r, e)))n.delete(t1);
                    i.delete(us(r, e));
                }
            }
            rasterize(t1, e, r, n, i = cg) {
                const a = this.getFromCache(t1, r, n);
                if (a) return a.clone();
                const s = i(e.icon, t1.options), o = wg._getImage(s);
                return this.setInCache(t1, o, r, n), o.clone();
            }
        }
        class Mg {
            constructor(t1){
                this.size = t1, this.minimums = [], this.maximums = [], this.leaves = [];
            }
            getElevation(t1, e) {
                const r = this.toIdx(t1, e);
                return {
                    min: this.minimums[r],
                    max: this.maximums[r]
                };
            }
            isLeaf(t1, e) {
                return this.leaves[this.toIdx(t1, e)];
            }
            toIdx(t1, e) {
                return e * this.size + t1;
            }
        }
        function Ag(t1, e, r, n) {
            let i = 0, a = Number.MAX_VALUE;
            for(let s = 0; s < 3; s++)if (Math.abs(n[s]) < 1e-15) {
                if (r[s] < t1[s] || r[s] > e[s]) return null;
            } else {
                const o = 1 / n[s];
                let l = (t1[s] - r[s]) * o, u = (e[s] - r[s]) * o;
                if (l > u) {
                    const t1 = l;
                    l = u, u = t1;
                }
                if (l > i && (i = l), u < a && (a = u), i > a) return null;
            }
            return i;
        }
        function Sg(t1, e, r, n, i, a, s, o, l, u, c) {
            const h = n - t1, p = i - e, f = a - r, d = s - t1, m = o - e, y = l - r, g = c[1] * y - c[2] * m, x = c[2] * d - c[0] * y, v = c[0] * m - c[1] * d, b = h * g + p * x + f * v;
            if (Math.abs(b) < 1e-15) return null;
            const _ = 1 / b, w = u[0] - t1, M = u[1] - e, A = u[2] - r, S = (w * g + M * x + A * v) * _;
            if (S < 0 || S > 1) return null;
            const I = M * f - A * p, P = A * h - w * f, z = w * p - M * h, E = (c[0] * I + c[1] * P + c[2] * z) * _;
            return E < 0 || S + E > 1 ? null : (d * I + m * P + y * z) * _;
        }
        function Ig(t1, e, r) {
            return (t1 - e) / (r - e);
        }
        function Pg(t1, e, r, n, i, a, s, o, l) {
            const u = 1 << r, c = a - n, h = s - i, p = (t1 + 1) / u * c + n, f = (e + 0) / u * h + i, d = (e + 1) / u * h + i;
            o[0] = (t1 + 0) / u * c + n, o[1] = f, l[0] = p, l[1] = d;
        }
        class zg {
            constructor(t1){
                if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t1, this._siblingOffset = [
                    [
                        0,
                        0
                    ],
                    [
                        1,
                        0
                    ],
                    [
                        0,
                        1
                    ],
                    [
                        1,
                        1
                    ]
                ], !this.dem) return;
                const e = function(t1) {
                    const e = Math.ceil(Math.log2(t1.dim / 8)), r = [];
                    let n = Math.ceil(Math.pow(2, e));
                    const i = 1 / n, a = (t1, e, r, n, i)=>{
                        const a = n ? 1 : 0, s = (t1 + 1) * r - a, o = e * r, l = (e + 1) * r - a;
                        i[0] = t1 * r, i[1] = o, i[2] = s, i[3] = l;
                    };
                    let s = new Mg(n);
                    const o = [];
                    for(let e = 0; e < n * n; e++){
                        a(e % n, Math.floor(e / n), i, !1, o);
                        const r = kg(o[0], o[1], t1), l = kg(o[2], o[1], t1), u = kg(o[2], o[3], t1), c = kg(o[0], o[3], t1);
                        s.minimums.push(Math.min(r, l, u, c)), s.maximums.push(Math.max(r, l, u, c)), s.leaves.push(1);
                    }
                    for(r.push(s), n /= 2; n >= 1; n /= 2){
                        const t1 = r[r.length - 1];
                        s = new Mg(n);
                        for(let e = 0; e < n * n; e++){
                            a(e % n, Math.floor(e / n), 2, !0, o);
                            const r = t1.getElevation(o[0], o[1]), i = t1.getElevation(o[2], o[1]), l = t1.getElevation(o[2], o[3]), u = t1.getElevation(o[0], o[3]), c = t1.isLeaf(o[0], o[1]), h = t1.isLeaf(o[2], o[1]), p = t1.isLeaf(o[2], o[3]), f = t1.isLeaf(o[0], o[3]), d = Math.min(r.min, i.min, l.min, u.min), m = Math.max(r.max, i.max, l.max, u.max), y = c && h && p && f;
                            s.maximums.push(m), s.minimums.push(d), s.leaves.push(m - d <= 5 && y ? 1 : 0);
                        }
                        r.push(s);
                    }
                    return r;
                }(this.dem), r = e.length - 1, n = e[r];
                this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e, 0, 0, r, 0);
            }
            raycastRoot(t1, e, r, n, i, a, s = 1) {
                return Ag([
                    t1,
                    e,
                    -100
                ], [
                    r,
                    n,
                    this.maximums[0] * s
                ], i, a);
            }
            raycast(t1, e, r, n, i, a, s = 1) {
                if (!this.nodeCount) return null;
                const o = this.raycastRoot(t1, e, r, n, i, a, s);
                if (null == o) return null;
                const l = [], u = [], c = [], h = [], p = [
                    {
                        idx: 0,
                        t: o,
                        nodex: 0,
                        nodey: 0,
                        depth: 0
                    }
                ];
                for(; p.length > 0;){
                    const { idx: o, t: f, nodex: d, nodey: m, depth: y } = p.pop();
                    if (this.leaves[o]) {
                        Pg(d, m, y, t1, e, r, n, c, h);
                        const o = 1 << y, l = (d + 0) / o, u = (d + 1) / o, p = (m + 0) / o, g = (m + 1) / o, x = kg(l, p, this.dem) * s, v = kg(u, p, this.dem) * s, b = kg(u, g, this.dem) * s, _ = kg(l, g, this.dem) * s, w = Sg(c[0], c[1], x, h[0], c[1], v, h[0], h[1], b, i, a), M = Sg(h[0], h[1], b, c[0], h[1], _, c[0], c[1], x, i, a), A = Math.min(null !== w ? w : Number.MAX_VALUE, null !== M ? M : Number.MAX_VALUE);
                        if (A !== Number.MAX_VALUE) return A;
                        {
                            const t1 = O.vec3.scaleAndAdd([], i, a, f);
                            if (Eg(x, v, _, b, Ig(t1[0], c[0], h[0]), Ig(t1[1], c[1], h[1])) >= t1[2]) return f;
                        }
                        continue;
                    }
                    let g = 0;
                    for(let p = 0; p < this._siblingOffset.length; p++){
                        Pg((d << 1) + this._siblingOffset[p][0], (m << 1) + this._siblingOffset[p][1], y + 1, t1, e, r, n, c, h), c[2] = -100, h[2] = this.maximums[this.childOffsets[o] + p] * s;
                        const f = Ag(c, h, i, a);
                        if (null != f) {
                            const t1 = f;
                            l[p] = t1;
                            let e = !1;
                            for(let r = 0; r < g && !e; r++)t1 >= l[u[r]] && (u.splice(r, 0, p), e = !0);
                            e || (u[g] = p), g++;
                        }
                    }
                    for(let t1 = 0; t1 < g; t1++){
                        const e = u[t1];
                        p.push({
                            idx: this.childOffsets[o] + e,
                            t: l[e],
                            nodex: (d << 1) + this._siblingOffset[e][0],
                            nodey: (m << 1) + this._siblingOffset[e][1],
                            depth: y + 1
                        });
                    }
                }
                return null;
            }
            _addNode(t1, e, r) {
                return this.minimums.push(t1), this.maximums.push(e), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;
            }
            _construct(t1, e, r, n, i) {
                if (1 === t1[n].isLeaf(e, r)) return;
                this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);
                const a = n - 1, s = t1[a];
                let o = 0, l = 0;
                for(let t1 = 0; t1 < this._siblingOffset.length; t1++){
                    const n = 2 * e + this._siblingOffset[t1][0], i = 2 * r + this._siblingOffset[t1][1], a = s.getElevation(n, i), u = s.isLeaf(n, i), c = this._addNode(a.min, a.max, u);
                    u && (o |= 1 << t1), l || (l = c);
                }
                for(let n = 0; n < this._siblingOffset.length; n++)o & 1 << n || this._construct(t1, 2 * e + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], a, l + n);
            }
        }
        function Eg(t1, e, r, n, i, a) {
            return ze(ze(t1, r, a), ze(e, n, a), i);
        }
        function kg(t1, e, r) {
            const n = r.dim, i = Q(t1 * n - .5, 0, n - 1), a = Q(e * n - .5, 0, n - 1), s = Math.floor(i), o = Math.floor(a), l = Math.min(s + 1, n - 1), u = Math.min(o + 1, n - 1);
            return Eg(r.get(s, o), r.get(l, o), r.get(s, u), r.get(l, u), i - s, a - o);
        }
        const Tg = {
            mapbox: [
                6553.6,
                25.6,
                .1,
                1e4
            ],
            terrarium: [
                256,
                1,
                1 / 256,
                32768
            ]
        };
        function Bg(t1, e, r) {
            return (256 * t1 * 256 + 256 * e + r) / 10 - 1e4;
        }
        function Vg(t1, e, r) {
            return 256 * t1 + e + r / 256 - 32768;
        }
        class Cg {
            get tree() {
                return this._tree || this._buildQuadTree(), this._tree;
            }
            constructor(t1, e, r, n = !1){
                if (this.uid = t1, e.height !== e.width) throw new RangeError("DEM tiles must be square");
                if (r && "mapbox" !== r && "terrarium" !== r) return void ft(`"${r}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
                this.stride = e.height;
                const i = this.dim = e.height - 2, a = new Uint32Array(e.data.buffer);
                if (this.pixels = new Uint8Array(e.data.buffer), this.floatView = new Float32Array(e.data.buffer), this.borderReady = n, this._modifiedForSources = {}, !n) {
                    for(let t1 = 0; t1 < i; t1++)a[this._idx(-1, t1)] = a[this._idx(0, t1)], a[this._idx(i, t1)] = a[this._idx(i - 1, t1)], a[this._idx(t1, -1)] = a[this._idx(t1, 0)], a[this._idx(t1, i)] = a[this._idx(t1, i - 1)];
                    a[this._idx(-1, -1)] = a[this._idx(0, 0)], a[this._idx(i, -1)] = a[this._idx(i - 1, 0)], a[this._idx(-1, i)] = a[this._idx(0, i - 1)], a[this._idx(i, i)] = a[this._idx(i - 1, i - 1)];
                }
                const s = "terrarium" === r ? Vg : Bg;
                for(let t1 = 0; t1 < a.length; ++t1){
                    const e = 4 * t1;
                    this.floatView[t1] = s(this.pixels[e], this.pixels[e + 1], this.pixels[e + 2]);
                }
                this._timestamp = Dt.now();
            }
            _buildQuadTree() {
                this._tree = new zg(this);
            }
            get(t1, e, r = !1) {
                r && (t1 = Q(t1, -1, this.dim), e = Q(e, -1, this.dim));
                const n = this._idx(t1, e);
                return this.floatView[n];
            }
            set(t1, e, r) {
                const n = this._idx(t1, e), i = this.floatView[n];
                return this.floatView[n] = r, r - i;
            }
            static getUnpackVector(t1) {
                return Tg[t1];
            }
            _idx(t1, e) {
                if (t1 < -1 || t1 >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
                return (e + 1) * this.stride + (t1 + 1);
            }
            static pack(t1, e) {
                const r = [
                    0,
                    0,
                    0,
                    0
                ], n = Cg.getUnpackVector(e);
                let i = Math.floor((t1 + n[3]) / n[2]);
                return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;
            }
            getPixels() {
                return new oc({
                    width: this.stride,
                    height: this.stride
                }, this.pixels);
            }
            backfillBorder(t1, e, r) {
                if (this.dim !== t1.dim) throw new Error("dem dimension mismatch");
                let n = e * this.dim, i = e * this.dim + this.dim, a = r * this.dim, s = r * this.dim + this.dim;
                switch(e){
                    case -1:
                        n = i - 1;
                        break;
                    case 1:
                        i = n + 1;
                }
                switch(r){
                    case -1:
                        a = s - 1;
                        break;
                    case 1:
                        s = a + 1;
                }
                const o = -e * this.dim, l = -r * this.dim;
                for(let e = a; e < s; e++)for(let r = n; r < i; r++){
                    const n = 4 * this._idx(r, e), i = 4 * this._idx(r + o, e + l);
                    this.pixels[n + 0] = t1.pixels[i + 0], this.pixels[n + 1] = t1.pixels[i + 1], this.pixels[n + 2] = t1.pixels[i + 2], this.pixels[n + 3] = t1.pixels[i + 3];
                }
            }
            onDeserialize() {
                this._tree && (this._tree.dem = this);
            }
        }
        function Dg(t1, e, r) {
            1 === t1 ? e.headerLength = r.readFixed32() : 2 === t1 ? e.x = r.readVarint() : 3 === t1 ? e.y = r.readVarint() : 4 === t1 ? e.z = r.readVarint() : 5 === t1 && e.layers.push(function(t1, e) {
                return t1.readFields(Ng, {
                    version: 0,
                    name: "",
                    units: "",
                    tileSize: 0,
                    buffer: 0,
                    pixelFormat: 0,
                    dataIndex: []
                }, e);
            }(r, r.readVarint() + r.pos));
        }
        function Lg(t1, e, r) {
            1 === t1 ? (e.delta_filter = function(t1, e) {
                return t1.readFields(Rg, {
                    blockSize: 0
                }, e);
            }(r, r.readVarint() + r.pos), e.filter = "delta_filter") : 2 === t1 ? (r.readVarint(), e.filter = "zigzag_filter") : 3 === t1 ? (r.readVarint(), e.filter = "bitshuffle_filter") : 4 === t1 && (r.readVarint(), e.filter = "byteshuffle_filter");
        }
        function Rg(t1, e, r) {
            1 === t1 && (e.blockSize = r.readVarint());
        }
        function Fg(t1, e, r) {
            1 === t1 ? (r.readVarint(), e.codec = "gzip_data") : 2 === t1 ? (r.readVarint(), e.codec = "jpeg_image") : 3 === t1 ? (r.readVarint(), e.codec = "webp_image") : 4 === t1 && (r.readVarint(), e.codec = "png_image");
        }
        function Og(t1, e, r) {
            let n = 0, i = 0;
            1 === t1 ? e.firstByte = r.readFixed64() : 2 === t1 ? e.lastByte = r.readFixed64() : 3 === t1 ? e.filters.push(function(t1, e) {
                return t1.readFields(Lg, {}, e);
            }(r, r.readVarint() + r.pos)) : 4 === t1 ? e.codec = function(t1, e) {
                return t1.readFields(Fg, {}, e);
            }(r, r.readVarint() + r.pos) : 5 === t1 ? i = r.readFloat() : 6 === t1 ? n = r.readFloat() : 7 === t1 ? e.bands.push(r.readString()) : 8 === t1 ? e.offset = r.readDouble() : 9 === t1 && (e.scale = r.readDouble()), 0 === e.offset && (e.offset = i), 0 === e.scale && (e.scale = n);
        }
        function Ng(t1, e, r) {
            1 === t1 ? e.version = r.readVarint() : 2 === t1 ? e.name = r.readString() : 3 === t1 ? e.units = r.readString() : 4 === t1 ? e.tileSize = r.readVarint() : 5 === t1 ? e.buffer = r.readVarint() : 6 === t1 ? e.pixelFormat = r.readVarint() : 7 === t1 && e.dataIndex.push(function(t1, e) {
                return t1.readFields(Og, {
                    firstByte: 0,
                    lastByte: 0,
                    filters: [],
                    codec: null,
                    offset: 0,
                    scale: 0,
                    bands: []
                }, e);
            }(r, r.readVarint() + r.pos));
        }
        function Ug(t1, e, r) {
            if (2 === t1) !function(t1, e, r) {
                t1.readFields(jg, r, e);
            }(r, r.readVarint() + r.pos, e);
            else if (3 === t1) throw new Error("Not implemented");
        }
        function jg(t1, e, r) {
            if (1 === t1) {
                let t1 = 0;
                const n = r.readVarint() + r.pos;
                for(; r.pos < n;)e[t1++] = r.readVarint();
            }
        }
        function qg(t1, e) {
            if (4 !== e.length) throw new Error(`Expected data of dimension 4 but got ${e.length}.`);
            let r = e[3];
            for(let n = 2; n >= 1; n--){
                const i = 1 === n ? 1 : 0, a = 2 === n ? 1 : 0;
                for(let n = 0; n < e[0]; n++){
                    const s = e[1] * n;
                    for(let n = i; n < e[1]; n++){
                        const i = e[2] * (n + s);
                        for(let n = a; n < e[2]; n++){
                            const a = e[3] * (n + i);
                            for(let n = 0; n < e[3]; n++){
                                const e = a + n;
                                t1[e] += t1[e - r];
                            }
                        }
                    }
                }
                r *= e[n];
            }
            return t1;
        }
        function $g(t1) {
            for(let e = 0, r = t1.length; e < r; e++)t1[e] = t1[e] >>> 1 ^ -(1 & t1[e]);
            return t1;
        }
        function Gg(t1, e) {
            switch(e){
                case "uint32":
                    return t1;
                case "uint16":
                    for(let e = 0; e < t1.length; e += 2){
                        const r = t1[e], n = t1[e + 1];
                        t1[e] = (240 & r) >> 4 | (61440 & r) >> 8 | (240 & n) << 4 | 61440 & n, t1[e + 1] = 15 & r | (3840 & r) >> 4 | (15 & n) << 8 | (3840 & n) << 4;
                    }
                    return t1;
                case "uint8":
                    for(let e = 0; e < t1.length; e += 4){
                        const r = t1[e], n = t1[e + 1], i = t1[e + 2], a = t1[e + 3];
                        t1[e + 0] = (192 & r) >> 6 | (192 & n) >> 4 | (192 & i) >> 2 | 192 & a, t1[e + 1] = (48 & r) >> 4 | (48 & n) >> 2 | 48 & i | (48 & a) << 2, t1[e + 2] = (12 & r) >> 2 | 12 & n | (12 & i) << 2 | (12 & a) << 4, t1[e + 3] = 3 & r | (3 & n) << 2 | (3 & i) << 4 | (3 & a) << 6;
                    }
                    return t1;
                default:
                    throw new Error(`Invalid pixel format, "${e}"`);
            }
        }
        oa(Cg, "DEMData"), oa(zg, "DemMinMaxQuadTree", {
            omit: [
                "dem"
            ]
        });
        var Yg = Uint8Array, Xg = Uint16Array, Zg = Int32Array, Hg = new Yg([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            4,
            4,
            4,
            4,
            5,
            5,
            5,
            5,
            0,
            0,
            0,
            0
        ]), Wg = new Yg([
            0,
            0,
            0,
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            4,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            8,
            8,
            9,
            9,
            10,
            10,
            11,
            11,
            12,
            12,
            13,
            13,
            0,
            0
        ]), Kg = new Yg([
            16,
            17,
            18,
            0,
            8,
            7,
            9,
            6,
            10,
            5,
            11,
            4,
            12,
            3,
            13,
            2,
            14,
            1,
            15
        ]), Jg = function(t1, e) {
            for(var r = new Xg(31), n = 0; n < 31; ++n)r[n] = e += 1 << t1[n - 1];
            var i = new Zg(r[30]);
            for(n = 1; n < 30; ++n)for(var a = r[n]; a < r[n + 1]; ++a)i[a] = a - r[n] << 5 | n;
            return {
                b: r,
                r: i
            };
        }, Qg = Jg(Hg, 2), tx = Qg.b, ex = Qg.r;
        tx[28] = 258, ex[258] = 28;
        for(var rx = Jg(Wg, 0).b, nx = new Xg(32768), ix = 0; ix < 32768; ++ix){
            var ax = (43690 & ix) >> 1 | (21845 & ix) << 1;
            nx[ix] = ((65280 & (ax = (61680 & (ax = (52428 & ax) >> 2 | (13107 & ax) << 2)) >> 4 | (3855 & ax) << 4)) >> 8 | (255 & ax) << 8) >> 1;
        }
        var sx = function(t1, e, r) {
            for(var n = t1.length, i = 0, a = new Xg(e); i < n; ++i)t1[i] && ++a[t1[i] - 1];
            var s, o = new Xg(e);
            for(i = 1; i < e; ++i)o[i] = o[i - 1] + a[i - 1] << 1;
            s = new Xg(1 << e);
            var l = 15 - e;
            for(i = 0; i < n; ++i)if (t1[i]) for(var u = i << 4 | t1[i], c = e - t1[i], h = o[t1[i] - 1]++ << c, p = h | (1 << c) - 1; h <= p; ++h)s[nx[h] >> l] = u;
            return s;
        }, ox = new Yg(288);
        for(ix = 0; ix < 144; ++ix)ox[ix] = 8;
        for(ix = 144; ix < 256; ++ix)ox[ix] = 9;
        for(ix = 256; ix < 280; ++ix)ox[ix] = 7;
        for(ix = 280; ix < 288; ++ix)ox[ix] = 8;
        var lx = new Yg(32);
        for(ix = 0; ix < 32; ++ix)lx[ix] = 5;
        var ux = sx(ox, 9), cx = sx(lx, 5), hx = function(t1) {
            for(var e = t1[0], r = 1; r < t1.length; ++r)t1[r] > e && (e = t1[r]);
            return e;
        }, px = function(t1, e, r) {
            var n = e / 8 | 0;
            return (t1[n] | t1[n + 1] << 8) >> (7 & e) & r;
        }, fx = function(t1, e) {
            var r = e / 8 | 0;
            return (t1[r] | t1[r + 1] << 8 | t1[r + 2] << 16) >> (7 & e);
        }, dx = [
            "unexpected EOF",
            "invalid block type",
            "invalid length/literal",
            "invalid distance",
            "stream finished",
            "no stream handler",
            ,
            "no callback",
            "invalid UTF-8 data",
            "extra field too long",
            "date not in range 1980-2099",
            "filename too long",
            "stream finishing",
            "invalid zip data"
        ], mx = function(t1, e, r) {
            var n = new Error(e || dx[t1]);
            if (n.code = t1, Error.captureStackTrace && Error.captureStackTrace(n, mx), !r) throw n;
            return n;
        }, yx = new Yg(0), gx = "undefined" != typeof TextDecoder && new TextDecoder;
        try {
            gx.decode(yx, {
                stream: !0
            });
        } catch (t1) {}
        const xx = {
            gzip_data: "gzip"
        };
        class vx extends Error {
            constructor(t1){
                super(t1), this.name = "MRTError";
            }
        }
        const bx = {
            0: "uint32",
            1: "uint32",
            2: "uint16",
            3: "uint8"
        }, _x = {
            uint32: 1,
            uint16: 2,
            uint8: 4
        }, wx = {
            uint32: Uint32Array,
            uint16: Uint16Array,
            uint8: Uint8Array
        };
        let Mx;
        class Ax {
            constructor(t1 = 5){
                this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t1;
            }
            getLayer(t1) {
                const e = this.layers[t1];
                if (!e) throw new vx(`Layer '${t1}' not found`);
                return e;
            }
            getHeaderLength(t1) {
                const e = new Uint8Array(t1), r = new DataView(t1);
                if (13 !== e[0]) throw new vx("File is not a valid MRT.");
                return r.getUint32(1, !0);
            }
            parseHeader(t1) {
                const e = new Uint8Array(t1), r = this.getHeaderLength(t1);
                if (e.length < r) throw new vx(`Expected header with length >= ${r} but got buffer of length ${e.length}`);
                const n = function(t1, e) {
                    return t1.readFields(Dg, {
                        headerLength: 0,
                        x: 0,
                        y: 0,
                        z: 0,
                        layers: []
                    }, void 0);
                }(new Mx(e.subarray(0, r)));
                if (!isNaN(this.x) && (this.x !== n.x || this.y !== n.y || this.z !== n.z)) throw new vx(`Invalid attempt to parse header ${n.z}/${n.x}/${n.y} for tile ${this.z}/${this.x}/${this.y}`);
                this.x = n.x, this.y = n.y, this.z = n.z;
                for (const t1 of n.layers)this.layers[t1.name] = new Sx(t1, {
                    cacheSize: this._cacheSize
                });
                return this;
            }
            createDecodingTask(t1) {
                const e = [], r = this.getLayer(t1.layerName);
                for (let n of t1.blockIndices){
                    const i = r.dataIndex[n], a = i.firstByte - t1.firstByte, s = i.lastByte - t1.firstByte;
                    if (r._blocksInProgress.has(n)) continue;
                    const o = {
                        layerName: r.name,
                        firstByte: a,
                        lastByte: s,
                        pixelFormat: r.pixelFormat,
                        blockIndex: n,
                        blockShape: [
                            i.bands.length
                        ].concat(r.bandShape),
                        buffer: r.buffer,
                        codec: i.codec.codec,
                        filters: i.filters.map((t1)=>t1.filter)
                    };
                    r._blocksInProgress.add(n), e.push(o);
                }
                return new Ix(e, ()=>{
                    e.forEach((t1)=>r._blocksInProgress.delete(t1.blockIndex));
                }, (t1, n)=>{
                    if (e.forEach((t1)=>r._blocksInProgress.delete(t1.blockIndex)), t1) throw t1;
                    n.forEach((t1)=>{
                        this.getLayer(t1.layerName).processDecodedData(t1);
                    });
                });
            }
        }
        class Sx {
            constructor({ version: t1, name: e, units: r, tileSize: n, pixelFormat: i, buffer: a, dataIndex: s }, o){
                if (this.version = t1, 1 !== this.version) throw new vx(`Cannot parse raster layer encoded with MRT version ${t1}`);
                this.name = e, this.units = r, this.tileSize = n, this.buffer = a, this.pixelFormat = bx[i], this.dataIndex = s, this.bandShape = [
                    n + 2 * a,
                    n + 2 * a,
                    _x[this.pixelFormat]
                ], this._decodedBlocks = new _g(o ? o.cacheSize : 5), this._blocksInProgress = new Set;
            }
            get dimension() {
                return _x[this.pixelFormat];
            }
            get cacheSize() {
                return this._decodedBlocks.capacity;
            }
            getBandList() {
                return this.dataIndex.map(({ bands: t1 })=>t1).flat();
            }
            processDecodedData(t1) {
                const e = t1.blockIndex.toString();
                this._decodedBlocks.get(e) || this._decodedBlocks.put(e, t1.data);
            }
            getBlockForBand(t1) {
                let e = 0;
                switch(typeof t1){
                    case "string":
                        for (const [r, n] of this.dataIndex.entries()){
                            for (const [i, a] of n.bands.entries())if (a === t1) return {
                                bandIndex: e + i,
                                blockIndex: r,
                                blockBandIndex: i
                            };
                            e += n.bands.length;
                        }
                        break;
                    case "number":
                        for (const [r, n] of this.dataIndex.entries()){
                            if (t1 >= e && t1 < e + n.bands.length) return {
                                bandIndex: t1,
                                blockIndex: r,
                                blockBandIndex: t1 - e
                            };
                            e += n.bands.length;
                        }
                        break;
                    default:
                        throw new vx(`Invalid band \`${JSON.stringify(t1)}\`. Expected string or integer.`);
                }
                throw new vx(`Band not found: ${JSON.stringify(t1)}`);
            }
            getDataRange(t1) {
                let e = 1 / 0, r = -1 / 0;
                const n = [], i = new Set;
                for (const a of t1){
                    const { blockIndex: t1 } = this.getBlockForBand(a);
                    if (t1 < 0) throw new vx(`Invalid band: ${JSON.stringify(a)}`);
                    const s = this.dataIndex[t1];
                    n.includes(t1) || n.push(t1), i.add(t1), e = Math.min(e, s.firstByte), r = Math.max(r, s.lastByte);
                }
                if (i.size > this.cacheSize) throw new vx(`Number of blocks to decode (${i.size}) exceeds cache size (${this.cacheSize}).`);
                return {
                    layerName: this.name,
                    firstByte: e,
                    lastByte: r,
                    blockIndices: n
                };
            }
            hasBand(t1) {
                const { blockIndex: e } = this.getBlockForBand(t1);
                return e >= 0;
            }
            hasDataForBand(t1) {
                const { blockIndex: e } = this.getBlockForBand(t1);
                return e >= 0 && !!this._decodedBlocks.get(e.toString());
            }
            getBandView(t1) {
                const { blockIndex: e, blockBandIndex: r } = this.getBlockForBand(t1), n = this._decodedBlocks.get(e.toString());
                if (!n) throw new vx(`Data for band ${JSON.stringify(t1)} of layer "${this.name}" not decoded.`);
                const i = this.dataIndex[e], a = this.bandShape.reduce((t1, e)=>t1 * e, 1), s = r * a, o = n.subarray(s, s + a);
                return {
                    data: o,
                    bytes: new Uint8Array(o.buffer).subarray(o.byteOffset, o.byteOffset + o.byteLength),
                    tileSize: this.tileSize,
                    buffer: this.buffer,
                    pixelFormat: this.pixelFormat,
                    dimension: this.dimension,
                    offset: i.offset,
                    scale: i.scale
                };
            }
        }
        Ax.setPbf = function(t1) {
            Mx = t1;
        };
        class Ix {
            constructor(t1, e, r){
                this.tasks = t1, this._onCancel = e, this._onComplete = r, this._finalized = !1;
            }
            cancel() {
                this._finalized || (this._onCancel(), this._finalized = !0);
            }
            complete(t1, e) {
                this._finalized || (this._onComplete(t1, e), this._finalized = !0);
            }
        }
        Ax.performDecoding = function(t1, e) {
            const r = new Uint8Array(t1);
            return Promise.all(e.tasks.map((t1)=>{
                const { layerName: e, firstByte: n, lastByte: i, pixelFormat: a, blockShape: s, blockIndex: o, filters: l, codec: u } = t1, c = r.subarray(n, i + 1), h = new Uint32Array(s[0] * s[1] * s[2]);
                let p;
                if ("gzip_data" !== u) throw new vx(`Unhandled codec: ${u}`);
                return p = (function(t1, e) {
                    if (!globalThis.DecompressionStream && "gzip_data" === e) return Promise.resolve(((a = function(t1) {
                        31 == t1[0] && 139 == t1[1] && 8 == t1[2] || mx(6, "invalid gzip data");
                        var e = t1[3], r = 10;
                        4 & e && (r += 2 + (t1[10] | t1[11] << 8));
                        for(var n = (e >> 3 & 1) + (e >> 4 & 1); n > 0; n -= !t1[r++]);
                        return r + (2 & e);
                    }(i = t1)) + 8 > i.length && mx(6, "invalid gzip data"), function(t1, e, r, n) {
                        var i = t1.length;
                        if (!i || e.f && !e.l) return r || new Yg(0);
                        var a = !r, s = a || 2 != e.i, o = e.i;
                        a && (r = new Yg(3 * i));
                        var l, u, c = function(t1) {
                            var e = r.length;
                            if (t1 > e) {
                                var n = new Yg(Math.max(2 * e, t1));
                                n.set(r), r = n;
                            }
                        }, h = e.f || 0, p = e.p || 0, f = e.b || 0, d = e.l, m = e.d, y = e.m, g = e.n, x = 8 * i;
                        do {
                            if (!d) {
                                h = px(t1, p, 1);
                                var v = px(t1, p + 1, 3);
                                if (p += 3, !v) {
                                    var b = t1[(T = 4 + ((p + 7) / 8 | 0)) - 4] | t1[T - 3] << 8, _ = T + b;
                                    if (_ > i) {
                                        o && mx(0);
                                        break;
                                    }
                                    s && c(f + b), r.set(t1.subarray(T, _), f), e.b = f += b, e.p = p = 8 * _, e.f = h;
                                    continue;
                                }
                                if (1 == v) d = ux, m = cx, y = 9, g = 5;
                                else if (2 == v) {
                                    var w = px(t1, p, 31) + 257, M = px(t1, p + 10, 15) + 4, A = w + px(t1, p + 5, 31) + 1;
                                    p += 14;
                                    for(var S = new Yg(A), I = new Yg(19), P = 0; P < M; ++P)I[Kg[P]] = px(t1, p + 3 * P, 7);
                                    p += 3 * M;
                                    var z = hx(I), E = (1 << z) - 1, k = sx(I, z);
                                    for(P = 0; P < A;){
                                        var T, B = k[px(t1, p, E)];
                                        if (p += 15 & B, (T = B >> 4) < 16) S[P++] = T;
                                        else {
                                            var V = 0, C = 0;
                                            for(16 == T ? (C = 3 + px(t1, p, 3), p += 2, V = S[P - 1]) : 17 == T ? (C = 3 + px(t1, p, 7), p += 3) : 18 == T && (C = 11 + px(t1, p, 127), p += 7); C--;)S[P++] = V;
                                        }
                                    }
                                    var D = S.subarray(0, w), L = S.subarray(w);
                                    y = hx(D), g = hx(L), d = sx(D, y), m = sx(L, g);
                                } else mx(1);
                                if (p > x) {
                                    o && mx(0);
                                    break;
                                }
                            }
                            s && c(f + 131072);
                            for(var R = (1 << y) - 1, F = (1 << g) - 1, O = p;; O = p){
                                var N = (V = d[fx(t1, p) & R]) >> 4;
                                if ((p += 15 & V) > x) {
                                    o && mx(0);
                                    break;
                                }
                                if (V || mx(2), N < 256) r[f++] = N;
                                else {
                                    if (256 == N) {
                                        O = p, d = null;
                                        break;
                                    }
                                    var U = N - 254;
                                    N > 264 && (U = px(t1, p, (1 << ($ = Hg[P = N - 257])) - 1) + tx[P], p += $);
                                    var j = m[fx(t1, p) & F], q = j >> 4;
                                    if (j || mx(3), p += 15 & j, L = rx[q], q > 3) {
                                        var $ = Wg[q];
                                        L += fx(t1, p) & (1 << $) - 1, p += $;
                                    }
                                    if (p > x) {
                                        o && mx(0);
                                        break;
                                    }
                                    s && c(f + 131072);
                                    var G = f + U;
                                    if (f < L) {
                                        var Y = 0 - L, X = Math.min(L, G);
                                        for(Y + f < 0 && mx(3); f < X; ++f)r[f] = (void 0)[Y + f];
                                    }
                                    for(; f < G; ++f)r[f] = r[f - L];
                                }
                            }
                            e.l = d, e.p = O, e.b = f, e.f = h, d && (h = 1, e.m = y, e.d = m, e.n = g);
                        }while (!h)
                        return f != r.length && a ? (l = r, (null == (u = f) || u > l.length) && (u = l.length), new Yg(l.subarray(0, u))) : r.subarray(0, f);
                    }(i.subarray(a, -8), {
                        i: 2
                    }, new Yg(((r = i)[(n = r.length) - 4] | r[n - 3] << 8 | r[n - 2] << 16 | r[n - 1] << 24) >>> 0))));
                    var r, n, i, a;
                    const s = xx[e];
                    if (!s) throw new Error(`Unhandled codec: ${e}`);
                    const o = new globalThis.DecompressionStream(s);
                    return new Response(new Blob([
                        t1
                    ]).stream().pipeThrough(o)).arrayBuffer().then((t1)=>new Uint8Array(t1));
                })(c, u).then((t1)=>((function(t1, e) {
                        t1.readFields(Ug, e);
                    })(new Mx(t1), h), new (0, wx[a])(h.buffer))), p.then((t1)=>{
                    for(let e = l.length - 1; e >= 0; e--)switch(l[e]){
                        case "delta_filter":
                            qg(t1, s);
                            break;
                        case "zigzag_filter":
                            $g(t1);
                            break;
                        case "bitshuffle_filter":
                            Gg(t1, a);
                            break;
                        default:
                            throw new vx(`Unhandled filter "${l[e]}"`);
                    }
                    return {
                        layerName: e,
                        blockIndex: o,
                        data: t1
                    };
                }).catch((t1)=>{
                    throw t1;
                });
            }));
        }, oa(Ix, "MRTDecodingBatch", {
            omit: [
                "_onCancel",
                "_onComplete"
            ]
        });
        let Px, zx, Ex, kx, Tx, Bx = null;
        function Vx() {
            return gt() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : zx || St.DRACO_URL;
        }
        function Cx() {
            if (gt() && self.worker && self.worker.meshoptUrl) return self.worker.meshoptUrl;
            if (kx) return kx;
            const t1 = new Uint8Array([
                0,
                97,
                115,
                109,
                1,
                0,
                0,
                0,
                1,
                4,
                1,
                96,
                0,
                0,
                3,
                3,
                2,
                0,
                0,
                5,
                3,
                1,
                0,
                1,
                12,
                1,
                0,
                10,
                22,
                2,
                12,
                0,
                65,
                0,
                65,
                0,
                65,
                0,
                252,
                10,
                0,
                0,
                11,
                7,
                0,
                65,
                0,
                253,
                15,
                26,
                11
            ]);
            if ("object" != typeof WebAssembly) throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
            return kx = WebAssembly.validate(t1) ? St.MESHOPT_SIMD_URL : St.MESHOPT_URL, kx;
        }
        const Dx = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        }, Lx = {
            5120: "DT_INT8",
            5121: "DT_UINT8",
            5122: "DT_INT16",
            5123: "DT_UINT16",
            5125: "DT_UINT32",
            5126: "DT_FLOAT32"
        }, Rx = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        };
        function Fx(t1, e, r) {
            const n = r.json.bufferViews.length, i = r.buffers.length;
            e.bufferView = n, r.json.bufferViews[n] = {
                buffer: i,
                byteLength: t1.byteLength
            }, r.buffers[i] = t1;
        }
        const Ox = "KHR_draco_mesh_compression";
        function Nx(t1, e) {
            const r = t1.extensions && t1.extensions[Ox];
            if (!r) return;
            const n = new Ex.Decoder, i = Xx(e, r.bufferView), a = new Ex.Mesh;
            if (!n.DecodeArrayToMesh(i, i.byteLength, a)) throw new Error("Failed to decode Draco mesh");
            const s = e.json.accessors[t1.indices], o = Dx[s.componentType], l = s.count * o.BYTES_PER_ELEMENT, u = Ex._malloc(l);
            o === Uint16Array ? n.GetTrianglesUInt16Array(a, l, u) : n.GetTrianglesUInt32Array(a, l, u), Fx(Ex.memory.buffer.slice(u, u + l), s, e), Ex._free(u);
            for (const i of Object.keys(r.attributes)){
                const s = n.GetAttributeByUniqueId(a, r.attributes[i]), o = e.json.accessors[t1.attributes[i]], l = Lx[o.componentType], u = o.count * Rx[o.type] * Dx[o.componentType].BYTES_PER_ELEMENT, c = Ex._malloc(u);
                n.GetAttributeDataArrayForAllPoints(a, s, Ex[l], u, c), Fx(Ex.memory.buffer.slice(c, c + u), o, e), Ex._free(c);
            }
            n.destroy(), a.destroy(), delete t1.extensions[Ox];
        }
        const Ux = "EXT_meshopt_compression";
        function jx(t1, e) {
            if (!t1.extensions || !t1.extensions[Ux]) return;
            const r = t1.extensions[Ux], n = new Uint8Array(e.buffers[r.buffer], r.byteOffset || 0, r.byteLength || 0), i = new Uint8Array(r.count * r.byteStride);
            Tx.decodeGltfBuffer(i, r.count, r.byteStride, n, r.mode, r.filter), t1.buffer = e.buffers.length, t1.byteOffset = 0, e.buffers[t1.buffer] = i.buffer, delete t1.extensions[Ux];
        }
        const qx = 1179937895, $x = new TextDecoder("utf8");
        function Gx(t1, e) {
            return new URL(t1, e).href;
        }
        function Yx(t1, e, r, n) {
            return fetch(Gx(t1.uri, n)).then((t1)=>t1.arrayBuffer()).then((t1)=>{
                e.buffers[r] = t1;
            });
        }
        function Xx(t1, e) {
            const r = t1.json.bufferViews[e];
            return new Uint8Array(t1.buffers[r.buffer], r.byteOffset || 0, r.byteLength);
        }
        function Zx(t1, e, r, n) {
            if (t1.uri) {
                const i = Gx(t1.uri, n);
                return fetch(i).then((t1)=>t1.blob()).then((t1)=>createImageBitmap(t1)).then((t1)=>{
                    e.images[r] = t1;
                });
            }
            if (void 0 !== t1.bufferView) {
                const n = Xx(e, t1.bufferView), i = new Blob([
                    n
                ], {
                    type: t1.mimeType
                });
                return createImageBitmap(i).then((t1)=>{
                    e.images[r] = t1;
                });
            }
        }
        function Hx(t1, e = 0, r) {
            const n = {
                json: null,
                images: [],
                buffers: []
            };
            if (new Uint32Array(t1, e, 1)[0] === qx) {
                const r = new Uint32Array(t1, e);
                let i = 2;
                const a = (r[i++] >> 2) - 3, s = r[i++] >> 2;
                if (i++, n.json = JSON.parse($x.decode(r.subarray(i, i + s))), i += s, i < a) {
                    const a = r[i++];
                    i++;
                    const s = e + (i << 2);
                    n.buffers[0] = t1.slice(s, s + a);
                }
            } else n.json = JSON.parse($x.decode(new Uint8Array(t1, e)));
            const { buffers: i, images: a, meshes: s, extensionsUsed: o, bufferViews: l } = n.json;
            let u = Promise.resolve();
            if (i) {
                const t1 = [];
                for(let e = 0; e < i.length; e++){
                    const a = i[e];
                    a.uri ? t1.push(Yx(a, n, e, r)) : n.buffers[e] || (n.buffers[e] = null);
                }
                u = Promise.all(t1);
            }
            return u.then(()=>{
                const t1 = [], e = o && o.includes(Ox), i = o && o.includes(Ux);
                if (e && t1.push(function() {
                    if (!Ex) return null != Px ? Px : (Px = function(t1) {
                        let e, r = null;
                        function n() {
                            e = new Uint8Array(r.buffer);
                        }
                        function i() {
                            throw new Error("Unexpected Draco error.");
                        }
                        const a = {
                            a: {
                                a: i,
                                d: function(t1, r, n) {
                                    return e.copyWithin(t1, r, r + n);
                                },
                                c: function(t1) {
                                    const i = e.length, a = Math.max(t1 >>> 0, Math.ceil(1.2 * i)), s = Math.ceil((a - i) / 65536);
                                    try {
                                        return r.grow(s), n(), !0;
                                    } catch (t1) {
                                        return !1;
                                    }
                                },
                                b: i
                            }
                        };
                        return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t1, a) : t1.then((t1)=>t1.arrayBuffer()).then((t1)=>WebAssembly.instantiate(t1, a))).then((t1)=>{
                            const { Rb: i, Qb: a, P: s, T: o, X: l, Ja: u, La: c, Qa: h, Va: p, Wa: f, eb: d, jb: m, f: y, e: g, yb: x, zb: v, Ab: b, Bb: _, Db: w, Gb: M } = t1.instance.exports;
                            r = g;
                            const A = (()=>{
                                let t1 = 0, r = 0, n = 0, s = 0;
                                return (o)=>{
                                    n && (i(s), i(t1), r += n, n = t1 = 0), t1 || (r += 128, t1 = a(r));
                                    const l = o.length + 7 & -8;
                                    let u = t1;
                                    l >= r && (n = l, u = s = a(l));
                                    for(let t1 = 0; t1 < o.length; t1++)e[u + t1] = o[t1];
                                    return u;
                                };
                            })();
                            return n(), y(), {
                                memory: g,
                                _free: i,
                                _malloc: a,
                                Mesh: class {
                                    constructor(){
                                        this.ptr = s();
                                    }
                                    destroy() {
                                        o(this.ptr);
                                    }
                                },
                                Decoder: class {
                                    constructor(){
                                        this.ptr = u();
                                    }
                                    destroy() {
                                        m(this.ptr);
                                    }
                                    DecodeArrayToMesh(t1, e, r) {
                                        const n = A(t1), i = c(this.ptr, n, e, r.ptr);
                                        return !!l(i);
                                    }
                                    GetAttributeByUniqueId(t1, e) {
                                        return {
                                            ptr: h(this.ptr, t1.ptr, e)
                                        };
                                    }
                                    GetTrianglesUInt16Array(t1, e, r) {
                                        p(this.ptr, t1.ptr, e, r);
                                    }
                                    GetTrianglesUInt32Array(t1, e, r) {
                                        f(this.ptr, t1.ptr, e, r);
                                    }
                                    GetAttributeDataArrayForAllPoints(t1, e, r, n, i) {
                                        d(this.ptr, t1.ptr, e.ptr, r, n, i);
                                    }
                                },
                                DT_INT8: x(),
                                DT_UINT8: v(),
                                DT_INT16: b(),
                                DT_UINT16: _(),
                                DT_UINT32: w(),
                                DT_FLOAT32: M()
                            };
                        });
                    }(fetch(Vx())), Px.then((t1)=>{
                        Ex = t1, Px = void 0;
                    }));
                }()), i && t1.push(function() {
                    if (Tx) return;
                    const t1 = function(t1) {
                        let e;
                        const r = WebAssembly.instantiateStreaming(t1, {}).then((t1)=>{
                            e = t1.instance, e.exports.__wasm_call_ctors();
                        }), n = {
                            NONE: "",
                            OCTAHEDRAL: "meshopt_decodeFilterOct",
                            QUATERNION: "meshopt_decodeFilterQuat",
                            EXPONENTIAL: "meshopt_decodeFilterExp"
                        }, i = {
                            ATTRIBUTES: "meshopt_decodeVertexBuffer",
                            TRIANGLES: "meshopt_decodeIndexBuffer",
                            INDICES: "meshopt_decodeIndexSequence"
                        };
                        return {
                            ready: r,
                            supported: !0,
                            decodeGltfBuffer (t1, r, a, s, o, l) {
                                !function(t1, e, r, n, i, a, s) {
                                    const o = t1.exports.sbrk, l = n + 3 & -4, u = o(l * i), c = o(a.length), h = new Uint8Array(t1.exports.memory.buffer);
                                    h.set(a, c);
                                    const p = e(u, n, i, c, a.length);
                                    if (0 === p && s && s(u, l, i), r.set(h.subarray(u, u + n * i)), o(u - o(0)), 0 !== p) throw new Error(`Malformed buffer data: ${p}`);
                                }(e, e.exports[i[o]], t1, r, a, s, e.exports[n[l]]);
                            }
                        };
                    }(fetch(Cx()));
                    return t1.ready.then(()=>{
                        Tx = t1;
                    });
                }()), a) for(let e = 0; e < a.length; e++)t1.push(Zx(a[e], n, e, r));
                return (t1.length ? Promise.all(t1) : Promise.resolve()).then(()=>{
                    if (e && s) for (const { primitives: t1 } of s)for (const e of t1)Nx(e, n);
                    if (i && s && l) for (const t1 of l)jx(t1, n);
                    return n;
                });
            });
        }
        function Wx(t1, e) {
            const r = t1.json.bufferViews[e.bufferView], n = Dx[e.componentType];
            return new n(t1.buffers[r.buffer], (e.byteOffset || 0) + (r.byteOffset || 0), e.count * (r.byteStride && r.byteStride !== Rx[e.type] * n.BYTES_PER_ELEMENT ? r.byteStride / n.BYTES_PER_ELEMENT : Rx[e.type]));
        }
        function Kx(t1, e, r, n) {
            const i = Dx[e.componentType], a = function(t1) {
                switch(t1){
                    case Int8Array:
                        return 1 / 127;
                    case Uint8Array:
                        return 1 / 255;
                    case Int16Array:
                        return 1 / 32767;
                    case Uint16Array:
                        return 1 / 65535;
                    default:
                        return 1;
                }
            }(i), s = t1.json.bufferViews[e.bufferView], o = s.byteStride ? s.byteStride / i.BYTES_PER_ELEMENT : Rx[e.type], l = r.float32, u = l.length / r.capacity;
            for(let t1 = 0, r = 0; t1 < e.count * o; t1 += o, r += u)for(let e = 0; e < u; e++)l[r + e] = n[t1 + e] * a;
            r._trim();
        }
        function Jx(t1, e, r) {
            const n = t1.indices, i = t1.attributes, a = {};
            a.indexArray = new Ls;
            const s = e.json.accessors[n], o = s.count / 3;
            a.indexArray.reserve(o);
            const l = Wx(e, s);
            for(let t1 = 0; t1 < o; t1++)a.indexArray.emplaceBack(l[3 * t1], l[3 * t1 + 1], l[3 * t1 + 2]);
            a.indexArray._trim(), a.vertexArray = new As;
            const u = e.json.accessors[i.POSITION];
            a.vertexArray.reserve(u.count);
            const c = Wx(e, u);
            for(let t1 = 0; t1 < u.count; t1++)a.vertexArray.emplaceBack(c[3 * t1], c[3 * t1 + 1], c[3 * t1 + 2]);
            if (a.vertexArray._trim(), a.aabb = new xu(u.min, u.max), a.centroid = function(t1, e) {
                const r = [
                    0,
                    0,
                    0
                ], n = t1.length;
                if (n > 0) {
                    for(let i = 0; i < n; i++){
                        const n = 3 * t1[i];
                        r[0] += e[n], r[1] += e[n + 1], r[2] += e[n + 2];
                    }
                    r[0] /= n, r[1] /= n, r[2] /= n;
                }
                return r;
            }(l, c), void 0 !== i.COLOR_0) {
                const t1 = e.json.accessors[i.COLOR_0], r = Rx[t1.type], n = Wx(e, t1);
                a.colorArray = 3 === r ? new As : new Ms, a.colorArray.resize(t1.count), Kx(e, t1, a.colorArray, n);
            }
            if (void 0 !== i.NORMAL) {
                a.normalArray = new As;
                const t1 = e.json.accessors[i.NORMAL];
                a.normalArray.resize(t1.count);
                const r = Wx(e, t1);
                Kx(e, t1, a.normalArray, r);
            }
            if (void 0 !== i.TEXCOORD_0 && r.length > 0) {
                a.texcoordArray = new $s;
                const t1 = e.json.accessors[i.TEXCOORD_0];
                a.texcoordArray.resize(t1.count);
                const r = Wx(e, t1);
                Kx(e, t1, a.texcoordArray, r);
            }
            if (void 0 !== i._FEATURE_ID_RGBA4444) {
                const t1 = e.json.accessors[i._FEATURE_ID_RGBA4444];
                e.json.extensionsUsed && e.json.extensionsUsed.includes("EXT_meshopt_compression") && (a.featureData = Wx(e, t1));
            }
            void 0 !== i._FEATURE_RGBA4444 && (a.featureData = new Uint32Array(Wx(e, e.json.accessors[i._FEATURE_RGBA4444]).buffer));
            const h = t1.material;
            return a.material = function(t1, e) {
                const { emissiveFactor: r = [
                    0,
                    0,
                    0
                ], alphaMode: n = "OPAQUE", alphaCutoff: i = .5, normalTexture: a, occlusionTexture: s, emissiveTexture: o, doubleSided: l } = t1, { baseColorFactor: u = [
                    1,
                    1,
                    1,
                    1
                ], metallicFactor: c = 1, roughnessFactor: h = 1, baseColorTexture: p, metallicRoughnessTexture: f } = t1.pbrMetallicRoughness || {}, d = s ? e[s.index] : void 0;
                if (s && s.extensions && s.extensions.KHR_texture_transform && d) {
                    const t1 = s.extensions.KHR_texture_transform;
                    d.offsetScale = [
                        t1.offset[0],
                        t1.offset[1],
                        t1.scale[0],
                        t1.scale[1]
                    ];
                }
                return {
                    pbrMetallicRoughness: {
                        baseColorFactor: new Ie(...u),
                        metallicFactor: c,
                        roughnessFactor: h,
                        baseColorTexture: p ? e[p.index] : void 0,
                        metallicRoughnessTexture: f ? e[f.index] : void 0
                    },
                    doubleSided: l,
                    emissiveFactor: r,
                    alphaMode: n,
                    alphaCutoff: i,
                    normalTexture: a ? e[a.index] : void 0,
                    occlusionTexture: d,
                    emissionTexture: o ? e[o.index] : void 0,
                    defined: void 0 === t1.defined
                };
            }(void 0 !== h ? e.json.materials[h] : {
                defined: !1
            }, r), a;
        }
        function Qx(t1, e, r) {
            const { matrix: n, rotation: i, translation: a, scale: s, mesh: o, extras: l, children: u } = t1, c = {};
            if (c.matrix = n || O.mat4.fromRotationTranslationScale([], i || [
                0,
                0,
                0,
                1
            ], a || [
                0,
                0,
                0
            ], s || [
                1,
                1,
                1
            ]), void 0 !== o) {
                c.meshes = r[o];
                const t1 = c.anchor = [
                    0,
                    0
                ];
                for (const e of c.meshes){
                    const { min: r, max: n } = e.aabb;
                    t1[0] += r[0] + n[0], t1[1] += r[1] + n[1];
                }
                t1[0] = Math.floor(t1[0] / c.meshes.length / 2), t1[1] = Math.floor(t1[1] / c.meshes.length / 2);
            }
            if (l && (l.id && (c.id = l.id), l.lights && (c.lights = function(t1) {
                if (!t1.length) return [];
                const e = function(t1) {
                    const e = atob(t1), r = new Uint8Array(e.length);
                    for(let t1 = 0; t1 < e.length; t1++)r[t1] = e.codePointAt(t1);
                    return r;
                }(t1), r = [], n = e.length / 24, i = new Uint16Array(e.buffer), a = new Float32Array(e.buffer);
                for(let t1 = 0; t1 < n; t1++){
                    const e = i[2 * t1 * 6] / 30, n = i[2 * t1 * 6 + 1] / 30, s = i[2 * t1 * 6 + 10] / 100, o = a[6 * t1 + 1], l = a[6 * t1 + 2], u = a[6 * t1 + 3], c = a[6 * t1 + 4], h = u - o, p = c - l, f = Math.hypot(h, p);
                    r.push({
                        pos: [
                            o + .5 * h,
                            l + .5 * p,
                            n
                        ],
                        normal: [
                            p / f,
                            -h / f,
                            0
                        ],
                        width: f,
                        height: e,
                        depth: s,
                        points: [
                            o,
                            l,
                            u,
                            c
                        ]
                    });
                }
                return r;
            }(l.lights))), u) {
                const t1 = [];
                for (const n of u)t1.push(Qx(e.json.nodes[n], e, r));
                c.children = t1;
            }
            return c;
        }
        function tv(t1) {
            if (0 === t1.vertices.length || 0 === t1.indices.length) return null;
            const e = new Yc(t1.vertices, t1.indices, 8, 256), [r, n] = [
                e.min.clone(),
                e.max.clone()
            ];
            return {
                vertices: t1.vertices,
                indices: t1.indices,
                grid: e,
                min: r,
                max: n
            };
        }
        function ev(t1) {
            if (!t1.extras || !t1.extras.ground) return null;
            const e = t1.extras.ground;
            if (!e || !Array.isArray(e) || 0 === e.length) return null;
            const r = e[0];
            if (!r || !Array.isArray(r) || 0 === r.length) return null;
            const n = [];
            for (const t1 of r){
                if (!Array.isArray(t1) || 2 !== t1.length) continue;
                const e = t1[0], r = t1[1];
                "number" == typeof e && "number" == typeof r && n.push(new q(e, r));
            }
            if (n.length < 3) return null;
            n.length > 1 && n[n.length - 1].equals(n[0]) && n.pop();
            let i = 0;
            for(let t1 = 0; t1 < n.length; t1++){
                const e = n[t1], r = n[(t1 + 1) % n.length], a = n[(t1 + 2) % n.length];
                i += (e.x - r.x) * (a.y - r.y) - (a.x - r.x) * (e.y - r.y);
            }
            i > 0 && n.reverse();
            const a = hc(n.flatMap((t1)=>[
                    t1.x,
                    t1.y
                ]), []);
            return 0 === a.length ? null : {
                vertices: n,
                indices: a
            };
        }
        function rv(t1, e) {
            const r = [], n = [];
            let i = 0;
            const a = [];
            for (const s of t1){
                i = r.length;
                const t1 = s.vertexArray.float32, o = s.indexArray.uint16;
                for(let n = 0; n < s.vertexArray.length; n++)a[0] = t1[3 * n + 0], a[1] = t1[3 * n + 1], a[2] = t1[3 * n + 2], O.vec3.transformMat4(a, a, e), r.push(new q(a[0], a[1]));
                for(let t1 = 0; t1 < 3 * s.indexArray.length; t1++)n.push(o[t1] + i);
            }
            if (n.length % 3 != 0) return null;
            for(let t1 = 0; t1 < n.length; t1 += 3){
                const e = r[n[t1 + 0]], i = r[n[t1 + 1]], a = r[n[t1 + 2]];
                (e.x - i.x) * (a.y - i.y) - (a.x - i.x) * (e.y - i.y) > 0 && ([n[t1 + 1], n[t1 + 2]] = [
                    n[t1 + 2],
                    n[t1 + 1]
                ]);
            }
            return {
                vertices: r,
                indices: n
            };
        }
        function nv(t1) {
            const e = function(t1, e) {
                const r = [], n = WebGL2RenderingContext;
                if (t1.json.textures) for (const i of t1.json.textures){
                    const a = {
                        magFilter: n.LINEAR,
                        minFilter: n.NEAREST,
                        wrapS: n.REPEAT,
                        wrapT: n.REPEAT
                    };
                    void 0 !== i.sampler && Object.assign(a, t1.json.samplers[i.sampler]), r.push({
                        image: e[i.source],
                        sampler: a,
                        uploaded: !1
                    });
                }
                return r;
            }(t1, t1.images), r = function(t1, e) {
                const r = [];
                for (const n of t1.json.meshes){
                    const i = [];
                    for (const r of n.primitives)i.push(Jx(r, t1, e));
                    r.push(i);
                }
                return r;
            }(t1, e), { scenes: n, scene: i, nodes: a } = t1.json, s = n ? n[i || 0].nodes : a, o = [];
            for (const e of s)o.push(Qx(a[e], t1, r));
            return function(t1, e, r) {
                const n = {}, i = new Set;
                for(let a = 0; a < t1.length; a++){
                    const t1 = r[e[a]];
                    if (!t1.extras) continue;
                    const s = t1.extras["mapbox:footprint:version"], o = t1.extras["mapbox:footprint:id"];
                    (s || o) && i.add(a), "1.0.0" === s && o && (n[o] = a);
                }
                for(let a = 0; a < t1.length; a++){
                    if (i.has(a)) continue;
                    const s = t1[a], o = r[e[a]];
                    if (!o.extras) continue;
                    let l = null;
                    s.id in n && (l = rv(t1[n[s.id]].meshes, s.matrix)), l || (l = ev(o)), l && (s.footprint = tv(l));
                }
                if (i.size > 0) {
                    const e = Array.from(i.values()).sort((t1, e)=>t1 - e);
                    for(let r = e.length - 1; r >= 0; r--)t1.splice(e[r], 1);
                }
            }(o, s, t1.json.nodes), o;
        }
        function iv(t1) {
            t1.heightmap = new Float32Array(4096), t1.heightmap.fill(-1);
            const e = t1.vertexArray.float32, r = t1.aabb.min[0] - 1, n = t1.aabb.min[1] - 1, i = ey / (t1.aabb.max[0] - r + 2), a = ey / (t1.aabb.max[1] - n + 2);
            for(let s = 0; s < e.length; s += 3){
                const o = e[s + 2], l = (e[s + 0] - r) * i | 0, u = (e[s + 1] - n) * a | 0;
                o > t1.heightmap[u * ey + l] && (t1.heightmap[u * ey + l] = o);
            }
        }
        function av(t1, e) {
            const r = {};
            r.indexArray = new Ls, r.indexArray.reserve(4 * t1.length), r.vertexArray = new As, r.vertexArray.reserve(10 * t1.length), r.colorArray = new Ms, r.vertexArray.reserve(10 * t1.length);
            let n = 0;
            for (const i of t1){
                const t1 = Math.min(10, Math.max(4, 1.3 * i.height)) * e, a = [
                    -i.normal[1],
                    i.normal[0],
                    0
                ], s = Math.min(.29, .1 * i.width / i.depth), o = i.width - 2 * i.depth * e * (s + .01), l = O.vec3.scaleAndAdd([], i.pos, a, o / 2), u = O.vec3.scaleAndAdd([], i.pos, a, -o / 2), c = [
                    l[0],
                    l[1],
                    l[2] + i.height
                ], h = [
                    u[0],
                    u[1],
                    u[2] + i.height
                ], p = O.vec3.scaleAndAdd([], i.normal, a, s);
                O.vec3.scale(p, p, t1);
                const f = O.vec3.scaleAndAdd([], i.normal, a, -s);
                O.vec3.scale(f, f, t1), O.vec3.add(p, l, p), O.vec3.add(f, u, f), l[2] += .1, u[2] += .1, r.vertexArray.emplaceBack(p[0], p[1], p[2]), r.vertexArray.emplaceBack(f[0], f[1], f[2]), r.vertexArray.emplaceBack(l[0], l[1], l[2]), r.vertexArray.emplaceBack(u[0], u[1], u[2]), r.vertexArray.emplaceBack(c[0], c[1], c[2]), r.vertexArray.emplaceBack(h[0], h[1], h[2]), r.vertexArray.emplaceBack(l[0], l[1], l[2]), r.vertexArray.emplaceBack(u[0], u[1], u[2]), r.vertexArray.emplaceBack(p[0], p[1], p[2]), r.vertexArray.emplaceBack(f[0], f[1], f[2]);
                const d = o / t1 / 2;
                r.colorArray.emplaceBack(-d - s, -1, d, .8), r.colorArray.emplaceBack(d + s, -1, d, .8), r.colorArray.emplaceBack(-d, 0, d, 1.3), r.colorArray.emplaceBack(d, 0, d, 1.3), r.colorArray.emplaceBack(d + s, -.8, d, .7), r.colorArray.emplaceBack(d + s, -.8, d, .7), r.colorArray.emplaceBack(0, 0, d, 1.3), r.colorArray.emplaceBack(0, 0, d, 1.3), r.colorArray.emplaceBack(d + s, -1.2, d, .8), r.colorArray.emplaceBack(d + s, -1.2, d, .8), r.indexArray.emplaceBack(6 + n, 4 + n, 8 + n), r.indexArray.emplaceBack(7 + n, 9 + n, 5 + n), r.indexArray.emplaceBack(0 + n, 1 + n, 2 + n), r.indexArray.emplaceBack(1 + n, 3 + n, 2 + n), n += 10;
            }
            const i = {
                defined: !0,
                emissiveFactor: [
                    0,
                    0,
                    0
                ]
            }, a = {};
            return a.baseColorFactor = Ie.white, i.pbrMetallicRoughness = a, r.material = i, r.aabb = new xu([
                1 / 0,
                1 / 0,
                1 / 0
            ], [
                -1 / 0,
                -1 / 0,
                -1 / 0
            ]), r;
        }
        class sv {
            constructor(t1){
                this._stringToNumber = {}, this._numberToString = [];
                for(let e = 0; e < t1.length; e++){
                    const r = t1[e];
                    this._stringToNumber[r] = e, this._numberToString[e] = r;
                }
            }
            encode(t1) {
                return this._stringToNumber[t1];
            }
            decode(t1) {
                return this._numberToString[t1];
            }
        }
        const ov = [
            "id",
            "tile",
            "layer",
            "source",
            "sourceLayer",
            "state"
        ];
        class lv {
            constructor(t1, e, r, n, i){
                this.type = "Feature", this._vectorTileFeature = t1, this._z = e, this._x = r, this._y = n, this.properties = t1.properties, this.id = i;
            }
            clone() {
                const t1 = new lv(this._vectorTileFeature, this._z, this._x, this._y, this.id);
                return this.state && (t1.state = {
                    ...this.state
                }), this.layer && (t1.layer = {
                    ...this.layer
                }), this.source && (t1.source = this.source), this.sourceLayer && (t1.sourceLayer = this.sourceLayer), t1;
            }
            get geometry() {
                return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
            }
            set geometry(t1) {
                this._geometry = t1;
            }
            toJSON() {
                const t1 = {
                    type: "Feature",
                    state: void 0,
                    geometry: this.geometry,
                    properties: this.properties
                };
                for (const e of ov)void 0 !== this[e] && (t1[e] = this[e]);
                return t1;
            }
        }
        class uv {
            constructor(t1, e){
                this.tileID = t1, this.x = t1.canonical.x, this.y = t1.canonical.y, this.z = t1.canonical.z, this.grid = new aa(Wr, 16, 0), this.featureIndexArray = new so, this.promoteId = e, this.is3DTile = !1, this.serializedLayersCache = new Map;
            }
            insert(t1, e, r, n, i, a = 0, s = 0) {
                const o = this.featureIndexArray.length;
                this.featureIndexArray.emplaceBack(r, n, i, a);
                const l = this.grid;
                for(let t1 = 0; t1 < e.length; t1++){
                    const r = e[t1], n = [
                        1 / 0,
                        1 / 0,
                        -1 / 0,
                        -1 / 0
                    ];
                    for(let t1 = 0; t1 < r.length; t1++){
                        const e = r[t1];
                        n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y);
                    }
                    0 !== s && (n[0] -= s, n[1] -= s, n[2] += s, n[3] += s), n[0] < Wr && n[1] < Wr && n[2] >= 0 && n[3] >= 0 && l.insert(o, n[0], n[1], n[2], n[3]);
                }
            }
            loadVTLayers() {
                if (!this.vtLayers) {
                    this.vtLayers = new fh.VectorTile(new pf(this.rawTileData)).layers, this.sourceLayerCoder = new sv(this.vtLayers ? Object.keys(this.vtLayers).sort() : [
                        "_geojsonTileLayer"
                    ]), this.vtFeatures = {};
                    for(const t1 in this.vtLayers)this.vtFeatures[t1] = [];
                }
                return this.vtLayers;
            }
            query(t1, e) {
                const { tilespaceGeometry: r, transform: n, tileTransform: i, pixelPosMatrix: a, availableImages: s } = e;
                this.loadVTLayers(), this.serializedLayersCache.clear();
                const o = r.bufferedTilespaceBounds, l = this.grid.query(o.min.x, o.min.y, o.max.x, o.max.y, (t1, e, n, i)=>ql(r.bufferedTilespaceGeometry, t1, e, n, i));
                l.sort(hv);
                let u = null;
                n.elevation && l.length > 0 && (u = uy.create(n.elevation, this.tileID));
                const c = {};
                let h;
                for(let e = 0; e < l.length; e++){
                    const o = l[e];
                    if (o === h) continue;
                    h = o;
                    const p = this.featureIndexArray.get(o);
                    let f = null;
                    this.is3DTile ? this.loadMatchingModelFeature(c, p, t1, r, n) : this.loadMatchingFeature(c, p, t1, s, (t1, e, s, o = 0)=>(f || (f = zl(t1, this.tileID.canonical, i)), e.queryIntersectsFeature(r, t1, s, f, this.z, n, a, u, o)));
                }
                return c;
            }
            loadMatchingFeature(t1, e, r, n, i) {
                const { featureIndex: a, bucketIndex: s, sourceLayerIndex: o, layoutVertexArrayOffset: l } = e, u = this.bucketLayerIDs[s], c = r.layers, h = Object.keys(c);
                if (h.length && !function(t1, e) {
                    for(let r = 0; r < t1.length; r++)if (e.indexOf(t1[r]) >= 0) return !0;
                    return !1;
                }(h, u)) return;
                const p = r.sourceCache, f = this.sourceLayerCoder.decode(o), d = this.vtLayers[f].feature(a), m = this.getId(d, f);
                for(let e = 0; e < u.length; e++){
                    const r = u[e];
                    if (!c[r]) continue;
                    const { styleLayer: s, targets: o } = c[r];
                    let h = {};
                    void 0 !== m && (h = p.getFeatureState(s.sourceLayer, m));
                    const f = !i || i(d, s, h, l);
                    if (!f) continue;
                    const y = new lv(d, this.z, this.x, this.y, m);
                    y.tile = this.tileID.canonical, y.state = h;
                    let g = this.serializedLayersCache.get(r);
                    g || (g = s.serialize(), g.id = r, this.serializedLayersCache.set(r, g)), y.source = g.source, y.sourceLayer = g["source-layer"], y.layer = nt({}, g), y.layer.paint = cv(g.paint, s.paint, d, h, n), y.layer.layout = cv(g.layout, s.layout, d, h, n);
                    let x = !1;
                    for (const t1 of o){
                        this.updateFeatureProperties(y, t1);
                        const { filter: e } = t1;
                        if (e) {
                            if (d.properties = y.properties, e.needGeometry) {
                                const t1 = El(d, !0);
                                if (!e.filter(new Va(this.tileID.overscaledZ), t1, this.tileID.canonical)) continue;
                            } else if (!e.filter(new Va(this.tileID.overscaledZ), d)) continue;
                        }
                        x = !0, t1.targetId && this.addFeatureVariant(y, t1);
                    }
                    x && this.appendToResult(t1, r, a, y, f);
                }
            }
            loadMatchingModelFeature(t1, e, r, n, i) {
                const a = this.bucketLayerIDs[0][0], s = r.layers;
                if (!s[a]) return;
                const { styleLayer: o, targets: l } = s[a];
                if ("model" !== o.type) return;
                const u = n.tile, c = e.featureIndex, h = u.getBucket(o);
                if (!(h && h instanceof yy)) return;
                const p = function(t1, e, r, n) {
                    const i = t1.getNodesInfo()[e];
                    if (i.hiddenByReplacement || !i.node.meshes) return;
                    let a = Number.MAX_VALUE;
                    const s = i.node, o = r.tile, l = n.calculatePosMatrix(o.tileID.toUnwrapped(), n.worldSize), u = i.evaluatedScale;
                    let c = 0;
                    n.elevation && s.elevation && (c = s.elevation * n.elevation.exaggeration()), O.mat4.translate(l, l, [
                        (s.anchor ? s.anchor[0] : 0) * (u[0] - 1),
                        (s.anchor ? s.anchor[1] : 0) * (u[1] - 1),
                        c
                    ]), O.mat4.scale(l, l, u);
                    const h = r.queryGeometry, p = h.isPointQuery() ? h.screenBounds : h.screenGeometry, f = function(t1) {
                        const e = O.mat4.multiply([], l, t1.matrix);
                        O.mat4.multiply(e, n.expandedFarZProjMatrix, e);
                        for(let r = 0; r < t1.meshes.length; ++r){
                            const i = t1.meshes[r];
                            if (r === t1.lightMeshIndex) continue;
                            const s = Om(p, n, e, i.aabb);
                            null != s && (a = Math.min(s, a));
                        }
                        if (t1.children) for (const e of t1.children)f(e);
                    };
                    if (f(s), a === Number.MAX_VALUE) return;
                    const d = new il(0, 0);
                    return by(o.tileID.canonical, d, i.node.anchor[0], i.node.anchor[1]), {
                        intersectionZ: a,
                        position: d,
                        feature: i.feature
                    };
                }(h, c, n, i);
                if (!p) return;
                const { z: f, x: d, y: m } = u.tileID.canonical, { feature: y, intersectionZ: g, position: x } = p;
                let v = {};
                void 0 !== y.id && (v = r.sourceCache.getFeatureState(o.sourceLayer, y.id));
                const b = new lv({}, f, d, m, y.id);
                b.tile = this.tileID.canonical, b.state = v, b.properties = y.properties, b.geometry = {
                    type: "Point",
                    coordinates: [
                        x.lng,
                        x.lat
                    ]
                };
                let _ = this.serializedLayersCache.get(a);
                _ || (_ = o.serialize(), _.id = a, this.serializedLayersCache.set(a, _)), b.source = _.source, b.sourceLayer = _["source-layer"], b.layer = nt({}, _);
                let w = !1;
                for (const t1 of l){
                    this.updateFeatureProperties(b, t1);
                    const { filter: e } = t1;
                    if (e) {
                        if (y.properties = b.properties, e.needGeometry) {
                            if (!e.filter(new Va(this.tileID.overscaledZ), y, this.tileID.canonical)) continue;
                        } else if (!e.filter(new Va(this.tileID.overscaledZ), y)) continue;
                    }
                    w = !0, t1.targetId && this.addFeatureVariant(b, t1);
                }
                w && this.appendToResult(t1, a, c, b, g);
            }
            updateFeatureProperties(t1, e, r) {
                if (e.properties) {
                    const n = {};
                    for(const i in e.properties){
                        const a = e.properties[i].evaluate({
                            zoom: this.z
                        }, t1._vectorTileFeature, t1.state, t1.tile, r);
                        null != a && (n[i] = a);
                    }
                    t1.properties = n;
                }
            }
            addFeatureVariant(t1, e, r) {
                const n = {
                    target: e.target,
                    namespace: e.namespace
                };
                e.properties && (n.properties = t1.properties), t1.variants = t1.variants || {}, t1.variants[e.targetId] = t1.variants[e.targetId] || [], t1.variants[e.targetId].push(n);
            }
            appendToResult(t1, e, r, n, i) {
                let a = t1[e];
                void 0 === a && (a = t1[e] = []), a.push({
                    featureIndex: r,
                    feature: n,
                    intersectionZ: i
                });
            }
            lookupSymbolFeatures(t1, e, r, n, i) {
                const a = {};
                this.loadVTLayers();
                for (const s of t1)this.loadMatchingFeature(a, {
                    bucketIndex: e,
                    sourceLayerIndex: r,
                    featureIndex: s,
                    layoutVertexArrayOffset: 0
                }, n, i);
                return a;
            }
            loadFeature(t1) {
                const { featureIndex: e, sourceLayerIndex: r } = t1;
                this.loadVTLayers();
                const n = this.sourceLayerCoder.decode(r), i = this.vtFeatures[n];
                if (i[e]) return i[e];
                const a = this.vtLayers[n].feature(e);
                return i[e] = a, a;
            }
            hasLayer(t1) {
                for (const e of this.bucketLayerIDs)for (const r of e)if (t1 === r) return !0;
                return !1;
            }
            getId(t1, e) {
                let r = t1.id;
                if (this.promoteId) {
                    const n = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e];
                    null != n && (r = t1.properties[n]), "boolean" == typeof r && (r = Number(r));
                }
                return r;
            }
        }
        function cv(t1, e, r, n, i) {
            return ut(t1, (t1, a)=>{
                const s = e instanceof Ua ? e.get(a) : null;
                return s && s.evaluate ? s.evaluate(r, n, i) : s;
            });
        }
        function hv(t1, e) {
            return e - t1;
        }
        oa(uv, "FeatureIndex", {
            omit: [
                "rawTileData",
                "sourceLayerCoder"
            ]
        });
        const pv = [
            Int8Array,
            Uint8Array,
            Uint8ClampedArray,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array
        ];
        class fv {
            static from(t1) {
                if (!(t1 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
                const [e, r] = new Uint8Array(t1, 0, 2);
                if (219 !== e) throw new Error("Data does not appear to be in a KDBush format.");
                const n = r >> 4;
                if (1 !== n) throw new Error(`Got v${n} data when expected v1.`);
                const i = pv[15 & r];
                if (!i) throw new Error("Unrecognized array type.");
                const [a] = new Uint16Array(t1, 2, 1), [s] = new Uint32Array(t1, 4, 1);
                return new fv(s, a, i, t1);
            }
            constructor(t1, e = 64, r = Float64Array, n){
                if (isNaN(t1) || t1 < 0) throw new Error(`Unpexpected numItems value: ${t1}.`);
                this.numItems = +t1, this.nodeSize = Math.min(Math.max(+e, 2), 65535), this.ArrayType = r, this.IndexArrayType = t1 < 65536 ? Uint16Array : Uint32Array;
                const i = pv.indexOf(this.ArrayType), a = 2 * t1 * this.ArrayType.BYTES_PER_ELEMENT, s = t1 * this.IndexArrayType.BYTES_PER_ELEMENT, o = (8 - s % 8) % 8;
                if (i < 0) throw new Error(`Unexpected typed array class: ${r}.`);
                n && n instanceof ArrayBuffer ? (this.data = n, this.ids = new this.IndexArrayType(this.data, 8, t1), this.coords = new this.ArrayType(this.data, 8 + s + o, 2 * t1), this._pos = 2 * t1, this._finished = !0) : (this.data = new ArrayBuffer(8 + a + s + o), this.ids = new this.IndexArrayType(this.data, 8, t1), this.coords = new this.ArrayType(this.data, 8 + s + o, 2 * t1), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([
                    219,
                    16 + i
                ]), new Uint16Array(this.data, 2, 1)[0] = e, new Uint32Array(this.data, 4, 1)[0] = t1);
            }
            add(t1, e) {
                const r = this._pos >> 1;
                return this.ids[r] = r, this.coords[this._pos++] = t1, this.coords[this._pos++] = e, r;
            }
            finish() {
                const t1 = this._pos >> 1;
                if (t1 !== this.numItems) throw new Error(`Added ${t1} items when expected ${this.numItems}.`);
                return dv(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
            }
            range(t1, e, r, n) {
                if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                const { ids: i, coords: a, nodeSize: s } = this, o = [
                    0,
                    i.length - 1,
                    0
                ], l = [];
                for(; o.length;){
                    const u = o.pop() || 0, c = o.pop() || 0, h = o.pop() || 0;
                    if (c - h <= s) {
                        for(let s = h; s <= c; s++){
                            const o = a[2 * s], u = a[2 * s + 1];
                            o >= t1 && o <= r && u >= e && u <= n && l.push(i[s]);
                        }
                        continue;
                    }
                    const p = h + c >> 1, f = a[2 * p], d = a[2 * p + 1];
                    f >= t1 && f <= r && d >= e && d <= n && l.push(i[p]), (0 === u ? t1 <= f : e <= d) && (o.push(h), o.push(p - 1), o.push(1 - u)), (0 === u ? r >= f : n >= d) && (o.push(p + 1), o.push(c), o.push(1 - u));
                }
                return l;
            }
            within(t1, e, r) {
                if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
                const { ids: n, coords: i, nodeSize: a } = this, s = [
                    0,
                    n.length - 1,
                    0
                ], o = [], l = r * r;
                for(; s.length;){
                    const u = s.pop() || 0, c = s.pop() || 0, h = s.pop() || 0;
                    if (c - h <= a) {
                        for(let r = h; r <= c; r++)xv(i[2 * r], i[2 * r + 1], t1, e) <= l && o.push(n[r]);
                        continue;
                    }
                    const p = h + c >> 1, f = i[2 * p], d = i[2 * p + 1];
                    xv(f, d, t1, e) <= l && o.push(n[p]), (0 === u ? t1 - r <= f : e - r <= d) && (s.push(h), s.push(p - 1), s.push(1 - u)), (0 === u ? t1 + r >= f : e + r >= d) && (s.push(p + 1), s.push(c), s.push(1 - u));
                }
                return o;
            }
        }
        function dv(t1, e, r, n, i, a) {
            if (i - n <= r) return;
            const s = n + i >> 1;
            mv(t1, e, s, n, i, a), dv(t1, e, r, n, s - 1, 1 - a), dv(t1, e, r, s + 1, i, 1 - a);
        }
        function mv(t1, e, r, n, i, a) {
            for(; i > n;){
                if (i - n > 600) {
                    const s = i - n + 1, o = r - n + 1, l = Math.log(s), u = .5 * Math.exp(2 * l / 3), c = .5 * Math.sqrt(l * u * (s - u) / s) * (o - s / 2 < 0 ? -1 : 1);
                    mv(t1, e, r, Math.max(n, Math.floor(r - o * u / s + c)), Math.min(i, Math.floor(r + (s - o) * u / s + c)), a);
                }
                const s = e[2 * r + a];
                let o = n, l = i;
                for(yv(t1, e, n, r), e[2 * i + a] > s && yv(t1, e, n, i); o < l;){
                    for(yv(t1, e, o, l), o++, l--; e[2 * o + a] < s;)o++;
                    for(; e[2 * l + a] > s;)l--;
                }
                e[2 * n + a] === s ? yv(t1, e, n, l) : (l++, yv(t1, e, l, i)), l <= r && (n = l + 1), r <= l && (i = l - 1);
            }
        }
        function yv(t1, e, r, n) {
            gv(t1, r, n), gv(e, 2 * r, 2 * n), gv(e, 2 * r + 1, 2 * n + 1);
        }
        function gv(t1, e, r) {
            const n = t1[e];
            t1[e] = t1[r], t1[r] = n;
        }
        function xv(t1, e, r, n) {
            const i = t1 - r, a = e - n;
            return i * i + a * a;
        }
        t1.$ = Ha, t1.A = tr, t1.B = 2, t1.C = jf, t1.D = zy, t1.E = we, t1.F = $f, t1.G = class extends Zm {
        }, t1.H = hr, t1.I = wg, t1.J = Te, t1.K = Xa, t1.L = Oi, t1.M = Li, t1.N = Fi, t1.O = Hi, t1.P = q, t1.Q = Za, t1.R = te, t1.S = Qi, t1.T = dm, t1.U = Wi, t1.V = Zm, t1.W = Bn, t1.X = Cn, t1.Y = Tn, t1.Z = yr, t1._ = Se, t1.a = function(t1) {
            return St.API_CDN_URL_REGEX.test(t1);
        }, t1.a$ = lv, t1.a0 = Ni, t1.a1 = Ri, t1.a2 = function(t1) {
            const e = t1.value;
            let r = [];
            if (!e) return r;
            const n = hr(e);
            return "string" !== n ? (r = r.concat([
                new Zm(t1.key, e, `string expected, "${n}" found`)
            ]), r) : (Hm(e, !0) || (r = r.concat([
                new Zm(t1.key, e, `invalid url "${e}"`)
            ])), r);
        }, t1.a3 = Ya, t1.a4 = La, t1.a5 = Ga, t1.a6 = ja, t1.a7 = class {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e) {
                return yt(t1.expression.evaluate(e));
            }
            interpolate(t1, e, r) {
                return {
                    x: ze(t1.x, e.x, r),
                    y: ze(t1.y, e.y, r),
                    z: ze(t1.z, e.z, r),
                    azimuthal: ze(t1.azimuthal, e.azimuthal, r),
                    polar: ze(t1.polar, e.polar, r)
                };
            }
        }, t1.a8 = Va, t1.a9 = Ji, t1.aA = cl, t1.aB = class {
            constructor(t1){
                this.entries = {}, this.scheduler = t1;
            }
            request(t1, e, r, n) {
                const i = this.entries[t1] = this.entries[t1] || {
                    callbacks: []
                };
                if (i.result) {
                    const [t1, r] = i.result;
                    return this.scheduler ? this.scheduler.add(()=>{
                        n(t1, r);
                    }, e) : n(t1, r), ()=>{};
                }
                return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n)=>{
                    i.result = [
                        r,
                        n
                    ];
                    for (const t1 of i.callbacks)this.scheduler ? this.scheduler.add(()=>{
                        t1(r, n);
                    }, e) : t1(r, n);
                    setTimeout(()=>delete this.entries[t1], 3e3);
                })), ()=>{
                    i.result || (i.callbacks = i.callbacks.filter((t1)=>t1 !== n), i.callbacks.length || (i.cancel(), delete this.entries[t1]));
                };
            }
        }, t1.aC = us, t1.aD = function(t1, e, r) {
            const n = JSON.stringify(t1.request);
            return t1.data && (this.deduped.entries[n] = {
                result: [
                    null,
                    t1.data
                ]
            }), this.deduped.request(n, {
                type: "parseTile",
                isSymbolTile: t1.isSymbolTile,
                zoom: t1.tileZoom
            }, (e)=>{
                const n = ie(t1.request, (t1, n, i, a)=>{
                    t1 ? e(t1) : n && e(null, {
                        vectorTile: r ? void 0 : new fh.VectorTile(new pf(n)),
                        rawData: n,
                        cacheControl: i,
                        expires: a
                    });
                });
                return ()=>{
                    n.cancel(), e();
                };
            }, e);
        }, t1.aE = function(t1) {
            Yt++, Yt > Nt && (t1.getActor().send("enforceCacheSizeLimit", Ot), Yt = 0);
        }, t1.aF = function(t1) {
            return t1 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t1) / Math.LN2));
        }, t1.aG = iu, t1.aH = _m, t1.aI = Pm, t1.aJ = vm, t1.aK = function(t1, e) {
            const r = document.createElement("video");
            r.muted = !0, r.onloadstart = function() {
                e(null, r);
            };
            for(let e = 0; e < t1.length; e++){
                const n = document.createElement("source");
                ae(t1[e]) || (r.crossOrigin = "Anonymous"), n.src = t1[e], r.appendChild(n);
            }
            return {
                cancel: ()=>{}
            };
        }, t1.aL = mm, t1.aM = function(t1) {
            return fetch(t1).then((t1)=>t1.arrayBuffer()).then((e)=>Hx(e, 0, t1));
        }, t1.aN = nv, t1.aO = class {
            constructor(t1, e, r, n){
                this.id = t1, this.position = null != e ? new il(e[0], e[1]) : new il(0, 0), this.orientation = null != r ? r : [
                    0,
                    0,
                    0
                ], this.nodes = n, this.uploaded = !1, this.aabb = new xu([
                    1 / 0,
                    1 / 0,
                    1 / 0
                ], [
                    -1 / 0,
                    -1 / 0,
                    -1 / 0
                ]), this.matrix = [];
            }
            _applyTransformations(t1, e) {
                if (O.mat4.multiply(t1.matrix, e, t1.matrix), t1.meshes) for (const e of t1.meshes){
                    const r = xu.applyTransformFast(e.aabb, t1.matrix);
                    this.aabb.encapsulate(r);
                }
                if (t1.children) for (const e of t1.children)this._applyTransformations(e, t1.matrix);
            }
            computeBoundsAndApplyParent() {
                const t1 = O.mat4.identity([]);
                for (const e of this.nodes)this._applyTransformations(e, t1);
            }
            computeModelMatrix(t1, e, r, n, i, a, s = !1) {
                ny(this.matrix, this, t1.transform, this.position, e, r, n, i, a, s);
            }
            upload(t1) {
                if (!this.uploaded) {
                    for (const e of this.nodes)sy(e, t1);
                    for (const t1 of this.nodes)oy(t1);
                    this.uploaded = !0;
                }
            }
            destroy() {
                for (const t1 of this.nodes)ly(t1);
            }
        }, t1.aP = ot, t1.aQ = wd, t1.aR = pl, t1.aS = fl, t1.aT = bs, t1.aU = Ls, t1.aV = at, t1.aW = Js, t1.aX = tm, t1.aY = function() {
            Ba.isLoading() || Ba.isLoaded() || "deferred" !== ka() || Ta();
        }, t1.aZ = Wa, t1.a_ = El, t1.aa = bl, t1.ab = O, t1.ac = tt, t1.ad = Ua, t1.ae = Fu, t1.af = ze, t1.ag = Wr, t1.ah = Ee, t1.ai = X, t1.aj = Ie, t1.ak = class {
            constructor(t1){
                this.specification = t1;
            }
            possiblyEvaluate(t1, e) {
                return function([t1, e]) {
                    const r = yt([
                        1,
                        t1,
                        e
                    ]);
                    return {
                        x: r.x,
                        y: r.y,
                        z: r.z
                    };
                }(t1.expression.evaluate(e));
            }
            interpolate(t1, e, r) {
                return {
                    x: ze(t1.x, e.x, r),
                    y: ze(t1.y, e.y, r),
                    z: ze(t1.z, e.z, r)
                };
            }
        }, t1.al = function(t1, e, r = 0, n = !0) {
            const i = new q(r, r), a = t1.sub(i), s = e.add(i), o = [
                a,
                new q(s.x, a.y),
                s,
                new q(a.x, s.y)
            ];
            return n && o.push(a.clone()), o;
        }, t1.am = function(t1, e) {
            const r = [];
            for(let n = 0; n < t1.length; n++){
                const i = et(n - 1, -1, t1.length - 1), a = et(n + 1, -1, t1.length - 1), s = t1[n], o = t1[a], l = t1[i].sub(s).unit(), u = o.sub(s).unit(), c = u.angleWithSep(l.x, l.y), h = l.add(u).unit().mult(-1 * e / Math.sin(c / 2));
                r.push(s.add(h));
            }
            return r;
        }, t1.an = Md, t1.ao = ql, t1.ap = function(t1, e, r = 0) {
            return O.vec3.fromValues(((e.x - r) * t1.scale - t1.x) * Wr, (e.y * t1.scale - t1.y) * Wr, dl(e.z, e.y));
        }, t1.aq = hu, t1.ar = zp, t1.as = function(t1) {
            let e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0;
            for (const a of t1)e = Math.min(e, a.x), r = Math.min(r, a.y), n = Math.max(n, a.x), i = Math.max(i, a.y);
            return {
                min: new q(e, r),
                max: new q(n, i)
            };
        }, t1.at = ul, t1.au = jl, t1.av = wl, t1.aw = Q, t1.ax = Yo, t1.ay = function(t1, e) {
            const r = {};
            for(let n = 0; n < e.length; n++){
                const i = e[n];
                i in t1 && (r[i] = t1[i]);
            }
            return r;
        }, t1.az = al, t1.b = function(t1) {
            return St.API_FONTS_REGEX.test(t1);
        }, t1.b$ = Bm, t1.b0 = xt, t1.b1 = Ap, t1.b2 = Uc, t1.b3 = zl, t1.b4 = xs, t1.b5 = Ys, t1.b6 = cu, t1.b7 = po, t1.b8 = hc, t1.b9 = hm, t1.bA = kh, t1.bB = pd, t1.bC = hd, t1.bD = Ef, t1.bE = fv, t1.bF = et, t1.bG = bt, t1.bH = hl, t1.bI = function(t1, e, r) {
            t1[4 * e + 0] = r[0], t1[4 * e + 1] = r[1], t1[4 * e + 2] = r[2], t1[4 * e + 3] = r[3];
        }, t1.bJ = Eo, t1.bK = Ao, t1.bL = So, t1.bM = Mo, t1.bN = wo, t1.bO = il, t1.bP = $d, t1.bQ = nu, t1.bR = gu, t1.bS = Tm, t1.bT = ru, t1.bU = Pu, t1.bV = function(t1, e, r, n, i, a, s, o, l) {
            if ("globe" === l.name) return Pu(t1, e, new ru(r, n, i), !1);
            const u = wd({
                z: r,
                x: n,
                y: i
            }, l);
            return new xu([
                (a + u.x / u.scale) * e,
                e * (u.y / u.scale),
                s
            ], [
                (a + u.x2 / u.scale) * e,
                e * (u.y2 / u.scale),
                o
            ]);
        }, t1.bW = function(t1, e, r) {
            let n = 0;
            for(let r = 0; r < 2; ++r){
                const i = 0;
                t1[r] > i && (n += (t1[r] - i) * (t1[r] - i)), e[r] < i && (n += (i - e[r]) * (i - e[r]));
            }
            return n;
        }, t1.bX = ml, t1.bY = Zo, t1.bZ = function(t1) {
            const e = O.mat4.identity(new Float64Array(16));
            O.mat4.multiply(e, t1.pixelMatrix, t1.globeMatrix);
            const r = [
                0,
                Jo,
                0
            ], n = [
                0,
                Qo,
                0
            ];
            return O.vec3.transformMat4(r, r, e), O.vec3.transformMat4(n, n, e), [
                r[0] > 0 && r[0] <= t1.width && r[1] > 0 && r[1] <= t1.height && !Nu(t1, new il(t1.center.lat, 90)),
                n[0] > 0 && n[0] <= t1.width && n[1] > 0 && n[1] <= t1.height && !Nu(t1, new il(t1.center.lat, -90))
            ];
        }, t1.b_ = function(t1, e) {
            const { scale: r } = t1.tileTransform, n = r * Wr / (t1.tileSize * Math.pow(2, e.zoom - t1.tileID.overscaledZ + t1.tileID.canonical.z));
            return O.mat2.scale(new Float32Array(4), e.inverseAdjustmentMatrix, [
                n,
                n
            ]);
        }, t1.ba = function(t1, e) {
            const r = Fu(e.zoom);
            if (0 === r) return Au(t1);
            const n = zu(t1), i = Eu(n), a = ul(n.getWest()) * e.worldSize, s = ul(n.getEast()) * e.worldSize, o = cl(n.getNorth()) * e.worldSize, l = cl(n.getSouth()) * e.worldSize, u = [
                a,
                o,
                0
            ], c = [
                s,
                o,
                0
            ], h = [
                a,
                l,
                0
            ], p = [
                s,
                l,
                0
            ], f = O.mat4.invert([], e.globeMatrix);
            return O.vec3.transformMat4(u, u, f), O.vec3.transformMat4(c, c, f), O.vec3.transformMat4(h, h, f), O.vec3.transformMat4(p, p, f), i[0] = Su(i[0], h, r), i[1] = Su(i[1], p, r), i[2] = Su(i[2], c, r), i[3] = Su(i[3], u, r), xu.fromPoints(i);
        }, t1.bb = Vu, t1.bc = ku, t1.bd = Su, t1.be = vs, t1.bf = uu, t1.bg = Ax, t1.bh = pf, t1.bi = ie, t1.bj = function(t1) {
            const e = [];
            for(const r in t1)e.push(t1[r]);
            return e;
        }, t1.bk = function(t1, e) {
            const r = [];
            for(const n in t1)n in e || r.push(n);
            return r;
        }, t1.bl = rt, t1.bm = [
            "type",
            "source",
            "source-layer",
            "minzoom",
            "maxzoom",
            "filter",
            "layout"
        ], t1.bn = $, t1.bo = function(t1, e) {
            const { x: r, y: n } = t1.point, i = Ru(r, n, t1.worldSize / t1._pixelsPerMercatorPixel, 0, 0);
            return O.mat4.multiply(i, i, Cu(Au(e)));
        }, t1.bp = Qp, t1.bq = xf, t1.br = Jp, t1.bs = function(t1, e, r, n, i) {
            const a = 5 * e + 2;
            t1.float32[a + 0] = r, t1.float32[a + 1] = n, t1.float32[a + 2] = i;
        }, t1.bt = Wd, t1.bu = Uf, t1.bv = Vl, t1.bw = Zp, t1.bx = bh, t1.by = Xm, t1.bz = Eh, t1.c = Pt, t1.c$ = (t1, e, r, n, i, a, s, o)=>{
            const l = t1.transform, u = l.pitch < 15 ? Ep(.07, .7, Q((14 - l.zoom) / 5, 0, 1)) : .07, c = "none" === r.paint.get("line-trim-color-use-theme").constantOr("default");
            return {
                u_matrix: Tp(t1, e, r, n),
                u_texsize: e.imageAtlasTexture ? e.imageAtlasTexture.size : [
                    0,
                    0
                ],
                u_pixels_to_tile_units: l.calculatePixelsToTileUnitsMatrix(e),
                u_device_pixel_ratio: i,
                u_width_scale: a,
                u_floor_width_scale: s,
                u_image: 0,
                u_tile_units_to_pixels: kp(e, l),
                u_units_to_pixels: [
                    1 / l.pixelsToGLUnits[0],
                    1 / l.pixelsToGLUnits[1]
                ],
                u_alpha_discard_threshold: 0,
                u_trim_offset: o,
                u_trim_fade_range: r.paint.get("line-trim-fade-range"),
                u_trim_color: r.paint.get("line-trim-color").toRenderColor(c ? null : r.lut).toArray01(),
                u_emissive_strength: r.paint.get("line-emissive-strength"),
                u_zbias_factor: u,
                u_tile_to_meter: vl(e.tileID.canonical, 0)
            };
        }, t1.c0 = km, t1.c1 = function(t1) {
            const e = km(t1, !0);
            return O.mat2.invert([], [
                e[0],
                e[1],
                e[4],
                e[5]
            ]);
        }, t1.c2 = pu, t1.c3 = function(t1) {
            const { x: e, y: r } = t1.point, { lng: n, lat: i } = t1._center;
            return Ru(e, r, t1.worldSize, n, i);
        }, t1.c4 = Z, t1.c5 = au, t1.c6 = Xo, t1.c7 = function(t1) {
            const e = Math.round((t1 + 45 + 360) % 360 / 90) % 4;
            return H[e];
        }, t1.c8 = 45, t1.c9 = ll, t1.cA = class extends _o {
            constructor(t1){
                super(t1), this.current = ko;
            }
            set(t1, e, r) {
                if (this.fetchUniformLocation(t1, e)) {
                    for(let t1 = 0; t1 < 9; t1++)if (r[t1] !== this.current[t1]) {
                        this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r);
                        break;
                    }
                }
            }
        }, t1.cB = W, t1.cC = function(t1, e, r) {
            const n = Fu(r.zoom), i = t1.style.map._antialias, a = e.options.extStandardDerivativesForceOff || t1.terrain && t1.terrain.exaggeration() > 0;
            return 0 === n && !i && !a;
        }, t1.cD = function(t1) {
            const e = t1.pixelsPerMeter, r = e / hl(1, t1.center.lat), n = O.mat4.identity(new Float64Array(16));
            return O.mat4.translate(n, n, [
                t1.point.x,
                t1.point.y,
                0
            ]), O.mat4.scale(n, n, [
                r,
                r,
                e
            ]), Float32Array.from(n);
        }, t1.cE = zu, t1.cF = function(t1) {
            const e = ml - 5;
            t1 = Q(t1, -e, e) / e * 90;
            const r = Math.pow(Math.abs(Math.sin(X(t1))), 3);
            return Math.round(r * (Ko.length - 1));
        }, t1.cG = function(t1, e, r, n) {
            const i = e.getNorth(), a = e.getSouth(), s = e.getWest(), o = e.getEast(), l = 1 << t1.z, u = o - s, c = i - a, h = u / Wo, p = -c / Ko[r], f = [
                0,
                h,
                0,
                p,
                0,
                0,
                i,
                s,
                0
            ];
            if (t1.z > 0) {
                const t1 = 180 / n;
                O.mat3.multiply(f, f, [
                    t1 / u + 1,
                    0,
                    0,
                    0,
                    t1 / c + 1,
                    0,
                    -.5 * t1 / h,
                    .5 * t1 / p,
                    1
                ]);
            }
            return f[2] = l, f[5] = t1.x, f[8] = t1.y, f;
        }, t1.cH = Au, t1.cI = function(t1, e, r) {
            const n = O.mat4.identity(new Float64Array(16)), i = (e / (1 << t1) - .5) * Math.PI * 2;
            return O.mat4.rotateY(n, r.globeMatrix, i), Float32Array.from(n);
        }, t1.cJ = class {
            isDataAvailableAtPoint(t1) {
                const e = this._source();
                if (this.isUsingMockSource() || !e || t1.y < 0 || t1.y > 1) return !1;
                const r = e.getSource().maxzoom, n = 1 << r, i = Math.floor(t1.x), a = Math.floor((t1.x - i) * n), s = Math.floor(t1.y * n), o = this.findDEMTileFor(new iu(r, i, r, a, s));
                return !(!o || !o.dem);
            }
            getAtPointOrZero(t1, e = 0) {
                return this.getAtPoint(t1, e) || 0;
            }
            getAtPoint(t1, e, r = !0) {
                if (this.isUsingMockSource()) return null;
                null == e && (e = null);
                const n = this._source();
                if (!n) return e;
                if (t1.y < 0 || t1.y > 1) return e;
                const i = n.getSource().maxzoom, a = 1 << i, s = Math.floor(t1.x), o = t1.x - s, l = new iu(i, s, i, Math.floor(o * a), Math.floor(t1.y * a)), u = this.findDEMTileFor(l);
                if (!u || !u.dem) return e;
                const c = u.dem, h = 1 << u.tileID.canonical.z, p = (o * h - u.tileID.canonical.x) * c.dim, f = (t1.y * h - u.tileID.canonical.y) * c.dim, d = Math.floor(p), m = Math.floor(f);
                return (r ? this.exaggeration() : 1) * ze(ze(c.get(d, m), c.get(d, m + 1), f - m), ze(c.get(d + 1, m), c.get(d + 1, m + 1), f - m), p - d);
            }
            getAtTileOffset(t1, e, r) {
                const n = 1 << t1.canonical.z;
                return this.getAtPointOrZero(new bl(t1.wrap + (t1.canonical.x + e / Wr) / n, (t1.canonical.y + r / Wr) / n));
            }
            getAtTileOffsetFunc(t1, e, r, n) {
                return (i)=>{
                    const a = this.getAtTileOffset(t1, i.x, i.y), s = n.upVector(t1.canonical, i.x, i.y), o = n.upVectorScale(t1.canonical, e, r).metersToTile;
                    return O.vec3.scale(s, s, a * o), s;
                };
            }
            getForTilePoints(t1, e, r, n) {
                if (this.isUsingMockSource()) return !1;
                const i = uy.create(this, t1, n);
                return !!i && (e.forEach((t1)=>{
                    t1[2] = this.exaggeration() * i.getElevationAt(t1[0], t1[1], r);
                }), !0);
            }
            getMinMaxForTile(t1) {
                if (this.isUsingMockSource()) return null;
                const e = this.findDEMTileFor(t1);
                if (!e || !e.dem) return null;
                const r = e.dem.tree, n = e.tileID, i = 1 << t1.canonical.z - n.canonical.z;
                let a = t1.canonical.x / i - n.canonical.x, s = t1.canonical.y / i - n.canonical.y, o = 0;
                for(let e = 0; e < t1.canonical.z - n.canonical.z && !r.leaves[o]; e++){
                    a *= 2, s *= 2;
                    const t1 = 2 * Math.floor(s) + Math.floor(a);
                    o = r.childOffsets[o] + t1, a %= 1, s %= 1;
                }
                return {
                    min: this.exaggeration() * r.minimums[o],
                    max: this.exaggeration() * r.maximums[o]
                };
            }
            getMinElevationBelowMSL() {
                throw new Error("Pure virtual method called.");
            }
            raycast(t1, e, r) {
                throw new Error("Pure virtual method called.");
            }
            pointCoordinate(t1) {
                throw new Error("Pure virtual method called.");
            }
            _source() {
                throw new Error("Pure virtual method called.");
            }
            isUsingMockSource() {
                throw new Error("Pure virtual method called.");
            }
            exaggeration() {
                throw new Error("Pure virtual method called.");
            }
            findDEMTileFor(t1) {
                throw new Error("Pure virtual method called.");
            }
            get visibleDemTiles() {
                throw new Error("Getter must be implemented in subclass.");
            }
            getMinMaxForVisibleTiles() {
                const t1 = this.visibleDemTiles;
                if (0 === t1.length) return null;
                let e = !1, r = Number.MAX_VALUE, n = Number.MIN_VALUE;
                for (const i of t1){
                    const t1 = this.getMinMaxForTile(i.tileID);
                    t1 && (r = Math.min(r, t1.min), n = Math.max(n, t1.max), e = !0);
                }
                return e ? {
                    min: r,
                    max: n
                } : null;
            }
        }, t1.cK = oc, t1.cL = vu, t1.cM = function(t1, e) {
            return [
                Math.pow(t1[0], 2.2) * e,
                Math.pow(t1[1], 2.2) * e,
                Math.pow(t1[2], 2.2) * e
            ];
        }, t1.cN = Lu, t1.cO = At, t1.cP = Mt, t1.cQ = 256, t1.cR = function(t1, e) {
            const r = [
                0,
                0,
                0
            ], n = Vu(Au(e.canonical));
            return O.vec3.transformMat4(r, r, n), O.vec3.transformMat4(r, r, t1), r;
        }, t1.cS = (t1)=>({
                u_camera_to_center_distance: new Mo(t1),
                u_extrude_scale: new Bo(t1),
                u_device_pixel_ratio: new Mo(t1),
                u_matrix: new Eo(t1),
                u_inv_rot_matrix: new Eo(t1),
                u_merc_center: new Ao(t1),
                u_tile_id: new So(t1),
                u_zoom_transition: new Mo(t1),
                u_up_dir: new So(t1),
                u_emissive_strength: new Mo(t1)
            }), t1.cT = (t1)=>({
                u_matrix: new Eo(t1),
                u_pixels_to_tile_units: new Bo(t1),
                u_device_pixel_ratio: new Mo(t1),
                u_width_scale: new Mo(t1),
                u_floor_width_scale: new Mo(t1),
                u_units_to_pixels: new Ao(t1),
                u_dash_image: new wo(t1),
                u_gradient_image: new wo(t1),
                u_image_height: new Mo(t1),
                u_texsize: new Ao(t1),
                u_tile_units_to_pixels: new Mo(t1),
                u_alpha_discard_threshold: new Mo(t1),
                u_trim_offset: new Ao(t1),
                u_trim_fade_range: new Ao(t1),
                u_trim_color: new Io(t1),
                u_emissive_strength: new Mo(t1),
                u_zbias_factor: new Mo(t1),
                u_tile_to_meter: new Mo(t1)
            }), t1.cU = (t1)=>({
                u_matrix: new Eo(t1),
                u_texsize: new Ao(t1),
                u_pixels_to_tile_units: new Bo(t1),
                u_device_pixel_ratio: new Mo(t1),
                u_width_scale: new Mo(t1),
                u_floor_width_scale: new Mo(t1),
                u_image: new wo(t1),
                u_units_to_pixels: new Ao(t1),
                u_tile_units_to_pixels: new Mo(t1),
                u_alpha_discard_threshold: new Mo(t1),
                u_trim_offset: new Ao(t1),
                u_trim_fade_range: new Ao(t1),
                u_trim_color: new Io(t1),
                u_emissive_strength: new Mo(t1),
                u_zbias_factor: new Mo(t1),
                u_tile_to_meter: new Mo(t1)
            }), t1.cV = Cs, t1.cW = Xp, t1.cX = tf, t1.cY = Gu, t1.cZ = (t1, e, r, n, i, a)=>{
            const s = t1.transform, o = "globe" === s.projection.name;
            let l;
            if ("map" === a.paint.get("circle-pitch-alignment")) if (o) {
                const t1 = Lu(s.zoom, e.canonical) * s._pixelsPerMercatorPixel;
                l = Float32Array.from([
                    t1,
                    0,
                    0,
                    t1
                ]);
            } else l = s.calculatePixelsToTileUnitsMatrix(r);
            else l = new Float32Array([
                s.pixelsToGLUnits[0],
                0,
                0,
                s.pixelsToGLUnits[1]
            ]);
            const u = {
                u_camera_to_center_distance: t1.transform.getCameraToCenterDistance(s.projection),
                u_matrix: t1.translatePosMatrix(e.projMatrix, r, a.paint.get("circle-translate"), a.paint.get("circle-translate-anchor")),
                u_device_pixel_ratio: Dt.devicePixelRatio,
                u_extrude_scale: l,
                u_inv_rot_matrix: $u,
                u_merc_center: [
                    0,
                    0
                ],
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_up_dir: [
                    0,
                    0,
                    0
                ],
                u_emissive_strength: a.paint.get("circle-emissive-strength")
            };
            if (o) {
                u.u_inv_rot_matrix = n, u.u_merc_center = i, u.u_tile_id = [
                    e.canonical.x,
                    e.canonical.y,
                    1 << e.canonical.z
                ], u.u_zoom_transition = Fu(s.zoom);
                const t1 = i[0] * Wr, r = i[1] * Wr;
                u.u_up_dir = s.projection.upVector(new ru(0, 0, 0), t1, r);
            }
            return u;
        }, t1.c_ = Bp, t1.ca = Io, t1.cb = function(t1, e, r) {
            const n = Math.sqrt(t1 * t1 + e * e + r * r), i = n > 0 ? Math.acos(r / n) * Y : 0;
            let a = 0 !== t1 || 0 !== e ? Math.atan2(-e, -t1) * Y + 90 : 0;
            return a < 0 && (a += 360), [
                n,
                a,
                i
            ];
        }, t1.cc = vl, t1.cd = xu, t1.ce = yt, t1.cf = function(t1) {
            return [
                Math.pow(t1[0], 1 / 2.2),
                Math.pow(t1[1], 1 / 2.2),
                Math.pow(t1[2], 1 / 2.2)
            ];
        }, t1.cg = function(t1, e) {
            return t1.readFields(Oy, {
                icons: []
            }, e);
        }, t1.ch = function(t1) {
            return t1({
                pluginStatus: Sa,
                pluginURL: Ia
            }), Ea.on("pluginStateChange", t1), t1;
        }, t1.ci = Ty, t1.cj = Kf, t1.ck = Wf, t1.cl = re, t1.cm = Pa, t1.cn = Rt, t1.co = ge, t1.cp = ht, t1.cq = function(t1) {
            const e = t1.indexOf(ls);
            return e >= 0 ? t1.slice(0, e) : t1;
        }, t1.cr = function(t1) {
            return t1.indexOf(ls) >= 0;
        }, t1.cs = function(t1) {
            const e = t1.indexOf(ls);
            return e >= 0 ? t1.slice(e + 1) : "";
        }, t1.ct = function(t1) {
            const e = [], r = t1.id;
            return void 0 === r && e.push({
                message: `layers.${r}: missing required property "id"`
            }), void 0 === t1.render && e.push({
                message: `layers.${r}: missing required method "render"`
            }), t1.renderingMode && "2d" !== t1.renderingMode && "3d" !== t1.renderingMode && e.push({
                message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"`
            }), e;
        }, t1.cu = function(t1, e, r, n) {
            return "custom" === t1.type ? new zm(t1, e) : new _y[t1.type](t1, e, r, n);
        }, t1.cv = ct, t1.cw = class extends lv {
            constructor(t1, e){
                super(t1._vectorTileFeature, t1._z, t1._x, t1._y, t1.id), t1.state && (this.state = {
                    ...t1.state
                }), this.target = e.target, this.namespace = e.namespace, e.properties && (this.properties = e.properties), this.target && ("featuresetId" in this.target && !this.target.importId || "layerId" in this.target) && (this.source = t1.source, this.sourceLayer = t1.sourceLayer, this.layer = t1.layer);
            }
            toJSON() {
                const t1 = super.toJSON();
                return t1.target = this.target, t1.namespace = this.namespace, t1;
            }
        }, t1.cx = Ea, t1.cy = ne, t1.cz = Po, t1.d = function(t1) {
            return St.API_TILEJSON_REGEX.test(t1);
        }, t1.d$ = ut, t1.d0 = (t1, e, r, n, i, a, s, o, l)=>{
            const u = t1.transform, c = u.calculatePixelsToTileUnitsMatrix(e), h = "none" === r.paint.get("line-trim-color-use-theme").constantOr("default"), p = u.pitch < 15 ? Ep(.07, .7, Q((14 - u.zoom) / 5, 0, 1)) : .07;
            return {
                u_matrix: Tp(t1, e, r, n),
                u_pixels_to_tile_units: c,
                u_device_pixel_ratio: a,
                u_width_scale: s,
                u_floor_width_scale: o,
                u_units_to_pixels: [
                    1 / u.pixelsToGLUnits[0],
                    1 / u.pixelsToGLUnits[1]
                ],
                u_dash_image: 0,
                u_gradient_image: 1,
                u_image_height: i,
                u_texsize: Vp(r) && e.lineAtlasTexture ? e.lineAtlasTexture.size : [
                    0,
                    0
                ],
                u_tile_units_to_pixels: kp(e, t1.transform),
                u_alpha_discard_threshold: 0,
                u_trim_offset: l,
                u_trim_fade_range: r.paint.get("line-trim-fade-range"),
                u_trim_color: r.paint.get("line-trim-color").toRenderColor(h ? null : r.lut).toArray01(),
                u_emissive_strength: r.paint.get("line-emissive-strength"),
                u_zbias_factor: p,
                u_tile_to_meter: vl(e.tileID.canonical, 0)
            };
        }, t1.d1 = st, t1.d2 = lc, t1.d3 = ap, t1.d4 = su, t1.d5 = Kh, t1.d6 = Oh, t1.d7 = 450, t1.d8 = 7, t1.d9 = bm, t1.dA = J, t1.dB = xl, t1.dC = el, t1.dD = function([t1, e, r]) {
            const n = Math.hypot(t1, e, r), i = Math.atan2(t1, r), a = .5 * Math.PI - Math.acos(-e / n);
            return new il(Z(i), Z(a));
        }, t1.dE = Cm, t1.dF = function(t1) {
            const e = t1.navigator ? t1.navigator.userAgent : null;
            return !!function(t1) {
                if (null == vt) {
                    const e = t1.navigator ? t1.navigator.userAgent : null;
                    vt = !!t1.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")));
                }
                return vt;
            }(t1) && e && (e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));
        }, t1.dG = function(t1, e) {
            Ot = t1, Nt = e;
        }, t1.dH = Nu, t1.dI = Ou, t1.dJ = function(t1) {
            const e = [
                0,
                0,
                0
            ], r = O.mat4.identity(new Float64Array(16));
            return O.mat4.multiply(r, t1.pixelMatrix, t1.globeMatrix), O.vec3.transformMat4(e, e, r), new q(e[0], e[1]);
        }, t1.dK = function(t1, e, r = !1) {
            if (Sa === _a || Sa === wa || Sa === Ma) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            Ia = Dt.resolveURL(t1), Sa = _a, Aa = e, za(), r || Ta();
        }, t1.dL = ka, t1.dM = function() {
            Ty().acquire(Iy);
        }, t1.dN = function() {
            const t1 = Ey;
            t1 && (t1.isPreloaded() && 1 === t1.numActive() ? (t1.release(Iy), Ey = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, t1.dO = Py, t1.dP = function(t1) {
            const e = $t();
            if (!e) return;
            const r = e.delete(Ft);
            t1 && r.catch(t1).then(()=>t1());
        }, t1.dQ = Sy, t1.dR = Vx, t1.dS = function(t1) {
            zx = Dt.resolveURL(t1), Bx || (Bx = new zy(Ty(), new we)), Bx.broadcast("setDracoUrl", zx);
        }, t1.dT = Cx, t1.dU = function(t1) {
            kx = Dt.resolveURL(t1), Bx || (Bx = new zy(Ty(), new we)), Bx.broadcast("setMeshoptUrl", kx);
        }, t1.dV = oa, t1.dW = ac, t1.dX = Hf, t1.dY = sv, t1.dZ = uv, t1.d_ = bp, t1.da = ys, t1.db = Hs, t1.dc = 256, t1.dd = Cu, t1.de = As, t1.df = Ns, t1.dg = Us, t1.dh = function(t1, e, r, n, i) {
            return Q((t1 - e) / (r - e) * (i - n) + n, n, i);
        }, t1.di = Ii, t1.dj = gl, t1.dk = class {
            constructor(t1, e, r, n){
                this.context = t1, this.format = n, this.size = r, this.texture = t1.gl.createTexture();
                const [i, a, s] = this.size, { gl: o } = t1;
                o.bindTexture(o.TEXTURE_3D, this.texture), t1.pixelStoreUnpackFlipY.set(!1), t1.pixelStoreUnpack.set(1), t1.pixelStoreUnpackPremultiplyAlpha.set(!1), o.texImage3D(o.TEXTURE_3D, 0, this.format, i, a, s, 0, pm(this.format), fm(this.format), e.data);
            }
            bind(t1, e) {
                const { context: r } = this, { gl: n } = r;
                n.bindTexture(n.TEXTURE_3D, this.texture), t1 !== this.minFilter && (n.texParameteri(n.TEXTURE_3D, n.TEXTURE_MAG_FILTER, t1), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_MIN_FILTER, t1), this.minFilter = t1), e !== this.wrapS && (n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_T, e), this.wrapS = e);
            }
            destroy() {
                const { gl: t1 } = this.context;
                t1.deleteTexture(this.texture), this.texture = null;
            }
        }, t1.dl = Fm, t1.dm = [
            1,
            1,
            1
        ], t1.dn = uy, t1.dp = ry, t1.dq = Ts, t1.dr = $s, t1.ds = rl, t1.dt = qs, t1.du = js, t1.dv = class {
            constructor(){
                this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = {
                    min: new q(1 / 0, 1 / 0),
                    max: new q(-1 / 0, -1 / 0)
                };
            }
            clear() {
                this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
            }
            get updateTime() {
                return this._updateTime;
            }
            getReplacementRegionsForTile(t1, e = !1) {
                const r = Sh(new q(0, 0), new q(Wr, Wr), t1), n = [];
                if (e && !Mh(r, this._globalClipBounds)) return n;
                for (const e of this._activeRegions){
                    if (e.hiddenByOverlap) continue;
                    if (!Mh(r, e)) continue;
                    const i = Ih(e.min, e.max, t1);
                    n.push({
                        min: i.min,
                        max: i.max,
                        sourceId: this._sourceIds[e.priority],
                        footprint: e.footprint,
                        footprintTileId: e.tileId,
                        order: e.order,
                        clipMask: e.clipMask,
                        clipScope: e.clipScope
                    });
                }
                return n;
            }
            setSources(t1) {
                this._setSources(t1.map((t1)=>({
                        getSourceId: ()=>t1.cache.id,
                        getFootprints: ()=>{
                            const e = [];
                            for (const r of t1.cache.getVisibleCoordinates()){
                                const n = t1.cache.getTile(r).buckets[t1.layer];
                                n && n.updateFootprints(r.toUnwrapped(), e);
                            }
                            return e;
                        },
                        getOrder: ()=>t1.order,
                        getClipMask: ()=>t1.clipMask,
                        getClipScope: ()=>t1.clipScope
                    })));
            }
            _addSource(t1) {
                const e = t1.getFootprints();
                if (0 === e.length) return;
                const r = t1.getOrder(), n = t1.getClipMask(), i = t1.getClipScope();
                for (const t1 of e){
                    if (!t1.footprint) continue;
                    const e = Sh(t1.footprint.min, t1.footprint.max, t1.id);
                    this._activeRegions.push({
                        min: e.min,
                        max: e.max,
                        hiddenByOverlap: !1,
                        priority: this._sourceIds.length,
                        tileId: t1.id,
                        footprint: t1.footprint,
                        order: r,
                        clipMask: n,
                        clipScope: i
                    });
                }
                this._sourceIds.push(t1.getSourceId());
            }
            _computeReplacement() {
                this._activeRegions.sort((t1, e)=>t1.priority - e.priority || _h(t1.min, e.min) || _h(t1.max, e.max) || t1.order - e.order || t1.clipMask - e.clipMask || function(t1, e) {
                        const r = (t1, e)=>t1 + e;
                        return t1.length - e.length || t1.reduce(r, "").localeCompare(e.reduce(r, ""));
                    }(t1.clipScope, e.clipScope));
                let t1 = this._activeRegions.length !== this._prevRegions.length;
                if (!t1) {
                    let e = 0;
                    for(; !t1 && e !== this._activeRegions.length;){
                        const r = this._activeRegions[e], n = this._prevRegions[e];
                        t1 = r.priority !== n.priority || !wh(r, n) || r.order !== n.order || r.clipMask !== n.clipMask || !$(r.clipScope, n.clipScope), ++e;
                    }
                }
                if (t1) {
                    ++this._updateTime;
                    for (const t1 of this._activeRegions)t1.order !== vh && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, t1.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, t1.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, t1.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, t1.max.y));
                    const t1 = (t1)=>{
                        const e = this._activeRegions;
                        if (t1 >= e.length) return t1;
                        const r = e[t1].priority;
                        for(; t1 < e.length && e[t1].priority === r;)++t1;
                        return t1;
                    };
                    if (this._sourceIds.length > 1) {
                        let e = 0, r = t1(e);
                        for(; e !== r;){
                            let n = e;
                            const i = e;
                            for(; n !== r;){
                                const t1 = this._activeRegions[n];
                                t1.hiddenByOverlap = !1;
                                for(let e = 0; e < i; e++){
                                    const r = this._activeRegions[e];
                                    if (!r.hiddenByOverlap && t1.order === vh && Mh(t1, r) && (t1.hiddenByOverlap = zh(t1.footprint, t1.tileId, r.footprint, r.tileId), t1.hiddenByOverlap)) break;
                                }
                                ++n;
                            }
                            e = r, r = t1(e);
                        }
                    }
                }
            }
            _setSources(t1) {
                [this._prevRegions, this._activeRegions] = [
                    this._activeRegions,
                    []
                ], this._sourceIds = [];
                for(let e = t1.length - 1; e >= 0; e--)this._addSource(t1[e]);
                this._computeReplacement();
            }
        }, t1.dw = class {
            constructor(t1){
                this._createGrid(t1), this._createPoles(t1);
            }
            destroy() {
                this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
                for (const t1 of this._poleSegments)t1.destroy();
                for (const t1 of this._gridSegments)t1.withSkirts.destroy(), t1.withoutSkirts.destroy();
            }
            _fillGridMeshWithLods(t1, e) {
                const r = new xs, n = new Ls, i = [], a = t1 + 1 + 2, s = e[0] + 1, o = e[0] + 1 + (1 + e.length), l = (t1, e, r)=>{
                    let n = t1 === a - 1 ? t1 - 2 : 0 === t1 ? t1 : t1 - 1;
                    return n += r ? 24575 : 0, [
                        n,
                        e
                    ];
                };
                for(let t1 = 0; t1 < a; ++t1)r.emplaceBack(...l(t1, 0, !0));
                for(let t1 = 0; t1 < s; ++t1)for(let e = 0; e < a; ++e)r.emplaceBack(...l(e, t1, (0 === e || e === a - 1) && !0));
                for(let t1 = 0; t1 < e.length; ++t1){
                    const n = e[t1];
                    for(let t1 = 0; t1 < a; ++t1)r.emplaceBack(...l(t1, n, !0));
                }
                for(let t1 = 0; t1 < e.length; ++t1){
                    const s = n.length, l = e[t1] + 1 + 2, u = new Ls;
                    for(let r = 0; r < l - 1; r++){
                        const i = r === l - 2, s = i ? a * (o - e.length + t1 - r) : a;
                        for(let t1 = 0; t1 < a - 1; t1++){
                            const e = r * a + t1;
                            0 === r || i || 0 === t1 || t1 === a - 2 ? (u.emplaceBack(e + 1, e, e + s), u.emplaceBack(e + s, e + s + 1, e + 1)) : (n.emplaceBack(e + 1, e, e + s), n.emplaceBack(e + s, e + s + 1, e + 1));
                        }
                    }
                    const c = po.simpleSegment(0, s, r.length, n.length - s);
                    for(let t1 = 0; t1 < u.uint16.length; t1 += 3)n.emplaceBack(u.uint16[t1], u.uint16[t1 + 1], u.uint16[t1 + 2]);
                    const h = po.simpleSegment(0, s, r.length, n.length - s);
                    i.push({
                        withoutSkirts: c,
                        withSkirts: h
                    });
                }
                return {
                    vertices: r,
                    indices: n,
                    segments: i
                };
            }
            _createGrid(t1) {
                const e = this._fillGridMeshWithLods(Wo, Ko);
                this._gridSegments = e.segments, this._gridBuffer = t1.createVertexBuffer(e.vertices, cu.members), this._gridIndexBuffer = t1.createIndexBuffer(e.indices, !0);
            }
            _createPoles(t1) {
                const e = new Ls;
                for(let t1 = 0; t1 <= Wo; t1++)e.emplaceBack(0, t1 + 1, t1 + 2);
                this._poleIndexBuffer = t1.createIndexBuffer(e, !0);
                const r = new Ns, n = new Ns, i = new Ns, a = new Ns;
                this._poleSegments = [];
                for(let t1 = 0, e = 0; t1 < Xo; t1++){
                    const s = 360 / (1 << t1);
                    r.emplaceBack(0, -Yo, 0, .5, 0), n.emplaceBack(0, -Yo, 0, .5, 1), i.emplaceBack(0, -Yo, 0, .5, .5), a.emplaceBack(0, -Yo, 0, .5, .5);
                    for(let t1 = 0; t1 <= Wo; t1++){
                        let e = t1 / Wo, o = 0;
                        const l = ze(0, s, e), [u, c, h] = tl(ju, qu, l, Yo);
                        r.emplaceBack(u, c, h, e, o), n.emplaceBack(u, c, h, e, 1 - o);
                        const p = X(l);
                        e = .5 + .5 * Math.sin(p), o = .5 + .5 * Math.cos(p), i.emplaceBack(u, c, h, e, o), a.emplaceBack(u, c, h, e, 1 - o);
                    }
                    this._poleSegments.push(po.simpleSegment(e, 0, 66, 64)), e += 66;
                }
                this._poleNorthVertexBuffer = t1.createVertexBuffer(r, lu, !1), this._poleSouthVertexBuffer = t1.createVertexBuffer(n, lu, !1), this._texturedPoleNorthVertexBuffer = t1.createVertexBuffer(i, lu, !1), this._texturedPoleSouthVertexBuffer = t1.createVertexBuffer(a, lu, !1);
            }
            getGridBuffers(t1, e) {
                return [
                    this._gridBuffer,
                    this._gridIndexBuffer,
                    e ? this._gridSegments[t1].withSkirts : this._gridSegments[t1].withoutSkirts
                ];
            }
            getPoleBuffers(t1, e) {
                return [
                    e ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer,
                    e ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer,
                    this._poleIndexBuffer,
                    this._poleSegments[t1]
                ];
            }
        }, t1.dx = vh, t1.dy = K, t1.dz = function() {
            return !!document.fullscreenElement || !!document.webkitFullscreenElement;
        }, t1.e = St, t1.e0 = Qe, t1.e1 = Gf, t1.e2 = function(t1, e, r, n, i, a, s, o, l, u, c = 1, h, p) {
            t1.createArrays(), t1.tilePixelRatio = Wr / (512 * t1.overscaling), t1.compareText = {}, t1.iconsNeedLinear = !1;
            const f = t1.layers[0].layout, d = t1.layers[0]._unevaluatedLayout._values, m = {};
            m.scaleFactor = c, m.textSizeScaleRange = f.get("text-size-scale-range"), m.iconSizeScaleRange = f.get("icon-size-scale-range");
            const [y, g] = m.textSizeScaleRange, [x, v] = m.iconSizeScaleRange;
            if (m.textScaleFactor = Q(m.scaleFactor, y, g), m.iconScaleFactor = Q(m.scaleFactor, x, v), "composite" === t1.textSizeData.kind) {
                const { minZoom: e, maxZoom: r } = t1.textSizeData;
                m.compositeTextSizes = [
                    d["text-size"].possiblyEvaluate(new Va(e), o),
                    d["text-size"].possiblyEvaluate(new Va(r), o)
                ];
            }
            if ("composite" === t1.iconSizeData.kind) {
                const { minZoom: e, maxZoom: r } = t1.iconSizeData;
                m.compositeIconSizes = [
                    d["icon-size"].possiblyEvaluate(new Va(e), o),
                    d["icon-size"].possiblyEvaluate(new Va(r), o)
                ];
            }
            m.layoutTextSize = d["text-size"].possiblyEvaluate(new Va(l + 1), o), m.layoutIconSize = d["icon-size"].possiblyEvaluate(new Va(l + 1), o), m.textMaxSize = d["text-size"].possiblyEvaluate(new Va(18), o);
            const b = "map" === f.get("text-rotation-alignment") && "point" !== f.get("symbol-placement"), _ = f.get("text-size");
            let w = !1;
            for (const e of t1.features)if (e.icon && e.icon.nameSecondary) {
                w = !0;
                break;
            }
            for (const a of t1.features){
                const l = f.get("text-font").evaluate(a, {}, o).join(","), c = _.evaluate(a, {}, o) * m.textScaleFactor, y = m.layoutTextSize.evaluate(a, {}, o) * m.textScaleFactor, g = (m.layoutIconSize.evaluate(a, {}, o), {
                    horizontal: {},
                    vertical: void 0
                }), x = a.text;
                let v, M = [
                    0,
                    0
                ];
                if (x) {
                    const n = x.toString(), s = f.get("text-letter-spacing").evaluate(a, {}, o) * Zp, u = f.get("text-line-height").evaluate(a, {}, o) * Zp, h = da(n) ? s : 0, p = f.get("text-anchor").evaluate(a, {}, o), d = f.get("text-variable-anchor");
                    if (!d) {
                        const t1 = f.get("text-radial-offset").evaluate(a, {}, o);
                        M = t1 ? hd(p, [
                            t1 * Zp,
                            ud
                        ]) : f.get("text-offset").evaluate(a, {}, o).map((t1)=>t1 * Zp);
                    }
                    let m = b ? "center" : f.get("text-justify").evaluate(a, {}, o);
                    const v = "point" === f.get("symbol-placement"), _ = v ? f.get("text-max-width").evaluate(a, {}, o) * Zp : 1 / 0, w = (a)=>{
                        t1.allowVerticalPlacement && fa(n) && (g.vertical = _f(x, e, r, i, l, _, u, p, a, h, M, xf.vertical, !0, y, c));
                    };
                    if (!b && d) {
                        const t1 = "auto" === m ? d.map((t1)=>pd(t1)) : [
                            m
                        ];
                        let n = !1;
                        for(let a = 0; a < t1.length; a++){
                            const s = t1[a];
                            if (!g.horizontal[s]) if (n) g.horizontal[s] = g.horizontal[0];
                            else {
                                const t1 = _f(x, e, r, i, l, _, u, "center", s, h, M, xf.horizontal, !1, y, c);
                                t1 && (g.horizontal[s] = t1, n = 1 === t1.positionedLines.length);
                            }
                        }
                        w("left");
                    } else {
                        if ("auto" === m && (m = pd(p)), v || f.get("text-writing-mode").indexOf("horizontal") >= 0 || !fa(n)) {
                            const t1 = _f(x, e, r, i, l, _, u, p, m, h, M, xf.horizontal, !1, y, c);
                            t1 && (g.horizontal[m] = t1);
                        }
                        w(v ? "left" : m);
                    }
                }
                let A = !1, S = !1;
                if (a.icon && a.icon.namePrimary) {
                    const e = Wp(t1.iconSizeData, d["icon-size"], o, t1.zoom, a) * m.iconScaleFactor * h, r = a.icon.getPrimary().scaleSelf(e).serialize(), s = n[r];
                    s && (v = Tf(i[r], a.icon.nameSecondary ? i[a.icon.getSecondary().scaleSelf(e).serialize()] : void 0, f.get("icon-offset").evaluate(a, {}, o), f.get("icon-anchor").evaluate(a, {}, o)), A = s.sdf, S = s.usvg, void 0 === t1.sdfIcons ? t1.sdfIcons = s.sdf : t1.sdfIcons !== s.sdf && ft("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (s.pixelRatio !== t1.pixelRatio || 0 !== f.get("icon-rotate").constantOr(1)) && (t1.iconsNeedLinear = !0));
                }
                const I = gd(g.horizontal) || g.vertical;
                t1.iconsInText || (t1.iconsInText = !!I && I.iconsInText), (I || v) && fd(t1, a, g, v, n, m, y, 0, M, A, S, s, o, u, p, w);
            }
            a && t1.generateCollisionDebugBuffers(l, t1.collisionBoxArray, m.textScaleFactor);
        }, t1.e3 = fh, t1.e4 = Cg, t1.e5 = j, t1.e6 = ph, t1.e7 = hf, t1.e8 = e, t1.e9 = function(t1) {
            let e = 0;
            if (new Uint32Array(t1, 0, 1)[0] !== qx) {
                const r = new Uint32Array(t1, 0, 7), [, , n, i, a, s] = r;
                e = r.byteLength + i + a + s + a, (n !== t1.byteLength || e >= t1.byteLength) && ft("Invalid b3dm header information.");
            }
            return Hx(t1, e);
        }, t1.ea = function(t1, e) {
            const r = nv(t1);
            for (const t1 of r){
                for (const e of t1.meshes)iv(e);
                t1.lights && (t1.lightMeshIndex = t1.meshes.length, t1.meshes.push(av(t1.lights, e)));
            }
            return r;
        }, t1.eb = yy, t1.ec = Ay, t1.ed = Ba, t1.ee = function(t1) {
            Gt(), null != jt && jt.then((e)=>{
                e.keys().then((r)=>{
                    for(let n = 0; n < r.length - t1; n++)e.delete(r[n]);
                });
            });
        }, t1.f = function(t1) {
            return 0 === t1.indexOf("mapbox:");
        }, t1.g = function(t1, e) {
            return ne(nt(t1, {
                method: "GET"
            }), e);
        }, t1.h = It, t1.i = function(t1) {
            return St.API_STYLE_REGEX.test(t1) && !Pt(t1);
        }, t1.j = function(t1) {
            return decodeURIComponent(atob(t1).split("").map((t1)=>"%" + ("00" + t1.charCodeAt(0).toString(16)).slice(-2)).join(""));
        }, t1.k = function(t1) {
            return btoa(encodeURIComponent(t1).replace(/%([0-9A-F]{2})/g, (t1, e)=>String.fromCharCode(Number("0x" + e))));
        }, t1.l = nt, t1.m = Xt, t1.n = function(t1, e) {
            return ne(nt(t1, {
                type: "json"
            }), e);
        }, t1.o = ue, t1.p = function(t1, e) {
            return ne(nt(t1, {
                method: "POST"
            }), e);
        }, t1.q = Dt, t1.r = sc, t1.s = function(t1) {
            try {
                const e = self[t1];
                return e.setItem("_mapbox_test_", 1), e.removeItem("_mapbox_test_"), !0;
            } catch (t1) {
                return !1;
            }
        }, t1.t = Ct, t1.u = function() {
            return function t1(e) {
                return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([
                    1e7
                ] + -[
                    1e3
                ] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t1);
            }();
        }, t1.v = function(t1) {
            return !!t1 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t1);
        }, t1.w = ft, t1.x = function() {
            return ky || (ky = new Py), ky;
        }, t1.y = ve, t1.z = xe;
    });
    define([
        "./shared"
    ], function(e) {
        function t1(e) {
            const t1 = e ? e.url.toString() : void 0;
            return t1 ? performance.getEntriesByName(t1) : [];
        }
        function s(e) {
            if ("number" == typeof e || "boolean" == typeof e || "string" == typeof e || null == e) return JSON.stringify(e);
            if (Array.isArray(e)) {
                let t1 = "[";
                for (const i of e)t1 += `${s(i)},`;
                return `${t1}]`;
            }
            let t1 = "{";
            for (const i of Object.keys(e).sort())t1 += `${i}:${s(e[i])},`;
            return `${t1}}`;
        }
        function i(t1) {
            let i = "";
            for (const o of e.bm)i += `/${s(t1[o])}`;
            return i;
        }
        class o {
            constructor(e){
                this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e && this.replace(e);
            }
            replace(e, t1) {
                this._layerConfigs = {}, this._layers = {}, this.update(e, [], t1);
            }
            update(t1, o, n) {
                this._options = n;
                for (const s of t1)this._layerConfigs[s.id] = s, (this._layers[s.id] = e.cu(s, this.scope, null, this._options)).compileFilter(n), this.keyCache[s.id] && delete this.keyCache[s.id];
                for (const e of o)delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];
                this.familiesBySource = {};
                const r = function(e, t1) {
                    const o = {};
                    for(let n = 0; n < e.length; n++){
                        const r = e[n];
                        let a = t1 && t1[r.id];
                        !a && (a = i(r), "line" === r.type && r.paint) && function e(t1) {
                            return "string" == typeof t1 && "line-progress" === t1 || (Array.isArray(t1) ? t1.some(e) : !(!t1 || "object" != typeof t1) && Object.values(t1).some(e));
                        }(r.paint["line-width"]) && (a += `/${s(r.paint["line-width"])}`), t1 && (t1[r.id] = a);
                        let l = o[a];
                        l || (l = o[a] = []), l.push(r);
                    }
                    const n = [];
                    for(const e in o)n.push(o[e]);
                    return n;
                }(e.bj(this._layerConfigs), this.keyCache);
                for (const e of r){
                    const t1 = e.map((e)=>this._layers[e.id]), s = t1[0];
                    if ("none" === s.visibility) continue;
                    const i = s.source || "";
                    let o = this.familiesBySource[i];
                    o || (o = this.familiesBySource[i] = {});
                    const n = s.sourceLayer || "_geojsonTileLayer";
                    let r = o[n];
                    r || (r = o[n] = []), r.push(t1);
                }
            }
        }
        const n = 1 * e.dX;
        class r {
            constructor(t1){
                const s = {}, i = [];
                for(const e in t1){
                    const o = t1[e], r = s[e] = {};
                    for(const e in o.glyphs){
                        const t1 = o.glyphs[+e];
                        if (!t1 || 0 === t1.bitmap.width || 0 === t1.bitmap.height) continue;
                        const s = t1.metrics.localGlyph ? n : 1, a = {
                            x: 0,
                            y: 0,
                            w: t1.bitmap.width + 2 * s,
                            h: t1.bitmap.height + 2 * s
                        };
                        i.push(a), r[e] = a;
                    }
                }
                const { w: o, h: r } = e.C(i), a = new e.dW({
                    width: o || 1,
                    height: r || 1
                });
                for(const i in t1){
                    const o = t1[i];
                    for(const t1 in o.glyphs){
                        const r = o.glyphs[+t1];
                        if (!r || 0 === r.bitmap.width || 0 === r.bitmap.height) continue;
                        const l = s[i][t1], c = r.metrics.localGlyph ? n : 1;
                        e.dW.copy(r.bitmap, a, {
                            x: 0,
                            y: 0
                        }, {
                            x: l.x + c,
                            y: l.y + c
                        }, r.bitmap);
                    }
                }
                this.image = a, this.positions = s;
            }
        }
        e.dV(r, "GlyphAtlas");
        class a {
            constructor(t1){
                this.tileID = new e.aG(t1.tileID.overscaledZ, t1.tileID.wrap, t1.tileID.canonical.z, t1.tileID.canonical.x, t1.tileID.canonical.y), this.tileZoom = t1.tileZoom, this.uid = t1.uid, this.zoom = t1.zoom, this.lut = t1.lut, this.canonical = t1.tileID.canonical, this.pixelRatio = t1.pixelRatio, this.tileSize = t1.tileSize, this.source = t1.source, this.scope = t1.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t1.showCollisionBoxes, this.collectResourceTiming = !!t1.request && t1.request.collectResourceTiming, this.promoteId = t1.promoteId, this.isSymbolTile = t1.isSymbolTile, this.tileTransform = e.aQ(t1.tileID.canonical, t1.projection), this.projection = t1.projection, this.worldview = t1.worldview, this.localizableLayerIds = t1.localizableLayerIds, this.brightness = t1.brightness, this.extraShadowCaster = !!t1.extraShadowCaster, this.tessellationStep = t1.tessellationStep, this.scaleFactor = t1.scaleFactor;
            }
            parse(t1, s, i, o, n) {
                this.status = "parsing", this.data = t1, this.collisionBoxArray = new e.aW;
                const a = new e.dY(Object.keys(t1.layers).sort()), c = new e.dZ(this.tileID, this.promoteId);
                c.bucketLayerIDs = [];
                const h = {}, u = new e.d_(256, 256), d = {
                    featureIndex: c,
                    iconDependencies: {},
                    patternDependencies: {},
                    glyphDependencies: {},
                    lineAtlas: u,
                    availableImages: i,
                    brightness: this.brightness,
                    scaleFactor: this.scaleFactor
                }, f = s.familiesBySource[this.source];
                for(const s in f){
                    const o = t1.layers[s];
                    if (!o) continue;
                    let n = !1, r = !1, u = !1;
                    for (const e of f[s])"symbol" === e[0].type ? n = !0 : r = !0, e[0].is3D() && "model" !== e[0].type && (u = !0);
                    if (this.extraShadowCaster && !u) continue;
                    if (!0 === this.isSymbolTile && !n) continue;
                    if (!1 === this.isSymbolTile && !r) continue;
                    1 === o.version && e.w(`Vector tile source "${this.source}" layer "${s}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                    const p = a.encode(s), g = [];
                    for(let e = 0, t1 = 0; e < o.length; e++){
                        const i = o.feature(e), n = c.getId(i, s);
                        if (this.localizableLayerIds && this.localizableLayerIds.has(s)) {
                            const e = i.properties ? i.properties.worldview : null;
                            if (this.worldview && "string" == typeof e) if ("all" === e) i.properties.$localized = !0;
                            else {
                                if (!e.split(",").includes(this.worldview)) continue;
                                i.properties.$localized = !0, i.properties.worldview = this.worldview;
                            }
                        }
                        g.push({
                            feature: i,
                            id: n,
                            index: t1,
                            sourceLayerIndex: p
                        }), t1++;
                    }
                    for (const t1 of f[s]){
                        const s = t1[0];
                        (!this.extraShadowCaster || s.is3D() && "model" !== s.type) && (void 0 !== this.isSymbolTile && "symbol" === s.type !== this.isSymbolTile || s.minzoom && this.zoom < Math.floor(s.minzoom) || s.maxzoom && this.zoom >= s.maxzoom || "none" !== s.visibility && (l(t1, this.zoom, d.brightness, i), (h[s.id] = s.createBucket({
                            index: c.bucketLayerIDs.length,
                            layers: t1,
                            zoom: this.zoom,
                            lut: this.lut,
                            canonical: this.canonical,
                            pixelRatio: this.pixelRatio,
                            overscaling: this.overscaling,
                            collisionBoxArray: this.collisionBoxArray,
                            sourceLayerIndex: p,
                            sourceID: this.source,
                            projection: this.projection.spec,
                            tessellationStep: this.tessellationStep
                        })).populate(g, d, this.tileID.canonical, this.tileTransform), c.bucketLayerIDs.push(t1.map((t1)=>e.aC(t1.id, t1.scope)))));
                    }
                }
                let p, g, m, y;
                u.trim();
                const x = {
                    type: "maybePrepare",
                    isSymbolTile: this.isSymbolTile,
                    zoom: this.zoom
                }, w = ()=>{
                    if (p) return this.status = "done", n(p);
                    if (this.extraShadowCaster) this.status = "done", n(null, {
                        buckets: e.bj(h).filter((e)=>!e.isEmpty()),
                        featureIndex: c,
                        collisionBoxArray: null,
                        glyphAtlasImage: null,
                        lineAtlas: null,
                        imageAtlas: null,
                        brightness: d.brightness,
                        glyphMap: null,
                        iconMap: null,
                        glyphPositions: null
                    });
                    else if (g && m && y) {
                        const t1 = new r(g), s = new e.e1(m, y, this.lut);
                        for(const o in h){
                            const n = h[o];
                            n instanceof e.aX ? (l(n.layers, this.zoom, d.brightness, i), e.e2(n, g, t1.positions, m, s.iconPositions, this.showCollisionBoxes, i, this.tileID.canonical, this.tileZoom, this.projection, this.scaleFactor, this.pixelRatio, this.brightness)) : n.hasPattern && (n instanceof e.b1 || n instanceof e.b2 || n instanceof e.d5) && (l(n.layers, this.zoom, d.brightness, i), n.addFeatures(d, this.tileID.canonical, s.patternPositions, i, this.tileTransform, this.brightness));
                        }
                        this.status = "done", n(null, {
                            buckets: e.bj(h).filter((e)=>!e.isEmpty()),
                            featureIndex: c,
                            collisionBoxArray: this.collisionBoxArray,
                            glyphAtlasImage: t1.image,
                            lineAtlas: u,
                            imageAtlas: s,
                            brightness: d.brightness
                        });
                    }
                };
                if (!this.extraShadowCaster) {
                    const t1 = e.d$(d.glyphDependencies, (e)=>Object.keys(e).map(Number));
                    Object.keys(t1).length ? o.send("getGlyphs", {
                        uid: this.uid,
                        stacks: t1,
                        scope: this.scope
                    }, (e, t1)=>{
                        p || (p = e, g = t1, w());
                    }, void 0, !1, x) : g = {};
                    const s = Object.keys(d.iconDependencies);
                    s.length ? o.send("getImages", {
                        icons: s,
                        source: this.source,
                        scope: this.scope,
                        tileID: this.tileID,
                        type: "icons"
                    }, (e, t1)=>{
                        if (p) return;
                        p = e;
                        const s = {};
                        Object.values(t1).some((e)=>e.usvg) ? this.rasterize(o, s, t1, d.iconDependencies, ()=>{
                            m = s, w();
                        }) : (this.fillImageMap(s, d.iconDependencies, t1), m = s, w());
                    }, void 0, !1, x) : m = {};
                    const i = Object.keys(d.patternDependencies);
                    i.length ? o.send("getImages", {
                        icons: i,
                        source: this.source,
                        scope: this.scope,
                        tileID: this.tileID,
                        type: "patterns"
                    }, (e, t1)=>{
                        if (!p) {
                            p = e;
                            const s = {};
                            Object.values(t1).some((e)=>e.usvg) ? this.rasterize(o, s, t1, d.patternDependencies, ()=>{
                                y = s, w();
                            }) : (this.fillImageMap(s, d.patternDependencies, t1), y = s, w());
                        }
                    }, void 0, !1, x) : y = {};
                }
                w();
            }
            fillImageMap(e, t1, s) {
                for(const i in s){
                    const o = t1[i] || [];
                    for (const t1 of o)s[t1.id].usvg || (e[t1.serialize()] = s[t1.id]);
                }
            }
            getImageTaskQueue(e, t1, s) {
                const i = {};
                for(const o in t1){
                    const n = s[o] || [];
                    for (const s of n){
                        const o = s.serialize();
                        t1[s.id].usvg ? i[o] || (i[o] = s) : e[o] = t1[s.id];
                    }
                }
                return i;
            }
            rasterize(t1, s, i, o, n) {
                const r = this.getImageTaskQueue(s, i, o);
                this.rasterizeTask = t1.send("rasterizeImages", {
                    scope: this.scope,
                    imageTasks: r
                }, (t1, o)=>{
                    if (!t1) for(const t1 in o){
                        const { id: n } = e.e0.deserializeFromString(t1);
                        s[t1] = Object.assign({}, i[n], {
                            data: o[t1]
                        });
                    }
                    n();
                });
            }
            cancelRasterize() {
                this.rasterizeTask && this.rasterizeTask.cancel();
            }
        }
        function l(t1, s, i, o) {
            const n = new e.a8(s, {
                brightness: i
            });
            for (const e of t1)e.recalculate(n, o);
        }
        class c extends e.E {
            constructor(t1, s, i, o, n, r){
                super(), this.actor = t1, this.layerIndex = s, this.availableImages = i, this.loadVectorData = n || e.aD, this.loading = {}, this.loaded = {}, this.deduped = new e.aB(t1.scheduler), this.isSpriteLoaded = o, this.scheduler = t1.scheduler, this.brightness = r;
            }
            loadTile(s, i) {
                const o = s.uid, n = s && s.request, r = n && n.collectResourceTiming, l = this.loading[o] = new a(s);
                l.abort = this.loadVectorData(s, (a, c)=>{
                    const h = !this.loading[o];
                    if (delete this.loading[o], l.cancelRasterize(), h || a || !c) return l.status = "done", h || (this.loaded[o] = l), i(a);
                    const u = c.rawData, d = {};
                    c.expires && (d.expires = c.expires), c.cacheControl && (d.cacheControl = c.cacheControl), l.vectorTile = c.vectorTile || new e.e3.VectorTile(new e.bh(u));
                    const f = ()=>{
                        l.parse(l.vectorTile, this.layerIndex, this.availableImages, this.actor, (s, o)=>{
                            if (s || !o) return i(s);
                            const a = {};
                            if (r) {
                                const e = t1(n);
                                e.length > 0 && (a.resourceTiming = JSON.parse(JSON.stringify(e)));
                            }
                            i(null, e.l({
                                rawTileData: u.slice(0)
                            }, o, d, a));
                        });
                    };
                    this.isSpriteLoaded ? f() : this.once("isSpriteLoaded", ()=>{
                        this.scheduler ? this.scheduler.add(f, {
                            type: "parseTile",
                            isSymbolTile: s.isSymbolTile,
                            zoom: s.tileZoom
                        }) : f();
                    }), this.loaded = this.loaded || {}, this.loaded[o] = l;
                });
            }
            reloadTile(t1, s) {
                const i = this.loaded, o = t1.uid;
                if (i && i[o]) {
                    const n = i[o];
                    n.scaleFactor = t1.scaleFactor, n.showCollisionBoxes = t1.showCollisionBoxes, n.projection = t1.projection, n.brightness = t1.brightness, n.tileTransform = e.aQ(t1.tileID.canonical, t1.projection), n.extraShadowCaster = t1.extraShadowCaster, n.lut = t1.lut;
                    const r = (e, t1)=>{
                        const i = n.reloadCallback;
                        i && (delete n.reloadCallback, n.parse(n.vectorTile, this.layerIndex, this.availableImages, this.actor, i)), s(e, t1);
                    };
                    "parsing" === n.status ? n.reloadCallback = r : "done" === n.status && (n.vectorTile ? n.parse(n.vectorTile, this.layerIndex, this.availableImages, this.actor, r) : r());
                } else s(null, void 0);
            }
            abortTile(e, t1) {
                const s = e.uid, i = this.loading[s];
                i && (i.abort && i.abort(), delete this.loading[s]), t1();
            }
            removeTile(e, t1) {
                const s = this.loaded, i = e.uid;
                s && s[i] && delete s[i], t1();
            }
        }
        class h {
            loadTile(t1, s) {
                const { uid: i, encoding: o, rawImageData: n, padding: r } = t1, a = ImageBitmap && n instanceof ImageBitmap ? this.getImageData(n, r) : n;
                s(null, new e.e4(i, a, o, r < 1));
            }
            getImageData(e, t1) {
                this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", {
                    willReadFrequently: !0
                })), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height);
                const s = this.offscreenCanvasContext.getImageData(-t1, -t1, e.width + 2 * t1, e.height + 2 * t1);
                return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), s;
            }
        }
        e.bg.setPbf(e.bh);
        class u {
            decodeRasterArray({ task: t1, buffer: s }, i) {
                e.bg.performDecoding(s, t1).then((e)=>{
                    i(null, e);
                }, (e)=>{
                    i(e);
                });
            }
        }
        const d = e.e3.VectorTileFeature.prototype.toGeoJSON;
        class f {
            constructor(t1){
                this._feature = t1, this.extent = e.ag, this.type = t1.type, this.properties = t1.tags, "id" in t1 && !isNaN(t1.id) && (this.id = parseInt(t1.id, 10));
            }
            loadGeometry() {
                if (1 === this._feature.type) {
                    const t1 = [];
                    for (const s of this._feature.geometry)t1.push([
                        new e.P(s[0], s[1])
                    ]);
                    return t1;
                }
                {
                    const t1 = [];
                    for (const s of this._feature.geometry){
                        const i = [];
                        for (const t1 of s)i.push(new e.P(t1[0], t1[1]));
                        t1.push(i);
                    }
                    return t1;
                }
            }
            toGeoJSON(e, t1, s) {
                return d.call(this, e, t1, s);
            }
        }
        class p {
            constructor(t1){
                this.layers = {
                    _geojsonTileLayer: this
                }, this.name = "_geojsonTileLayer", this.extent = e.ag, this.length = t1.length, this._features = t1;
            }
            feature(e) {
                return new f(this._features[e]);
            }
        }
        const g = 64 / 4096, m = 128;
        class y {
            constructor(){
                this.features = new Map;
            }
            clear() {
                this.features.clear();
            }
            load(e = [], t1) {
                for (const s of e){
                    const e = s.id;
                    if (null == e) continue;
                    let i = this.features.get(e);
                    i && this.updateCache(i, t1), s.geometry ? (i = w(s), this.updateCache(i, t1), this.features.set(e, i)) : this.features.delete(e), this.updateCache(i, t1);
                }
            }
            updateCache(e, t1) {
                for (const { canonical: s, uid: i } of Object.values(t1)){
                    const { z: o, x: n, y: r } = s;
                    x(e, Math.pow(2, o), n, r) && delete t1[i];
                }
            }
            getTile(e, t1, s) {
                const i = Math.pow(2, e), o = [];
                for (const e of this.features.values())x(e, i, t1, s) && o.push(I(e, i, t1, s));
                return {
                    features: o
                };
            }
            getFeatures() {
                return [
                    ...this.features.values()
                ];
            }
        }
        function x({ minX: e, minY: t1, maxX: s, maxY: i }, o, n, r) {
            return e < (n + 1 + g) / o && t1 < (r + 1 + g) / o && s > (n - g) / o && i > (r - g) / o;
        }
        function w(e) {
            const { id: t1, geometry: s, properties: i } = e;
            if (!s) return;
            if ("GeometryCollection" === s.type) throw new Error("GeometryCollection not supported in dynamic mode.");
            const { type: o, coordinates: n } = s, r = {
                id: t1,
                type: 1,
                geometry: [],
                tags: i,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            }, a = r.geometry;
            if ("Point" === o) b(n, a, r);
            else if ("MultiPoint" === o) for (const e of n)b(e, a, r);
            else if ("LineString" === o) r.type = 2, S(n, a, r);
            else if ("MultiLineString" === o) r.type = 2, v(n, a, r);
            else if ("Polygon" === o) r.type = 3, v(n, a, r, !0);
            else {
                if ("MultiPolygon" !== o) throw new Error("Input data is not a valid GeoJSON object.");
                r.type = 3;
                for (const e of n)v(e, a, r, !0);
            }
            return r;
        }
        function b([t1, s], i, o) {
            const n = e.at(t1);
            let r = e.aA(s);
            r = r < 0 ? 0 : r > 1 ? 1 : r, i.push(n, r), o.minX = Math.min(o.minX, n), o.minY = Math.min(o.minY, r), o.maxX = Math.max(o.maxX, n), o.maxY = Math.max(o.maxY, r);
        }
        function S(e, t1, s, i = !1, o = !1) {
            const n = [];
            for (const t1 of e)b(t1, n, s);
            t1.push(n), i && function(e, t1) {
                let s = 0;
                for(let t1 = 0, i = e.length, o = i - 2; t1 < i; o = t1, t1 += 2)s += (e[t1] - e[o]) * (e[t1 + 1] + e[o + 1]);
                if (s > 0 === t1) for(let t1 = 0, s = e.length; t1 < s / 2; t1 += 2){
                    const i = e[t1], o = e[t1 + 1];
                    e[t1] = e[s - 2 - t1], e[t1 + 1] = e[s - 1 - t1], e[s - 2 - t1] = i, e[s - 1 - t1] = o;
                }
            }(n, o);
        }
        function v(e, t1, s, i = !1) {
            for(let o = 0; o < e.length; o++)S(e[o], t1, s, i, 0 === o);
        }
        function I(t1, s, i, o) {
            const { id: n, type: r, geometry: a, tags: l } = t1, c = [];
            if (1 === r) !function(t1, s, i, o, n) {
                for(let r = 0; r < t1.length; r += 2){
                    const a = Math.round(e.ag * (t1[r + 0] * s - i)), l = Math.round(e.ag * (t1[r + 1] * s - o));
                    n.push([
                        a,
                        l
                    ]);
                }
            }(a, s, i, o, c);
            else for (const e of a)M(e, s, i, o, c);
            return {
                id: n,
                type: r,
                geometry: c,
                tags: l
            };
        }
        function M(t1, s, i, o, n) {
            const r = -m, a = e.ag + m;
            let l;
            for(let c = 0; c < t1.length - 2; c += 2){
                let h = Math.round(e.ag * (t1[c + 0] * s - i)), u = Math.round(e.ag * (t1[c + 1] * s - o)), d = Math.round(e.ag * (t1[c + 2] * s - i)), f = Math.round(e.ag * (t1[c + 3] * s - o));
                const p = d - h, g = f - u;
                h < r && d < r || (h < r ? (u += Math.round(g * ((r - h) / p)), h = r) : d < r && (f = u + Math.round(g * ((r - h) / p)), d = r), u < r && f < r || (u < r ? (h += Math.round(p * ((r - u) / g)), u = r) : f < r && (d = h + Math.round(p * ((r - u) / g)), f = r), h >= a && d >= a || (h >= a ? (u += Math.round(g * ((a - h) / p)), h = a) : d >= a && (f = u + Math.round(g * ((a - h) / p)), d = a), u >= a && f >= a || (u >= a ? (h += Math.round(p * ((a - u) / g)), u = a) : f >= a && (d = h + Math.round(p * ((a - u) / g)), f = a), l && h === l[l.length - 1][0] && u === l[l.length - 1][1] || (l = [
                    [
                        h,
                        u
                    ]
                ], n.push(l)), l.push([
                    d,
                    f
                ])))));
            }
        }
        var k, T, P, C = {
            exports: {}
        }, z = function() {
            if (P) return C.exports;
            P = 1;
            var t1 = e.e7(), s = function() {
                if (T) return k;
                T = 1;
                var t1 = e.e5(), s = e.e6().VectorTileFeature;
                function i(e, t1) {
                    this.options = t1 || {}, this.features = e, this.length = e.length;
                }
                function o(e, t1) {
                    this.id = "number" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [
                        e.geometry
                    ] : e.geometry, this.properties = e.tags, this.extent = t1 || 4096;
                }
                return k = i, i.prototype.feature = function(e) {
                    return new o(this.features[e], this.options.extent);
                }, o.prototype.loadGeometry = function() {
                    var e = this.rawGeometry;
                    this.geometry = [];
                    for(var s = 0; s < e.length; s++){
                        for(var i = e[s], o = [], n = 0; n < i.length; n++)o.push(new t1(i[n][0], i[n][1]));
                        this.geometry.push(o);
                    }
                    return this.geometry;
                }, o.prototype.bbox = function() {
                    this.geometry || this.loadGeometry();
                    for(var e = this.geometry, t1 = 1 / 0, s = -1 / 0, i = 1 / 0, o = -1 / 0, n = 0; n < e.length; n++)for(var r = e[n], a = 0; a < r.length; a++){
                        var l = r[a];
                        t1 = Math.min(t1, l.x), s = Math.max(s, l.x), i = Math.min(i, l.y), o = Math.max(o, l.y);
                    }
                    return [
                        t1,
                        i,
                        s,
                        o
                    ];
                }, o.prototype.toGeoJSON = s.prototype.toGeoJSON, k;
            }();
            function i(e) {
                var s = new t1;
                return function(e, t1) {
                    for(var s in e.layers)t1.writeMessage(3, o, e.layers[s]);
                }(e, s), s.finish();
            }
            function o(e, t1) {
                var s;
                t1.writeVarintField(15, e.version || 1), t1.writeStringField(1, e.name || ""), t1.writeVarintField(5, e.extent || 4096);
                var i = {
                    keys: [],
                    values: [],
                    keycache: {},
                    valuecache: {}
                };
                for(s = 0; s < e.length; s++)i.feature = e.feature(s), t1.writeMessage(2, n, i);
                var o = i.keys;
                for(s = 0; s < o.length; s++)t1.writeStringField(3, o[s]);
                var r = i.values;
                for(s = 0; s < r.length; s++)t1.writeMessage(4, h, r[s]);
            }
            function n(e, t1) {
                var s = e.feature;
                void 0 !== s.id && t1.writeVarintField(1, s.id), t1.writeMessage(2, r, e), t1.writeVarintField(3, s.type), t1.writeMessage(4, c, s);
            }
            function r(e, t1) {
                var s = e.feature, i = e.keys, o = e.values, n = e.keycache, r = e.valuecache;
                for(var a in s.properties){
                    var l = s.properties[a], c = n[a];
                    if (null !== l) {
                        void 0 === c && (i.push(a), n[a] = c = i.length - 1), t1.writeVarint(c);
                        var h = typeof l;
                        "string" !== h && "boolean" !== h && "number" !== h && (l = JSON.stringify(l));
                        var u = h + ":" + l, d = r[u];
                        void 0 === d && (o.push(l), r[u] = d = o.length - 1), t1.writeVarint(d);
                    }
                }
            }
            function a(e, t1) {
                return (t1 << 3) + (7 & e);
            }
            function l(e) {
                return e << 1 ^ e >> 31;
            }
            function c(e, t1) {
                for(var s = e.loadGeometry(), i = e.type, o = 0, n = 0, r = s.length, c = 0; c < r; c++){
                    var h = s[c], u = 1;
                    1 === i && (u = h.length), t1.writeVarint(a(1, u));
                    for(var d = 3 === i ? h.length - 1 : h.length, f = 0; f < d; f++){
                        1 === f && 1 !== i && t1.writeVarint(a(2, d - 1));
                        var p = h[f].x - o, g = h[f].y - n;
                        t1.writeVarint(l(p)), t1.writeVarint(l(g)), o += p, n += g;
                    }
                    3 === i && t1.writeVarint(a(7, 1));
                }
            }
            function h(e, t1) {
                var s = typeof e;
                "string" === s ? t1.writeStringField(1, e) : "boolean" === s ? t1.writeBooleanField(7, e) : "number" === s && (e % 1 != 0 ? t1.writeDoubleField(3, e) : e < 0 ? t1.writeSVarintField(6, e) : t1.writeVarintField(5, e));
            }
            return C.exports = i, C.exports.fromVectorTileJs = i, C.exports.fromGeojsonVt = function(e, t1) {
                t1 = t1 || {};
                var o = {};
                for(var n in e)o[n] = new s(e[n].features, t1), o[n].name = n, o[n].version = t1.version, o[n].extent = t1.extent;
                return i({
                    layers: o
                });
            }, C.exports.GeoJSONWrapper = s, C.exports;
        }(), _ = e.e8(z);
        const L = {
            minZoom: 0,
            maxZoom: 16,
            minPoints: 2,
            radius: 40,
            extent: 512,
            nodeSize: 64,
            log: !1,
            generateId: !1,
            reduce: null,
            map: (e)=>e
        }, D = Math.fround || (j = new Float32Array(1), (e)=>(j[0] = +e, j[0]));
        var j;
        const O = 3, F = 5, A = 6;
        class Z {
            constructor(e){
                this.options = Object.assign(Object.create(L), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
            }
            load(e) {
                const { log: t1, minZoom: s, maxZoom: i } = this.options;
                t1 && console.time("total time");
                const o = `prepare ${e.length} points`;
                t1 && console.time(o), this.points = e;
                const n = [];
                for(let t1 = 0; t1 < e.length; t1++){
                    const s = e[t1];
                    if (!s.geometry) continue;
                    const [i, o] = s.geometry.coordinates, r = D(X(i)), a = D(Y(o));
                    n.push(r, a, 1 / 0, t1, -1, 1), this.options.reduce && n.push(0);
                }
                let r = this.trees[i + 1] = this._createTree(n);
                t1 && console.timeEnd(o);
                for(let e = i; e >= s; e--){
                    const s = +Date.now();
                    r = this.trees[e] = this._createTree(this._cluster(r, e)), t1 && console.log("z%d: %d clusters in %dms", e, r.numItems, +Date.now() - s);
                }
                return t1 && console.timeEnd("total time"), this;
            }
            getClusters(e, t1) {
                let s = ((e[0] + 180) % 360 + 360) % 360 - 180;
                const i = Math.max(-90, Math.min(90, e[1]));
                let o = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;
                const n = Math.max(-90, Math.min(90, e[3]));
                if (e[2] - e[0] >= 360) s = -180, o = 180;
                else if (s > o) {
                    const e = this.getClusters([
                        s,
                        i,
                        180,
                        n
                    ], t1), r = this.getClusters([
                        -180,
                        i,
                        o,
                        n
                    ], t1);
                    return e.concat(r);
                }
                const r = this.trees[this._limitZoom(t1)], a = r.range(X(s), Y(n), X(o), Y(i)), l = r.data, c = [];
                for (const e of a){
                    const t1 = this.stride * e;
                    c.push(l[t1 + F] > 1 ? E(l, t1, this.clusterProps) : this.points[l[t1 + O]]);
                }
                return c;
            }
            getChildren(e) {
                const t1 = this._getOriginId(e), s = this._getOriginZoom(e), i = "No cluster with the specified id.", o = this.trees[s];
                if (!o) throw new Error(i);
                const n = o.data;
                if (t1 * this.stride >= n.length) throw new Error(i);
                const r = this.options.radius / (this.options.extent * Math.pow(2, s - 1)), a = o.within(n[t1 * this.stride], n[t1 * this.stride + 1], r), l = [];
                for (const t1 of a){
                    const s = t1 * this.stride;
                    n[s + 4] === e && l.push(n[s + F] > 1 ? E(n, s, this.clusterProps) : this.points[n[s + O]]);
                }
                if (0 === l.length) throw new Error(i);
                return l;
            }
            getLeaves(e, t1, s) {
                const i = [];
                return this._appendLeaves(i, e, t1 = t1 || 10, s = s || 0, 0), i;
            }
            getTile(e, t1, s) {
                const i = this.trees[this._limitZoom(e)], o = Math.pow(2, e), { extent: n, radius: r } = this.options, a = r / n, l = (s - a) / o, c = (s + 1 + a) / o, h = {
                    features: []
                };
                return this._addTileFeatures(i.range((t1 - a) / o, l, (t1 + 1 + a) / o, c), i.data, t1, s, o, h), 0 === t1 && this._addTileFeatures(i.range(1 - a / o, l, 1, c), i.data, o, s, o, h), t1 === o - 1 && this._addTileFeatures(i.range(0, l, a / o, c), i.data, -1, s, o, h), h.features.length ? h : null;
            }
            getClusterExpansionZoom(e) {
                let t1 = this._getOriginZoom(e) - 1;
                for(; t1 <= this.options.maxZoom;){
                    const s = this.getChildren(e);
                    if (t1++, 1 !== s.length) break;
                    e = s[0].properties.cluster_id;
                }
                return t1;
            }
            _appendLeaves(e, t1, s, i, o) {
                const n = this.getChildren(t1);
                for (const t1 of n){
                    const n = t1.properties;
                    if (n && n.cluster ? o + n.point_count <= i ? o += n.point_count : o = this._appendLeaves(e, n.cluster_id, s, i, o) : o < i ? o++ : e.push(t1), e.length === s) break;
                }
                return o;
            }
            _createTree(t1) {
                const s = new e.bE(t1.length / this.stride | 0, this.options.nodeSize, Float32Array);
                for(let e = 0; e < t1.length; e += this.stride)s.add(t1[e], t1[e + 1]);
                return s.finish(), s.data = t1, s;
            }
            _addTileFeatures(e, t1, s, i, o, n) {
                for (const r of e){
                    const e = r * this.stride, a = t1[e + F] > 1;
                    let l, c, h;
                    if (a) l = W(t1, e, this.clusterProps), c = t1[e], h = t1[e + 1];
                    else {
                        const s = this.points[t1[e + O]];
                        l = s.properties;
                        const [i, o] = s.geometry.coordinates;
                        c = X(i), h = Y(o);
                    }
                    const u = {
                        type: 1,
                        geometry: [
                            [
                                Math.round(this.options.extent * (c * o - s)),
                                Math.round(this.options.extent * (h * o - i))
                            ]
                        ],
                        tags: l
                    };
                    let d;
                    d = a || this.options.generateId ? t1[e + O] : this.points[t1[e + O]].id, void 0 !== d && (u.id = d), n.features.push(u);
                }
            }
            _limitZoom(e) {
                return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));
            }
            _cluster(e, t1) {
                const { radius: s, extent: i, reduce: o, minPoints: n } = this.options, r = s / (i * Math.pow(2, t1)), a = e.data, l = [], c = this.stride;
                for(let s = 0; s < a.length; s += c){
                    if (a[s + 2] <= t1) continue;
                    a[s + 2] = t1;
                    const i = a[s], h = a[s + 1], u = e.within(a[s], a[s + 1], r), d = a[s + F];
                    let f = d;
                    for (const e of u){
                        const s = e * c;
                        a[s + 2] > t1 && (f += a[s + F]);
                    }
                    if (f > d && f >= n) {
                        let e, n = i * d, r = h * d, p = -1;
                        const g = (s / c << 5) + (t1 + 1) + this.points.length;
                        for (const i of u){
                            const l = i * c;
                            if (a[l + 2] <= t1) continue;
                            a[l + 2] = t1;
                            const h = a[l + F];
                            n += a[l] * h, r += a[l + 1] * h, a[l + 4] = g, o && (e || (e = this._map(a, s, !0), p = this.clusterProps.length, this.clusterProps.push(e)), o(e, this._map(a, l)));
                        }
                        a[s + 4] = g, l.push(n / f, r / f, 1 / 0, g, -1, f), o && l.push(p);
                    } else {
                        for(let e = 0; e < c; e++)l.push(a[s + e]);
                        if (f > 1) for (const e of u){
                            const s = e * c;
                            if (!(a[s + 2] <= t1)) {
                                a[s + 2] = t1;
                                for(let e = 0; e < c; e++)l.push(a[s + e]);
                            }
                        }
                    }
                }
                return l;
            }
            _getOriginId(e) {
                return e - this.points.length >> 5;
            }
            _getOriginZoom(e) {
                return (e - this.points.length) % 32;
            }
            _map(e, t1, s) {
                if (e[t1 + F] > 1) {
                    const i = this.clusterProps[e[t1 + A]];
                    return s ? Object.assign({}, i) : i;
                }
                const i = this.points[e[t1 + O]].properties, o = this.options.map(i);
                return s && o === i ? Object.assign({}, o) : o;
            }
        }
        function E(e, t1, s) {
            return {
                type: "Feature",
                id: e[t1 + O],
                properties: W(e, t1, s),
                geometry: {
                    type: "Point",
                    coordinates: [
                        (i = e[t1], 360 * (i - .5)),
                        G(e[t1 + 1])
                    ]
                }
            };
            "TURBOPACK unreachable";
            var i;
        }
        function W(e, t1, s) {
            const i = e[t1 + F], o = i >= 1e4 ? `${Math.round(i / 1e3)}k` : i >= 1e3 ? Math.round(i / 100) / 10 + "k" : i, n = e[t1 + A], r = -1 === n ? {} : Object.assign({}, s[n]);
            return Object.assign(r, {
                cluster: !0,
                cluster_id: e[t1 + O],
                point_count: i,
                point_count_abbreviated: o
            });
        }
        function X(e) {
            return e / 360 + .5;
        }
        function Y(e) {
            const t1 = Math.sin(e * Math.PI / 180), s = .5 - .25 * Math.log((1 + t1) / (1 - t1)) / Math.PI;
            return s < 0 ? 0 : s > 1 ? 1 : s;
        }
        function G(e) {
            const t1 = (180 - 360 * e) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t1)) / Math.PI - 90;
        }
        function N(e, t1, s, i) {
            let o = i;
            const n = t1 + (s - t1 >> 1);
            let r, a = s - t1;
            const l = e[t1], c = e[t1 + 1], h = e[s], u = e[s + 1];
            for(let i = t1 + 3; i < s; i += 3){
                const t1 = B(e[i], e[i + 1], l, c, h, u);
                if (t1 > o) r = i, o = t1;
                else if (t1 === o) {
                    const e = Math.abs(i - n);
                    e < a && (r = i, a = e);
                }
            }
            o > i && (r - t1 > 3 && N(e, t1, r, i), e[r + 2] = o, s - r > 3 && N(e, r, s, i));
        }
        function B(e, t1, s, i, o, n) {
            let r = o - s, a = n - i;
            if (0 !== r || 0 !== a) {
                const l = ((e - s) * r + (t1 - i) * a) / (r * r + a * a);
                l > 1 ? (s = o, i = n) : l > 0 && (s += r * l, i += a * l);
            }
            return r = e - s, a = t1 - i, r * r + a * a;
        }
        function R(e, t1, s, i) {
            const o = {
                id: e ?? null,
                type: t1,
                geometry: s,
                tags: i,
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            };
            if ("Point" === t1 || "MultiPoint" === t1 || "LineString" === t1) J(o, s);
            else if ("Polygon" === t1) J(o, s[0]);
            else if ("MultiLineString" === t1) for (const e of s)J(o, e);
            else if ("MultiPolygon" === t1) for (const e of s)J(o, e[0]);
            return o;
        }
        function J(e, t1) {
            for(let s = 0; s < t1.length; s += 3)e.minX = Math.min(e.minX, t1[s]), e.minY = Math.min(e.minY, t1[s + 1]), e.maxX = Math.max(e.maxX, t1[s]), e.maxY = Math.max(e.maxY, t1[s + 1]);
        }
        function V(e, t1, s, i) {
            if (!t1.geometry) return;
            const o = t1.geometry.coordinates;
            if (o && 0 === o.length) return;
            const n = t1.geometry.type, r = Math.pow(s.tolerance / ((1 << s.maxZoom) * s.extent), 2);
            let a = [], l = t1.id;
            if (s.promoteId ? l = t1.properties[s.promoteId] : s.generateId && (l = i || 0), "Point" === n) $(o, a);
            else if ("MultiPoint" === n) for (const e of o)$(e, a);
            else if ("LineString" === n) U(o, a, r, !1);
            else if ("MultiLineString" === n) {
                if (s.lineMetrics) {
                    for (const s of o)a = [], U(s, a, r, !1), e.push(R(l, "LineString", a, t1.properties));
                    return;
                }
                q(o, a, r, !1);
            } else if ("Polygon" === n) q(o, a, r, !0);
            else {
                if ("MultiPolygon" !== n) {
                    if ("GeometryCollection" === n) {
                        for (const o of t1.geometry.geometries)V(e, {
                            id: l,
                            geometry: o,
                            properties: t1.properties
                        }, s, i);
                        return;
                    }
                    throw new Error("Input data is not a valid GeoJSON object.");
                }
                for (const e of o){
                    const t1 = [];
                    q(e, t1, r, !0), a.push(t1);
                }
            }
            e.push(R(l, n, a, t1.properties));
        }
        function $(e, t1) {
            t1.push(Q(e[0]), H(e[1]), 0);
        }
        function U(e, t1, s, i) {
            let o, n, r = 0;
            for(let s = 0; s < e.length; s++){
                const a = Q(e[s][0]), l = H(e[s][1]);
                t1.push(a, l, 0), s > 0 && (r += i ? (o * l - a * n) / 2 : Math.sqrt(Math.pow(a - o, 2) + Math.pow(l - n, 2))), o = a, n = l;
            }
            const a = t1.length - 3;
            t1[2] = 1, N(t1, 0, a, s), t1[a + 2] = 1, t1.size = Math.abs(r), t1.start = 0, t1.end = t1.size;
        }
        function q(e, t1, s, i) {
            for(let o = 0; o < e.length; o++){
                const n = [];
                U(e[o], n, s, i), t1.push(n);
            }
        }
        function Q(e) {
            return e / 360 + .5;
        }
        function H(e) {
            const t1 = Math.sin(e * Math.PI / 180), s = .5 - .25 * Math.log((1 + t1) / (1 - t1)) / Math.PI;
            return s < 0 ? 0 : s > 1 ? 1 : s;
        }
        function K(e, t1, s, i, o, n, r, a) {
            if (i /= t1, n >= (s /= t1) && r < i) return e;
            if (r < s || n >= i) return null;
            const l = [];
            for (const t1 of e){
                const e = t1.geometry;
                let n = t1.type;
                const r = 0 === o ? t1.minX : t1.minY, c = 0 === o ? t1.maxX : t1.maxY;
                if (r >= s && c < i) {
                    l.push(t1);
                    continue;
                }
                if (c < s || r >= i) continue;
                let h = [];
                if ("Point" === n || "MultiPoint" === n) ee(e, h, s, i, o);
                else if ("LineString" === n) te(e, h, s, i, o, !1, a.lineMetrics);
                else if ("MultiLineString" === n) ie(e, h, s, i, o, !1);
                else if ("Polygon" === n) ie(e, h, s, i, o, !0);
                else if ("MultiPolygon" === n) for (const t1 of e){
                    const e = [];
                    ie(t1, e, s, i, o, !0), e.length && h.push(e);
                }
                if (h.length) {
                    if (a.lineMetrics && "LineString" === n) {
                        for (const e of h)l.push(R(t1.id, n, e, t1.tags));
                        continue;
                    }
                    "LineString" !== n && "MultiLineString" !== n || (1 === h.length ? (n = "LineString", h = h[0]) : n = "MultiLineString"), "Point" !== n && "MultiPoint" !== n || (n = 3 === h.length ? "Point" : "MultiPoint"), l.push(R(t1.id, n, h, t1.tags));
                }
            }
            return l.length ? l : null;
        }
        function ee(e, t1, s, i, o) {
            for(let n = 0; n < e.length; n += 3){
                const r = e[n + o];
                r >= s && r <= i && oe(t1, e[n], e[n + 1], e[n + 2]);
            }
        }
        function te(e, t1, s, i, o, n, r) {
            let a = se(e);
            const l = 0 === o ? ne : re;
            let c, h, u = e.start;
            for(let d = 0; d < e.length - 3; d += 3){
                const f = e[d], p = e[d + 1], g = e[d + 2], m = e[d + 3], y = e[d + 4], x = 0 === o ? f : p, w = 0 === o ? m : y;
                let b = !1;
                r && (c = Math.sqrt(Math.pow(f - m, 2) + Math.pow(p - y, 2))), x < s ? w > s && (h = l(a, f, p, m, y, s), r && (a.start = u + c * h)) : x > i ? w < i && (h = l(a, f, p, m, y, i), r && (a.start = u + c * h)) : oe(a, f, p, g), w < s && x >= s && (h = l(a, f, p, m, y, s), b = !0), w > i && x <= i && (h = l(a, f, p, m, y, i), b = !0), !n && b && (r && (a.end = u + c * h), t1.push(a), a = se(e)), r && (u += c);
            }
            let d = e.length - 3;
            const f = e[d], p = e[d + 1], g = 0 === o ? f : p;
            g >= s && g <= i && oe(a, f, p, e[d + 2]), d = a.length - 3, n && d >= 3 && (a[d] !== a[0] || a[d + 1] !== a[1]) && oe(a, a[0], a[1], a[2]), a.length && t1.push(a);
        }
        function se(e) {
            const t1 = [];
            return t1.size = e.size, t1.start = e.start, t1.end = e.end, t1;
        }
        function ie(e, t1, s, i, o, n) {
            for (const r of e)te(r, t1, s, i, o, n, !1);
        }
        function oe(e, t1, s, i) {
            e.push(t1, s, i);
        }
        function ne(e, t1, s, i, o, n) {
            const r = (n - t1) / (i - t1);
            return oe(e, n, s + (o - s) * r, 1), r;
        }
        function re(e, t1, s, i, o, n) {
            const r = (n - s) / (o - s);
            return oe(e, t1 + (i - t1) * r, n, 1), r;
        }
        function ae(e, t1) {
            const s = [];
            for(let i = 0; i < e.length; i++){
                const o = e[i], n = o.type;
                let r;
                if ("Point" === n || "MultiPoint" === n || "LineString" === n) r = le(o.geometry, t1);
                else if ("MultiLineString" === n || "Polygon" === n) {
                    r = [];
                    for (const e of o.geometry)r.push(le(e, t1));
                } else if ("MultiPolygon" === n) {
                    r = [];
                    for (const e of o.geometry){
                        const s = [];
                        for (const i of e)s.push(le(i, t1));
                        r.push(s);
                    }
                }
                s.push(R(o.id, n, r, o.tags));
            }
            return s;
        }
        function le(e, t1) {
            const s = [];
            s.size = e.size, void 0 !== e.start && (s.start = e.start, s.end = e.end);
            for(let i = 0; i < e.length; i += 3)s.push(e[i] + t1, e[i + 1], e[i + 2]);
            return s;
        }
        function ce(e, t1) {
            if (e.transformed) return e;
            const s = 1 << e.z, i = e.x, o = e.y;
            for (const n of e.features){
                const e = n.geometry, r = n.type;
                if (n.geometry = [], 1 === r) for(let r = 0; r < e.length; r += 2)n.geometry.push(he(e[r], e[r + 1], t1, s, i, o));
                else for(let r = 0; r < e.length; r++){
                    const a = [];
                    for(let n = 0; n < e[r].length; n += 2)a.push(he(e[r][n], e[r][n + 1], t1, s, i, o));
                    n.geometry.push(a);
                }
            }
            return e.transformed = !0, e;
        }
        function he(e, t1, s, i, o, n) {
            return [
                Math.round(s * (e * i - o)),
                Math.round(s * (t1 * i - n))
            ];
        }
        function ue(e, t1, s, i, o) {
            const n = t1 === o.maxZoom ? 0 : o.tolerance / ((1 << t1) * o.extent), r = {
                features: [],
                numPoints: 0,
                numSimplified: 0,
                numFeatures: e.length,
                source: null,
                x: s,
                y: i,
                z: t1,
                transformed: !1,
                minX: 2,
                minY: 1,
                maxX: -1,
                maxY: 0
            };
            for (const t1 of e)de(r, t1, n, o);
            return r;
        }
        function de(e, t1, s, i) {
            const o = t1.geometry, n = t1.type, r = [];
            if (e.minX = Math.min(e.minX, t1.minX), e.minY = Math.min(e.minY, t1.minY), e.maxX = Math.max(e.maxX, t1.maxX), e.maxY = Math.max(e.maxY, t1.maxY), "Point" === n || "MultiPoint" === n) for(let t1 = 0; t1 < o.length; t1 += 3)r.push(o[t1], o[t1 + 1]), e.numPoints++, e.numSimplified++;
            else if ("LineString" === n) fe(r, o, e, s, !1, !1);
            else if ("MultiLineString" === n || "Polygon" === n) for(let t1 = 0; t1 < o.length; t1++)fe(r, o[t1], e, s, "Polygon" === n, 0 === t1);
            else if ("MultiPolygon" === n) for(let t1 = 0; t1 < o.length; t1++){
                const i = o[t1];
                for(let t1 = 0; t1 < i.length; t1++)fe(r, i[t1], e, s, !0, 0 === t1);
            }
            if (r.length) {
                let s = t1.tags || null;
                if ("LineString" === n && i.lineMetrics) {
                    s = {};
                    for(const e in t1.tags)s[e] = t1.tags[e];
                    s.mapbox_clip_start = o.start / o.size, s.mapbox_clip_end = o.end / o.size;
                }
                const a = {
                    geometry: r,
                    type: "Polygon" === n || "MultiPolygon" === n ? 3 : "LineString" === n || "MultiLineString" === n ? 2 : 1,
                    tags: s
                };
                null !== t1.id && (a.id = t1.id), e.features.push(a);
            }
        }
        function fe(e, t1, s, i, o, n) {
            const r = i * i;
            if (i > 0 && t1.size < (o ? r : i)) return void (s.numPoints += t1.length / 3);
            const a = [];
            for(let e = 0; e < t1.length; e += 3)(0 === i || t1[e + 2] > r) && (s.numSimplified++, a.push(t1[e], t1[e + 1])), s.numPoints++;
            o && function(e, t1) {
                let s = 0;
                for(let t1 = 0, i = e.length, o = i - 2; t1 < i; o = t1, t1 += 2)s += (e[t1] - e[o]) * (e[t1 + 1] + e[o + 1]);
                if (s > 0 === t1) for(let t1 = 0, s = e.length; t1 < s / 2; t1 += 2){
                    const i = e[t1], o = e[t1 + 1];
                    e[t1] = e[s - 2 - t1], e[t1 + 1] = e[s - 1 - t1], e[s - 2 - t1] = i, e[s - 1 - t1] = o;
                }
            }(a, n), e.push(a);
        }
        const pe = {
            maxZoom: 14,
            indexMaxZoom: 5,
            indexMaxPoints: 1e5,
            tolerance: 3,
            extent: 4096,
            buffer: 64,
            lineMetrics: !1,
            promoteId: null,
            generateId: !1,
            debug: 0
        };
        class ge {
            constructor(e, t1){
                const s = (t1 = this.options = function(e, t1) {
                    for(const s in t1)e[s] = t1[s];
                    return e;
                }(Object.create(pe), t1)).debug;
                if (s && console.time("preprocess data"), t1.maxZoom < 0 || t1.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
                if (t1.promoteId && t1.generateId) throw new Error("promoteId and generateId cannot be used together.");
                let i = function(e, t1) {
                    const s = [];
                    if ("FeatureCollection" === e.type) for(let i = 0; i < e.features.length; i++)V(s, e.features[i], t1, i);
                    else V(s, "Feature" === e.type ? e : {
                        geometry: e
                    }, t1);
                    return s;
                }(e, t1);
                this.tiles = {}, this.tileCoords = [], s && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t1.indexMaxZoom, t1.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i = function(e, t1) {
                    const s = t1.buffer / t1.extent;
                    let i = e;
                    const o = K(e, 1, -1 - s, s, 0, -1, 2, t1), n = K(e, 1, 1 - s, 2 + s, 0, -1, 2, t1);
                    return (o || n) && (i = K(e, 1, -s, 1 + s, 0, -1, 2, t1) || [], o && (i = ae(o, 1).concat(i)), n && (i = i.concat(ae(n, -1)))), i;
                }(i, t1), i.length && this.splitTile(i, 0, 0, 0), s && (i.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
            }
            splitTile(e, t1, s, i, o, n, r) {
                const a = [
                    e,
                    t1,
                    s,
                    i
                ], l = this.options, c = l.debug;
                for(; a.length;){
                    i = a.pop(), s = a.pop(), t1 = a.pop(), e = a.pop();
                    const h = 1 << t1, u = me(t1, s, i);
                    let d = this.tiles[u];
                    if (!d && (c > 1 && console.time("creation"), d = this.tiles[u] = ue(e, t1, s, i, l), this.tileCoords.push({
                        z: t1,
                        x: s,
                        y: i
                    }), c)) {
                        c > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t1, s, i, d.numFeatures, d.numPoints, d.numSimplified), console.timeEnd("creation"));
                        const e = `z${t1}`;
                        this.stats[e] = (this.stats[e] || 0) + 1, this.total++;
                    }
                    if (d.source = e, null == o) {
                        if (t1 === l.indexMaxZoom || d.numPoints <= l.indexMaxPoints) continue;
                    } else {
                        if (t1 === l.maxZoom || t1 === o) continue;
                        if (null != o) {
                            const e = o - t1;
                            if (s !== n >> e || i !== r >> e) continue;
                        }
                    }
                    if (d.source = null, 0 === e.length) continue;
                    c > 1 && console.time("clipping");
                    const f = .5 * l.buffer / l.extent, p = .5 - f, g = .5 + f, m = 1 + f;
                    let y = null, x = null, w = null, b = null, S = K(e, h, s - f, s + g, 0, d.minX, d.maxX, l), v = K(e, h, s + p, s + m, 0, d.minX, d.maxX, l);
                    e = null, S && (y = K(S, h, i - f, i + g, 1, d.minY, d.maxY, l), x = K(S, h, i + p, i + m, 1, d.minY, d.maxY, l), S = null), v && (w = K(v, h, i - f, i + g, 1, d.minY, d.maxY, l), b = K(v, h, i + p, i + m, 1, d.minY, d.maxY, l), v = null), c > 1 && console.timeEnd("clipping"), a.push(y || [], t1 + 1, 2 * s, 2 * i), a.push(x || [], t1 + 1, 2 * s, 2 * i + 1), a.push(w || [], t1 + 1, 2 * s + 1, 2 * i), a.push(b || [], t1 + 1, 2 * s + 1, 2 * i + 1);
                }
            }
            getTile(e, t1, s) {
                e = +e, t1 = +t1, s = +s;
                const i = this.options, { extent: o, debug: n } = i;
                if (e < 0 || e > 24) return null;
                const r = 1 << e, a = me(e, t1 = t1 + r & r - 1, s);
                if (this.tiles[a]) return ce(this.tiles[a], o);
                n > 1 && console.log("drilling down to z%d-%d-%d", e, t1, s);
                let l, c = e, h = t1, u = s;
                for(; !l && c > 0;)c--, h >>= 1, u >>= 1, l = this.tiles[me(c, h, u)];
                return l && l.source ? (n > 1 && (console.log("found parent tile z%d-%d-%d", c, h, u), console.time("drilling down")), this.splitTile(l.source, c, h, u, e, t1, s), n > 1 && console.timeEnd("drilling down"), this.tiles[a] ? ce(this.tiles[a], o) : null) : null;
            }
        }
        function me(e, t1, s) {
            return 32 * ((1 << e) * s + t1) + e;
        }
        function ye(e, t1) {
            const s = e.tileID.canonical;
            if (!this._geoJSONIndex) return void t1(null, null);
            const i = this._geoJSONIndex.getTile(s.z, s.x, s.y);
            if (!i) return void t1(null, null);
            const o = new p(i.features);
            let n = _(o);
            0 === n.byteOffset && n.byteLength === n.buffer.byteLength || (n = new Uint8Array(n)), t1(null, {
                vectorTile: o,
                rawData: n.buffer
            });
        }
        class xe extends c {
            constructor(e, t1, s, i, o, n){
                super(e, t1, s, i, ye, n), o && (this.loadGeoJSON = o), this._dynamicIndex = new y;
            }
            loadData(s, i) {
                const o = s && s.request, n = o && o.collectResourceTiming;
                this.loadGeoJSON(s, (r, a)=>{
                    if (r || !a) return i(r);
                    if ("object" != typeof a) return i(new Error(`Input data given to '${s.source}' is not a valid GeoJSON object.`));
                    {
                        try {
                            if (s.filter) {
                                const t1 = e.U(s.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if ("error" === t1.result) throw new Error(t1.value.map((e)=>`${e.key}: ${e.message}`).join(", "));
                                a.features = a.features.filter((e)=>t1.value.evaluate({
                                        zoom: 0
                                    }, e));
                            }
                            s.dynamic ? ("Feature" === a.type && (a = {
                                type: "FeatureCollection",
                                features: [
                                    a
                                ]
                            }), s.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(a.features, this.loaded), s.cluster && (a.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = s.cluster ? new Z(function({ superclusterOptions: t1, clusterProperties: s }) {
                                if (!s || !t1) return t1;
                                const i = {}, o = {}, n = {
                                    accumulated: null,
                                    zoom: 0
                                }, r = {
                                    properties: null
                                }, a = Object.keys(s);
                                for (const t1 of a){
                                    const [n, r] = s[t1], a = e.U(r), l = e.U("string" == typeof n ? [
                                        n,
                                        [
                                            "accumulated"
                                        ],
                                        [
                                            "get",
                                            t1
                                        ]
                                    ] : n);
                                    i[t1] = a.value, o[t1] = l.value;
                                }
                                return t1.map = (e)=>{
                                    r.properties = e;
                                    const t1 = {};
                                    for (const e of a)t1[e] = i[e].evaluate(n, r);
                                    return t1;
                                }, t1.reduce = (e, t1)=>{
                                    r.properties = t1;
                                    for (const t1 of a)n.accumulated = e[t1], e[t1] = o[t1].evaluate(n, r);
                                }, t1;
                            }(s)).load(a.features) : s.dynamic ? this._dynamicIndex : function(e, t1) {
                                return new ge(e, t1);
                            }(a, s.geojsonVtOptions);
                        } catch (e) {
                            return i(e);
                        }
                        const r = {};
                        if (n) {
                            const e = t1(o);
                            e && (r.resourceTiming = {}, r.resourceTiming[s.source] = JSON.parse(JSON.stringify(e)));
                        }
                        i(null, r);
                    }
                });
            }
            reloadTile(e, t1) {
                const s = this.loaded;
                return s && s[e.uid] ? e.partial ? t1(null, void 0) : super.reloadTile(e, t1) : this.loadTile(e, t1);
            }
            loadGeoJSON(t1, s) {
                if (t1.request) e.n(t1.request, s);
                else {
                    if ("string" != typeof t1.data) return s(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                    try {
                        return s(null, JSON.parse(t1.data));
                    } catch (e) {
                        return s(new Error(`Input data given to '${t1.source}' is not a valid GeoJSON object.`));
                    }
                }
            }
            getClusterExpansionZoom(e, t1) {
                try {
                    t1(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));
                } catch (e) {
                    t1(e);
                }
            }
            getClusterChildren(e, t1) {
                try {
                    t1(null, this._geoJSONIndex.getChildren(e.clusterId));
                } catch (e) {
                    t1(e);
                }
            }
            getClusterLeaves(e, t1) {
                try {
                    t1(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));
                } catch (e) {
                    t1(e);
                }
            }
        }
        class we {
            constructor(t1, s){
                this.tileID = new e.aG(t1.tileID.overscaledZ, t1.tileID.wrap, t1.tileID.canonical.z, t1.tileID.canonical.x, t1.tileID.canonical.y), this.tileZoom = t1.tileZoom, this.uid = t1.uid, this.zoom = t1.zoom, this.canonical = t1.tileID.canonical, this.pixelRatio = t1.pixelRatio, this.tileSize = t1.tileSize, this.source = t1.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t1.projection, this.brightness = s;
            }
            parse(t1, s, i, o) {
                this.status = "parsing";
                const n = new e.aG(i.tileID.overscaledZ, i.tileID.wrap, i.tileID.canonical.z, i.tileID.canonical.x, i.tileID.canonical.y), r = [], a = s.familiesBySource[i.source], l = new e.dZ(n, i.promoteId);
                return l.bucketLayerIDs = [], l.is3DTile = !0, e.e9(t1).then((t1)=>{
                    if (!t1) return o(new Error("Could not parse tile"));
                    const s = e.ea(t1, 1 / e.cc(i.tileID.canonical)), c = t1.json.extensionsUsed && t1.json.extensionsUsed.includes("MAPBOX_mesh_features") || t1.json.asset.extras && t1.json.asset.extras.MAPBOX_mesh_features, h = t1.json.extensionsUsed && t1.json.extensionsUsed.includes("EXT_meshopt_compression"), u = new e.a8(this.zoom, {
                        brightness: this.brightness
                    });
                    for(const t1 in a)for (const i of a[t1]){
                        const t1 = i[0];
                        l.bucketLayerIDs.push(i.map((t1)=>e.aC(t1.id, t1.scope))), t1.recalculate(u, []);
                        const o = new e.eb(i, s, n, c, h, this.brightness, l);
                        c || (o.needsUpload = !0), r.push(o), o.evaluate(t1);
                    }
                    this.status = "done", o(null, {
                        buckets: r,
                        featureIndex: l,
                        collisionBoxArray: null,
                        glyphAtlasImage: null,
                        lineAtlas: null,
                        imageAtlas: null,
                        brightness: null
                    });
                }).catch((e)=>o(new Error(e.message)));
            }
        }
        class be {
            constructor(e, t1, s, i, o, n){
                this.actor = e, this.layerIndex = t1, this.availableImages = s, this.brightness = n, this.loading = {}, this.loaded = {};
            }
            loadTile(t1, s) {
                const i = t1.uid, o = this.loading[i] = new we(t1, this.brightness);
                e.bi(t1.request, (e, n)=>{
                    const r = !this.loading[i];
                    return delete this.loading[i], r || e ? (o.status = "done", r || (this.loaded[i] = o), s(e)) : n && 0 !== n.byteLength ? void o.parse(n, this.layerIndex, t1, (e, t1)=>{
                        o.status = "done", this.loaded = this.loaded || {}, this.loaded[i] = o, e || !t1 ? s(e) : s(null, t1);
                    }) : (o.status = "done", this.loaded[i] = o, s());
                });
            }
            reloadTile(e, t1) {
                const s = this.loaded, i = e.uid;
                if (s && s[i]) {
                    const o = s[i];
                    o.projection = e.projection, o.brightness = e.brightness;
                    const n = (s, i)=>{
                        o.reloadCallback && (delete o.reloadCallback, this.loadTile(e, t1)), t1(s, i);
                    };
                    "parsing" === o.status ? o.reloadCallback = n : "done" === o.status && this.loadTile(e, t1);
                }
            }
            abortTile(e, t1) {
                const s = e.uid;
                this.loading[s] && delete this.loading[s], t1();
            }
            removeTile(e, t1) {
                const s = this.loaded, i = e.uid;
                s && s[i] && delete s[i], t1();
            }
        }
        class Se {
            constructor(t1){
                this.self = t1, this.actor = new e.ec(t1, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new e.I, this.projections = {}, this.defaultProjection = e.bP({
                    name: "mercator"
                }), this.workerSourceTypes = {
                    vector: c,
                    geojson: xe,
                    "batched-model": be
                }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e, t1)=>{
                    if (this.workerSourceTypes[e]) throw new Error(`Worker source with name "${e}" already registered.`);
                    this.workerSourceTypes[e] = t1;
                }, this.self.registerRTLTextPlugin = (t1)=>{
                    if (e.ed.isParsed()) throw new Error("RTL text plugin already registered.");
                    e.ed.applyArabicShaping = t1.applyArabicShaping, e.ed.processBidirectionalText = t1.processBidirectionalText, e.ed.processStyledBidirectionalText = t1.processStyledBidirectionalText;
                };
            }
            clearCaches(e, t1, s) {
                delete this.layerIndexes[e], delete this.availableImages[e], delete this.workerSources[e], delete this.demWorkerSources[e], delete this.rasterArrayWorkerSource, s();
            }
            checkIfReady(e, t1, s) {
                s();
            }
            setReferrer(e, t1) {
                this.referrer = t1;
            }
            spriteLoaded(t1, { scope: s, isLoaded: i }) {
                if (this.isSpriteLoaded[t1] || (this.isSpriteLoaded[t1] = {}), this.isSpriteLoaded[t1][s] = i, this.workerSources[t1] && this.workerSources[t1][s]) for(const o in this.workerSources[t1][s]){
                    const n = this.workerSources[t1][s][o];
                    for(const t1 in n){
                        const s = n[t1];
                        s instanceof c && (s.isSpriteLoaded = i, s.fire(new e.z("isSpriteLoaded")));
                    }
                }
            }
            setImages(e, { scope: t1, images: s }, i) {
                if (this.availableImages[e] || (this.availableImages[e] = {}), this.availableImages[e][t1] = s, this.workerSources[e] && this.workerSources[e][t1]) {
                    for(const i in this.workerSources[e][t1]){
                        const o = this.workerSources[e][t1][i];
                        for(const e in o)o[e].availableImages = s;
                    }
                    i();
                } else i();
            }
            setProjection(t1, s) {
                this.projections[t1] = e.bP(s);
            }
            setBrightness(e, t1, s) {
                this.brightness = t1, s();
            }
            setLayers(e, t1, s) {
                this.getLayerIndex(e, t1.scope).replace(t1.layers, t1.options), s();
            }
            updateLayers(e, t1, s) {
                this.getLayerIndex(e, t1.scope).update(t1.layers, t1.removedIds, t1.options), s();
            }
            loadTile(e, t1, s) {
                t1.projection = this.projections[e] || this.defaultProjection, this.getWorkerSource(e, t1.type, t1.source, t1.scope).loadTile(t1, s);
            }
            loadDEMTile(e, t1, s) {
                this.getDEMWorkerSource(e, t1.source, t1.scope).loadTile(t1, s);
            }
            decodeRasterArray(e, t1, s) {
                this.getRasterArrayWorkerSource().decodeRasterArray(t1, s);
            }
            reloadTile(e, t1, s) {
                t1.projection = this.projections[e] || this.defaultProjection, this.getWorkerSource(e, t1.type, t1.source, t1.scope).reloadTile(t1, s);
            }
            abortTile(e, t1, s) {
                this.getWorkerSource(e, t1.type, t1.source, t1.scope).abortTile(t1, s);
            }
            removeTile(e, t1, s) {
                this.getWorkerSource(e, t1.type, t1.source, t1.scope).removeTile(t1, s);
            }
            removeSource(e, t1, s) {
                if (!(this.workerSources[e] && this.workerSources[e][t1.scope] && this.workerSources[e][t1.scope][t1.type] && this.workerSources[e][t1.scope][t1.type][t1.source])) return;
                const i = this.workerSources[e][t1.scope][t1.type][t1.source];
                delete this.workerSources[e][t1.scope][t1.type][t1.source], void 0 !== i.removeSource ? i.removeSource(t1, s) : s();
            }
            loadWorkerSource(e, t1, s) {
                try {
                    this.self.importScripts(t1.url), s();
                } catch (e) {
                    s(e.toString());
                }
            }
            syncRTLPluginState(t1, s, i) {
                try {
                    e.ed.setState(s);
                    const t1 = e.ed.getPluginURL();
                    if (e.ed.isLoaded() && !e.ed.isParsed() && null != t1) {
                        this.self.importScripts(t1);
                        const s = e.ed.isParsed();
                        i(s ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t1}`), s);
                    }
                } catch (e) {
                    i(e.toString());
                }
            }
            setDracoUrl(e, t1) {
                this.dracoUrl = t1;
            }
            getAvailableImages(e, t1) {
                this.availableImages[e] || (this.availableImages[e] = {});
                let s = this.availableImages[e][t1];
                return s || (s = []), s;
            }
            getLayerIndex(e, t1) {
                this.layerIndexes[e] || (this.layerIndexes[e] = {});
                let s = this.layerIndexes[e][t1];
                return s || (s = this.layerIndexes[e][t1] = new o, s.scope = t1), s;
            }
            getWorkerSource(e, t1, s, i) {
                return this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][i] || (this.workerSources[e][i] = {}), this.workerSources[e][i][t1] || (this.workerSources[e][i][t1] = {}), this.isSpriteLoaded[e] || (this.isSpriteLoaded[e] = {}), this.workerSources[e][i][t1][s] || (this.workerSources[e][i][t1][s] = new this.workerSourceTypes[t1]({
                    send: (t1, s, i, o, n, r)=>{
                        this.actor.send(t1, s, i, e, n, r);
                    },
                    scheduler: this.actor.scheduler
                }, this.getLayerIndex(e, i), this.getAvailableImages(e, i), this.isSpriteLoaded[e][i], void 0, this.brightness)), this.workerSources[e][i][t1][s];
            }
            rasterizeImages(e, t1, s) {
                const { imageTasks: i, scope: o } = t1, n = {};
                for(const t1 in i){
                    const { image: s, imageIdWithOptions: r } = i[t1];
                    n[t1] = this.imageRasterizer.rasterize(r, s, o, e);
                }
                s(void 0, n);
            }
            removeRasterizedImages(e, t1, s) {
                const { imageIds: i, scope: o } = t1;
                this.imageRasterizer.removeImagesFromCacheByIds(i, o, e), s();
            }
            getDEMWorkerSource(e, t1, s) {
                return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][s] || (this.demWorkerSources[e][s] = {}), this.demWorkerSources[e][s][t1] || (this.demWorkerSources[e][s][t1] = new h), this.demWorkerSources[e][s][t1];
            }
            getRasterArrayWorkerSource() {
                return this.rasterArrayWorkerSource || (this.rasterArrayWorkerSource = new u), this.rasterArrayWorkerSource;
            }
            enforceCacheSizeLimit(t1, s) {
                e.ee(s);
            }
            getWorkerPerformanceMetrics(e, t1, s) {
                s(void 0, void 0);
            }
        }
        return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Se(self)), Se;
    });
    define([
        "./shared"
    ], function(e) {
        var t1 = "3.9.4";
        const i = {
            create: "create",
            load: "load",
            fullLoad: "fullLoad"
        }, o = {
            mark (e) {
                performance.mark(e);
            },
            measure (e, t1, i) {
                performance.measure(e, t1, i);
            }
        };
        function s(t1) {
            const i = t1.name.split("?")[0];
            return e.a(i) && i.includes("mapbox-gl.js") ? "javascript" : e.a(i) && i.includes("mapbox-gl.css") ? "css" : e.b(i) ? "fontRange" : e.c(i) ? "sprite" : e.i(i) ? "style" : e.d(i) ? "tilejson" : "other";
        }
        var r, a = {}, n = function() {
            if (r) return a;
            function e(e) {
                return !t1(e);
            }
            function t1(t1) {
                return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : function() {
                    if (!("Worker" in window && "Blob" in window && "URL" in window)) return !1;
                    var e, t1, i = new Blob([
                        ""
                    ], {
                        type: "text/javascript"
                    }), o = URL.createObjectURL(i);
                    try {
                        t1 = new Worker(o), e = !0;
                    } catch (t1) {
                        e = !1;
                    }
                    return t1 && t1.terminate(), URL.revokeObjectURL(o), e;
                }() ? function() {
                    var e = document.createElement("canvas");
                    e.width = e.height = 1;
                    var t1 = e.getContext("2d");
                    if (!t1) return !1;
                    var i = t1.getImageData(0, 0, 1, 1);
                    return i && i.width === e.width;
                }() ? (void 0 === i[o = t1 && t1.failIfMajorPerformanceCaveat] && (i[o] = function(t1) {
                    var i, o = function(t1) {
                        var i = document.createElement("canvas"), o = Object.create(e.webGLContextAttributes);
                        return o.failIfMajorPerformanceCaveat = t1, i.getContext("webgl2", o);
                    }(t1);
                    if (!o) return !1;
                    try {
                        i = o.createShader(o.VERTEX_SHADER);
                    } catch (e) {
                        return !1;
                    }
                    return !(!i || o.isContextLost()) && (o.shaderSource(i, "void main() {}"), o.compileShader(i), !0 === o.getShaderParameter(i, o.COMPILE_STATUS));
                }(o)), i[o] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
                "TURBOPACK unreachable";
                var o;
            }
            r = 1, a.supported = e, a.notSupportedReason = t1;
            var i = {};
            return e.webGLContextAttributes = {
                antialias: !1,
                alpha: !0,
                stencil: !0,
                depth: !0
            }, a;
        }();
        function l(e, t1, i) {
            const o = document.createElement(e);
            return null != t1 && (o.className = t1), i && i.appendChild(o), o;
        }
        function c(e, t1, i) {
            const o = document.createElementNS("http://www.w3.org/2000/svg", e);
            for (const e of Object.keys(t1))o.setAttributeNS(null, e, String(t1[e]));
            return i && i.appendChild(o), o;
        }
        const h = "undefined" != typeof document ? document.documentElement && document.documentElement.style : null, u = h && void 0 !== h.userSelect ? "userSelect" : "WebkitUserSelect";
        let d;
        function _() {
            h && u && (d = h[u], h[u] = "none");
        }
        function p() {
            h && u && (h[u] = d);
        }
        function f(e) {
            e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", f, !0);
        }
        function m() {
            window.addEventListener("click", f, !0), window.setTimeout(()=>{
                window.removeEventListener("click", f, !0);
            }, 0);
        }
        function g(e, t1) {
            const i = e.getBoundingClientRect();
            return x(e, i, t1);
        }
        function v(e, t1) {
            const i = e.getBoundingClientRect(), o = [];
            for(let s = 0; s < t1.length; s++)o.push(x(e, i, t1[s]));
            return o;
        }
        function y(e) {
            return void 0 !== window.InstallTrigger && 2 === e.button && e.ctrlKey && window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e.button;
        }
        function x(t1, i, o) {
            const s = t1.offsetWidth === i.width ? 1 : t1.offsetWidth / i.width;
            return new e.P((o.clientX - i.left) * s, (o.clientY - i.top) * s);
        }
        const b = "01", w = "NO_ACCESS_TOKEN";
        class T {
            constructor(e, t1, i){
                this._transformRequestFn = e, this._customAccessToken = t1, this._silenceAuthErrors = !!i, this._createSkuToken();
            }
            _createSkuToken() {
                const e = function() {
                    let e = "";
                    for(let t1 = 0; t1 < 10; t1++)e += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                    return {
                        token: [
                            "1",
                            b,
                            e
                        ].join(""),
                        tokenExpiresAt: Date.now() + 432e5
                    };
                }();
                this._skuToken = e.token, this._skuTokenExpiresAt = e.tokenExpiresAt;
            }
            _isSkuTokenExpired() {
                return Date.now() > this._skuTokenExpiresAt;
            }
            transformRequest(e, t1) {
                return this._transformRequestFn && this._transformRequestFn(e, t1) || {
                    url: e
                };
            }
            normalizeStyleURL(i, o) {
                if (!e.f(i)) return i;
                const s = S(i);
                return s.params.push(`sdk=js-${t1}`), s.path = `/styles/v1${s.path}`, this._makeAPIURL(s, this._customAccessToken || o);
            }
            normalizeGlyphsURL(t1, i) {
                if (!e.f(t1)) return t1;
                const o = S(t1);
                return o.path = `/fonts/v1${o.path}`, this._makeAPIURL(o, this._customAccessToken || i);
            }
            normalizeModelURL(t1, i) {
                if (!e.f(t1)) return t1;
                const o = S(t1);
                return o.path = `/models/v1${o.path}`, this._makeAPIURL(o, this._customAccessToken || i);
            }
            normalizeSourceURL(t1, i, o, s) {
                if (!e.f(t1)) return t1;
                const r = S(t1);
                return r.path = `/v4/${r.authority}.json`, r.params.push("secure"), o && r.params.push(`language=${o}`), s && r.params.push(`worldview=${s}`), this._makeAPIURL(r, this._customAccessToken || i);
            }
            normalizeIconsetURL(t1, i) {
                const o = S(t1);
                return e.f(t1) ? (o.path = `/styles/v1${o.path}/iconset.pbf`, this._makeAPIURL(o, this._customAccessToken || i)) : C(o);
            }
            normalizeSpriteURL(t1, i, o, s) {
                const r = S(t1);
                return e.f(t1) ? (r.path = `/styles/v1${r.path}/sprite${i}${o}`, this._makeAPIURL(r, this._customAccessToken || s)) : (r.path += `${i}${o}`, C(r));
            }
            normalizeTileURL(t1, i, o) {
                if (this._isSkuTokenExpired() && this._createSkuToken(), t1 && !e.f(t1)) return t1;
                const s = S(t1);
                s.path = s.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${i || o && "raster" !== s.authority && 512 === o ? "@2x" : ""}${e.m.supported ? ".webp" : "$1"}`), "raster" === s.authority ? s.path = `/${e.e.RASTER_URL_PREFIX}${s.path}` : "rasterarrays" === s.authority ? s.path = `/${e.e.RASTERARRAYS_URL_PREFIX}${s.path}` : "3dtiles" === s.authority ? s.path = `/${e.e.TILES3D_URL_PREFIX}${s.path}` : (s.path = s.path.replace(/^.+\/v4\//, "/"), s.path = `/${e.e.TILE_URL_VERSION}${s.path}`);
                const r = this._customAccessToken || function(e) {
                    for (const t1 of e){
                        const e = t1.match(/^access_token=(.*)$/);
                        if (e) return e[1];
                    }
                    return null;
                }(s.params) || e.e.ACCESS_TOKEN;
                return e.e.REQUIRE_ACCESS_TOKEN && r && this._skuToken && s.params.push(`sku=${this._skuToken}`), this._makeAPIURL(s, r);
            }
            canonicalizeTileURL(t1, i) {
                const o = S(t1);
                if (!o.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !o.path.match(/\.[\w]+$/)) return t1;
                let s = "mapbox://";
                o.path.match(/^\/raster\/v1\//) ? s += `raster/${o.path.replace(`/${e.e.RASTER_URL_PREFIX}/`, "")}` : o.path.match(/^\/rasterarrays\/v1\//) ? s += `rasterarrays/${o.path.replace(`/${e.e.RASTERARRAYS_URL_PREFIX}/`, "")}` : s += `tiles/${o.path.replace(`/${e.e.TILE_URL_VERSION}/`, "")}`;
                let r = o.params;
                return i && (r = r.filter((e)=>!e.match(/^access_token=/))), r.length && (s += `?${r.join("&")}`), s;
            }
            canonicalizeTileset(t1, i) {
                const o = !!i && e.f(i), s = [];
                for (const i of t1.tiles || [])e.h(i) ? s.push(this.canonicalizeTileURL(i, o)) : s.push(i);
                return s;
            }
            _makeAPIURL(t1, i) {
                const o = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", s = S(e.e.API_URL);
                if (t1.protocol = s.protocol, t1.authority = s.authority, "http" === t1.protocol) {
                    const e = t1.params.indexOf("secure");
                    e >= 0 && t1.params.splice(e, 1);
                }
                if ("/" !== s.path && (t1.path = `${s.path}${t1.path}`), !e.e.REQUIRE_ACCESS_TOKEN) return C(t1);
                if (i = i || e.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
                    if (!i) throw new Error(`An API access token is required to use Mapbox GL. ${o}`);
                    if ("s" === i[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${o}`);
                }
                return t1.params = t1.params.filter((e)=>-1 === e.indexOf("access_token")), t1.params.push(`access_token=${i || ""}`), C(t1);
            }
        }
        const E = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
        function S(e) {
            const t1 = e.match(E);
            if (!t1) throw new Error("Unable to parse URL object");
            return {
                protocol: t1[1],
                authority: t1[2],
                path: t1[3] || "/",
                params: t1[4] ? t1[4].split("&") : []
            };
        }
        function C(e) {
            const t1 = e.params.length ? `?${e.params.join("&")}` : "";
            return `${e.protocol}://${e.authority}${e.path}${t1}`;
        }
        const I = "mapbox.eventData";
        function R(t1) {
            if (!t1) return null;
            const i = t1.split(".");
            if (!i || 3 !== i.length) return null;
            try {
                return JSON.parse(e.j(i[1]));
            } catch (e) {
                return null;
            }
        }
        class D {
            constructor(e){
                this.type = e, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
            }
            getStorageKey(t1) {
                const i = R(e.e.ACCESS_TOKEN);
                let o = "";
                return o = i && i.u ? e.k(i.u) : e.e.ACCESS_TOKEN || "", t1 ? `${I}.${t1}:${o}` : `${I}:${o}`;
            }
            fetchEventData() {
                const t1 = e.s("localStorage"), i = this.getStorageKey(), o = this.getStorageKey("uuid");
                if (t1) try {
                    const e = localStorage.getItem(i);
                    e && (this.eventData = JSON.parse(e));
                    const t1 = localStorage.getItem(o);
                    t1 && (this.anonId = t1);
                } catch (t1) {
                    e.w("Unable to read from LocalStorage");
                }
            }
            saveEventData() {
                const t1 = e.s("localStorage"), i = this.getStorageKey(), o = this.getStorageKey("uuid"), s = this.anonId;
                if (t1 && s) try {
                    localStorage.setItem(o, s), Object.keys(this.eventData).length >= 1 && localStorage.setItem(i, JSON.stringify(this.eventData));
                } catch (t1) {
                    e.w("Unable to write to LocalStorage");
                }
            }
            processRequests(e) {}
            postEvent(t1, i, o, s) {
                if (!e.e.EVENTS_URL) return;
                const r = S(e.e.EVENTS_URL);
                r.params.push(`access_token=${s || e.e.ACCESS_TOKEN || ""}`);
                const a = {
                    event: this.type,
                    created: new Date(t1).toISOString()
                }, n = i ? e.l(a, i) : a, l = {
                    url: C(r),
                    headers: {
                        "Content-Type": "text/plain"
                    },
                    body: JSON.stringify([
                        n
                    ])
                };
                this.pendingRequest = e.p(l, (e)=>{
                    this.pendingRequest = null, o(e), this.saveEventData(), this.processRequests(s);
                });
            }
            queueRequest(e, t1) {
                this.queue.push(e), this.processRequests(t1);
            }
        }
        const L = new class extends D {
            constructor(e){
                super("appUserTurnstile"), this._customAccessToken = e;
            }
            postTurnstileEvent(t1, i) {
                e.e.EVENTS_URL && e.e.ACCESS_TOKEN && Array.isArray(t1) && t1.some((t1)=>e.f(t1) || e.h(t1)) && this.queueRequest(Date.now(), i);
            }
            processRequests(i) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
                const o = R(e.e.ACCESS_TOKEN), s = o ? o.u : e.e.ACCESS_TOKEN;
                let r = s !== this.eventData.tokenU;
                e.v(this.anonId) || (this.anonId = e.u(), r = !0);
                const a = this.queue.shift();
                if (this.eventData.lastSuccess) {
                    const e = new Date(this.eventData.lastSuccess), t1 = new Date(a), i = (a - this.eventData.lastSuccess) / 864e5;
                    r = r || i >= 1 || i < -1 || e.getDate() !== t1.getDate();
                } else r = !0;
                r ? this.postEvent(a, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: t1,
                    skuId: b,
                    "enabled.telemetry": !1,
                    userId: this.anonId
                }, (e)=>{
                    e || (this.eventData.lastSuccess = a, this.eventData.tokenU = s);
                }, i) : this.processRequests();
            }
        }, A = L.postTurnstileEvent.bind(L), z = new class extends D {
            constructor(){
                super("map.load"), this.success = {}, this.skuToken = "";
            }
            postMapLoadEvent(t1, i, o, s) {
                this.skuToken = i, this.errorCb = s, e.e.EVENTS_URL && (o || e.e.ACCESS_TOKEN ? this.queueRequest({
                    id: t1,
                    timestamp: Date.now()
                }, o) : this.errorCb(new Error(w)));
            }
            processRequests(i) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { id: o, timestamp: s } = this.queue.shift();
                o && this.success[o] || (this.anonId || this.fetchEventData(), e.v(this.anonId) || (this.anonId = e.u()), this.postEvent(s, {
                    sdkIdentifier: "mapbox-gl-js",
                    sdkVersion: t1,
                    skuId: b,
                    skuToken: this.skuToken,
                    userId: this.anonId
                }, (e)=>{
                    e ? this.errorCb(e) : o && (this.success[o] = !0);
                }, i));
            }
            remove() {
                this.errorCb = null;
            }
        }, P = z.postMapLoadEvent.bind(z), M = new class extends D {
            constructor(){
                super("style.load"), this.eventIdPerMapInstanceMap = new Map, this.mapInstanceIdMap = new WeakMap;
            }
            getMapInstanceId(t1) {
                let i = this.mapInstanceIdMap.get(t1);
                return i || (i = e.u(), this.mapInstanceIdMap.set(t1, i)), i;
            }
            getEventId(e) {
                const t1 = this.eventIdPerMapInstanceMap.get(e) || 0;
                return this.eventIdPerMapInstanceMap.set(e, t1 + 1), t1;
            }
            postStyleLoadEvent(t1, i) {
                const { map: o, style: s, importedStyles: r } = i;
                if (!e.e.EVENTS_URL || !t1 && !e.e.ACCESS_TOKEN) return;
                const a = this.getMapInstanceId(o), n = {
                    mapInstanceId: a,
                    eventId: this.getEventId(a),
                    style: s
                };
                r.length && (n.importedStyles = r), this.queueRequest({
                    timestamp: Date.now(),
                    payload: n
                }, t1);
            }
            processRequests(e) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { timestamp: t1, payload: i } = this.queue.shift();
                this.postEvent(t1, i, ()=>{}, e);
            }
        }, O = M.postStyleLoadEvent.bind(M), F = new class extends D {
            constructor(){
                super("gljs.performance");
            }
            postPerformanceEvent(t1, i) {
                e.e.EVENTS_URL && (t1 || e.e.ACCESS_TOKEN) && this.queueRequest({
                    timestamp: Date.now(),
                    performanceData: i
                }, t1);
            }
            processRequests(o) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { timestamp: r, performanceData: a } = this.queue.shift(), n = function(o) {
                    const r = performance.getEntriesByType("resource"), a = performance.getEntriesByType("mark"), n = function(e) {
                        const t1 = {};
                        if (e) {
                            for(const i in e)if ("other" !== i) for (const o of e[i]){
                                const e = `${i}ResolveRangeMin`, s = `${i}ResolveRangeMax`, r = `${i}RequestCount`, a = `${i}RequestCachedCount`;
                                t1[e] = Math.min(t1[e] || 1 / 0, o.startTime), t1[s] = Math.max(t1[s] || -1 / 0, o.responseEnd);
                                const n = (e)=>{
                                    void 0 === t1[e] && (t1[e] = 0), ++t1[e];
                                };
                                void 0 !== o.transferSize && 0 === o.transferSize && n(a), n(r);
                            }
                        }
                        return t1;
                    }(function(e, t1) {
                        const i = {};
                        if (e) for (const o of e){
                            const e = t1(o);
                            void 0 === i[e] && (i[e] = []), i[e].push(o);
                        }
                        return i;
                    }(r, s)), l = window.devicePixelRatio, c = navigator.connection || navigator.mozConnection || navigator.webkitConnection, h = c ? c.effectiveType : void 0, u = {
                        counters: [],
                        metadata: [],
                        attributes: []
                    }, d = (e, t1, i)=>{
                        null != i && e.push({
                            name: t1,
                            value: i.toString()
                        });
                    };
                    for(const e in n)d(u.counters, e, n[e]);
                    if (o.interactionRange[0] !== 1 / 0 && o.interactionRange[1] !== -1 / 0 && (d(u.counters, "interactionRangeMin", o.interactionRange[0]), d(u.counters, "interactionRangeMax", o.interactionRange[1])), a) for (const e of Object.keys(i)){
                        const t1 = i[e], o = a.find((e)=>e.name === t1);
                        o && d(u.counters, t1, o.startTime);
                    }
                    return d(u.counters, "visibilityHidden", o.visibilityHidden), d(u.attributes, "style", function(t1) {
                        if (t1) for (const i of t1){
                            const t1 = i.name.split("?")[0];
                            if (e.i(t1)) {
                                const e = t1.split("/").slice(-2);
                                if (2 === e.length) return `mapbox://styles/${e[0]}/${e[1]}`;
                            }
                        }
                    }(r)), d(u.attributes, "terrainEnabled", o.terrainEnabled ? "true" : "false"), d(u.attributes, "fogEnabled", o.fogEnabled ? "true" : "false"), d(u.attributes, "projection", o.projection), d(u.attributes, "zoom", o.zoom), d(u.metadata, "devicePixelRatio", l), d(u.metadata, "connectionEffectiveType", h), d(u.metadata, "navigatorUserAgent", navigator.userAgent), d(u.metadata, "screenWidth", window.screen.width), d(u.metadata, "screenHeight", window.screen.height), d(u.metadata, "windowWidth", window.innerWidth), d(u.metadata, "windowHeight", window.innerHeight), d(u.metadata, "mapWidth", o.width / l), d(u.metadata, "mapHeight", o.height / l), d(u.metadata, "webglRenderer", o.renderer), d(u.metadata, "webglVendor", o.vendor), d(u.metadata, "sdkVersion", t1), d(u.metadata, "sdkIdentifier", "mapbox-gl-js"), u;
                }(a);
                for (const e of n.metadata);
                for (const e of n.counters);
                for (const e of n.attributes);
                this.postEvent(r, n, ()=>{}, o);
            }
        }, k = F.postPerformanceEvent.bind(F), B = new class extends D {
            constructor(){
                super("map.auth"), this.success = {}, this.skuToken = "";
            }
            getSession(t1, i, o, s) {
                if (!e.e.API_URL || !e.e.SESSION_PATH) return;
                const r = S(e.e.API_URL + e.e.SESSION_PATH);
                r.params.push(`sku=${i || ""}`), r.params.push(`access_token=${s || e.e.ACCESS_TOKEN || ""}`);
                const a = {
                    url: C(r),
                    headers: {
                        "Content-Type": "text/plain"
                    }
                };
                this.pendingRequest = e.g(a, (e)=>{
                    this.pendingRequest = null, o(e), this.saveEventData(), this.processRequests(s);
                });
            }
            getSessionAPI(t1, i, o, s) {
                this.skuToken = i, this.errorCb = s, e.e.SESSION_PATH && e.e.API_URL && (o || e.e.ACCESS_TOKEN ? this.queueRequest({
                    id: t1,
                    timestamp: Date.now()
                }, o) : this.errorCb(new Error(w)));
            }
            processRequests(e) {
                if (this.pendingRequest || 0 === this.queue.length) return;
                const { id: t1, timestamp: i } = this.queue.shift();
                t1 && this.success[t1] || this.getSession(i, this.skuToken, (e)=>{
                    e ? this.errorCb(e) : t1 && (this.success[t1] = !0);
                }, e);
            }
            remove() {
                this.errorCb = null;
            }
        }, N = B.getSessionAPI.bind(B), U = new Set;
        function G(e, t1) {
            t1 ? U.add(e) : U.delete(e);
        }
        class j {
            constructor(){
                this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = new Set, this._updatedImages = new Set;
            }
            isDirty() {
                return this._changed;
            }
            setDirty() {
                this._changed = !0;
            }
            getUpdatedSourceCaches() {
                return this._updatedSourceCaches;
            }
            updateSourceCache(e, t1) {
                this._updatedSourceCaches[e] = t1, this.setDirty();
            }
            discardSourceCacheUpdate(e) {
                delete this._updatedSourceCaches[e];
            }
            updateLayer(e) {
                const t1 = e.scope;
                this._updatedLayers[t1] = this._updatedLayers[t1] || new Set, this._updatedLayers[t1].add(e.id), this.setDirty();
            }
            removeLayer(e) {
                const t1 = e.scope;
                this._removedLayers[t1] = this._removedLayers[t1] || {}, this._updatedLayers[t1] = this._updatedLayers[t1] || new Set, this._removedLayers[t1][e.id] = e, this._updatedLayers[t1].delete(e.id), this._updatedPaintProps.delete(e.fqid), this.setDirty();
            }
            getRemovedLayer(e) {
                return this._removedLayers[e.scope] ? this._removedLayers[e.scope][e.id] : null;
            }
            discardLayerRemoval(e) {
                this._removedLayers[e.scope] && delete this._removedLayers[e.scope][e.id];
            }
            getLayerUpdatesByScope() {
                const e = {};
                for(const t1 in this._updatedLayers)e[t1] = e[t1] || {}, e[t1].updatedIds = Array.from(this._updatedLayers[t1].values());
                for(const t1 in this._removedLayers)e[t1] = e[t1] || {}, e[t1].removedIds = Object.keys(this._removedLayers[t1]);
                return e;
            }
            getUpdatedPaintProperties() {
                return this._updatedPaintProps;
            }
            updatePaintProperties(e) {
                this._updatedPaintProps.add(e.fqid), this.setDirty();
            }
            getUpdatedImages() {
                return Array.from(this._updatedImages.values());
            }
            updateImage(e) {
                this._updatedImages.add(e), this.setDirty();
            }
            resetUpdatedImages() {
                this._updatedImages.clear();
            }
            reset() {
                this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages.clear();
            }
        }
        function V(e) {
            const { userImage: t1 } = e;
            return !!(t1 && t1.render && t1.render()) && (e.data.replace(new Uint8Array(t1.data.buffer)), !0);
        }
        class q extends e.E {
            constructor(t1){
                super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = {}, this.requestors = [], this.patterns = {}, this.atlasImage = {}, this.atlasTexture = {}, this.dirty = !0, this.spriteFormat = t1, "raster" !== t1 && e.t() && (this.imageRasterizerDispatcher = new e.D(e.x(), this, "Image Rasterizer Worker", 1));
            }
            get imageRasterizer() {
                return this._imageRasterizer || (this._imageRasterizer = new e.I), this._imageRasterizer;
            }
            createScope(t1) {
                this.images[t1] = {}, this.loaded[t1] = !1, this.updatedImages[t1] = {}, this.patterns[t1] = {}, this.callbackDispatchedThisFrame[t1] = {}, this.atlasImage[t1] = new e.r({
                    width: 1,
                    height: 1
                });
            }
            isLoaded() {
                for(const e in this.loaded)if (!this.loaded[e]) return !1;
                return !0;
            }
            setLoaded(e, t1) {
                if (this.loaded[t1] !== e && (this.loaded[t1] = e, e)) {
                    for (const { ids: e, callback: i } of this.requestors)this._notify(e, t1, i);
                    this.requestors = [];
                }
            }
            hasImage(e, t1) {
                return !!this.getImage(e, t1);
            }
            getImage(e, t1) {
                return this.images[t1][e];
            }
            addImage(e, t1, i) {
                this._validate(e, i) && (this.images[t1][e] = i);
            }
            _validate(t1, i) {
                let o = !0;
                return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e.y(new Error(`Image "${t1}" has invalid "stretchX" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e.y(new Error(`Image "${t1}" has invalid "stretchY" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new e.y(new Error(`Image "${t1}" has invalid "content" value`))), o = !1), o;
            }
            _validateStretch(e, t1) {
                if (!e) return !0;
                let i = 0;
                for (const o of e){
                    if (o[0] < i || o[1] < o[0] || t1 < o[1]) return !1;
                    i = o[1];
                }
                return !0;
            }
            _validateContent(e, t1) {
                if (!e) return !0;
                if (4 !== e.length) return !1;
                if (!t1.usvg) {
                    if (e[0] < 0 || t1.data.width < e[0]) return !1;
                    if (e[1] < 0 || t1.data.height < e[1]) return !1;
                    if (e[2] < 0 || t1.data.width < e[2]) return !1;
                    if (e[3] < 0 || t1.data.height < e[3]) return !1;
                }
                return !(e[2] < e[0] || e[3] < e[1]);
            }
            updateImage(e, t1, i) {
                i.version = this.images[t1][e].version + 1, this.images[t1][e] = i, this.updatedImages[t1][e] = !0, this.removeFromImageRasterizerCache(e, t1);
            }
            removeFromImageRasterizerCache(t1, i) {
                "raster" !== this.spriteFormat && (e.t() ? this.imageRasterizerDispatcher.getActor().send("removeRasterizedImages", {
                    imageIds: [
                        t1
                    ],
                    scope: i
                }) : this.imageRasterizer.removeImagesFromCacheByIds([
                    t1
                ], i));
            }
            removeImage(e, t1) {
                const i = this.images[t1][e];
                delete this.images[t1][e], delete this.patterns[t1][e], this.removeFromImageRasterizerCache(e, t1), i.userImage && i.userImage.onRemove && i.userImage.onRemove();
            }
            listImages(e) {
                return Object.keys(this.images[e]);
            }
            getImages(e, t1, i) {
                let o = !0;
                const s = !!this.loaded[t1];
                if (!s) for (const i of e)this.images[t1][i] || (o = !1);
                s || o ? this._notify(e, t1, i) : this.requestors.push({
                    ids: e,
                    scope: t1,
                    callback: i
                });
            }
            rasterizeImages({ scope: t1, imageTasks: i }, o) {
                const s = {};
                for(const e in i){
                    const o = i[e], r = this.getImage(o.id, t1);
                    r && (s[e] = {
                        image: r,
                        imageIdWithOptions: o
                    });
                }
                e.t() ? this.imageRasterizerDispatcher.getActor().send("rasterizeImages", {
                    imageTasks: s,
                    scope: t1
                }, o) : this.rasterizeImagesInMainThread({
                    imageTasks: s,
                    scope: t1
                }, o);
            }
            rasterizeImagesInMainThread(e, t1) {
                const { imageTasks: i, scope: o } = e, s = {};
                for(const e in i){
                    const { image: t1, imageIdWithOptions: r } = i[e];
                    s[e] = this.imageRasterizer.rasterize(r, t1, o, "");
                }
                t1(void 0, s);
            }
            getUpdatedImages(e) {
                return this.updatedImages[e];
            }
            _notify(t1, i, o) {
                const s = {};
                for (const o of t1){
                    this.images[i][o] || this.fire(new e.z("styleimagemissing", {
                        id: o
                    }));
                    const t1 = this.images[i][o];
                    t1 ? s[o] = {
                        data: t1.usvg ? null : t1.data.clone(),
                        pixelRatio: t1.pixelRatio,
                        sdf: t1.sdf,
                        usvg: t1.usvg,
                        version: t1.version,
                        stretchX: t1.stretchX,
                        stretchY: t1.stretchY,
                        content: t1.content,
                        hasRenderCallback: Boolean(t1.userImage && t1.userImage.render)
                    } : e.w(`Image "${o}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                }
                o(null, s);
            }
            getPixelSize(e) {
                const { width: t1, height: i } = this.atlasImage[e];
                return {
                    width: t1,
                    height: i
                };
            }
            getPattern(t1, i, o) {
                const s = this.patterns[i][t1], r = this.getImage(t1, i);
                if (!r) return null;
                if (s && s.position.version === r.version) return s.position;
                if (s) s.position.version = r.version;
                else {
                    r.usvg && !r.data && (r.data = this.imageRasterizer.rasterize(e.A.from(t1).getPrimary(), r, i, ""));
                    const o = {
                        w: r.data.width + 2 * e.B,
                        h: r.data.height + 2 * e.B,
                        x: 0,
                        y: 0
                    }, s = new e.F(o, r, e.B);
                    this.patterns[i][t1] = {
                        bin: o,
                        position: s
                    };
                }
                return this._updatePatternAtlas(i, o), this.patterns[i][t1].position;
            }
            bind(t1, i) {
                const o = t1.gl;
                let s = this.atlasTexture[i];
                s ? this.dirty && (s.update(this.atlasImage[i]), this.dirty = !1) : (s = new e.T(t1, this.atlasImage[i], o.RGBA8), this.atlasTexture[i] = s), s.bind(o.LINEAR, o.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas(t1, i) {
                const o = [];
                for(const e in this.patterns[t1])o.push(this.patterns[t1][e].bin);
                const { w: s, h: r } = e.C(o), a = this.atlasImage[t1];
                a.resize({
                    width: s || 1,
                    height: r || 1
                });
                for(const o in this.patterns[t1]){
                    const { bin: s, position: r } = this.patterns[t1][o];
                    let n = r.padding;
                    const l = s.x + n, c = s.y + n, h = this.images[t1][o].data, u = h.width, d = h.height;
                    n = n > 1 ? n - 1 : n, e.r.copy(h, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: l,
                        y: c
                    }, {
                        width: u,
                        height: d
                    }, i), e.r.copy(h, a, {
                        x: 0,
                        y: d - n
                    }, {
                        x: l,
                        y: c - n
                    }, {
                        width: u,
                        height: n
                    }, i), e.r.copy(h, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: l,
                        y: c + d
                    }, {
                        width: u,
                        height: n
                    }, i), e.r.copy(h, a, {
                        x: u - n,
                        y: 0
                    }, {
                        x: l - n,
                        y: c
                    }, {
                        width: n,
                        height: d
                    }, i), e.r.copy(h, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: l + u,
                        y: c
                    }, {
                        width: n,
                        height: d
                    }, i), e.r.copy(h, a, {
                        x: u - n,
                        y: d - n
                    }, {
                        x: l - n,
                        y: c - n
                    }, {
                        width: n,
                        height: n
                    }, i), e.r.copy(h, a, {
                        x: 0,
                        y: d - n
                    }, {
                        x: l + u,
                        y: c - n
                    }, {
                        width: n,
                        height: n
                    }, i), e.r.copy(h, a, {
                        x: 0,
                        y: 0
                    }, {
                        x: l + u,
                        y: c + d
                    }, {
                        width: n,
                        height: n
                    }, i), e.r.copy(h, a, {
                        x: u - n,
                        y: 0
                    }, {
                        x: l - n,
                        y: c + d
                    }, {
                        width: n,
                        height: n
                    }, i);
                }
                this.dirty = !0;
            }
            beginFrame() {
                for(const e in this.images)this.callbackDispatchedThisFrame[e] = {};
            }
            dispatchRenderCallbacks(e, t1) {
                for (const i of e){
                    if (this.callbackDispatchedThisFrame[t1][i]) continue;
                    this.callbackDispatchedThisFrame[t1][i] = !0;
                    const e = this.images[t1][i];
                    V(e) && this.updateImage(i, t1, e);
                }
            }
        }
        function H(t1) {
            const i = t1.key, o = t1.value, s = t1.valueSpec || {}, r = t1.objectElementValidators || {}, a = t1.style, n = t1.styleSpec;
            let l = [];
            const c = e.H(o);
            if ("object" !== c) return [
                new e.V(i, o, `object expected, ${c} found`)
            ];
            for(const t1 in o){
                const c = t1.split(".")[0];
                let h;
                r[c] ? h = r[c] : s[c] ? h = _e : r["*"] ? h = r["*"] : s["*"] && (h = _e), h ? l = l.concat(h({
                    key: (i ? `${i}.` : i) + t1,
                    value: o[t1],
                    valueSpec: s[c] || s["*"],
                    style: a,
                    styleSpec: n,
                    object: o,
                    objectKey: t1
                }, o)) : l.push(new e.G(i, o[t1], `unknown property "${t1}"`));
            }
            for(const t1 in s)r[t1] || s[t1].required && void 0 === s[t1].default && void 0 === o[t1] && l.push(new e.V(i, o, `missing required property "${t1}"`));
            return l;
        }
        function Z(t1) {
            const i = t1.value, o = t1.valueSpec, s = t1.style, r = t1.styleSpec, a = t1.key, n = t1.arrayElementValidator || _e;
            if ("array" !== e.H(i)) return [
                new e.V(a, i, `array expected, ${e.H(i)} found`)
            ];
            if (o.length && i.length !== o.length) return [
                new e.V(a, i, `array length ${o.length} expected, length ${i.length} found`)
            ];
            if (o["min-length"] && i.length < o["min-length"]) return [
                new e.V(a, i, `array length at least ${o["min-length"]} expected, length ${i.length} found`)
            ];
            let l = {
                type: o.value,
                values: o.values,
                minimum: o.minimum,
                maximum: o.maximum,
                function: void 0
            };
            r.$version < 7 && (l.function = o.function), "object" === e.H(o.value) && (l = o.value);
            let c = [];
            for(let e = 0; e < i.length; e++)c = c.concat(n({
                array: i,
                arrayIndex: e,
                value: i[e],
                valueSpec: l,
                style: s,
                styleSpec: r,
                key: `${a}[${e}]`
            }, !0));
            return c;
        }
        function W(t1) {
            const i = t1.key, o = t1.value, s = t1.valueSpec;
            let r = e.H(o);
            if ("number" === r && o != o && (r = "NaN"), "number" !== r) return [
                new e.V(i, o, `number expected, ${r} found`)
            ];
            if ("minimum" in s) {
                let r = s.minimum;
                if ("array" === e.H(s.minimum) && (r = s.minimum[t1.arrayIndex]), o < r) return [
                    new e.V(i, o, `${o} is less than the minimum value ${r}`)
                ];
            }
            if ("maximum" in s) {
                let r = s.maximum;
                if ("array" === e.H(s.maximum) && (r = s.maximum[t1.arrayIndex]), o > r) return [
                    new e.V(i, o, `${o} is greater than the maximum value ${r}`)
                ];
            }
            return [];
        }
        function $(t1) {
            const i = t1.valueSpec, o = e.K(t1.value.type);
            let s, r, a, n = {};
            const l = "categorical" !== o && void 0 === t1.value.property, c = !l, h = "array" === e.H(t1.value.stops) && "array" === e.H(t1.value.stops[0]) && "object" === e.H(t1.value.stops[0][0]), u = H({
                key: t1.key,
                value: t1.value,
                valueSpec: t1.styleSpec.function,
                style: t1.style,
                styleSpec: t1.styleSpec,
                objectElementValidators: {
                    stops: function(t1) {
                        if ("identity" === o) return [
                            new e.V(t1.key, t1.value, 'identity function may not have a "stops" property')
                        ];
                        let i = [];
                        const s = t1.value;
                        return i = i.concat(Z({
                            key: t1.key,
                            value: s,
                            valueSpec: t1.valueSpec,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            arrayElementValidator: d
                        })), "array" === e.H(s) && 0 === s.length && i.push(new e.V(t1.key, s, "array must have at least one stop")), i;
                    },
                    default: function(e) {
                        return _e({
                            key: e.key,
                            value: e.value,
                            valueSpec: i,
                            style: e.style,
                            styleSpec: e.styleSpec
                        });
                    }
                }
            });
            return "identity" === o && l && u.push(new e.V(t1.key, t1.value, 'missing required property "property"')), "identity" === o || t1.value.stops || u.push(new e.V(t1.key, t1.value, 'missing required property "stops"')), "exponential" === o && t1.valueSpec.expression && !e.L(t1.valueSpec) && u.push(new e.V(t1.key, t1.value, "exponential functions not supported")), t1.styleSpec.$version >= 8 && (c && !e.M(t1.valueSpec) ? u.push(new e.V(t1.key, t1.value, "property functions not supported")) : l && !e.N(t1.valueSpec) && u.push(new e.V(t1.key, t1.value, "zoom functions not supported"))), "categorical" !== o && !h || void 0 !== t1.value.property || u.push(new e.V(t1.key, t1.value, '"property" property is required')), u;
            "TURBOPACK unreachable";
            function d(t1) {
                let o = [];
                const s = t1.value, l = t1.key;
                if ("array" !== e.H(s)) return [
                    new e.V(l, s, `array expected, ${e.H(s)} found`)
                ];
                if (2 !== s.length) return [
                    new e.V(l, s, `array length 2 expected, length ${s.length} found`)
                ];
                if (h) {
                    if ("object" !== e.H(s[0])) return [
                        new e.V(l, s, `object expected, ${e.H(s[0])} found`)
                    ];
                    if (void 0 === s[0].zoom) return [
                        new e.V(l, s, "object stop key must have zoom")
                    ];
                    if (void 0 === s[0].value) return [
                        new e.V(l, s, "object stop key must have value")
                    ];
                    const i = e.K(s[0].zoom);
                    if ("number" != typeof i) return [
                        new e.V(l, s[0].zoom, "stop zoom values must be numbers")
                    ];
                    if (a && a > i) return [
                        new e.V(l, s[0].zoom, "stop zoom values must appear in ascending order")
                    ];
                    i !== a && (a = i, r = void 0, n = {}), o = o.concat(H({
                        key: `${l}[0]`,
                        value: s[0],
                        valueSpec: {
                            zoom: {}
                        },
                        style: t1.style,
                        styleSpec: t1.styleSpec,
                        objectElementValidators: {
                            zoom: W,
                            value: _
                        }
                    }));
                } else o = o.concat(_({
                    key: `${l}[0]`,
                    value: s[0],
                    valueSpec: {},
                    style: t1.style,
                    styleSpec: t1.styleSpec
                }, s));
                return e.O(e.Q(s[1])) ? o.concat([
                    new e.V(`${l}[1]`, s[1], "expressions are not allowed in function stops.")
                ]) : o.concat(_e({
                    key: `${l}[1]`,
                    value: s[1],
                    valueSpec: i,
                    style: t1.style,
                    styleSpec: t1.styleSpec
                }));
            }
            function _(t1, a) {
                const l = e.H(t1.value), c = e.K(t1.value), h = null !== t1.value ? t1.value : a;
                if (s) {
                    if (l !== s) return [
                        new e.V(t1.key, h, `${l} stop domain type must match previous stop domain type ${s}`)
                    ];
                } else s = l;
                if ("number" !== l && "string" !== l && "boolean" !== l && "number" != typeof c && "string" != typeof c && "boolean" != typeof c) return [
                    new e.V(t1.key, h, "stop domain value must be a number, string, or boolean")
                ];
                if ("number" !== l && "categorical" !== o) {
                    let s = `number expected, ${l} found`;
                    return e.M(i) && void 0 === o && (s += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [
                        new e.V(t1.key, h, s)
                    ];
                }
                return "categorical" !== o || "number" !== l || "number" == typeof c && isFinite(c) && Math.floor(c) === c ? "categorical" !== o && "number" === l && "number" == typeof c && "number" == typeof r && void 0 !== r && c < r ? [
                    new e.V(t1.key, h, "stop domain values must appear in ascending order")
                ] : (r = c, "categorical" === o && c in n ? [
                    new e.V(t1.key, h, "stop domain values must be unique")
                ] : (n[c] = !0, [])) : [
                    new e.V(t1.key, h, `integer expected, found ${String(c)}`)
                ];
            }
        }
        function X(t1) {
            const i = ("property" === t1.expressionContext ? e.S : e.U)(e.Q(t1.value), t1.valueSpec);
            if ("error" === i.result) return i.value.map((i)=>new e.V(`${t1.key}${i.key}`, t1.value, i.message));
            const o = i.value.expression || i.value._styleExpression.expression;
            if ("property" === t1.expressionContext && "text-font" === t1.propertyKey && !o.outputDefined()) return [
                new e.V(t1.key, t1.value, `Invalid data expression for "${t1.propertyKey}". Output values must be contained as literals within the expression.`)
            ];
            if ("property" === t1.expressionContext && "layout" === t1.propertyType && !e.W(o)) return [
                new e.V(t1.key, t1.value, '"feature-state" data expressions are not supported with layout properties.')
            ];
            if ("filter" === t1.expressionContext) return K(o, t1);
            if (t1.expressionContext && 0 === t1.expressionContext.indexOf("cluster")) {
                if (!e.X(o, [
                    "zoom",
                    "feature-state"
                ])) return [
                    new e.V(t1.key, t1.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')
                ];
                if ("cluster-initial" === t1.expressionContext && !e.Y(o)) return [
                    new e.V(t1.key, t1.value, "Feature data expressions are not supported with initial expression part of cluster properties.")
                ];
            }
            return [];
        }
        function K(t1, i) {
            const o = new Set([
                "zoom",
                "feature-state",
                "pitch",
                "distance-from-center"
            ]);
            if (i.valueSpec && i.valueSpec.expression) for (const e of i.valueSpec.expression.parameters)o.delete(e);
            if (0 === o.size) return [];
            const s = [];
            return t1 instanceof e.Z && o.has(t1.name) ? [
                new e.V(i.key, i.value, `["${t1.name}"] expression is not supported in a filter for a ${i.object.type} layer with id: ${i.object.id}`)
            ] : (t1.eachChild((e)=>{
                s.push(...K(e, i));
            }), s);
        }
        function Y(t1) {
            const i = t1.key, o = t1.value, s = t1.valueSpec, r = [];
            return Array.isArray(s.values) ? -1 === s.values.indexOf(e.K(o)) && r.push(new e.V(i, o, `expected one of [${s.values.join(", ")}], ${JSON.stringify(o)} found`)) : -1 === Object.keys(s.values).indexOf(e.K(o)) && r.push(new e.V(i, o, `expected one of [${Object.keys(s.values).join(", ")}], ${JSON.stringify(o)} found`)), r;
        }
        function J(t1) {
            return e.$(e.Q(t1.value)) ? X(e.J({}, t1, {
                expressionContext: "filter",
                valueSpec: t1.styleSpec[`filter_${t1.layerType || "fill"}`]
            })) : Q(t1);
        }
        function Q(t1) {
            const i = t1.value, o = t1.key;
            if ("array" !== e.H(i)) return [
                new e.V(o, i, `array expected, ${e.H(i)} found`)
            ];
            const s = t1.styleSpec;
            let r, a = [];
            if (i.length < 1) return [
                new e.V(o, i, "filter array must have at least 1 element")
            ];
            switch(a = a.concat(Y({
                key: `${o}[0]`,
                value: i[0],
                valueSpec: s.filter_operator,
                style: t1.style,
                styleSpec: t1.styleSpec
            })), e.K(i[0])){
                case "<":
                case "<=":
                case ">":
                case ">=":
                    i.length >= 2 && "$type" === e.K(i[1]) && a.push(new e.V(o, i, `"$type" cannot be use with operator "${i[0]}"`));
                case "==":
                case "!=":
                    3 !== i.length && a.push(new e.V(o, i, `filter array for operator "${i[0]}" must have 3 elements`));
                case "in":
                case "!in":
                    i.length >= 2 && (r = e.H(i[1]), "string" !== r && a.push(new e.V(`${o}[1]`, i[1], `string expected, ${r} found`)));
                    for(let n = 2; n < i.length; n++)r = e.H(i[n]), "$type" === e.K(i[1]) ? a = a.concat(Y({
                        key: `${o}[${n}]`,
                        value: i[n],
                        valueSpec: s.geometry_type,
                        style: t1.style,
                        styleSpec: t1.styleSpec
                    })) : "string" !== r && "number" !== r && "boolean" !== r && a.push(new e.V(`${o}[${n}]`, i[n], `string, number, or boolean expected, ${r} found`));
                    break;
                case "any":
                case "all":
                case "none":
                    for(let e = 1; e < i.length; e++)a = a.concat(Q({
                        key: `${o}[${e}]`,
                        value: i[e],
                        style: t1.style,
                        styleSpec: t1.styleSpec
                    }));
                    break;
                case "has":
                case "!has":
                    r = e.H(i[1]), 2 !== i.length ? a.push(new e.V(o, i, `filter array for "${i[0]}" operator must have 2 elements`)) : "string" !== r && a.push(new e.V(`${o}[1]`, i[1], `string expected, ${r} found`));
            }
            return a;
        }
        function ee(t1, i) {
            const o = t1.key, s = t1.style, r = t1.layer, a = t1.styleSpec, n = t1.value, l = t1.objectKey, c = a[`${i}_${t1.layerType}`];
            if (!c) return [];
            const h = l.match(/^(.*)-use-theme$/);
            if ("paint" === i && h && c[h[1]]) return _e({
                key: o,
                value: n,
                valueSpec: {
                    type: "string"
                },
                style: s,
                styleSpec: a
            });
            const u = l.match(/^(.*)-transition$/);
            if ("paint" === i && u && c[u[1]] && c[u[1]].transition) return _e({
                key: o,
                value: n,
                valueSpec: a.transition,
                style: s,
                styleSpec: a
            });
            const d = t1.valueSpec || c[l];
            if (!d) return [
                new e.G(o, n, `unknown property "${l}"`)
            ];
            let _;
            if ("string" === e.H(n) && e.M(d) && !d.tokens && (_ = /^{([^}]+)}$/.exec(n))) {
                const t1 = `\`{ "type": "identity", "property": ${_ ? JSON.stringify(_[1]) : '"_"'} }\``;
                return [
                    new e.V(o, n, `"${l}" does not support interpolation syntax\nUse an identity property function instead: ${t1}.`)
                ];
            }
            const p = [];
            if ("symbol" === t1.layerType) "text-field" !== l || !s || s.glyphs || s.imports || p.push(new e.V(o, n, 'use of "text-field" requires a style "glyphs" property')), "text-font" === l && e.a0(e.Q(n)) && "identity" === e.K(n.type) && p.push(new e.V(o, n, '"text-font" does not support identity functions'));
            else if ("model" === t1.layerType && "paint" === i && r && r.layout && r.layout.hasOwnProperty("model-id") && e.M(d) && (e.a1(d) || e.N(d))) {
                const t1 = e.S(e.Q(n), d), i = t1.value.expression || t1.value._styleExpression.expression;
                i && !e.X(i, [
                    "measure-light"
                ]) && ("model-emissive-strength" === l && e.Y(i) && e.W(i) || p.push(new e.V(o, n, `${l} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
            }
            return p.concat(_e({
                key: t1.key,
                value: n,
                valueSpec: d,
                style: s,
                styleSpec: a,
                expressionContext: "property",
                propertyType: i,
                propertyKey: l
            }));
        }
        function te(e) {
            return ee(e, "paint");
        }
        function ie(e) {
            return ee(e, "layout");
        }
        function oe(t1) {
            let i = [];
            const o = t1.value, s = t1.key, r = t1.style, a = t1.styleSpec;
            o.type || o.ref || i.push(new e.V(s, o, 'either "type" or "ref" is required'));
            let n = e.K(o.type);
            const l = e.K(o.ref);
            if (o.id) {
                const a = e.K(o.id);
                for(let n = 0; n < t1.arrayIndex; n++){
                    const t1 = r.layers[n];
                    e.K(t1.id) === a && i.push(new e.V(s, o.id, `duplicate layer id "${o.id}", previously used at line ${t1.id.__line__}`));
                }
            }
            if ("ref" in o) {
                let t1;
                [
                    "type",
                    "source",
                    "source-layer",
                    "filter",
                    "layout"
                ].forEach((t1)=>{
                    t1 in o && i.push(new e.V(s, o[t1], `"${t1}" is prohibited for ref layers`));
                }), r.layers.forEach((i)=>{
                    e.K(i.id) === l && (t1 = i);
                }), t1 ? t1.ref ? i.push(new e.V(s, o.ref, "ref cannot reference another ref layer")) : n = e.K(t1.type) : "string" == typeof l && i.push(new e.V(s, o.ref, `ref layer "${l}" not found`));
            } else if ("background" !== n && "sky" !== n && "slot" !== n) if (o.source) {
                const t1 = r.sources && r.sources[o.source], a = t1 && e.K(t1.type);
                t1 ? "vector" === a && "raster" === n ? i.push(new e.V(s, o.source, `layer "${o.id}" requires a raster source`)) : "raster" === a && "raster" !== n ? i.push(new e.V(s, o.source, `layer "${o.id}" requires a vector source`)) : "vector" !== a || o["source-layer"] ? "raster-dem" === a && "hillshade" !== n ? i.push(new e.V(s, o.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "raster-array" !== a || [
                    "raster",
                    "raster-particle"
                ].includes(n) ? "line" !== n || !o.paint || !o.paint["line-gradient"] && !o.paint["line-trim-offset"] || "geojson" === a && t1.lineMetrics ? "raster-particle" === n && "raster-array" !== a && i.push(new e.V(s, o.source, `layer "${o.id}" requires a 'raster-array' source.`)) : i.push(new e.V(s, o, `layer "${o.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : i.push(new e.V(s, o.source, "raster-array source can only be used with layer type 'raster'.")) : i.push(new e.V(s, o, `layer "${o.id}" must specify a "source-layer"`)) : i.push(new e.V(s, o.source, `source "${o.source}" not found`));
            } else i.push(new e.V(s, o, 'missing required property "source"'));
            return i = i.concat(H({
                key: s,
                value: o,
                valueSpec: a.layer,
                style: t1.style,
                styleSpec: t1.styleSpec,
                objectElementValidators: {
                    "*": ()=>[],
                    type: ()=>_e({
                            key: `${s}.type`,
                            value: o.type,
                            valueSpec: a.layer.type,
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            object: o,
                            objectKey: "type"
                        }),
                    filter: (t1)=>J(e.J({
                            layerType: n
                        }, t1)),
                    layout: (t1)=>H({
                            layer: o,
                            key: t1.key,
                            value: t1.value,
                            valueSpec: {},
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            objectElementValidators: {
                                "*": (t1)=>ie(e.J({
                                        layerType: n
                                    }, t1))
                            }
                        }),
                    paint: (t1)=>H({
                            layer: o,
                            key: t1.key,
                            value: t1.value,
                            valueSpec: {},
                            style: t1.style,
                            styleSpec: t1.styleSpec,
                            objectElementValidators: {
                                "*": (t1)=>te(e.J({
                                        layerType: n,
                                        layer: o
                                    }, t1))
                            }
                        })
                }
            })), i;
        }
        function se(t1) {
            const i = t1.value, o = t1.key, s = e.H(i);
            return "string" !== s ? [
                new e.V(o, i, `string expected, ${s} found`)
            ] : [];
        }
        const re = {
            promoteId: function({ key: t1, value: i }) {
                if ("string" === e.H(i)) return se({
                    key: t1,
                    value: i
                });
                {
                    const e = [];
                    for(const o in i)e.push(...se({
                        key: `${t1}.${o}`,
                        value: i[o]
                    }));
                    return e;
                }
            }
        };
        function ae(t1) {
            const i = t1.value, o = t1.key, s = t1.styleSpec, r = t1.style;
            if (!i.type) return [
                new e.V(o, i, '"type" is required')
            ];
            const a = e.K(i.type);
            let n = [];
            switch([
                "vector",
                "raster",
                "raster-dem",
                "raster-array"
            ].includes(a) && (i.url || i.tiles || n.push(new e.G(o, i, 'Either "url" or "tiles" is required.'))), a){
                case "vector":
                case "raster":
                case "raster-dem":
                case "raster-array":
                    return n = n.concat(H({
                        key: o,
                        value: i,
                        valueSpec: s[`source_${a.replace("-", "_")}`],
                        style: t1.style,
                        styleSpec: s,
                        objectElementValidators: re
                    })), n;
                case "geojson":
                    if (n = H({
                        key: o,
                        value: i,
                        valueSpec: s.source_geojson,
                        style: r,
                        styleSpec: s,
                        objectElementValidators: re
                    }), i.cluster) for(const e in i.clusterProperties){
                        const [t1, s] = i.clusterProperties[e], r = "string" == typeof t1 ? [
                            t1,
                            [
                                "accumulated"
                            ],
                            [
                                "get",
                                e
                            ]
                        ] : t1;
                        n.push(...X({
                            key: `${o}.${e}.map`,
                            value: s,
                            expressionContext: "cluster-map"
                        })), n.push(...X({
                            key: `${o}.${e}.reduce`,
                            value: r,
                            expressionContext: "cluster-reduce"
                        }));
                    }
                    return n;
                case "video":
                    return H({
                        key: o,
                        value: i,
                        valueSpec: s.source_video,
                        style: r,
                        styleSpec: s
                    });
                case "image":
                    return H({
                        key: o,
                        value: i,
                        valueSpec: s.source_image,
                        style: r,
                        styleSpec: s
                    });
                case "canvas":
                    return [
                        new e.V(o, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")
                    ];
                default:
                    return Y({
                        key: `${o}.type`,
                        value: i.type,
                        valueSpec: {
                            values: ne(s)
                        },
                        style: r,
                        styleSpec: s
                    });
            }
        }
        function ne(e) {
            return e.source.reduce((t1, i)=>{
                const o = e[i];
                return "enum" === o.type.type && (t1 = t1.concat(Object.keys(o.type.values))), t1;
            }, []);
        }
        function le(t1) {
            const i = t1.value, o = t1.styleSpec, s = o.light, r = t1.style;
            let a = [];
            const n = e.H(i);
            if (void 0 === i) return a;
            if ("object" !== n) return a = a.concat([
                new e.V("light", i, `object expected, ${n} found`)
            ]), a;
            for(const t1 in i){
                const n = t1.match(/^(.*)-transition$/), l = t1.match(/^(.*)-use-theme$/);
                a = a.concat(l && s[l[1]] ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: {
                        type: "string"
                    },
                    style: r,
                    styleSpec: o
                }) : n && s[n[1]] && s[n[1]].transition ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: o.transition,
                    style: r,
                    styleSpec: o
                }) : s[t1] ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: s[t1],
                    style: r,
                    styleSpec: o
                }) : [
                    new e.V(t1, i[t1], `unknown property "${t1}"`)
                ]);
            }
            return a;
        }
        function ce(t1) {
            const i = t1.value;
            let o = [];
            if (!i) return o;
            const s = e.H(i);
            if ("object" !== s) return o = o.concat([
                new e.V("light-3d", i, `object expected, ${s} found`)
            ]), o;
            const r = t1.styleSpec, a = r["light-3d"], n = t1.key, l = t1.style, c = t1.style.lights;
            for (const t1 of [
                "type",
                "id"
            ])if (!(t1 in i)) return o = o.concat([
                new e.V("light-3d", i, `missing property ${t1} on light`)
            ]), o;
            if (i.type && c) for(let s = 0; s < t1.arrayIndex; s++){
                const t1 = e.K(i.type), r = c[s];
                e.K(r.type) === t1 && o.push(new e.V(n, i.id, `duplicate light type "${i.type}", previously defined at line ${r.id.__line__}`));
            }
            const h = `properties_light_${i.type}`;
            if (!(h in r)) return o = o.concat([
                new e.V("light-3d", i, `Invalid light type ${i.type}`)
            ]), o;
            const u = r[h];
            for(const s in i)if ("properties" === s) {
                const a = i[s], n = e.H(a);
                if ("object" !== n) return o = o.concat([
                    new e.V("properties", a, `object expected, ${n} found`)
                ]), o;
                for(const i in a)o = o.concat(u[i] ? _e({
                    key: i,
                    value: a[i],
                    valueSpec: u[i],
                    style: l,
                    styleSpec: r
                }) : [
                    new e.G(t1.key, a[i], `unknown property "${i}"`)
                ]);
            } else {
                const t1 = s.match(/^(.*)-transition$/), n = s.match(/^(.*)-use-theme$/);
                o = o.concat(n && a[n[1]] ? _e({
                    key: s,
                    value: i[s],
                    valueSpec: {
                        type: "string"
                    },
                    style: l,
                    styleSpec: r
                }) : t1 && a[t1[1]] && a[t1[1]].transition ? _e({
                    key: s,
                    value: i[s],
                    valueSpec: r.transition,
                    style: l,
                    styleSpec: r
                }) : a[s] ? _e({
                    key: s,
                    value: i[s],
                    valueSpec: a[s],
                    style: l,
                    styleSpec: r
                }) : [
                    new e.G(s, i[s], `unknown property "${s}"`)
                ]);
            }
            return o;
        }
        function he(t1) {
            const i = t1.value, o = t1.key, s = t1.style, r = t1.styleSpec, a = r.terrain;
            let n = [];
            const l = e.H(i);
            if (void 0 === i) return n;
            if ("null" === l) return n;
            if ("object" !== l) return n = n.concat([
                new e.V("terrain", i, `object expected, ${l} found`)
            ]), n;
            for(const t1 in i){
                const o = t1.match(/^(.*)-transition$/), l = t1.match(/^(.*)-use-theme$/);
                n = n.concat(l && a[l[1]] ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: {
                        type: "string"
                    },
                    style: s,
                    styleSpec: r
                }) : o && a[o[1]] && a[o[1]].transition ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: r.transition,
                    style: s,
                    styleSpec: r
                }) : a[t1] ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: a[t1],
                    style: s,
                    styleSpec: r
                }) : [
                    new e.G(t1, i[t1], `unknown property "${t1}"`)
                ]);
            }
            if (i.source) {
                const t1 = s.sources && s.sources[i.source], r = t1 && e.K(t1.type);
                t1 ? "raster-dem" !== r && n.push(new e.V(o, i.source, `terrain cannot be used with a source of type ${String(r)}, it only be used with a "raster-dem" source type`)) : n.push(new e.V(o, i.source, `source "${i.source}" not found`));
            } else n.push(new e.V(o, i, 'terrain is missing required property "source"'));
            return n;
        }
        function ue(t1) {
            const i = t1.value, o = t1.style, s = t1.styleSpec, r = s.fog;
            let a = [];
            const n = e.H(i);
            if (void 0 === i) return a;
            if ("object" !== n) return a = a.concat([
                new e.V("fog", i, `object expected, ${n} found`)
            ]), a;
            for(const t1 in i){
                const n = t1.match(/^(.*)-transition$/), l = t1.match(/^(.*)-use-theme$/);
                a = a.concat(l && r[l[1]] ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: {
                        type: "string"
                    },
                    style: o,
                    styleSpec: s
                }) : n && r[n[1]] && r[n[1]].transition ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: s.transition,
                    style: o,
                    styleSpec: s
                }) : r[t1] ? _e({
                    key: t1,
                    value: i[t1],
                    valueSpec: r[t1],
                    style: o,
                    styleSpec: s
                }) : [
                    new e.G(t1, i[t1], `unknown property "${t1}"`)
                ]);
            }
            return a;
        }
        const de = {
            "*": ()=>[],
            array: Z,
            boolean: function(t1) {
                const i = t1.value, o = t1.key, s = e.H(i);
                return "boolean" !== s ? [
                    new e.V(o, i, `boolean expected, ${s} found`)
                ] : [];
            },
            number: W,
            color: function(t1) {
                const i = t1.key, o = t1.value, s = e.H(o);
                return "string" !== s ? [
                    new e.V(i, o, `color expected, ${s} found`)
                ] : null === e._.parseCSSColor(o) ? [
                    new e.V(i, o, `color expected, "${o}" found`)
                ] : [];
            },
            enum: Y,
            filter: J,
            function: $,
            layer: oe,
            object: H,
            source: ae,
            model: e.a2,
            light: le,
            "light-3d": ce,
            terrain: he,
            fog: ue,
            string: se,
            formatted: function(e) {
                return 0 === se(e).length ? [] : X(e);
            },
            resolvedImage: function(e) {
                return 0 === se(e).length ? [] : X(e);
            },
            projection: function(t1) {
                const i = t1.value, o = t1.styleSpec, s = o.projection, r = t1.style;
                let a = [];
                const n = e.H(i);
                if ("object" === n) for(const e in i)a = a.concat(_e({
                    key: e,
                    value: i[e],
                    valueSpec: s[e],
                    style: r,
                    styleSpec: o
                }));
                else "string" !== n && (a = a.concat([
                    new e.V("projection", i, `object or string expected, ${n} found`)
                ]));
                return a;
            },
            import: function(t1) {
                const { value: i, styleSpec: o } = t1, { data: s, ...r } = i;
                Object.defineProperty(r, "__line__", {
                    value: i.__line__,
                    enumerable: !1
                });
                let a = H(e.J({}, t1, {
                    value: r,
                    valueSpec: o.import
                }));
                return "" === e.K(r.id) && a.push(new e.V(`${t1.key}.id`, r, "import id can't be an empty string")), s && (a = a.concat(fe(s, o, {
                    key: `${t1.key}.data`
                }))), a;
            }
        };
        function _e(t1, i = !1) {
            const o = t1.value, s = t1.valueSpec, r = t1.styleSpec;
            if (s.expression && e.a0(e.K(o))) return $(t1);
            if (s.expression && e.O(e.Q(o))) return X(t1);
            if (s.type && de[s.type]) {
                const o = de[s.type](t1);
                return !0 === i && o.length > 0 && "array" === e.H(t1.value) ? X(t1) : o;
            }
            return H(e.J({}, t1, {
                valueSpec: s.type ? r[s.type] : s
            }));
        }
        function pe(t1) {
            const i = t1.value, o = t1.key, s = se(t1);
            return s.length || (-1 === i.indexOf("{fontstack}") && s.push(new e.V(o, i, '"glyphs" url must include a "{fontstack}" token')), -1 === i.indexOf("{range}") && s.push(new e.V(o, i, '"glyphs" url must include a "{range}" token'))), s;
        }
        function fe(t1, i = e.a3, o = {}) {
            return _e({
                key: o.key || "",
                value: t1,
                valueSpec: i.$root,
                styleSpec: i,
                style: t1,
                objectElementValidators: {
                    glyphs: pe,
                    "*": ()=>[]
                }
            });
        }
        function me(t1, i = e.a3) {
            return De(fe(t1, i));
        }
        const ge = (e)=>De(ae(e)), ve = (e)=>De(le(e)), ye = (e)=>De(ce(e)), xe = (e)=>De(he(e)), be = (e)=>De(ue(e)), we = (t1)=>De(function(t1) {
                const i = t1.value, o = t1.style, s = t1.styleSpec, r = s.snow;
                let a = [];
                const n = e.H(i);
                if (void 0 === i) return a;
                if ("object" !== n) return a = a.concat([
                    new e.V("snow", i, `object expected, ${n} found`)
                ]), a;
                for(const t1 in i){
                    const n = t1.match(/^(.*)-transition$/);
                    a = a.concat(n && r[n[1]] && r[n[1]].transition ? _e({
                        key: t1,
                        value: i[t1],
                        valueSpec: s.transition,
                        style: o,
                        styleSpec: s
                    }) : r[t1] ? _e({
                        key: t1,
                        value: i[t1],
                        valueSpec: r[t1],
                        style: o,
                        styleSpec: s
                    }) : [
                        new e.G(t1, i[t1], `unknown property "${t1}"`)
                    ]);
                }
                return a;
            }(t1)), Te = (t1)=>De(function(t1) {
                const i = t1.value, o = t1.style, s = t1.styleSpec, r = s.rain;
                let a = [];
                const n = e.H(i);
                if (void 0 === i) return a;
                if ("object" !== n) return a = a.concat([
                    new e.V("rain", i, `object expected, ${n} found`)
                ]), a;
                for(const t1 in i){
                    const n = t1.match(/^(.*)-transition$/);
                    a = a.concat(n && r[n[1]] && r[n[1]].transition ? _e({
                        key: t1,
                        value: i[t1],
                        valueSpec: s.transition,
                        style: o,
                        styleSpec: s
                    }) : r[t1] ? _e({
                        key: t1,
                        value: i[t1],
                        valueSpec: r[t1],
                        style: o,
                        styleSpec: s
                    }) : [
                        new e.G(t1, i[t1], `unknown property "${t1}"`)
                    ]);
                }
                return a;
            }(t1)), Ee = (e)=>De(oe(e)), Se = (e)=>De(J(e)), Ce = (e)=>De(te(e)), Ie = (e)=>De(ie(e)), Re = (t1)=>De(e.a2(t1));
        function De(e) {
            return e.slice().sort((e, t1)=>e.line && t1.line ? e.line - t1.line : 0);
        }
        function Le(t1, i) {
            let o = !1;
            if (i && i.length) for (const s of i)s instanceof e.G ? e.w(s.message) : (t1.fire(new e.y(new Error(s.message))), o = !0);
            return o;
        }
        let Ae;
        class ze extends e.E {
            constructor(t1, i = "flat"){
                super(), this._transitionable = new e.a4(Ae || (Ae = new e.a5({
                    anchor: new e.a6(e.a3.light.anchor),
                    position: new e.a7(e.a3.light.position),
                    color: new e.a6(e.a3.light.color),
                    intensity: new e.a6(e.a3.light.intensity)
                }))), this.setLight(t1, i), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
                return this._transitionable.serialize();
            }
            setLight(e, t1, i = {}) {
                this._validate(ve, e, i) || (this._transitionable.setTransitionOrValue(e), this.id = t1);
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && Le(this, t1.call(me, e.l({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e.a3
                })));
            }
        }
        let Pe = class extends e.E {
            constructor(t1, i, o, s){
                super(), this.scope = o, this._transitionable = new e.a4(new e.a5({
                    source: new e.a6(e.a3.terrain.source),
                    exaggeration: new e.a6(e.a3.terrain.exaggeration)
                }), o, s), this._transitionable.setTransitionOrValue(t1, s), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i;
            }
            get() {
                return this._transitionable.serialize();
            }
            set(e, t1) {
                this._transitionable.setTransitionOrValue(e, t1);
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            getExaggeration(t1) {
                return this._transitioning.possiblyEvaluate(new e.a8(t1)).get("exaggeration");
            }
            getAttenuationRange() {
                if (!this.isZoomDependent()) return null;
                const t1 = this._transitionable._values.exaggeration;
                if (!t1) return null;
                const i = t1.value.expression;
                if (!i) return null;
                let o = -1, s = -1, r = 1;
                for (const t1 of i.zoomStops)r = i.evaluate(new e.a8(t1)), r > .01 ? (o = t1, s = -1) : s = t1;
                return r < .01 && o > 0 && s > o ? [
                    o,
                    s
                ] : null;
            }
            isZoomDependent() {
                const t1 = this._transitionable._values.exaggeration;
                return null != t1 && null != t1.value && null != t1.value.expression && t1.value.expression instanceof e.a9;
            }
        };
        const Me = 45, Oe = 65, Fe = .05;
        function ke(t1, i, o, s) {
            const r = e.ac(Me, Oe, o), [a, n] = Be(t1, s);
            let l = 1 - Math.min(1, Math.exp((i - a) / (n - a) * -6));
            return l *= l * l, l = Math.min(1, 1.00747 * l), l * r * t1.alpha;
        }
        function Be(e, t1) {
            const i = .5 / Math.tan(.5 * t1);
            return [
                e.range[0] + i,
                e.range[1] + i
            ];
        }
        function Ne(t1, i, o, s, r) {
            const a = e.ab.vec3.transformMat4([], [
                i,
                o,
                s
            ], r.mercatorFogMatrix);
            return ke(t1, e.ab.vec3.length(a), r.pitch, r._fov);
        }
        function Ue(t1, i, o, s, r, a, n) {
            const l = [
                [
                    o,
                    s,
                    0
                ],
                [
                    r,
                    s,
                    0
                ],
                [
                    r,
                    a,
                    0
                ],
                [
                    o,
                    a,
                    0
                ]
            ];
            let c = Number.MAX_VALUE, h = -Number.MAX_VALUE;
            for (const t1 of l){
                const o = e.ab.vec3.transformMat4([], t1, i), s = e.ab.vec3.length(o);
                c = Math.min(c, s), h = Math.max(h, s);
            }
            return [
                ke(t1, c, n.pitch, n._fov),
                ke(t1, h, n.pitch, n._fov)
            ];
        }
        class Ge extends e.E {
            constructor(t1, i, o, s){
                super();
                const r = new e.a5({
                    range: new e.a6(e.a3.fog.range),
                    color: new e.a6(e.a3.fog.color),
                    "color-use-theme": new e.a6({
                        type: "string",
                        "property-type": "data-constant",
                        default: "default"
                    }),
                    "high-color": new e.a6(e.a3.fog["high-color"]),
                    "high-color-use-theme": new e.a6({
                        type: "string",
                        "property-type": "data-constant",
                        default: "default"
                    }),
                    "space-color": new e.a6(e.a3.fog["space-color"]),
                    "space-color-use-theme": new e.a6({
                        type: "string",
                        "property-type": "data-constant",
                        default: "default"
                    }),
                    "horizon-blend": new e.a6(e.a3.fog["horizon-blend"]),
                    "star-intensity": new e.a6(e.a3.fog["star-intensity"]),
                    "vertical-range": new e.a6(e.a3.fog["vertical-range"])
                });
                this._transitionable = new e.a4(r, o, new Map(s)), this.set(t1, s), this._transitioning = this._transitionable.untransitioned(), this._transform = i, this.properties = new e.ad(r), this.scope = o;
            }
            get state() {
                const t1 = this._transform, i = "globe" === t1.projection.name, o = e.ae(t1.zoom), s = this.properties.get("range"), r = [
                    .5,
                    3
                ];
                return {
                    range: i ? [
                        e.af(r[0], s[0], o),
                        e.af(r[1], s[1], o)
                    ] : s,
                    horizonBlend: this.properties.get("horizon-blend"),
                    alpha: this.properties.get("color").a
                };
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t1, i, o = {}) {
                if (this._validate(be, t1, o)) return;
                const s = e.l({}, t1);
                for (const t1 of Object.keys(e.a3.fog))void 0 === s[t1] && (s[t1] = e.a3.fog[t1].default);
                this._options = s, this._transitionable.setTransitionOrValue(this._options, i);
            }
            getOpacity(t1) {
                if (!this._transform.projection.supportsFog) return 0;
                const i = this.properties && this.properties.get("color") || 1;
                return ("globe" === this._transform.projection.name ? 1 : e.ac(Me, Oe, t1)) * i.a;
            }
            getOpacityAtLatLng(t1, i) {
                return this._transform.projection.supportsFog ? function(t1, i, o) {
                    const s = e.aa.fromLngLat(i), r = o.elevation ? o.elevation.getAtPointOrZero(s) : 0;
                    return Ne(t1, s.x, s.y, r, o);
                }(this.state, t1, i) : 0;
            }
            getOpacityForTile(t1) {
                if (!this._transform.projection.supportsFog) return [
                    1,
                    1
                ];
                const i = this._transform.calculateFogTileMatrix(t1.toUnwrapped());
                return Ue(this.state, i, 0, 0, e.ag, e.ag, this._transform);
            }
            getOpacityForBounds(e, t1, i, o, s) {
                return this._transform.projection.supportsFog ? Ue(this.state, e, t1, i, o, s, this._transform) : [
                    1,
                    1
                ];
            }
            getFovAdjustedRange(e) {
                return this._transform.projection.supportsFog ? Be(this.state, e) : [
                    0,
                    1
                ];
            }
            isVisibleOnFrustum(t1) {
                if (!this._transform.projection.supportsFog) return !1;
                const i = [
                    4,
                    5,
                    6,
                    7
                ];
                for (const o of i){
                    const i = t1.points[o];
                    let s;
                    if (i[2] >= 0) s = i;
                    else {
                        const r = t1.points[o - 4];
                        s = e.ah(r, i, r[2] / (r[2] - i[2]));
                    }
                    if (Ne(this.state, s[0], s[1], 0, this._transform) >= Fe) return !0;
                }
                return !1;
            }
            updateConfig(e) {
                this._transitionable.setTransitionOrValue(this._options, new Map(e));
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && Le(this, t1.call(me, e.l({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e.a3
                })));
            }
        }
        let je, Ve, qe, He, Ze = class extends e.E {
            constructor(t1, i, o, s){
                super();
                const r = je || (je = new e.a5({
                    density: new e.a6(e.a3.snow.density),
                    intensity: new e.a6(e.a3.snow.intensity),
                    color: new e.a6(e.a3.snow.color),
                    opacity: new e.a6(e.a3.snow.opacity),
                    vignette: new e.a6(e.a3.snow.vignette),
                    "vignette-color": new e.a6(e.a3.snow["vignette-color"]),
                    "center-thinning": new e.a6(e.a3.snow["center-thinning"]),
                    direction: new e.a6(e.a3.snow.direction),
                    "flake-size": new e.a6(e.a3.snow["flake-size"])
                }));
                this._transitionable = new e.a4(r, o, new Map(s)), this.set(t1, s), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.ad(r), this.scope = o;
            }
            get state() {
                const t1 = this.properties.get("opacity"), i = this.properties.get("color"), o = this.properties.get("direction"), s = e.ai(o[0]), r = -Math.max(e.ai(o[1]), .01), a = [
                    Math.cos(s) * Math.cos(r),
                    Math.sin(s) * Math.cos(r),
                    Math.sin(r)
                ], n = this.properties.get("vignette"), l = this.properties.get("vignette-color");
                return l.a = n, {
                    density: this.properties.get("density"),
                    intensity: this.properties.get("intensity"),
                    color: new e.aj(i.r, i.g, i.b, i.a * t1),
                    direction: a,
                    centerThinning: this.properties.get("center-thinning"),
                    flakeSize: this.properties.get("flake-size"),
                    vignetteColor: l
                };
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t1, i, o = {}) {
                if (this._validate(we, t1, o)) return;
                const s = e.l({}, t1);
                for (const t1 of Object.keys(e.a3.snow))void 0 === s[t1] && (s[t1] = e.a3.snow[t1].default);
                this._options = s, this._transitionable.setTransitionOrValue(this._options, i);
            }
            updateConfig(e) {
                this._transitionable.setTransitionOrValue(this._options, new Map(e));
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && Le(this, t1.call(me, e.l({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e.a3
                })));
            }
        }, We = class extends e.E {
            constructor(t1, i, o, s){
                super();
                const r = Ve || (Ve = new e.a5({
                    density: new e.a6(e.a3.rain.density),
                    intensity: new e.a6(e.a3.rain.intensity),
                    color: new e.a6(e.a3.rain.color),
                    opacity: new e.a6(e.a3.rain.opacity),
                    vignette: new e.a6(e.a3.rain.vignette),
                    "vignette-color": new e.a6(e.a3.rain["vignette-color"]),
                    "center-thinning": new e.a6(e.a3.rain["center-thinning"]),
                    direction: new e.a6(e.a3.rain.direction),
                    "droplet-size": new e.a6(e.a3.rain["droplet-size"]),
                    "distortion-strength": new e.a6(e.a3.rain["distortion-strength"])
                }));
                this._transitionable = new e.a4(r, o, new Map(s)), this.set(t1, s), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.ad(r), this.scope = o;
            }
            get state() {
                const t1 = this.properties.get("opacity"), i = this.properties.get("color"), o = this.properties.get("direction"), s = e.ai(o[0]), r = -Math.max(e.ai(o[1]), .01), a = [
                    Math.cos(s) * Math.cos(r),
                    Math.sin(s) * Math.cos(r),
                    Math.sin(r)
                ], n = this.properties.get("vignette-color");
                return n.a = this.properties.get("vignette"), {
                    density: this.properties.get("density"),
                    intensity: this.properties.get("intensity"),
                    color: new e.aj(i.r, i.g, i.b, i.a * t1),
                    direction: a,
                    centerThinning: this.properties.get("center-thinning"),
                    dropletSize: this.properties.get("droplet-size"),
                    distortionStrength: this.properties.get("distortion-strength"),
                    vignetteColor: n
                };
            }
            get() {
                return this._transitionable.serialize();
            }
            set(t1, i, o = {}) {
                if (this._validate(Te, t1, o)) return;
                const s = e.l({}, t1);
                for (const t1 of Object.keys(e.a3.rain))void 0 === s[t1] && (s[t1] = e.a3.rain[t1].default);
                this._options = s, this._transitionable.setTransitionOrValue(this._options, i);
            }
            updateConfig(e) {
                this._transitionable.setTransitionOrValue(this._options, new Map(e));
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            _validate(t1, i, o) {
                return (!o || !1 !== o.validate) && Le(this, t1.call(me, e.l({
                    value: i,
                    style: {
                        glyphs: !0,
                        sprite: !0
                    },
                    styleSpec: e.a3
                })));
            }
        };
        class $e extends e.E {
            constructor(t1, i, o, s){
                super(), this.scope = o, this._options = t1, this.properties = new e.ad(i), this._transitionable = new e.a4(i, o, new Map(s)), this._transitionable.setTransitionOrValue(t1.properties), this._transitioning = this._transitionable.untransitioned();
            }
            updateConfig(e) {
                this._transitionable.setTransitionOrValue(this._options.properties, new Map(e));
            }
            updateTransitions(e) {
                this._transitioning = this._transitionable.transitioned(e, this._transitioning);
            }
            hasTransition() {
                return this._transitioning.hasTransition();
            }
            recalculate(e) {
                this.properties = this._transitioning.possiblyEvaluate(e);
            }
            get() {
                return this._options.properties = this._transitionable.serialize(), this._options;
            }
            set(e, t1) {
                this._options = e, this._transitionable.setTransitionOrValue(e.properties, t1);
            }
            shadowsEnabled() {
                return !!this.properties && !0 === this.properties.get("cast-shadows");
            }
        }
        class Xe {
            constructor(e, t1, i, o){
                this.screenBounds = e, this.cameraPoint = t1, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o);
            }
            static createFromScreenPoints(t1, i) {
                let o, s;
                if (t1 instanceof e.P || "number" == typeof t1[0]) {
                    const r = e.P.convert(t1);
                    o = [
                        r
                    ], s = i.isPointAboveHorizon(r);
                } else {
                    const r = e.P.convert(t1[0]), a = e.P.convert(t1[1]);
                    o = [
                        r,
                        a
                    ], s = e.al(r, a).every((e)=>i.isPointAboveHorizon(e));
                }
                return new Xe(o, i.getCameraPoint(), s, i);
            }
            isPointQuery() {
                return 1 === this.screenBounds.length;
            }
            bufferedScreenGeometry(t1) {
                return e.al(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t1);
            }
            bufferedCameraGeometry(t1) {
                const i = this.screenBounds[0], o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], s = e.al(i, o, 0, !1);
                return this.cameraPoint.y > o.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < o.x ? s.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o.x ? s[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (s[3] = this.cameraPoint)), e.am(s, t1);
            }
            bufferedCameraGeometryGlobe(t1) {
                const i = this.screenBounds[0], o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], s = e.al(i, o, t1), r = this.cameraPoint.clone();
                switch(3 * ((r.y > i.y) + (r.y > o.y)) + ((r.x > i.x) + (r.x > o.x))){
                    case 0:
                        s[0] = r, s[4] = r.clone();
                        break;
                    case 1:
                        s.splice(1, 0, r);
                        break;
                    case 2:
                        s[1] = r;
                        break;
                    case 3:
                        s.splice(4, 0, r);
                        break;
                    case 5:
                        s.splice(2, 0, r);
                        break;
                    case 6:
                        s[3] = r;
                        break;
                    case 7:
                        s.splice(3, 0, r);
                        break;
                    case 8:
                        s[2] = r;
                }
                return s;
            }
            containsTile(t1, i, o, s = 0) {
                const r = t1.queryPadding / i._pixelsPerMercatorPixel + 1, a = o ? this._bufferedCameraMercator(r, i) : this._bufferedScreenMercator(r, i);
                let n = t1.tileID.wrap + (a.unwrapped ? s : 0);
                const l = a.polygon.map((i)=>e.an(t1.tileTransform, i, n));
                if (!e.ao(l, 0, 0, e.ag, e.ag)) return;
                n = t1.tileID.wrap + (this.screenGeometryMercator.unwrapped ? s : 0);
                const c = this.screenGeometryMercator.polygon.map((i)=>e.ap(t1.tileTransform, i, n)), h = c.map((t1)=>new e.P(t1[0], t1[1])), u = i.getFreeCameraOptions().position || new e.aa(0, 0, 0), d = e.ap(t1.tileTransform, u, n), _ = c.map((t1)=>{
                    const i = e.ab.vec3.sub(t1, t1, d);
                    return e.ab.vec3.normalize(i, i), new e.aq(d, i);
                }), p = e.ar(t1, 1, i.zoom) * i._pixelsPerMercatorPixel;
                return {
                    queryGeometry: this,
                    tilespaceGeometry: h,
                    tilespaceRays: _,
                    bufferedTilespaceGeometry: l,
                    bufferedTilespaceBounds: (f = e.as(l), f.min.x = e.aw(f.min.x, 0, e.ag), f.min.y = e.aw(f.min.y, 0, e.ag), f.max.x = e.aw(f.max.x, 0, e.ag), f.max.y = e.aw(f.max.y, 0, e.ag), f),
                    tile: t1,
                    tileID: t1.tileID,
                    pixelToTileUnitsFactor: p
                };
                "TURBOPACK unreachable";
                var f;
            }
            _bufferedScreenMercator(e, t1) {
                const i = Je(e);
                if (this._screenRaycastCache[i]) return this._screenRaycastCache[i];
                {
                    let o;
                    return o = "globe" === t1.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e), t1) : {
                        polygon: this.bufferedScreenGeometry(e).map((e)=>t1.pointCoordinate3D(e)),
                        unwrapped: !0
                    }, this._screenRaycastCache[i] = o, o;
                }
            }
            _bufferedCameraMercator(e, t1) {
                const i = Je(e);
                if (this._cameraRaycastCache[i]) return this._cameraRaycastCache[i];
                {
                    let o;
                    return o = "globe" === t1.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e), t1) : {
                        polygon: this.bufferedCameraGeometry(e).map((e)=>t1.pointCoordinate3D(e)),
                        unwrapped: !0
                    }, this._cameraRaycastCache[i] = o, o;
                }
            }
            _projectAndResample(t1, i) {
                const o = function(t1, i) {
                    const o = e.ab.mat4.multiply([], i.pixelMatrix, i.globeMatrix), s = [
                        0,
                        -e.ax,
                        0,
                        1
                    ], r = [
                        0,
                        e.ax,
                        0,
                        1
                    ], a = [
                        0,
                        0,
                        0,
                        1
                    ];
                    e.ab.vec4.transformMat4(s, s, o), e.ab.vec4.transformMat4(r, r, o), e.ab.vec4.transformMat4(a, a, o);
                    const n = new e.P(s[0] / s[3], s[1] / s[3]), l = new e.P(r[0] / r[3], r[1] / r[3]), c = e.au(t1, n) && s[3] < a[3], h = e.au(t1, l) && r[3] < a[3];
                    if (!c && !h) return null;
                    const u = function(e, t1, i) {
                        for(let o = 1; o < e.length; o++){
                            const s = Ye(t1.pointCoordinate3D(e[o - 1]).x), r = Ye(t1.pointCoordinate3D(e[o]).x);
                            if (i < 0) {
                                if (s < r) return {
                                    idx: o,
                                    t: -s / (r - 1 - s)
                                };
                            } else if (r < s) return {
                                idx: o,
                                t: (1 - s) / (r + 1 - s)
                            };
                        }
                        return null;
                    }(t1, i, c ? -1 : 1);
                    if (!u) return null;
                    const { idx: d, t: _ } = u;
                    let p = d > 1 ? Ke(t1.slice(0, d), i) : [], f = d < t1.length ? Ke(t1.slice(d), i) : [];
                    p = p.map((t1)=>new e.P(Ye(t1.x), t1.y)), f = f.map((t1)=>new e.P(Ye(t1.x), t1.y));
                    const m = [
                        ...p
                    ];
                    0 === m.length && m.push(f[f.length - 1]);
                    const g = e.af(m[m.length - 1].y, (0 === f.length ? p[0] : f[0]).y, _);
                    let v;
                    return v = c ? [
                        new e.P(0, g),
                        new e.P(0, 0),
                        new e.P(1, 0),
                        new e.P(1, g)
                    ] : [
                        new e.P(1, g),
                        new e.P(1, 1),
                        new e.P(0, 1),
                        new e.P(0, g)
                    ], m.push(...v), 0 === f.length ? m.push(p[0]) : m.push(...f), {
                        polygon: m.map((t1)=>new e.aa(t1.x, t1.y)),
                        unwrapped: !1
                    };
                }(t1, i);
                if (o) return o;
                const s = function(t1, i) {
                    let o = !1, s = -1 / 0, r = 0;
                    for(let e = 0; e < t1.length - 1; e++)t1[e].x > s && (s = t1[e].x, r = e);
                    for(let e = 0; e < t1.length - 1; e++){
                        const i = (r + e) % (t1.length - 1), s = t1[i], a = t1[i + 1];
                        Math.abs(s.x - a.x) > .5 && (s.x < a.x ? (s.x += 1, 0 === i && (t1[t1.length - 1].x += 1)) : (a.x += 1, i + 1 === t1.length - 1 && (t1[0].x += 1)), o = !0);
                    }
                    const a = e.at(i.center.lng);
                    return o && a < Math.abs(a - 1) && t1.forEach((e)=>{
                        e.x -= 1;
                    }), {
                        polygon: t1,
                        unwrapped: o
                    };
                }(Ke(t1, i).map((t1)=>new e.P(Ye(t1.x), t1.y)), i);
                return {
                    polygon: s.polygon.map((t1)=>new e.aa(t1.x, t1.y)),
                    unwrapped: s.unwrapped
                };
            }
        }
        function Ke(t1, i) {
            return e.av(t1, (e)=>{
                const t1 = i.pointCoordinate3D(e);
                e.x = t1.x, e.y = t1.y;
            }, 1 / 256);
        }
        function Ye(e) {
            return e < 0 ? 1 + e % 1 : e % 1;
        }
        function Je(e) {
            return 100 * e | 0;
        }
        function Qe(t1, i, o, s, r) {
            const a = function(o, s) {
                if (o) return r(o);
                if (s) {
                    if (t1.url && s.tiles && t1.tiles && delete t1.tiles, s.variants) {
                        if (!Array.isArray(s.variants)) return r(new Error("variants must be an array"));
                        for (const t1 of s.variants){
                            if (null == t1 || "object" != typeof t1 || t1.constructor !== Object) return r(new Error("variant must be an object"));
                            if (!Array.isArray(t1.capabilities)) return r(new Error("capabilities must be an array"));
                            if (1 === t1.capabilities.length && "meshopt" === t1.capabilities[0]) {
                                s = e.l(s, t1);
                                break;
                            }
                        }
                    }
                    const o = e.ay(e.l({}, s, t1), [
                        "tilejson",
                        "tiles",
                        "minzoom",
                        "maxzoom",
                        "attribution",
                        "mapbox_logo",
                        "bounds",
                        "scheme",
                        "tileSize",
                        "encoding",
                        "vector_layers",
                        "raster_layers",
                        "worldview_options",
                        "worldview_default",
                        "worldview"
                    ]);
                    o.tiles = i.canonicalizeTileset(o, t1.url), r(null, o);
                }
            }, n = function(e, t1, i) {
                if (!e) return null;
                if (!t1 && !i) return e;
                i = i || e.worldview_default;
                const o = Object.values(e.language || {});
                if (0 === o.length) return null;
                const s = Object.values(e.worldview || {});
                if (0 === s.length) return null;
                const r = o.every((e)=>e === t1), a = s.every((e)=>e === i);
                return r && a ? e : t1 in (e.language_options || {}) || i in (e.worldview_options || {}) ? null : e.language_options && e.worldview_options ? e : null;
            }(t1.data, o, s);
            return n ? e.q.frame(()=>a(null, n)) : t1.url ? e.n(i.transformRequest(i.normalizeSourceURL(t1.url, null, o, s), e.R.Source), a) : e.q.frame(()=>{
                const { data: e, ...i } = t1;
                a(null, i);
            });
        }
        class et {
            constructor(t1, i, o){
                this.bounds = e.az.convert(this.validateBounds(t1)), this.minzoom = i || 0, this.maxzoom = o || 24;
            }
            validateBounds(e) {
                return Array.isArray(e) && 4 === e.length ? [
                    Math.max(-180, e[0]),
                    Math.max(-90, e[1]),
                    Math.min(180, e[2]),
                    Math.min(90, e[3])
                ] : [
                    -180,
                    -90,
                    180,
                    90
                ];
            }
            contains(t1) {
                const i = Math.pow(2, t1.z), o = Math.floor(e.at(this.bounds.getWest()) * i), s = Math.floor(e.aA(this.bounds.getNorth()) * i), r = Math.ceil(e.at(this.bounds.getEast()) * i), a = Math.ceil(e.aA(this.bounds.getSouth()) * i);
                return t1.x >= o && t1.x < r && t1.y >= s && t1.y < a;
            }
        }
        class tt extends e.E {
            constructor(t1, i, o, s){
                if (super(), this.id = t1, this.dispatcher = o, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e.l(this, e.ay(i, [
                    "url",
                    "scheme",
                    "tileSize",
                    "promoteId"
                ])), this._options = e.l({
                    type: "vector"
                }, i), this._collectResourceTiming = !!i.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
                this.setEventedParent(s), this._tileWorkers = {}, this._deduped = new e.aB;
            }
            load(t1) {
                this._loaded = !1, this.fire(new e.z("dataloading", {
                    dataType: "source"
                }));
                const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o = this.map.getWorldview();
                this._tileJSONRequest = Qe(this._options, this.map._requestManager, i, o, (s, r)=>{
                    if (this._tileJSONRequest = null, this._loaded = !0, s) i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.y(s));
                    else if (r) {
                        if (e.l(this, r), this.hasWorldviews = !!r.worldview_options, r.worldview_default && (this.worldviewDefault = r.worldview_default), r.vector_layers) {
                            this.vectorLayers = r.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = new Set;
                            for (const e of r.vector_layers)this.vectorLayerIds.push(e.id), r.worldview && r.worldview[e.source] && this.localizableLayerIds.add(e.id);
                        }
                        r.bounds && (this.tileBounds = new et(r.bounds, this.minzoom, this.maxzoom)), A(r.tiles, this.map._requestManager._customAccessToken), this.fire(new e.z("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        })), this.fire(new e.z("data", {
                            dataType: "source",
                            sourceDataType: "content"
                        }));
                    }
                    t1 && t1(s);
                });
            }
            loaded() {
                return this._loaded;
            }
            hasTile(e) {
                return !this.tileBounds || this.tileBounds.contains(e.canonical);
            }
            onAdd(e) {
                this.map = e, this.load();
            }
            reload() {
                this.cancelTileJSONRequest();
                const t1 = e.aC(this.id, this.scope);
                this.load(()=>this.map.style.clearSource(t1));
            }
            setTiles(e) {
                return this._options.tiles = e, this.reload(), this;
            }
            setUrl(e) {
                return this.url = e, this._options.url = e, this.reload(), this;
            }
            onRemove(e) {
                this.cancelTileJSONRequest();
            }
            serialize() {
                return e.l({}, this._options);
            }
            loadTile(t1, i) {
                const o = t1.tileID.canonical.url(this.tiles, this.scheme), s = this.map._requestManager.normalizeTileURL(o), r = this.map._requestManager.transformRequest(s, e.R.Tile), a = this.map.style ? this.map.style.getLut(this.scope) : null, n = a ? {
                    image: a.image.clone()
                } : null, l = {
                    request: r,
                    data: void 0,
                    uid: t1.uid,
                    tileID: t1.tileID,
                    tileZoom: t1.tileZoom,
                    zoom: t1.tileID.overscaledZ,
                    maxZoom: this.maxzoom,
                    lut: n,
                    tileSize: this.tileSize * t1.tileID.overscaleFactor(),
                    type: this.type,
                    source: this.id,
                    scope: this.scope,
                    pixelRatio: e.q.devicePixelRatio,
                    showCollisionBoxes: this.map.showCollisionBoxes,
                    promoteId: this.promoteId,
                    isSymbolTile: t1.isSymbolTile,
                    brightness: this.map.style && this.map.style.getBrightness() || 0,
                    extraShadowCaster: t1.isExtraShadowCaster,
                    tessellationStep: this.map._tessellationStep,
                    scaleFactor: this.map.getScaleFactor()
                };
                if (this.hasWorldviews && e.f(o) && (l.worldview = this.map.getWorldview() || this.worldviewDefault, l.localizableLayerIds = this.localizableLayerIds), l.request.collectResourceTiming = this._collectResourceTiming, t1.actor && "expired" !== t1.state) "loading" === t1.state ? t1.reloadCallback = i : t1.request = t1.actor.send("reloadTile", l, c.bind(this));
                else if (t1.actor = this._tileWorkers[s] = this._tileWorkers[s] || this.dispatcher.getActor(), this.dispatcher.ready) t1.request = t1.actor.send("loadTile", l, c.bind(this), void 0, !0);
                else {
                    const i = e.aD.call({
                        deduped: this._deduped
                    }, l, (e, i)=>{
                        e || !i ? c.call(this, e) : (l.data = {
                            cacheControl: i.cacheControl,
                            expires: i.expires,
                            rawData: i.rawData.slice(0)
                        }, t1.actor && t1.actor.send("loadTile", l, c.bind(this), void 0, !0));
                    }, !0);
                    t1.request = {
                        cancel: i
                    };
                }
                function c(o, s) {
                    return delete t1.request, t1.aborted ? i(null) : o && 404 !== o.status ? i(o) : (s && s.resourceTiming && (t1.resourceTiming = s.resourceTiming), this.map._refreshExpiredTiles && s && t1.setExpiryData(s), t1.loadVectorData(s, this.map.painter), e.aE(this.dispatcher), i(null), void (t1.reloadCallback && (this.loadTile(t1, t1.reloadCallback), t1.reloadCallback = null)));
                }
            }
            abortTile(e) {
                e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send("abortTile", {
                    uid: e.uid,
                    type: this.type,
                    source: this.id,
                    scope: this.scope
                });
            }
            unloadTile(e, t1) {
                e.actor && e.actor.send("removeTile", {
                    uid: e.uid,
                    type: this.type,
                    source: this.id,
                    scope: this.scope
                }), e.destroy();
            }
            hasTransition() {
                return !1;
            }
            afterUpdate() {
                this._tileWorkers = {};
            }
            cancelTileJSONRequest() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
        }
        class it extends e.E {
            constructor(t1, i, o, s){
                super(), this.id = t1, this.dispatcher = o, this.setEventedParent(s), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = e.l({
                    type: "raster"
                }, i), e.l(this, e.ay(i, [
                    "url",
                    "scheme",
                    "tileSize"
                ]));
            }
            load(t1) {
                this._loaded = !1, this.fire(new e.z("dataloading", {
                    dataType: "source"
                })), this._tileJSONRequest = Qe(this._options, this.map._requestManager, null, null, (i, o)=>{
                    this._tileJSONRequest = null, this._loaded = !0, i ? this.fire(new e.y(i)) : o && (e.l(this, o), o.raster_layers && (this.rasterLayers = o.raster_layers, this.rasterLayerIds = this.rasterLayers.map((e)=>e.id)), o.bounds && (this.tileBounds = new et(o.bounds, this.minzoom, this.maxzoom)), A(o.tiles), this.fire(new e.z("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e.z("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }))), t1 && t1(i);
                });
            }
            loaded() {
                return this._loaded;
            }
            onAdd(e) {
                this.map = e, this.load();
            }
            reload() {
                this.cancelTileJSONRequest();
                const t1 = e.aC(this.id, this.scope);
                this.load(()=>this.map.style.clearSource(t1));
            }
            setTiles(e) {
                return this._options.tiles = e, this.reload(), this;
            }
            setUrl(e) {
                return this.url = e, this._options.url = e, this.reload(), this;
            }
            onRemove(e) {
                this.cancelTileJSONRequest();
            }
            serialize() {
                return e.l({}, this._options);
            }
            hasTile(e) {
                return !this.tileBounds || this.tileBounds.contains(e.canonical);
            }
            loadTile(t1, i) {
                const o = e.q.devicePixelRatio >= 2, s = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), o, this.tileSize);
                t1.request = e.o(this.map._requestManager.transformRequest(s, e.R.Tile), (o, s, r, a)=>(delete t1.request, t1.aborted ? (t1.state = "unloaded", i(null)) : o ? (t1.state = "errored", i(o)) : s ? (this.map._refreshExpiredTiles && t1.setExpiryData({
                        cacheControl: r,
                        expires: a
                    }), t1.setTexture(s, this.map.painter), t1.state = "loaded", e.aE(this.dispatcher), void i(null)) : i(null)));
            }
            abortTile(e, t1) {
                e.request && (e.request.cancel(), delete e.request), t1 && t1();
            }
            unloadTile(t1, i) {
                t1.texture && t1.texture instanceof e.T ? (t1.destroy(!0), t1.texture && t1.texture instanceof e.T && this.map.painter.saveTileTexture(t1.texture)) : t1.destroy(), i && i();
            }
            hasTransition() {
                return !1;
            }
            cancelTileJSONRequest() {
                this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
        }
        class ot extends it {
            constructor(t1, i, o, s){
                super(t1, i, o, s), this.type = "raster-array", this.maxzoom = 22, this._options = e.l({
                    type: "raster-array"
                }, i);
            }
            triggerRepaint(e) {
                const t1 = this.map.painter._terrain, i = this.map.style.getSourceCache(this.id);
                t1 && t1.enabled && i && t1._clearRenderCacheForTile(i.id, e.tileID), this.map.triggerRepaint();
            }
            loadTile(t1, i) {
                const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize), s = this.map._requestManager.transformRequest(o, e.R.Tile);
                t1.requestParams = s, t1.actor || (t1.actor = this.dispatcher.getActor()), t1.request = t1.fetchHeader(void 0, (e, o, s, r)=>{
                    if (delete t1.request, t1.aborted) return t1.state = "unloaded", i(null);
                    if (e) {
                        if (20 === e.code) return;
                        return t1.state = "errored", i(e);
                    }
                    this.map._refreshExpiredTiles && t1.setExpiryData({
                        cacheControl: s,
                        expires: r
                    }), t1.state = "empty", i(null);
                });
            }
            unloadTile(t1, i) {
                const o = t1.texture;
                o && o instanceof e.T ? (t1.destroy(!0), this.map.painter.saveTileTexture(o)) : (t1.destroy(), t1.flushQueues(), t1._isHeaderLoaded = !1, delete t1._mrt, delete t1.textureDescriptor), t1.fbo && (t1.fbo.destroy(), delete t1.fbo), delete t1.request, delete t1.requestParams, delete t1.neighboringTiles, t1.state = "unloaded";
            }
            prepareTile(t1, i, o) {
                t1._isHeaderLoaded && ("empty" !== t1.state && (t1.state = "reloading"), t1.fetchBand(i, o, (i, o)=>{
                    if (i) return t1.state = "errored", this.fire(new e.y(i)), void this.triggerRepaint(t1);
                    o && (t1.setTexture(o, this.map.painter), t1.state = "loaded", this.triggerRepaint(t1));
                }));
            }
            getInitialBand(e) {
                if (!this.rasterLayers) return 0;
                const t1 = this.rasterLayers.find(({ id: t1 })=>t1 === e), i = t1 && t1.fields, o = i && i.bands && i.bands;
                return o ? o[0] : 0;
            }
            getTextureDescriptor(t1, i, o) {
                if (!t1) return;
                const s = i.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
                if (!s) return;
                let r = null;
                i instanceof e.aH ? r = i.paint.get("raster-array-band") : i instanceof e.aI && (r = i.paint.get("raster-particle-array-band"));
                const a = r || this.getInitialBand(s);
                if (null != a) if (t1.textureDescriptor) {
                    if (!t1.updateNeeded(s, a) || o) return Object.assign({}, t1.textureDescriptor, {
                        texture: t1.texture
                    });
                } else this.prepareTile(t1, s, a);
            }
        }
        const st = {
            vector: tt,
            raster: it,
            "raster-dem": class extends it {
                constructor(t1, i, o, s){
                    super(t1, i, o, s), this.type = "raster-dem", this.maxzoom = 22, this._options = e.l({
                        type: "raster-dem"
                    }, i), this.encoding = i.encoding || "mapbox";
                }
                loadTile(t1, i) {
                    const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
                    function s(e, o) {
                        e && (t1.state = "errored", i(e)), o && (t1.dem = o, t1.dem.onDeserialize(), t1.needsHillshadePrepare = !0, t1.needsDEMTextureUpload = !0, t1.state = "loaded", i(null));
                    }
                    t1.request = e.o(this.map._requestManager.transformRequest(o, e.R.Tile), (function(o, r, a, n) {
                        if (delete t1.request, t1.aborted) t1.state = "unloaded", i(null);
                        else if (o) t1.state = "errored", i(o);
                        else if (r) {
                            this.map._refreshExpiredTiles && t1.setExpiryData({
                                cacheControl: a,
                                expires: n
                            });
                            const i = ImageBitmap && r instanceof ImageBitmap && e.t(), o = 1 - (r.width - e.aF(r.width)) / 2;
                            o < 1 || t1.neighboringTiles || (t1.neighboringTiles = this._getNeighboringTiles(t1.tileID));
                            const l = i ? r : e.q.getImageData(r, o), c = {
                                uid: t1.uid,
                                coord: t1.tileID,
                                source: this.id,
                                scope: this.scope,
                                rawImageData: l,
                                encoding: this.encoding,
                                padding: o
                            };
                            t1.actor && "expired" !== t1.state || (t1.actor = this.dispatcher.getActor(), t1.actor.send("loadDEMTile", c, s.bind(this), void 0, !0));
                        }
                    }).bind(this));
                }
                _getNeighboringTiles(t1) {
                    const i = t1.canonical, o = Math.pow(2, i.z), s = (i.x - 1 + o) % o, r = 0 === i.x ? t1.wrap - 1 : t1.wrap, a = (i.x + 1 + o) % o, n = i.x + 1 === o ? t1.wrap + 1 : t1.wrap, l = {};
                    return l[new e.aG(t1.overscaledZ, r, i.z, s, i.y).key] = {
                        backfilled: !1
                    }, l[new e.aG(t1.overscaledZ, n, i.z, a, i.y).key] = {
                        backfilled: !1
                    }, i.y > 0 && (l[new e.aG(t1.overscaledZ, r, i.z, s, i.y - 1).key] = {
                        backfilled: !1
                    }, l[new e.aG(t1.overscaledZ, t1.wrap, i.z, i.x, i.y - 1).key] = {
                        backfilled: !1
                    }, l[new e.aG(t1.overscaledZ, n, i.z, a, i.y - 1).key] = {
                        backfilled: !1
                    }), i.y + 1 < o && (l[new e.aG(t1.overscaledZ, r, i.z, s, i.y + 1).key] = {
                        backfilled: !1
                    }, l[new e.aG(t1.overscaledZ, t1.wrap, i.z, i.x, i.y + 1).key] = {
                        backfilled: !1
                    }, l[new e.aG(t1.overscaledZ, n, i.z, a, i.y + 1).key] = {
                        backfilled: !1
                    }), l;
                }
            },
            "raster-array": ot,
            geojson: class extends e.E {
                constructor(t1, i, o, s){
                    super(), this.id = t1, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(s), this._data = i.data, this._options = e.l({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), void 0 !== i.minzoom && (this.minzoom = i.minzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;
                    const r = e.ag / this.tileSize;
                    this.workerOptions = e.l({
                        source: this.id,
                        scope: this.scope,
                        cluster: i.cluster || !1,
                        geojsonVtOptions: {
                            buffer: (void 0 !== i.buffer ? i.buffer : 128) * r,
                            tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * r,
                            extent: e.ag,
                            maxZoom: this.maxzoom,
                            lineMetrics: i.lineMetrics || !1,
                            generateId: i.generateId || !1
                        },
                        superclusterOptions: {
                            maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,
                            minPoints: Math.max(2, i.clusterMinPoints || 2),
                            extent: e.ag,
                            radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * r,
                            log: !1,
                            generateId: i.generateId || !1
                        },
                        clusterProperties: i.clusterProperties,
                        filter: i.filter,
                        dynamic: i.dynamic
                    }, i.workerOptions);
                }
                onAdd(e) {
                    this.map = e, this.setData(this._data);
                }
                setData(e) {
                    return this._data = e, this._updateWorkerData(), this;
                }
                updateData(t1) {
                    if (!this._options.dynamic) return this.fire(new e.y(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
                    if ("string" != typeof t1 && ("Feature" === t1.type && (t1 = {
                        type: "FeatureCollection",
                        features: [
                            t1
                        ]
                    }), "FeatureCollection" !== t1.type)) return this.fire(new e.y(new Error("Data to update should be a feature or a feature collection.")));
                    if (this._coalesce && "string" != typeof t1 && "string" != typeof this._data && "FeatureCollection" === this._data.type) {
                        const e = new Map;
                        for (const t1 of this._data.features)e.set(t1.id, t1);
                        for (const i of t1.features)e.set(i.id, i);
                        this._data.features = [
                            ...e.values()
                        ];
                    } else this._data = t1;
                    return this._updateWorkerData(!0), this;
                }
                getClusterExpansionZoom(e, t1) {
                    return this.actor.send("geojson.getClusterExpansionZoom", {
                        clusterId: e,
                        source: this.id,
                        scope: this.scope
                    }, t1), this;
                }
                getClusterChildren(e, t1) {
                    return this.actor.send("geojson.getClusterChildren", {
                        clusterId: e,
                        source: this.id,
                        scope: this.scope
                    }, t1), this;
                }
                getClusterLeaves(e, t1, i, o) {
                    return this.actor.send("geojson.getClusterLeaves", {
                        source: this.id,
                        scope: this.scope,
                        clusterId: e,
                        limit: t1,
                        offset: i
                    }, o), this;
                }
                _updateWorkerData(t1 = !1) {
                    if (this._pendingLoad) return void (this._coalesce = !0);
                    this.fire(new e.z("dataloading", {
                        dataType: "source"
                    })), this._loaded = !1;
                    const i = e.l({
                        append: t1
                    }, this.workerOptions);
                    i.scope = this.scope;
                    const o = this._data;
                    "string" == typeof o ? (i.request = this.map._requestManager.transformRequest(e.q.resolveURL(o), e.R.Source), i.request.collectResourceTiming = this._collectResourceTiming) : i.data = JSON.stringify(o), this._pendingLoad = this.actor.send(`${this.type}.loadData`, i, (i, o)=>{
                        if (this._loaded = !0, this._pendingLoad = null, i) this.fire(new e.y(i));
                        else {
                            const i = {
                                dataType: "source",
                                sourceDataType: this._metadataFired ? "content" : "metadata"
                            };
                            this._collectResourceTiming && o && o.resourceTiming && o.resourceTiming[this.id] && (i.resourceTiming = o.resourceTiming[this.id]), t1 && (this._partialReload = !0), this.fire(new e.z("data", i)), this._partialReload = !1, this._metadataFired = !0;
                        }
                        this._coalesce && (this._updateWorkerData(t1), this._coalesce = !1);
                    });
                }
                loaded() {
                    return this._loaded;
                }
                loadTile(t1, i) {
                    const o = t1.actor ? "reloadTile" : "loadTile";
                    t1.actor = this.actor;
                    const s = this.map.style ? this.map.style.getLut(this.scope) : null, r = s ? {
                        image: s.image.clone()
                    } : null, a = this._partialReload, n = {
                        type: this.type,
                        uid: t1.uid,
                        tileID: t1.tileID,
                        tileZoom: t1.tileZoom,
                        zoom: t1.tileID.overscaledZ,
                        maxZoom: this.maxzoom,
                        tileSize: this.tileSize,
                        source: this.id,
                        lut: r,
                        scope: this.scope,
                        pixelRatio: e.q.devicePixelRatio,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        promoteId: this.promoteId,
                        brightness: this.map.style && this.map.style.getBrightness() || 0,
                        scaleFactor: this.map.getScaleFactor(),
                        partial: a
                    };
                    t1.request = this.actor.send(o, n, (e, s)=>a && !s ? (t1.state = "loaded", i(null)) : (delete t1.request, t1.destroy(), t1.aborted ? i(null) : e ? i(e) : (t1.loadVectorData(s, this.map.painter, "reloadTile" === o), i(null))), void 0, "loadTile" === o);
                }
                abortTile(e) {
                    e.request && (e.request.cancel(), delete e.request), e.aborted = !0;
                }
                unloadTile(e, t1) {
                    this.actor.send("removeTile", {
                        uid: e.uid,
                        type: this.type,
                        source: this.id,
                        scope: this.scope
                    }), e.destroy();
                }
                onRemove(e) {
                    this._pendingLoad && this._pendingLoad.cancel();
                }
                serialize() {
                    return e.l({}, this._options, {
                        type: this.type,
                        data: this._data
                    });
                }
                hasTransition() {
                    return !1;
                }
            },
            video: class extends e.aJ {
                constructor(e, t1, i, o){
                    super(e, t1, i, o), this.roundZoom = !0, this.type = "video", this.options = t1;
                }
                load() {
                    this._loaded = !1;
                    const t1 = this.options;
                    this.urls = [];
                    for (const i of t1.urls)this.urls.push(this.map._requestManager.transformRequest(i, e.R.Source).url);
                    e.aK(this.urls, (t1, i)=>{
                        this._loaded = !0, t1 ? this.fire(new e.y(t1)) : i && (this.video = i, this.video.loop = !0, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", ()=>{
                            this.map.triggerRepaint();
                        }), this.map && this.video.play(), this._finishLoading());
                    });
                }
                pause() {
                    this.video && this.video.pause();
                }
                play() {
                    this.video && this.video.play();
                }
                seek(t1) {
                    if (this.video) {
                        const i = this.video.seekable;
                        t1 < i.start(0) || t1 > i.end(0) ? this.fire(new e.y(new e.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = t1;
                    }
                }
                getVideo() {
                    return this.video;
                }
                onAdd(e) {
                    this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
                }
                prepare() {
                    if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
                    const t1 = this.map.painter.context, i = t1.gl;
                    this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new e.T(t1, this.video, i.RGBA8), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t1);
                }
                serialize() {
                    return {
                        type: "video",
                        urls: this.urls,
                        coordinates: this.coordinates
                    };
                }
                hasTransition() {
                    return this.video && !this.video.paused;
                }
            },
            image: e.aJ,
            model: class extends e.E {
                constructor(e, t1, i, o){
                    super(), this.id = e, this.type = "model", this.models = [], this._loaded = !1, this._options = t1;
                }
                load() {
                    const t1 = [];
                    for(const i in this._options.models){
                        const o = this._options.models[i], s = e.aM(this.map._requestManager.transformRequest(o.uri, e.R.Model).url).then((t1)=>{
                            if (!t1) return;
                            const s = e.aN(t1), r = new e.aO(i, o.position, o.orientation, s);
                            r.computeBoundsAndApplyParent(), this.models.push(r);
                        }).catch((t1)=>{
                            this.fire(new e.y(new Error(`Could not load model ${i} from ${o.uri}: ${t1.message}`)));
                        });
                        t1.push(s);
                    }
                    return Promise.allSettled(t1).then(()=>{
                        this._loaded = !0, this.fire(new e.z("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        }));
                    }).catch((t1)=>{
                        this.fire(new e.y(new Error(`Could not load models: ${t1.message}`)));
                    });
                }
                onAdd(e) {
                    this.map = e, this.load();
                }
                hasTransition() {
                    return !1;
                }
                loaded() {
                    return this._loaded;
                }
                getModels() {
                    return this.models;
                }
                loadTile(e, t1) {}
                serialize() {
                    return {
                        type: "model"
                    };
                }
            },
            "batched-model": class extends e.E {
                constructor(e, t1, i, o){
                    super(), this.type = "batched-model", this.id = e, this.tileSize = 512, this._options = t1, this.tiles = this._options.tiles, this.maxzoom = t1.maxzoom || 19, this.minzoom = t1.minzoom || 0, this.roundZoom = !0, this.usedInConflation = !0, this.dispatcher = i, this.reparseOverscaled = !1, this.scheme = "xyz", this._loaded = !1, this.setEventedParent(o);
                }
                onAdd(e) {
                    this.map = e, this.load();
                }
                load(t1) {
                    this._loaded = !1, this.fire(new e.z("dataloading", {
                        dataType: "source"
                    }));
                    const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o = this.map.getWorldview();
                    this._tileJSONRequest = Qe(this._options, this.map._requestManager, i, o, (s, r)=>{
                        this._tileJSONRequest = null, this._loaded = !0, s ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && 2 !== o.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.y(s))) : r && (e.l(this, r), r.bounds && (this.tileBounds = new et(r.bounds, this.minzoom, this.maxzoom)), A(r.tiles, this.map._requestManager._customAccessToken), this.fire(new e.z("data", {
                            dataType: "source",
                            sourceDataType: "metadata"
                        })), this.fire(new e.z("data", {
                            dataType: "source",
                            sourceDataType: "content"
                        }))), t1 && t1(s);
                    });
                }
                hasTransition() {
                    return !1;
                }
                hasTile(e) {
                    return !this.tileBounds || this.tileBounds.contains(e.canonical);
                }
                loaded() {
                    return this._loaded;
                }
                loadTile(t1, i) {
                    const o = this.map._requestManager.normalizeTileURL(t1.tileID.canonical.url(this.tiles, this.scheme)), s = {
                        request: this.map._requestManager.transformRequest(o, e.R.Tile),
                        data: void 0,
                        uid: t1.uid,
                        tileID: t1.tileID,
                        tileZoom: t1.tileZoom,
                        zoom: t1.tileID.overscaledZ,
                        tileSize: this.tileSize * t1.tileID.overscaleFactor(),
                        type: this.type,
                        source: this.id,
                        scope: this.scope,
                        showCollisionBoxes: this.map.showCollisionBoxes,
                        isSymbolTile: t1.isSymbolTile,
                        brightness: this.map.style && this.map.style.getBrightness() || 0,
                        lut: null,
                        maxZoom: null,
                        promoteId: null,
                        pixelRatio: null,
                        scaleFactor: null
                    };
                    if (t1.actor && "expired" !== t1.state) if ("loading" === t1.state) t1.reloadCallback = i;
                    else {
                        if (t1.buckets) {
                            const e = Object.values(t1.buckets);
                            for (const t1 of e)t1.dirty = !0;
                            return void (t1.state = "loaded");
                        }
                        t1.request = t1.actor.send("reloadTile", s, r.bind(this));
                    }
                    else t1.actor = this.dispatcher.getActor(), t1.request = t1.actor.send("loadTile", s, r.bind(this), void 0, !0);
                    function r(e, o) {
                        return t1.aborted ? i(null) : e && 404 !== e.status ? i(e) : (this.map._refreshExpiredTiles && o && t1.setExpiryData(o), t1.loadModelData(o, this.map.painter), t1.state = "loaded", void i(null));
                    }
                }
                serialize() {
                    return e.l({}, this._options);
                }
            },
            canvas: class extends e.aJ {
                constructor(t1, i, o, s){
                    super(t1, i, o, s), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some((e)=>!Array.isArray(e) || 2 !== e.length || e.some((e)=>"number" != typeof e)) || this.fire(new e.y(new e.V(`sources.${t1}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.y(new e.V(`sources.${t1}`, null, 'missing required property "coordinates"'))), i.animate && "boolean" != typeof i.animate && this.fire(new e.y(new e.V(`sources.${t1}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? "string" == typeof i.canvas || i.canvas instanceof HTMLCanvasElement || this.fire(new e.y(new e.V(`sources.${t1}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.y(new e.V(`sources.${t1}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;
                }
                load() {
                    this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.y(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                        this._playing = !0, this.map.triggerRepaint();
                    }, this.pause = function() {
                        this._playing && (this.prepare(), this._playing = !1);
                    }, this._finishLoading());
                }
                getCanvas() {
                    return this.canvas;
                }
                onAdd(e) {
                    this.map = e, this.load(), this.canvas && this.animate && this.play();
                }
                onRemove(e) {
                    this.pause();
                }
                prepare() {
                    let t1 = !1;
                    if (this.canvas.width !== this.width && (this.width = this.canvas.width, t1 = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t1 = !0), this._hasInvalidDimensions()) return;
                    if (0 === Object.keys(this.tiles).length) return;
                    const i = this.map.painter.context;
                    this.texture ? !t1 && !this._playing || this.texture instanceof e.aL || this.texture.update(this.canvas, {
                        premultiply: !0
                    }) : this.texture = new e.T(i, this.canvas, i.gl.RGBA8, {
                        premultiply: !0
                    }), this._prepareData(i);
                }
                serialize() {
                    return {
                        type: "canvas",
                        coordinates: this.coordinates
                    };
                }
                hasTransition() {
                    return this._playing;
                }
                _hasInvalidDimensions() {
                    for (const e of [
                        this.canvas.width,
                        this.canvas.height
                    ])if (isNaN(e) || e <= 0) return !0;
                    return !1;
                }
            },
            custom: class extends e.E {
                constructor(t1, i, o, s){
                    super(), this.id = t1, this.type = "custom", this._dataType = "raster", this._dispatcher = o, this._implementation = i, this.setEventedParent(s), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e.y(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.y(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new et(this._implementation.bounds, this.minzoom, this.maxzoom)), i.update = this._update.bind(this), i.clearTiles = this._clearTiles.bind(this), i.coveringTiles = this._coveringTiles.bind(this), e.l(this, e.ay(i, [
                        "dataType",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution",
                        "minTileCacheSize",
                        "maxTileCacheSize"
                    ]));
                }
                serialize() {
                    return e.ay(this, [
                        "type",
                        "scheme",
                        "minzoom",
                        "maxzoom",
                        "tileSize",
                        "attribution"
                    ]);
                }
                load() {
                    this._loaded = !0, this.fire(new e.z("data", {
                        dataType: "source",
                        sourceDataType: "metadata"
                    })), this.fire(new e.z("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
                loaded() {
                    return this._loaded;
                }
                onAdd(t1) {
                    this.map = t1, this._loaded = !1, this.fire(new e.z("dataloading", {
                        dataType: "source"
                    })), this._implementation.onAdd && this._implementation.onAdd(t1), this.load();
                }
                onRemove(e) {
                    this._implementation.onRemove && this._implementation.onRemove(e);
                }
                hasTile(e) {
                    if (this._implementation.hasTile) {
                        const { x: t1, y: i, z: o } = e.canonical;
                        return this._implementation.hasTile({
                            x: t1,
                            y: i,
                            z: o
                        });
                    }
                    return !this.tileBounds || this.tileBounds.contains(e.canonical);
                }
                loadTile(e, t1) {
                    const { x: i, y: o, z: s } = e.tileID.canonical, r = new AbortController;
                    e.request = Promise.resolve(this._implementation.loadTile({
                        x: i,
                        y: o,
                        z: s
                    }, {
                        signal: r.signal
                    })).then((function(i) {
                        return delete e.request, e.aborted ? (e.state = "unloaded", t1(null)) : void 0 === i ? (e.state = "errored", t1(null)) : null === i ? (this.loadTileData(e, {
                            width: this.tileSize,
                            height: this.tileSize,
                            data: null
                        }), e.state = "loaded", t1(null)) : function(e) {
                            return e instanceof ImageData || e instanceof HTMLCanvasElement || e instanceof ImageBitmap || e instanceof HTMLImageElement;
                        }(i) ? (this.loadTileData(e, i), e.state = "loaded", void t1(null)) : (e.state = "errored", t1(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
                    }).bind(this)).catch((i)=>{
                        20 !== i.code && (e.state = "errored", t1(i));
                    }), e.request.cancel = ()=>r.abort();
                }
                loadTileData(e, t1) {
                    e.setTexture(t1, this.map.painter);
                }
                unloadTile(t1, i) {
                    if (t1.texture && t1.texture instanceof e.T ? (t1.destroy(!0), t1.texture && t1.texture instanceof e.T && this.map.painter.saveTileTexture(t1.texture)) : t1.destroy(), this._implementation.unloadTile) {
                        const { x: e, y: i, z: o } = t1.tileID.canonical;
                        this._implementation.unloadTile({
                            x: e,
                            y: i,
                            z: o
                        });
                    }
                    i && i();
                }
                abortTile(e, t1) {
                    e.request && e.request.cancel && (e.request.cancel(), delete e.request), t1 && t1();
                }
                hasTransition() {
                    return !1;
                }
                _coveringTiles() {
                    return this.map.transform.coveringTiles({
                        tileSize: this.tileSize,
                        minzoom: this.minzoom,
                        maxzoom: this.maxzoom,
                        roundZoom: this.roundZoom
                    }).map((e)=>({
                            x: e.canonical.x,
                            y: e.canonical.y,
                            z: e.canonical.z
                        }));
                }
                _clearTiles() {
                    const t1 = e.aC(this.id, this.scope);
                    this.map.style.clearSource(t1);
                }
                _update() {
                    this.fire(new e.z("data", {
                        dataType: "source",
                        sourceDataType: "content"
                    }));
                }
            }
        }, rt = function(t1, i, o, s) {
            const r = new st[i.type](t1, i, o, s);
            if (r.id !== t1) throw new Error(`Expected Source id to be ${t1} instead of ${r.id}`);
            return e.aP([
                "load",
                "abort",
                "unload",
                "serialize",
                "prepare"
            ], r), r;
        };
        function at(e, t1, i, o, s = !1) {
            const r = t1.sourceCache.transform, a = t1.sourceCache.tilesIn(e, t1.has3DLayers, s);
            a.sort(ct);
            const n = [];
            for (const e of a){
                const a = e.tile.queryRenderedFeatures(t1, e, i, o, r, s);
                Object.keys(a).length && n.push({
                    wrappedTileID: e.tile.tileID.wrapped().key,
                    queryResults: a
                });
            }
            return 0 === n.length ? {} : function(e) {
                const t1 = {}, i = {};
                for (const o of e){
                    const e = o.queryResults, s = o.wrappedTileID, r = i[s] = i[s] || {};
                    for(const i in e){
                        const o = e[i], s = r[i] = r[i] || {}, a = t1[i] = t1[i] || [];
                        for (const e of o)s[e.featureIndex] || (s[e.featureIndex] = !0, a.push(e));
                    }
                }
                return t1;
            }(n);
        }
        function nt(e, t1, i, o, s) {
            const r = {}, a = o.queryRenderedSymbols(e), n = [];
            for (const e of Object.keys(a).map(Number))n.push(s[e]);
            n.sort(ct);
            for (const e of n){
                const o = e.featureIndex.lookupSymbolFeatures(a[e.bucketInstanceId], e.bucketIndex, e.sourceLayerIndex, t1, i);
                for(const t1 in o){
                    const i = r[t1] = r[t1] || [], s = o[t1];
                    s.sort((t1, i)=>{
                        const o = e.featureSortOrder;
                        if (o) {
                            const e = o.indexOf(t1.featureIndex);
                            return o.indexOf(i.featureIndex) - e;
                        }
                        return i.featureIndex - t1.featureIndex;
                    });
                    for (const e of s)i.push(e);
                }
            }
            return r;
        }
        function lt(e, t1) {
            const i = e.getRenderableIds().map((t1)=>e.getTileByID(t1)), o = [], s = {};
            for(let e = 0; e < i.length; e++){
                const r = i[e], a = r.tileID.canonical.key;
                s[a] || (s[a] = !0, r.querySourceFeatures(o, t1));
            }
            return o;
        }
        function ct(e, t1) {
            const i = e.tileID, o = t1.tileID;
            return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;
        }
        function ht(e, t1) {
            const i = {};
            if (!t1) return i;
            for (const o of e){
                const e = o.layerIds.map((e)=>t1.getLayer(e)).filter(Boolean);
                if (0 !== e.length) {
                    o.layers = e, o.stateDependentLayerIds && (o.stateDependentLayers = o.stateDependentLayerIds.map((t1)=>e.filter((e)=>e.id === t1)[0]));
                    for (const t1 of e)i[t1.fqid] = o;
                }
            }
            return i;
        }
        const ut = 32, dt = 33, _t = new Uint16Array(8184);
        for(let e = 0; e < 2046; e++){
            let t1 = e + 2, i = 0, o = 0, s = 0, r = 0, a = 0, n = 0;
            for(1 & t1 ? s = r = a = ut : i = o = n = ut; (t1 >>= 1) > 1;){
                const e = i + s >> 1, l = o + r >> 1;
                1 & t1 ? (s = i, r = o, i = a, o = n) : (i = s, o = r, s = a, r = n), a = e, n = l;
            }
            const l = 4 * e;
            _t[l + 0] = i, _t[l + 1] = o, _t[l + 2] = s, _t[l + 3] = r;
        }
        const pt = new Uint16Array(2178), ft = new Uint8Array(1089), mt = new Uint16Array(1089);
        function gt(e) {
            return 0 === e ? -.03125 : 32 === e ? .03125 : 0;
        }
        const vt = (()=>({
                type: 2,
                extent: e.ag,
                loadGeometry: ()=>[
                        [
                            new e.P(0, 0),
                            new e.P(e.ag + 1, 0),
                            new e.P(e.ag + 1, e.ag + 1),
                            new e.P(0, e.ag + 1),
                            new e.P(0, 0)
                        ]
                    ]
            }))();
        class yt {
            constructor(t1, i, o, s, r){
                this.tileID = t1, this.uid = e.aV(), this.uses = 0, this.tileSize = i, this.tileZoom = o, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = r, s && s.style && (this._lastUpdatedBrightness = s.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", s && s.transform && (this.projection = s.transform.projection);
            }
            registerFadeDuration(t1) {
                const i = t1 + this.timeAdded;
                i < e.q.now() || this.fadeEndTime && i < this.fadeEndTime || (this.fadeEndTime = i);
            }
            wasRequested() {
                return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            get tileTransform() {
                return this._tileTransform || (this._tileTransform = e.aQ(this.tileID.canonical, this.projection)), this._tileTransform;
            }
            loadVectorData(t1, i, o) {
                if (this.unloadVectorData(), this.state = "loaded", t1) {
                    t1.featureIndex && (this.latestFeatureIndex = t1.featureIndex, t1.rawTileData ? (this.latestRawTileData = t1.rawTileData, this.latestFeatureIndex.rawTileData = t1.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t1.collisionBoxArray, this.buckets = ht(t1.buckets, i.style), this.hasSymbolBuckets = !1;
                    for(const t1 in this.buckets){
                        const i = this.buckets[t1];
                        if (i instanceof e.aX) {
                            if (this.hasSymbolBuckets = !0, !o) break;
                            i.justReloaded = !0;
                        }
                    }
                    if (this.hasRTLText = !1, this.hasSymbolBuckets) for(const t1 in this.buckets){
                        const i = this.buckets[t1];
                        if (i instanceof e.aX && i.hasRTLText) {
                            this.hasRTLText = !0, e.aY();
                            break;
                        }
                    }
                    this.queryPadding = 0;
                    for(const e in this.buckets){
                        const t1 = this.buckets[e], o = i.style.getOwnLayer(e);
                        if (!o) continue;
                        const s = o.queryRadius(t1);
                        this.queryPadding = Math.max(this.queryPadding, s);
                    }
                    t1.imageAtlas && (this.imageAtlas = t1.imageAtlas), t1.glyphAtlasImage && (this.glyphAtlasImage = t1.glyphAtlasImage), t1.lineAtlas && (this.lineAtlas = t1.lineAtlas), this._lastUpdatedBrightness = t1.brightness;
                } else this.collisionBoxArray = new e.aW;
            }
            unloadVectorData() {
                if (this.hasData()) {
                    for(const e in this.buckets)this.buckets[e].destroy();
                    this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
                }
            }
            loadModelData(e, t1, i) {
                e && (e.resourceTiming && (this.resourceTiming = e.resourceTiming), this.buckets = {
                    ...this.buckets,
                    ...ht(e.buckets, t1.style)
                }, e.featureIndex && (this.latestFeatureIndex = e.featureIndex));
            }
            getBucket(e) {
                return this.buckets[e.fqid];
            }
            upload(t1) {
                for(const e in this.buckets){
                    const i = this.buckets[e];
                    i.uploadPending() && i.upload(t1);
                }
                const i = t1.gl, o = this.imageAtlas;
                if (o && !o.uploaded) {
                    const s = !!Object.keys(o.patternPositions).length;
                    this.imageAtlasTexture = new e.T(t1, o.image, i.RGBA8, {
                        useMipmap: s
                    }), this.imageAtlas.uploaded = !0;
                }
                this.glyphAtlasImage && (this.glyphAtlasTexture = new e.T(t1, this.glyphAtlasImage, i.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new e.T(t1, this.lineAtlas.image, i.R8), this.lineAtlas.uploaded = !0);
            }
            prepare(e, t1, i) {
                if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture, i), !t1 || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;
                const o = t1.style.getBrightness();
                (this._lastUpdatedBrightness || o) && (this._lastUpdatedBrightness && o && Math.abs(this._lastUpdatedBrightness - o) < .001 || (this.updateBuckets(t1, this._lastUpdatedBrightness !== o), this._lastUpdatedBrightness = o));
            }
            queryRenderedFeatures(t1, i, o, s, r, a) {
                if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile) return {};
                const n = function(t1, i) {
                    const o = e.ab.mat4.fromScaling([], [
                        .5 * t1.width,
                        .5 * -t1.height,
                        1
                    ]);
                    return e.ab.mat4.translate(o, o, [
                        1,
                        -1,
                        0
                    ]), e.ab.mat4.multiply(o, o, t1.calculateProjMatrix(i.toUnwrapped())), Float32Array.from(o);
                }(r, this.tileID);
                return this.latestFeatureIndex.query(t1, {
                    tilespaceGeometry: i,
                    pixelPosMatrix: n,
                    transform: s,
                    availableImages: o,
                    tileTransform: this.tileTransform
                });
            }
            querySourceFeatures(t1, i) {
                const o = this.latestFeatureIndex;
                if (!o || !o.rawTileData) return;
                const s = o.loadVTLayers(), r = i ? i.sourceLayer : "", a = s._geojsonTileLayer || s[r];
                if (!a) return;
                const n = e.aZ(i && i.filter), { z: l, x: c, y: h } = this.tileID.canonical, u = {
                    z: l,
                    x: c,
                    y: h
                };
                for(let i = 0; i < a.length; i++){
                    const s = a.feature(i);
                    if (n.needGeometry) {
                        const t1 = e.a_(s, !0);
                        if (!n.filter(new e.a8(this.tileID.overscaledZ), t1, this.tileID.canonical)) continue;
                    } else if (!n.filter(new e.a8(this.tileID.overscaledZ), s)) continue;
                    const d = o.getId(s, r), _ = new e.a$(s, l, c, h, d);
                    _.tile = u, t1.push(_);
                }
            }
            hasData() {
                return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
                return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(t1) {
                const i = this.expirationTime;
                if (t1.cacheControl) {
                    const i = e.b0(t1.cacheControl);
                    i["max-age"] && (this.expirationTime = Date.now() + 1e3 * i["max-age"]);
                } else t1.expires && (this.expirationTime = new Date(t1.expires).getTime());
                if (this.expirationTime) {
                    const e = Date.now();
                    let t1 = !1;
                    if (this.expirationTime > e) t1 = !1;
                    else if (i) if (this.expirationTime < i) t1 = !0;
                    else {
                        const o = this.expirationTime - i;
                        o ? this.expirationTime = e + Math.max(o, 3e4) : t1 = !0;
                    }
                    else t1 = !0;
                    t1 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
                }
            }
            getExpiryTimeout() {
                if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1);
            }
            refreshFeatureState(e) {
                this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && e && this.updateBuckets(e);
            }
            updateBuckets(t1, i) {
                if (!this.latestFeatureIndex) return;
                if (!t1.style) return;
                const o = this.latestFeatureIndex.loadVTLayers(), s = t1.style.listImages(), r = t1.style.getBrightness();
                for(const a in this.buckets){
                    if (!t1.style.hasLayer(a)) continue;
                    const n = this.buckets[a], l = n.layers[0], c = l.sourceLayer || "_geojsonTileLayer", h = o[c], u = t1.style.getLayerSourceCache(l);
                    let d = {};
                    u && (d = u._state.getState(c, void 0));
                    const _ = this.imageAtlas && this.imageAtlas.patternPositions || {}, p = Object.keys(d).length > 0 && !i;
                    p && !n.stateDependentLayers.length && !i || n.update(d, h, s, _, p ? n.stateDependentLayers : n.layers, i, r), (n instanceof e.b1 || n instanceof e.b2) && t1._terrain && t1._terrain.enabled && u && n.programConfigurations.needsUpload && t1._terrain._clearRenderCacheForTile(u.id, this.tileID);
                    const f = t1 && t1.style && t1.style.getOwnLayer(a);
                    f && (this.queryPadding = Math.max(this.queryPadding, f.queryRadius(n)));
                }
            }
            holdingForFade() {
                return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
                return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < e.q.now();
            }
            clearFadeHold() {
                this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(t1) {
                this.symbolFadeHoldUntil = e.q.now() + t1;
            }
            setTexture(t1, i) {
                const o = i.context, s = o.gl;
                this.texture = this.texture || i.getTileTexture(t1.width), this.texture && this.texture instanceof e.T ? this.texture.update(t1) : (this.texture = new e.T(o, t1, s.RGBA8, {
                    useMipmap: !0
                }), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE));
            }
            setDependencies(e, t1) {
                const i = {};
                for (const e of t1)i[e] = !0;
                this.dependencies[e] = i;
            }
            hasDependency(e, t1) {
                for (const i of e){
                    const e = this.dependencies[i];
                    if (e) {
                        for (const i of t1)if (e[i]) return !0;
                    }
                }
                return !1;
            }
            clearQueryDebugViz() {}
            _makeDebugTileBoundsBuffers(t1, i) {
                if (!i || "mercator" === i.name || this._tileDebugBuffer) return;
                const o = e.b3(vt, this.tileID.canonical, this.tileTransform)[0], s = new e.b4, r = new e.b5;
                for(let e = 0; e < o.length; e++){
                    const { x: t1, y: i } = o[e];
                    s.emplaceBack(t1, i), r.emplaceBack(e);
                }
                r.emplaceBack(0), this._tileDebugIndexBuffer = t1.createIndexBuffer(r), this._tileDebugBuffer = t1.createVertexBuffer(s, e.b6.members), this._tileDebugSegments = e.b7.simpleSegment(0, 0, s.length, r.length);
            }
            _makeTileBoundsBuffers(t1, i) {
                if (this._tileBoundsBuffer || !i || "mercator" === i.name) return;
                const o = e.b3(vt, this.tileID.canonical, this.tileTransform)[0];
                let s, r;
                if (this.isRaster) {
                    const t1 = function(t1, i) {
                        const o = e.aQ(t1, i), s = Math.pow(2, t1.z);
                        for(let r = 0; r < dt; r++)for(let a = 0; a < dt; a++){
                            const n = e.aR((t1.x + (a + gt(a)) / ut) / s), l = e.aS((t1.y + (r + gt(r)) / ut) / s), c = i.project(n, l), h = r * dt + a;
                            pt[2 * h + 0] = Math.round((c.x * o.scale - o.x) * e.ag), pt[2 * h + 1] = Math.round((c.y * o.scale - o.y) * e.ag);
                        }
                        ft.fill(0), mt.fill(0);
                        for(let e = 2045; e >= 0; e--){
                            const t1 = 4 * e, i = _t[t1 + 0], o = _t[t1 + 1], s = _t[t1 + 2], r = _t[t1 + 3], a = i + s >> 1, n = o + r >> 1, l = a + n - o, c = n + i - a, h = o * dt + i, u = r * dt + s, d = n * dt + a, _ = Math.hypot((pt[2 * h + 0] + pt[2 * u + 0]) / 2 - pt[2 * d + 0], (pt[2 * h + 1] + pt[2 * u + 1]) / 2 - pt[2 * d + 1]) >= 16;
                            ft[d] = ft[d] || (_ ? 1 : 0), e < 1022 && (ft[d] = ft[d] || ft[(o + c >> 1) * dt + (i + l >> 1)] || ft[(r + c >> 1) * dt + (s + l >> 1)]);
                        }
                        const r = new e.aT, a = new e.aU;
                        let n = 0;
                        function l(t1, i) {
                            const o = i * dt + t1;
                            return 0 === mt[o] && (r.emplaceBack(pt[2 * o + 0], pt[2 * o + 1], t1 * e.ag / ut, i * e.ag / ut), mt[o] = ++n), mt[o] - 1;
                        }
                        function c(e, t1, i, o, s, r) {
                            const n = e + i >> 1, h = t1 + o >> 1;
                            if (Math.abs(e - s) + Math.abs(t1 - r) > 1 && ft[h * dt + n]) c(s, r, e, t1, n, h), c(i, o, s, r, n, h);
                            else {
                                const n = l(e, t1), c = l(i, o), h = l(s, r);
                                a.emplaceBack(n, c, h);
                            }
                        }
                        return c(0, 0, ut, ut, ut, 0), c(ut, ut, 0, 0, 0, ut), {
                            vertices: r,
                            indices: a
                        };
                    }(this.tileID.canonical, i);
                    s = t1.vertices, r = t1.indices;
                } else {
                    s = new e.aT, r = new e.aU;
                    for (const { x: e, y: t1 } of o)s.emplaceBack(e, t1, 0, 0);
                    const t1 = e.b8(s.int16, void 0, 4);
                    for(let e = 0; e < t1.length; e += 3)r.emplaceBack(t1[e], t1[e + 1], t1[e + 2]);
                }
                this._tileBoundsBuffer = t1.createVertexBuffer(s, e.b9.members), this._tileBoundsIndexBuffer = t1.createIndexBuffer(r), this._tileBoundsSegments = e.b7.simpleSegment(0, 0, s.length, r.length);
            }
            _makeGlobeTileDebugBuffers(t1, i) {
                const o = i.projection;
                if (!o || "globe" !== o.name || i.freezeTileCoverage) return;
                const s = this.tileID.canonical, r = e.ba(s, i), a = e.bb(r), n = e.ae(i.zoom);
                let l;
                n > 0 && (l = e.ab.mat4.invert(new Float64Array(16), i.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t1, s, i, a, l, n), this._makeGlobeTileDebugTextBuffer(t1, s, i, a, l, n);
            }
            _globePoint(t1, i, o, s, r, a, n) {
                let l = e.bc(t1, i, o);
                if (a) {
                    const r = 1 << o.z, c = e.at(s.center.lng), h = e.aA(s.center.lat), u = (o.x + .5) / r - c;
                    let d = 0;
                    u > .5 ? d = -1 : u < -.5 && (d = 1);
                    let _ = (t1 / e.ag + o.x) / r + d, p = (i / e.ag + o.y) / r;
                    _ = (_ - c) * s._pixelsPerMercatorPixel + c, p = (p - h) * s._pixelsPerMercatorPixel + h;
                    const f = [
                        _ * s.worldSize,
                        p * s.worldSize,
                        0
                    ];
                    e.ab.vec3.transformMat4(f, f, a), l = e.bd(l, f, n);
                }
                return e.ab.vec3.transformMat4(l, l, r);
            }
            _makeGlobeTileDebugBorderBuffer(t1, i, o, s, r, a) {
                const n = new e.b4, l = new e.b5, c = new e.be, h = (e, t1, h, u, d)=>{
                    const _ = (h - e) / (d - 1), p = (u - t1) / (d - 1), f = n.length;
                    for(let h = 0; h < d; h++){
                        const u = e + h * _, d = t1 + h * p;
                        n.emplaceBack(u, d);
                        const m = this._globePoint(u, d, i, o, s, r, a);
                        c.emplaceBack(m[0], m[1], m[2]), l.emplaceBack(f + h);
                    }
                }, u = e.ag;
                h(0, 0, u, 0, 16), h(u, 0, u, u, 16), h(u, u, 0, u, 16), h(0, u, 0, 0, 16), this._tileDebugIndexBuffer = t1.createIndexBuffer(l), this._tileDebugBuffer = t1.createVertexBuffer(n, e.b6.members), this._globeTileDebugBorderBuffer = t1.createVertexBuffer(c, e.bf.members), this._tileDebugSegments = e.b7.simpleSegment(0, 0, n.length, l.length);
            }
            _makeGlobeTileDebugTextBuffer(t1, i, o, s, r, a) {
                const n = e.ag / 4, l = new e.b4, c = new e.aU, h = new e.be, u = 25;
                c.reserve(32), l.reserve(u), h.reserve(u);
                const d = (e, t1)=>u * e + t1;
                for(let e = 0; e < u; e++){
                    const t1 = e * n;
                    for(let e = 0; e < u; e++){
                        const c = e * n;
                        l.emplaceBack(c, t1);
                        const u = this._globePoint(c, t1, i, o, s, r, a);
                        h.emplaceBack(u[0], u[1], u[2]);
                    }
                }
                for(let e = 0; e < 4; e++)for(let t1 = 0; t1 < 4; t1++){
                    const i = d(e, t1), o = d(e, t1 + 1), s = d(e + 1, t1), r = d(e + 1, t1 + 1);
                    c.emplaceBack(i, o, s), c.emplaceBack(s, o, r);
                }
                this._tileDebugTextIndexBuffer = t1.createIndexBuffer(c), this._tileDebugTextBuffer = t1.createVertexBuffer(l, e.b6.members), this._globeTileDebugTextBuffer = t1.createVertexBuffer(h, e.bf.members), this._tileDebugTextSegments = e.b7.simpleSegment(0, 0, u, 32);
            }
            destroy(t1 = !1) {
                for(const e in this.buckets)this.buckets[e].destroy();
                this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t1 && this.texture && this.texture instanceof e.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
            }
        }
        e.bg.setPbf(e.bh);
        class xt extends yt {
            constructor(e, t1, i, o, s){
                super(e, t1, i, o, s), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = !1;
            }
            setTexture(t1, i) {
                const o = i.context, s = o.gl;
                this.texture = this.texture || i.getTileTexture(t1.width), this.texture && this.texture instanceof e.T ? this.texture.update(t1, {
                    premultiply: !1
                }) : this.texture = new e.T(o, t1, s.RGBA8, {
                    premultiply: !1
                });
            }
            flushQueues() {
                for(; this._workQueue.length;)this._workQueue.pop()();
                for(; this._fetchQueue.length;)this._fetchQueue.pop()();
            }
            fetchHeader(t1 = 16384, i) {
                const o = this._mrt = new e.bg(30), s = Object.assign({}, this.requestParams, {
                    headers: {
                        Range: "bytes=0-" + (t1 - 1)
                    }
                });
                return this.entireBuffer = null, this.request = e.bi(s, (e, s, r, a)=>{
                    if (e) i(e);
                    else try {
                        const e = o.getHeaderLength(s);
                        if (e > t1) return void (this.request = this.fetchHeader(e, i));
                        o.parseHeader(s), this._isHeaderLoaded = !0;
                        let n = 0;
                        for (const e of Object.values(o.layers))n = Math.max(n, e.dataIndex[e.dataIndex.length - 1].last_byte);
                        s.byteLength >= n && (this.entireBuffer = s), i(null, this.entireBuffer || s, r, a);
                    } catch (e) {
                        i(e);
                    }
                }), this.request;
            }
            fetchBand(t1, i, o) {
                const s = this._mrt;
                if (!this._isHeaderLoaded || !s) return void o(new Error("Tile header is not ready"));
                const r = this.actor;
                if (!r) return void o(new Error("Can't fetch tile band without an actor"));
                let a;
                const n = (e, s)=>{
                    a.complete(e, s), e ? o(e) : (this.updateTextureDescriptor(t1, i), o(null, this.textureDescriptor && this.textureDescriptor.img));
                }, l = (e, t1)=>{
                    if (e) return o(e);
                    const i = r.send("decodeRasterArray", {
                        buffer: t1,
                        task: a
                    }, n, void 0, !0);
                    this._workQueue.push(()=>{
                        i && i.cancel(), a.cancel();
                    });
                }, c = s.getLayer(t1);
                if (!c) return void o(new Error(`Unknown sourceLayer "${t1}"`));
                if (c.hasDataForBand(i)) return this.updateTextureDescriptor(t1, i), void o(null, this.textureDescriptor ? this.textureDescriptor.img : null);
                const h = c.getDataRange([
                    i
                ]);
                if (a = s.createDecodingTask(h), !a || a.tasks.length) if (this.flushQueues(), this.entireBuffer) l(null, this.entireBuffer.slice(h.firstByte, h.lastByte + 1));
                else {
                    const t1 = Object.assign({}, this.requestParams, {
                        headers: {
                            Range: `bytes=${h.firstByte}-${h.lastByte}`
                        }
                    }), i = e.bi(t1, l);
                    this._fetchQueue.push(()=>{
                        i.cancel(), a.cancel();
                    });
                }
                else o(null);
            }
            updateNeeded(e, t1) {
                return (!this.textureDescriptor || this.textureDescriptor.band !== t1 || this.textureDescriptor.layer !== e) && "errored" !== this.state;
            }
            updateTextureDescriptor(t1, i) {
                if (!this._mrt) return;
                const o = this._mrt.getLayer(t1);
                if (!o || !o.hasBand(i) || !o.hasDataForBand(i)) return;
                const { bytes: s, tileSize: r, buffer: a, offset: n, scale: l } = o.getBandView(i), c = r + 2 * a, h = {
                    data: s,
                    width: c,
                    height: c
                }, u = this.texture;
                u && u instanceof e.T && u.update(h, {
                    premultiply: !1
                }), this.textureDescriptor = {
                    layer: t1,
                    band: i,
                    img: h,
                    buffer: a,
                    offset: n,
                    tileSize: r,
                    format: o.pixelFormat,
                    mix: [
                        l,
                        256 * l,
                        65536 * l,
                        16777216 * l
                    ]
                };
            }
        }
        class bt {
            constructor(e, t1){
                this.max = e, this.onRemove = t1, this.reset();
            }
            reset() {
                for(const e in this.data)for (const t1 of this.data[e])t1.timeout && clearTimeout(t1.timeout), this.onRemove(t1.value);
                return this.data = {}, this.order = [], this;
            }
            add(e, t1, i) {
                const o = e.wrapped().key;
                void 0 === this.data[o] && (this.data[o] = []);
                const s = {
                    value: t1,
                    timeout: void 0
                };
                if (void 0 !== i && (s.timeout = setTimeout(()=>{
                    this.remove(e, s);
                }, i)), this.data[o].push(s), this.order.push(o), this.order.length > this.max) {
                    const e = this._getAndRemoveByKey(this.order[0]);
                    e && this.onRemove(e);
                }
                return this;
            }
            has(e) {
                return e.wrapped().key in this.data;
            }
            getAndRemove(e) {
                return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;
            }
            _getAndRemoveByKey(e) {
                const t1 = this.data[e].shift();
                return t1.timeout && clearTimeout(t1.timeout), 0 === this.data[e].length && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t1.value;
            }
            getByKey(e) {
                const t1 = this.data[e];
                return t1 ? t1[0].value : null;
            }
            get(e) {
                return this.has(e) ? this.data[e.wrapped().key][0].value : null;
            }
            remove(e, t1) {
                if (!this.has(e)) return this;
                const i = e.wrapped().key, o = void 0 === t1 ? 0 : this.data[i].indexOf(t1), s = this.data[i][o];
                return this.data[i].splice(o, 1), s.timeout && clearTimeout(s.timeout), 0 === this.data[i].length && delete this.data[i], this.onRemove(s.value), this.order.splice(this.order.indexOf(i), 1), this;
            }
            setMaxSize(e) {
                for(this.max = e; this.order.length > this.max;){
                    const e = this._getAndRemoveByKey(this.order[0]);
                    e && this.onRemove(e);
                }
                return this;
            }
            filter(e) {
                const t1 = [];
                for(const i in this.data)for (const o of this.data[i])e(o.value) || t1.push(o);
                for (const e of t1)this.remove(e.value.tileID, e);
            }
        }
        class wt {
            constructor(){
                this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(t1, i, o) {
                const s = String(i);
                if (this.stateChanges[t1] = this.stateChanges[t1] || {}, this.stateChanges[t1][s] = this.stateChanges[t1][s] || {}, e.l(this.stateChanges[t1][s], o), null === this.deletedStates[t1]) {
                    this.deletedStates[t1] = {};
                    for(const e in this.state[t1])e !== s && (this.deletedStates[t1][e] = null);
                } else if (this.deletedStates[t1] && null === this.deletedStates[t1][s]) {
                    this.deletedStates[t1][s] = {};
                    for(const e in this.state[t1][s])o[e] || (this.deletedStates[t1][s][e] = null);
                } else for(const e in o)this.deletedStates[t1] && this.deletedStates[t1][s] && null === this.deletedStates[t1][s][e] && delete this.deletedStates[t1][s][e];
            }
            removeFeatureState(e, t1, i) {
                if (null === this.deletedStates[e]) return;
                const o = String(t1);
                if (this.deletedStates[e] = this.deletedStates[e] || {}, i && void 0 !== t1) null !== this.deletedStates[e][o] && (this.deletedStates[e][o] = this.deletedStates[e][o] || {}, this.deletedStates[e][o][i] = null);
                else if (void 0 !== t1) if (this.stateChanges[e] && this.stateChanges[e][o]) for(i in this.deletedStates[e][o] = {}, this.stateChanges[e][o])this.deletedStates[e][o][i] = null;
                else this.deletedStates[e][o] = null;
                else this.deletedStates[e] = null;
            }
            getState(t1, i) {
                const o = this.state[t1] || {}, s = this.stateChanges[t1] || {}, r = this.deletedStates[t1];
                if (null === r) return {};
                if (void 0 !== i) {
                    const t1 = String(i), a = e.l({}, o[t1], s[t1]);
                    if (r) {
                        const e = r[i];
                        if (null === e) return {};
                        for(const t1 in e)delete a[t1];
                    }
                    return a;
                }
                const a = e.l({}, o, s);
                if (r) for(const e in r)delete a[e];
                return a;
            }
            initializeTileState(e, t1) {
                e.refreshFeatureState(t1);
            }
            coalesceChanges(t1, i) {
                const o = {};
                for(const t1 in this.stateChanges){
                    this.state[t1] = this.state[t1] || {};
                    const i = {};
                    for(const o in this.stateChanges[t1])this.state[t1][o] || (this.state[t1][o] = {}), e.l(this.state[t1][o], this.stateChanges[t1][o]), i[o] = this.state[t1][o];
                    o[t1] = i;
                }
                for(const t1 in this.deletedStates){
                    this.state[t1] = this.state[t1] || {};
                    const i = {};
                    if (null === this.deletedStates[t1]) for(const e in this.state[t1])i[e] = {}, this.state[t1][e] = {};
                    else for(const e in this.deletedStates[t1]){
                        if (null === this.deletedStates[t1][e]) this.state[t1][e] = {};
                        else if (this.state[t1][e]) for (const i of Object.keys(this.deletedStates[t1][e]))delete this.state[t1][e][i];
                        i[e] = this.state[t1][e];
                    }
                    o[t1] = o[t1] || {}, e.l(o[t1], i);
                }
                if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o).length) for(const e in t1)t1[e].refreshFeatureState(i);
            }
        }
        class Tt extends e.E {
            constructor(e, t1, i){
                super(), this.id = e, this._onlySymbols = i, t1.on("data", (e)=>{
                    "source" === e.dataType && "metadata" === e.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === e.dataType && "content" === e.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
                }), t1.on("error", ()=>{
                    this._sourceErrored = !0;
                }), this._source = t1, this._tiles = {}, this._cache = new bt(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t1.minTileCacheSize, this._maxTileCacheSize = t1.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = !1, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new wt, this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "raster-array" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
            }
            onAdd(e) {
                this.map = e, this._minTileCacheSize = void 0 === this._minTileCacheSize && e ? e._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e ? e._maxTileCacheSize : this._maxTileCacheSize;
            }
            loaded() {
                if (this._sourceErrored) return !0;
                if (!this._sourceLoaded) return !1;
                if (!this._source.loaded()) return !1;
                for(const e in this._tiles){
                    const t1 = this._tiles[e];
                    if ("loaded" !== t1.state && "errored" !== t1.state) return !1;
                }
                return !0;
            }
            getSource() {
                return this._source;
            }
            pause() {
                this._paused = !0;
            }
            resume() {
                if (!this._paused) return;
                const e = this._shouldReloadOnResume;
                this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform);
            }
            _loadTile(e, t1) {
                return e.isSymbolTile = this._onlySymbols, e.isExtraShadowCaster = this._shadowCasterTiles[e.tileID.key], this._source.loadTile(e, t1);
            }
            _unloadTile(e) {
                if (this._source.unloadTile) return this._source.unloadTile(e);
            }
            _abortTile(e) {
                if (this._source.abortTile) return this._source.abortTile(e);
            }
            serialize() {
                return this._source.serialize();
            }
            prepare(e) {
                this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                for(const t1 in this._tiles){
                    const i = this._tiles[t1];
                    i.upload(e), i.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
                }
            }
            getIds() {
                return e.bj(this._tiles).map((e)=>e.tileID).sort(Et).map((e)=>e.key);
            }
            getRenderableIds(t1, i) {
                const o = [];
                for(const e in this._tiles)this._isIdRenderable(+e, t1, i) && o.push(this._tiles[e]);
                return t1 ? o.sort((t1, i)=>{
                    const o = t1.tileID, s = i.tileID, r = new e.P(o.canonical.x, o.canonical.y)._rotate(this.transform.angle), a = new e.P(s.canonical.x, s.canonical.y)._rotate(this.transform.angle);
                    return o.overscaledZ - s.overscaledZ || a.y - r.y || a.x - r.x;
                }).map((e)=>e.tileID.key) : o.map((e)=>e.tileID).sort(Et).map((e)=>e.key);
            }
            hasRenderableParent(e) {
                const t1 = this.findLoadedParent(e, 0);
                return !!t1 && this._isIdRenderable(t1.tileID.key);
            }
            _isIdRenderable(e, t1, i) {
                return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (t1 || !this._tiles[e].holdingForFade()) && (i || !this._shadowCasterTiles[e]);
            }
            reload() {
                if (this._paused) this._shouldReloadOnResume = !0;
                else {
                    this._cache.reset();
                    for(const e in this._tiles)"errored" !== this._tiles[e].state && this._reloadTile(+e, "reloading");
                }
            }
            _reloadTile(e, t1) {
                const i = this._tiles[e];
                i && ("loading" !== i.state && (i.state = t1), this._loadTile(i, this._tileLoaded.bind(this, i, e, t1)));
            }
            _tileLoaded(t1, i, o, s) {
                if (s) if (t1.state = "errored", 404 !== s.status) this._source.fire(new e.y(s, {
                    tile: t1
                }));
                else {
                    if (this._source.fire(new e.z("data", {
                        dataType: "source",
                        sourceDataType: "error",
                        sourceId: this._source.id,
                        tile: t1
                    })), !(t1.tileID.key in this._loadedParentTiles)) return;
                    if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                        const e = this.map.painter.terrain;
                        this.update(this.transform, e.getScaledDemTileSize(), !0), e.resetTileLookupCache(this.id);
                    } else this.update(this.transform);
                }
                else t1.timeAdded = e.q.now(), "expired" === o && (t1.refreshedUponExpiration = !0), this._setTileReloadTimer(i, t1), "raster-dem" === this._source.type && t1.dem && this._backfillDEM(t1), this._state.initializeTileState(t1, this.map ? this.map.painter : null), this._source.fire(new e.z("data", {
                    dataType: "source",
                    tile: t1,
                    coord: t1.tileID,
                    sourceCacheId: this.id
                }));
            }
            _backfillDEM(e) {
                const t1 = this.getRenderableIds();
                for(let o = 0; o < t1.length; o++){
                    const s = t1[o];
                    if (e.neighboringTiles && e.neighboringTiles[s]) {
                        const t1 = this.getTileByID(s);
                        i(e, t1), i(t1, e);
                    }
                }
                function i(e, t1) {
                    if (!e.dem || e.dem.borderReady) return;
                    e.needsHillshadePrepare = !0, e.needsDEMTextureUpload = !0;
                    let i = t1.tileID.canonical.x - e.tileID.canonical.x;
                    const o = t1.tileID.canonical.y - e.tileID.canonical.y, s = Math.pow(2, e.tileID.canonical.z), r = t1.tileID.key;
                    0 === i && 0 === o || Math.abs(o) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + s) ? i += s : 1 === Math.abs(i - s) && (i -= s)), t1.dem && e.dem && (e.dem.backfillBorder(t1.dem, i, o), e.neighboringTiles && e.neighboringTiles[r] && (e.neighboringTiles[r].backfilled = !0)));
                }
            }
            getTile(e) {
                return this.getTileByID(e.key);
            }
            getTileByID(e) {
                return this._tiles[e];
            }
            _retainLoadedChildren(e, t1, i, o) {
                for(const s in this._tiles){
                    let r = this._tiles[s];
                    if (o[s] || !r.hasData() || r.tileID.overscaledZ <= t1 || r.tileID.overscaledZ > i) continue;
                    let a = r.tileID;
                    for(; r && r.tileID.overscaledZ > t1 + 1;){
                        const e = r.tileID.scaledTo(r.tileID.overscaledZ - 1);
                        r = this._tiles[e.key], r && r.hasData() && (a = e);
                    }
                    let n = a;
                    for(; n.overscaledZ > t1;)if (n = n.scaledTo(n.overscaledZ - 1), e[n.key]) {
                        o[a.key] = a;
                        break;
                    }
                }
            }
            findLoadedParent(e, t1) {
                if (e.key in this._loadedParentTiles) {
                    const i = this._loadedParentTiles[e.key];
                    return i && i.tileID.overscaledZ >= t1 ? i : null;
                }
                for(let i = e.overscaledZ - 1; i >= t1; i--){
                    const t1 = e.scaledTo(i), o = this._getLoadedTile(t1);
                    if (o) return o;
                }
            }
            _getLoadedTile(e) {
                const t1 = this._tiles[e.key];
                return t1 && t1.hasData() ? t1 : this._cache.getByKey(this._source.reparseOverscaled ? e.wrapped().key : e.canonical.key);
            }
            updateCacheSize(e, t1) {
                t1 = t1 || this._source.tileSize;
                const i = Math.ceil(e.width / t1) + 1, o = Math.ceil(e.height / t1) + 1, s = Math.floor(i * o * 5), r = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, s) : s, a = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r) : r;
                this._cache.setMaxSize(a);
            }
            handleWrapJump(e) {
                const t1 = Math.round((e - (void 0 === this._prevLng ? e : this._prevLng)) / 360);
                if (this._prevLng = e, t1) {
                    const e = {};
                    for(const i in this._tiles){
                        const o = this._tiles[i];
                        o.tileID = o.tileID.unwrapTo(o.tileID.wrap + t1), e[o.tileID.key] = o;
                    }
                    this._tiles = e;
                    for(const e in this._timers)clearTimeout(this._timers[e]), delete this._timers[e];
                    for(const e in this._tiles)this._setTileReloadTimer(+e, this._tiles[e]);
                }
            }
            update(t1, i, o, s) {
                if (this.transform = t1, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
                if (this.usedForTerrain && !o) return;
                this.updateCacheSize(t1, i), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};
                const r = "batched-model" === this._source.type;
                let a, n = this._source.maxzoom;
                const l = this.map && this.map.painter ? this.map.painter._terrain : null;
                if (l && l.sourceCache === this && l.attenuationRange()) {
                    const e = l.attenuationRange()[0], t1 = Math.floor(e) - Math.log2(l.getDemUpscale());
                    n > t1 && (n = t1);
                }
                if (this.used || this.usedForTerrain) {
                    if (this._source.tileID) a = t1.getVisibleUnwrappedCoordinates(this._source.tileID).map((t1)=>new e.aG(t1.canonical.z, t1.wrap, t1.canonical.z, t1.canonical.x, t1.canonical.y));
                    else if (0 !== this.tileCoverLift) {
                        const s = t1.clone();
                        s.tileCoverLift = this.tileCoverLift, a = s.coveringTiles({
                            tileSize: i || this._source.tileSize,
                            minzoom: this._source.minzoom,
                            maxzoom: n,
                            roundZoom: this._source.roundZoom && !o,
                            reparseOverscaled: this._source.reparseOverscaled,
                            isTerrainDEM: this.usedForTerrain,
                            calculateQuadrantVisibility: r
                        }), this._source.minzoom <= 1 && "globe" === t1.projection.name && (a.push(new e.aG(1, 0, 1, 0, 0)), a.push(new e.aG(1, 0, 1, 1, 0)), a.push(new e.aG(1, 0, 1, 0, 1)), a.push(new e.aG(1, 0, 1, 1, 1)));
                    } else if (a = t1.coveringTiles({
                        tileSize: i || this._source.tileSize,
                        minzoom: this._source.minzoom,
                        maxzoom: n,
                        roundZoom: this._source.roundZoom && !o,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain,
                        calculateQuadrantVisibility: r
                    }), this._source.hasTile) {
                        const e = this._source.hasTile.bind(this._source);
                        a = a.filter((t1)=>e(t1));
                    }
                } else a = [];
                if (a.length > 0 && this.castsShadows && s && "globe" !== this.transform.projection.name && !this.usedForTerrain && !St(this._source.type)) {
                    const e = t1.coveringZoomLevel({
                        tileSize: i || this._source.tileSize,
                        roundZoom: this._source.roundZoom && !o
                    }), n = Math.min(e, this._source.maxzoom);
                    if (r) {
                        const e = t1.extendTileCover(a, n);
                        for (const t1 of e)a.push(t1);
                    } else {
                        const e = t1.extendTileCover(a, n, s);
                        for (const t1 of e)this._shadowCasterTiles[t1.key] = !0, a.push(t1);
                    }
                }
                const c = this._updateRetainedTiles(a);
                if (St(this._source.type) && 0 !== a.length) {
                    const t1 = {}, i = {}, o = Object.keys(c);
                    for (const s of o){
                        const o = c[s], r = this._tiles[s];
                        if (!r || r.fadeEndTime && r.fadeEndTime <= e.q.now()) continue;
                        const a = this.findLoadedParent(o, Math.max(o.overscaledZ - Tt.maxOverzooming, this._source.minzoom));
                        a && (this._addTile(a.tileID), t1[a.tileID.key] = a.tileID), i[s] = o;
                    }
                    const s = a[a.length - 1].overscaledZ;
                    for(const e in this._tiles){
                        const t1 = this._tiles[e];
                        if (c[e] || !t1.hasData()) continue;
                        let o = t1.tileID;
                        for(; o.overscaledZ > s;){
                            o = o.scaledTo(o.overscaledZ - 1);
                            const s = this._tiles[o.key];
                            if (s && s.hasData() && i[o.key]) {
                                c[e] = t1.tileID;
                                break;
                            }
                        }
                    }
                    for(const e in t1)c[e] || (this._coveredTiles[e] = !0, c[e] = t1[e]);
                }
                for(const e in c)this._tiles[e].clearFadeHold();
                const h = e.bk(this._tiles, c);
                for (const e of h){
                    const t1 = this._tiles[e];
                    t1.hasSymbolBuckets && !t1.holdingForFade() ? t1.setHoldDuration(this.map._fadeDuration) : t1.hasSymbolBuckets && !t1.symbolFadeFinished() || this._removeTile(+e);
                }
                this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
            }
            releaseSymbolFadeTiles() {
                for(const e in this._tiles)this._tiles[e].holdingForFade() && this._removeTile(+e);
            }
            _updateRetainedTiles(e) {
                const t1 = {};
                if (0 === e.length) return t1;
                const i = {}, o = e.reduce((e, t1)=>Math.min(e, t1.overscaledZ), 1 / 0), s = e[0].overscaledZ, r = Math.max(s - Tt.maxOverzooming, this._source.minzoom), a = Math.max(s + Tt.maxUnderzooming, this._source.minzoom), n = {};
                for (const i of e){
                    const e = this._addTile(i);
                    t1[i.key] = i, e.hasData() || o < this._source.maxzoom && (n[i.key] = i);
                }
                this._retainLoadedChildren(n, o, a, t1);
                for (const o of e){
                    let e = this._tiles[o.key];
                    if (e.hasData()) continue;
                    if (o.canonical.z >= this._source.maxzoom) {
                        const e = o.children(this._source.maxzoom)[0], i = this.getTile(e);
                        if (i && i.hasData()) {
                            t1[e.key] = e;
                            continue;
                        }
                    } else {
                        const e = o.children(this._source.maxzoom);
                        if (t1[e[0].key] && t1[e[1].key] && t1[e[2].key] && t1[e[3].key]) continue;
                    }
                    let s = e.wasRequested();
                    for(let a = o.overscaledZ - 1; a >= r; --a){
                        const r = o.scaledTo(a);
                        if (i[r.key]) break;
                        if (i[r.key] = !0, e = this.getTile(r), !e && s && (e = this._addTile(r)), e && (t1[r.key] = r, s = e.wasRequested(), e.hasData())) break;
                    }
                }
                return t1;
            }
            _updateLoadedParentTileCache() {
                this._loadedParentTiles = {};
                for(const e in this._tiles){
                    const t1 = [];
                    let i, o = this._tiles[e].tileID;
                    for(; o.overscaledZ > 0;){
                        if (o.key in this._loadedParentTiles) {
                            i = this._loadedParentTiles[o.key];
                            break;
                        }
                        t1.push(o.key);
                        const e = o.scaledTo(o.overscaledZ - 1);
                        if (i = this._getLoadedTile(e), i) break;
                        o = e;
                    }
                    for (const e of t1)this._loadedParentTiles[e] = i;
                }
            }
            _addTile(t1) {
                let i = this._tiles[t1.key];
                if (i) return !0 !== i.isExtraShadowCaster || !!this._shadowCasterTiles[t1.key] || this._reloadTile(t1.key, "reloading"), i;
                i = this._cache.getAndRemove(t1), i && (this._setTileReloadTimer(t1.key, i), i.tileID = t1, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[t1.key] && (clearTimeout(this._cacheTimers[t1.key]), delete this._cacheTimers[t1.key], this._setTileReloadTimer(t1.key, i)));
                const o = Boolean(i);
                if (!o) {
                    const e = this.map ? this.map.painter : null, o = this._source.tileSize * t1.overscaleFactor();
                    i = "raster-array" === this._source.type ? new xt(t1, o, this.transform.tileZoom, e, this._isRaster) : new yt(t1, o, this.transform.tileZoom, e, this._isRaster), this._loadTile(i, this._tileLoaded.bind(this, i, t1.key, i.state));
                }
                return i ? (i.uses++, this._tiles[t1.key] = i, o || this._source.fire(new e.z("dataloading", {
                    tile: i,
                    coord: i.tileID,
                    dataType: "source"
                })), i) : null;
            }
            _setTileReloadTimer(e, t1) {
                e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);
                const i = t1.getExpiryTimeout();
                i && (this._timers[e] = setTimeout(()=>{
                    this._reloadTile(e, "expired"), delete this._timers[e];
                }, i));
            }
            _removeTile(e) {
                const t1 = this._tiles[e];
                t1 && (t1.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), t1.uses > 0 || (t1.hasData() && "reloading" !== t1.state || "empty" === t1.state ? this._cache.add(t1.tileID, t1, t1.getExpiryTimeout()) : (t1.aborted = !0, this._abortTile(t1), this._unloadTile(t1))));
            }
            clearTiles() {
                this._shouldReloadOnResume = !1, this._paused = !1;
                for(const e in this._tiles)this._removeTile(+e);
                this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
            }
            tilesIn(t1, i, o) {
                const s = [], r = this.transform;
                if (!r) return s;
                const a = "globe" === r.projection.name, n = e.at(r.center.lng);
                for(const l in this._tiles){
                    const c = this._tiles[l];
                    if (o && c.clearQueryDebugViz(), c.holdingForFade()) continue;
                    let h;
                    if (a) {
                        const t1 = c.tileID.canonical;
                        if (0 === t1.z) {
                            const i = [
                                Math.abs(e.aw(n, ...Ct(t1, -1)) - n),
                                Math.abs(e.aw(n, ...Ct(t1, 1)) - n)
                            ];
                            h = [
                                0,
                                2 * i.indexOf(Math.min(...i)) - 1
                            ];
                        } else {
                            const i = [
                                Math.abs(e.aw(n, ...Ct(t1, -1)) - n),
                                Math.abs(e.aw(n, ...Ct(t1, 0)) - n),
                                Math.abs(e.aw(n, ...Ct(t1, 1)) - n)
                            ];
                            h = [
                                i.indexOf(Math.min(...i)) - 1
                            ];
                        }
                    } else h = [
                        0
                    ];
                    for (const e of h){
                        const o = t1.containsTile(c, r, i, e);
                        o && s.push(o);
                    }
                }
                return s;
            }
            getShadowCasterCoordinates() {
                return this._getRenderableCoordinates(!1, !0);
            }
            getVisibleCoordinates(e) {
                return this._getRenderableCoordinates(e);
            }
            _getRenderableCoordinates(e, t1) {
                const i = this.getRenderableIds(e, t1).map((e)=>this._tiles[e].tileID), o = "globe" === this.transform.projection.name;
                for (const e of i)e.projMatrix = this.transform.calculateProjMatrix(e.toUnwrapped()), e.expandedProjMatrix = o ? this.transform.calculateProjMatrix(e.toUnwrapped(), !1, !0) : e.projMatrix;
                return i;
            }
            sortCoordinatesByDistance(e) {
                const t1 = e.slice(), i = this.transform._camera.position, o = this.transform._camera.forward(), s = {};
                for (const e of t1){
                    const t1 = 1 / (1 << e.canonical.z);
                    s[e.key] = ((e.canonical.x + .5) * t1 + e.wrap - i[0]) * o[0] + ((e.canonical.y + .5) * t1 - i[1]) * o[1] - i[2] * o[2];
                }
                return t1.sort((e, t1)=>s[e.key] - s[t1.key]), t1;
            }
            hasTransition() {
                if (this._source.hasTransition()) return !0;
                if (St(this._source.type)) for(const t1 in this._tiles){
                    const i = this._tiles[t1];
                    if (void 0 !== i.fadeEndTime && i.fadeEndTime >= e.q.now()) return !0;
                }
                return !1;
            }
            setFeatureState(e, t1, i) {
                this._state.updateState(e = e || "_geojsonTileLayer", t1, i);
            }
            removeFeatureState(e, t1, i) {
                this._state.removeFeatureState(e = e || "_geojsonTileLayer", t1, i);
            }
            getFeatureState(e, t1) {
                return this._state.getState(e = e || "_geojsonTileLayer", t1);
            }
            setDependencies(e, t1, i) {
                const o = this._tiles[e];
                o && o.setDependencies(t1, i);
            }
            reloadTilesForDependencies(e, t1) {
                for(const i in this._tiles)this._tiles[i].hasDependency(e, t1) && this._reloadTile(+i, "reloading");
                this._cache.filter((i)=>!i.hasDependency(e, t1));
            }
            _preloadTiles(t1, i) {
                if (!this._sourceLoaded) {
                    const e = ()=>{
                        this._sourceLoaded && (this._source.off("data", e), this._preloadTiles(t1, i));
                    };
                    return void this._source.on("data", e);
                }
                const o = new Map, s = Array.isArray(t1) ? t1 : [
                    t1
                ], r = this.map.painter.terrain, a = this.usedForTerrain && r ? r.getScaledDemTileSize() : this._source.tileSize;
                for (const e of s){
                    const t1 = e.coveringTiles({
                        tileSize: a,
                        minzoom: this._source.minzoom,
                        maxzoom: this._source.maxzoom,
                        roundZoom: this._source.roundZoom && !this.usedForTerrain,
                        reparseOverscaled: this._source.reparseOverscaled,
                        isTerrainDEM: this.usedForTerrain
                    });
                    for (const e of t1)o.set(e.key, e);
                    this.usedForTerrain && e.updateElevation(!1);
                }
                const n = Array.from(o.values());
                e.bl(n, (e, t1)=>{
                    const i = new yt(e, this._source.tileSize * e.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
                    this._loadTile(i, (e)=>{
                        "raster-dem" === this._source.type && i.dem && this._backfillDEM(i), t1(e, i);
                    });
                }, i);
            }
        }
        function Et(e, t1) {
            const i = Math.abs(2 * e.wrap) - +(e.wrap < 0), o = Math.abs(2 * t1.wrap) - +(t1.wrap < 0);
            return e.overscaledZ - t1.overscaledZ || o - i || t1.canonical.y - e.canonical.y || t1.canonical.x - e.canonical.x;
        }
        function St(e) {
            return "raster" === e || "image" === e || "video" === e || "custom" === e;
        }
        function Ct(e, t1) {
            const i = 1 << e.z;
            return [
                e.x / i + t1,
                (e.x + 1) / i + t1
            ];
        }
        Tt.maxOverzooming = 10, Tt.maxUnderzooming = 3;
        class It {
            constructor(e){
                this.style = e, this.layersGotHidden = !1, this.layers = [];
            }
            processLayersChanged() {
                this.layers = [];
                const e = !1, t1 = !1;
                for(const i in this.style._mergedLayers){
                    const o = this.style._mergedLayers[i];
                    if ("fill-extrusion" === o.type) this.layers.push({
                        layer: o,
                        visible: e,
                        visibilityChanged: t1
                    });
                    else if ("model" === o.type) {
                        const i = this.style.getLayerSource(o);
                        i && "batched-model" === i.type && this.layers.push({
                            layer: o,
                            visible: e,
                            visibilityChanged: t1
                        });
                    }
                }
            }
            onNewFrame(e) {
                this.layersGotHidden = !1;
                for (const t1 of this.layers){
                    const i = t1.layer;
                    let o = !1;
                    "fill-extrusion" === i.type ? o = !i.isHidden(e) && i.paint.get("fill-extrusion-opacity") > 0 : "model" === i.type && (o = !i.isHidden(e) && i.paint.get("model-opacity").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !o && t1.visible, t1.visible = o;
                }
            }
            updateZOffset(e, t1) {
                this.currentBuildingBuckets = [];
                for (const e of this.layers){
                    const i = e.layer, o = this.style.getLayerSourceCache(i);
                    let s = 1;
                    "fill-extrusion" === i.type && (s = e.visible ? i.paint.get("fill-extrusion-vertical-scale") : 0);
                    let r = o ? o.getTile(t1) : null;
                    if (!r && o && t1.canonical.z > o.getSource().minzoom) {
                        let e = t1.scaledTo(Math.min(o.getSource().maxzoom, t1.overscaledZ - 1));
                        for(; e.overscaledZ >= o.getSource().minzoom && (r = o.getTile(e), !r && 0 !== e.overscaledZ);)e = e.scaledTo(e.overscaledZ - 1);
                    }
                    this.currentBuildingBuckets.push({
                        bucket: r ? r.getBucket(i) : null,
                        tileID: r ? r.tileID : t1,
                        verticalScale: s
                    });
                }
                e.hasAnyZOffset = !1;
                let i = !1;
                for(let o = 0; o < e.symbolInstances.length; o++){
                    const s = e.symbolInstances.get(o), r = s.zOffset, a = this._getHeightAtTileOffset(t1, s.tileAnchorX, s.tileAnchorY);
                    s.zOffset = a !== Number.NEGATIVE_INFINITY ? a : r, i || r === s.zOffset || (i = !0), e.hasAnyZOffset || 0 === s.zOffset || (e.hasAnyZOffset = !0);
                }
                i && (e.zOffsetBuffersNeedUpload = !0, e.zOffsetSortDirty = !0);
            }
            _mapCoordToOverlappingTile(t1, i, o, s) {
                let r = i, a = o;
                if (t1.canonical.z !== s.canonical.z) {
                    const n = s.canonical, l = 1 / (1 << t1.canonical.z - n.z);
                    r = (i + t1.canonical.x * e.ag) * l - n.x * e.ag | 0, a = (o + t1.canonical.y * e.ag) * l - n.y * e.ag | 0;
                }
                return {
                    tileX: r,
                    tileY: a
                };
            }
            _getHeightAtTileOffset(e, t1, i) {
                let o, s;
                for(let r = 0; r < this.layers.length; ++r){
                    if ("fill-extrusion" !== this.layers[r].layer.type) continue;
                    const { bucket: a, tileID: n, verticalScale: l } = this.currentBuildingBuckets[r];
                    if (!a) continue;
                    const { tileX: c, tileY: h } = this._mapCoordToOverlappingTile(e, t1, i, n), u = a.getHeightAtTileCoord(c, h);
                    u && void 0 !== u.height && (u.hidden ? o = u.height : s = Math.max(u.height * l, s || 0));
                }
                if (void 0 !== s) return s;
                for(let s = 0; s < this.layers.length; ++s){
                    const r = this.layers[s];
                    if ("model" !== r.layer.type || !r.visible) continue;
                    const { bucket: a, tileID: n } = this.currentBuildingBuckets[s];
                    if (!a) continue;
                    const { tileX: l, tileY: c } = this._mapCoordToOverlappingTile(e, t1, i, n), h = a.getHeightAtTileCoord(l, c);
                    if (h && !h.hidden) return void 0 === h.height && void 0 !== o ? Math.min(h.maxHeight, o) * h.verticalScale : h.height ? h.height * h.verticalScale : Number.NEGATIVE_INFINITY;
                }
                return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
            }
        }
        function Rt(t1, i) {
            const o = {};
            for(const e in t1)"ref" !== e && (o[e] = t1[e]);
            return e.bm.forEach((e)=>{
                e in i && (o[e] = i[e]);
            }), o;
        }
        function Dt(e) {
            e = e.slice();
            const t1 = Object.create(null);
            for(let i = 0; i < e.length; i++)t1[e[i].id] = e[i];
            for(let i = 0; i < e.length; i++)"ref" in e[i] && (e[i] = Rt(e[i], t1[e[i].ref]));
            return e;
        }
        const Lt = {
            setStyle: "setStyle",
            addLayer: "addLayer",
            removeLayer: "removeLayer",
            setPaintProperty: "setPaintProperty",
            setLayoutProperty: "setLayoutProperty",
            setSlot: "setSlot",
            setFilter: "setFilter",
            addSource: "addSource",
            removeSource: "removeSource",
            setGeoJSONSourceData: "setGeoJSONSourceData",
            setLayerZoomRange: "setLayerZoomRange",
            setLayerProperty: "setLayerProperty",
            setCenter: "setCenter",
            setZoom: "setZoom",
            setBearing: "setBearing",
            setPitch: "setPitch",
            setSprite: "setSprite",
            setGlyphs: "setGlyphs",
            setTransition: "setTransition",
            setLight: "setLight",
            setTerrain: "setTerrain",
            setFog: "setFog",
            setSnow: "setSnow",
            setRain: "setRain",
            setCamera: "setCamera",
            setLights: "setLights",
            setProjection: "setProjection",
            addImport: "addImport",
            removeImport: "removeImport",
            updateImport: "updateImport"
        };
        function At(e, t1, i) {
            i.push({
                command: Lt.addSource,
                args: [
                    e,
                    t1[e]
                ]
            });
        }
        function zt(e, t1, i) {
            t1.push({
                command: Lt.removeSource,
                args: [
                    e
                ]
            }), i[e] = !0;
        }
        function Pt(e, t1, i, o) {
            zt(e, i, o), At(e, t1, i);
        }
        function Mt(t1, i, o) {
            let s;
            for(s in t1[o])if (t1[o].hasOwnProperty(s) && "data" !== s && !e.bn(t1[o][s], i[o][s])) return !1;
            for(s in i[o])if (i[o].hasOwnProperty(s) && "data" !== s && !e.bn(t1[o][s], i[o][s])) return !1;
            return !0;
        }
        function Ot(t1, i, o, s, r, a) {
            let n;
            for(n in i = i || {}, t1 = t1 || {})t1.hasOwnProperty(n) && (e.bn(t1[n], i[n]) || o.push({
                command: a,
                args: [
                    s,
                    n,
                    i[n],
                    r
                ]
            }));
            for(n in i)i.hasOwnProperty(n) && !t1.hasOwnProperty(n) && (e.bn(t1[n], i[n]) || o.push({
                command: a,
                args: [
                    s,
                    n,
                    i[n],
                    r
                ]
            }));
        }
        function Ft(e) {
            return e.id;
        }
        function kt(e, t1) {
            return e[t1.id] = t1, e;
        }
        class Bt {
            constructor(e, t1){
                this.reset(e, t1);
            }
            reset(e, t1) {
                this.points = e || [], this._distances = [
                    0
                ];
                for(let e = 1; e < this.points.length; e++)this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);
                this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t1 || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(t1) {
                if (1 === this.points.length) return this.points[0];
                t1 = e.aw(t1, 0, 1);
                let i = 1, o = this._distances[i];
                const s = t1 * this.paddedLength + this.padding;
                for(; o < s && i < this._distances.length;)o = this._distances[++i];
                const r = i - 1, a = this._distances[r], n = o - a, l = n > 0 ? (s - a) / n : 0;
                return this.points[r].mult(1 - l).add(this.points[i].mult(l));
            }
        }
        class Nt {
            constructor(e, t1, i){
                const o = this.boxCells = [], s = this.circleCells = [];
                this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t1 / i);
                for(let e = 0; e < this.xCellCount * this.yCellCount; e++)o.push([]), s.push([]);
                this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t1, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t1, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
                return this.boxKeys.length + this.circleKeys.length;
            }
            insert(e, t1, i, o, s) {
                this._forEachCell(t1, i, o, s, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t1), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(s);
            }
            insertCircle(e, t1, i, o) {
                this._forEachCell(t1 - o, i - o, t1 + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t1), this.circles.push(i), this.circles.push(o);
            }
            _insertBoxCell(e, t1, i, o, s, r) {
                this.boxCells[s].push(r);
            }
            _insertCircleCell(e, t1, i, o, s, r) {
                this.circleCells[s].push(r);
            }
            _query(e, t1, i, o, s, r) {
                if (i < 0 || e > this.width || o < 0 || t1 > this.height) return !s && [];
                const a = [];
                if (e <= 0 && t1 <= 0 && this.width <= i && this.height <= o) {
                    if (s) return !0;
                    for(let e = 0; e < this.boxKeys.length; e++)a.push({
                        key: this.boxKeys[e],
                        x1: this.bboxes[4 * e],
                        y1: this.bboxes[4 * e + 1],
                        x2: this.bboxes[4 * e + 2],
                        y2: this.bboxes[4 * e + 3]
                    });
                    for(let e = 0; e < this.circleKeys.length; e++){
                        const t1 = this.circles[3 * e], i = this.circles[3 * e + 1], o = this.circles[3 * e + 2];
                        a.push({
                            key: this.circleKeys[e],
                            x1: t1 - o,
                            y1: i - o,
                            x2: t1 + o,
                            y2: i + o
                        });
                    }
                    return r ? a.filter(r) : a;
                }
                return this._forEachCell(e, t1, i, o, this._queryCell, a, {
                    hitTest: s,
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, r), s ? a.length > 0 : a;
            }
            _queryCircle(e, t1, i, o, s) {
                const r = e - i, a = e + i, n = t1 - i, l = t1 + i;
                if (a < 0 || r > this.width || l < 0 || n > this.height) return !o && [];
                const c = [];
                return this._forEachCell(r, n, a, l, this._queryCellCircle, c, {
                    hitTest: o,
                    circle: {
                        x: e,
                        y: t1,
                        radius: i
                    },
                    seenUids: {
                        box: {},
                        circle: {}
                    }
                }, s), o ? c.length > 0 : c;
            }
            query(e, t1, i, o, s) {
                return this._query(e, t1, i, o, !1, s);
            }
            hitTest(e, t1, i, o, s) {
                return this._query(e, t1, i, o, !0, s);
            }
            hitTestCircle(e, t1, i, o) {
                return this._queryCircle(e, t1, i, !0, o);
            }
            _queryCell(e, t1, i, o, s, r, a, n) {
                const l = a.seenUids, c = this.boxCells[s];
                if (null !== c) {
                    const s = this.bboxes;
                    for (const h of c)if (!l.box[h]) {
                        l.box[h] = !0;
                        const c = 4 * h;
                        if (e <= s[c + 2] && t1 <= s[c + 3] && i >= s[c + 0] && o >= s[c + 1] && (!n || n(this.boxKeys[h]))) {
                            if (a.hitTest) return r.push(!0), !0;
                            r.push({
                                key: this.boxKeys[h],
                                x1: s[c],
                                y1: s[c + 1],
                                x2: s[c + 2],
                                y2: s[c + 3]
                            });
                        }
                    }
                }
                const h = this.circleCells[s];
                if (null !== h) {
                    const s = this.circles;
                    for (const c of h)if (!l.circle[c]) {
                        l.circle[c] = !0;
                        const h = 3 * c;
                        if (this._circleAndRectCollide(s[h], s[h + 1], s[h + 2], e, t1, i, o) && (!n || n(this.circleKeys[c]))) {
                            if (a.hitTest) return r.push(!0), !0;
                            {
                                const e = s[h], t1 = s[h + 1], i = s[h + 2];
                                r.push({
                                    key: this.circleKeys[c],
                                    x1: e - i,
                                    y1: t1 - i,
                                    x2: e + i,
                                    y2: t1 + i
                                });
                            }
                        }
                    }
                }
            }
            _queryCellCircle(e, t1, i, o, s, r, a, n) {
                const l = a.circle, c = a.seenUids, h = this.boxCells[s];
                if (null !== h) {
                    const e = this.bboxes;
                    for (const t1 of h)if (!c.box[t1]) {
                        c.box[t1] = !0;
                        const i = 4 * t1;
                        if (this._circleAndRectCollide(l.x, l.y, l.radius, e[i + 0], e[i + 1], e[i + 2], e[i + 3]) && (!n || n(this.boxKeys[t1]))) return r.push(!0), !0;
                    }
                }
                const u = this.circleCells[s];
                if (null !== u) {
                    const e = this.circles;
                    for (const t1 of u)if (!c.circle[t1]) {
                        c.circle[t1] = !0;
                        const i = 3 * t1;
                        if (this._circlesCollide(e[i], e[i + 1], e[i + 2], l.x, l.y, l.radius) && (!n || n(this.circleKeys[t1]))) return r.push(!0), !0;
                    }
                }
            }
            _forEachCell(e, t1, i, o, s, r, a, n) {
                const l = this._convertToXCellCoord(e), c = this._convertToYCellCoord(t1), h = this._convertToXCellCoord(i), u = this._convertToYCellCoord(o);
                for(let d = l; d <= h; d++)for(let l = c; l <= u; l++)if (s.call(this, e, t1, i, o, this.xCellCount * l + d, r, a, n)) return;
            }
            _convertToXCellCoord(e) {
                return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));
            }
            _convertToYCellCoord(e) {
                return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));
            }
            _circlesCollide(e, t1, i, o, s, r) {
                const a = o - e, n = s - t1, l = i + r;
                return l * l > a * a + n * n;
            }
            _circleAndRectCollide(e, t1, i, o, s, r, a) {
                const n = (r - o) / 2, l = Math.abs(e - (o + n));
                if (l > n + i) return !1;
                const c = (a - s) / 2, h = Math.abs(t1 - (s + c));
                if (h > c + i) return !1;
                if (l <= n || h <= c) return !0;
                const u = l - n, d = h - c;
                return u * u + d * d <= i * i;
            }
        }
        const Ut = {
            unknown: 0,
            flipRequired: 1,
            flipNotRequired: 2
        }, Gt = Math.tan(85 * Math.PI / 180);
        function jt(t1, i, o, s, r, a, n) {
            const l = e.ab.mat4.create();
            if (o) if ("globe" === a.name) {
                const t1 = e.bo(r, i);
                e.ab.mat4.multiply(l, l, t1);
            } else {
                const t1 = e.ab.mat2.invert([], n);
                l[0] = t1[0], l[1] = t1[1], l[4] = t1[2], l[5] = t1[3], s || e.ab.mat4.rotateZ(l, l, r.angle);
            }
            else e.ab.mat4.multiply(l, r.labelPlaneMatrix, t1);
            return l;
        }
        function Vt(e, t1, i, o, s, r, a) {
            const n = jt(e, t1, i, o, s, r, a);
            return "globe" === r.name && i || (n[2] = n[6] = n[10] = n[14] = 0), n;
        }
        function qt(t1, i, o, s, r, a, n) {
            if (o) {
                if ("globe" === a.name) {
                    const l = jt(t1, i, o, s, r, a, n);
                    return e.ab.mat4.invert(l, l), e.ab.mat4.multiply(l, t1, l), l;
                }
                {
                    const i = e.ab.mat4.clone(t1), o = e.ab.mat4.identity([]);
                    return o[0] = n[0], o[1] = n[1], o[4] = n[2], o[5] = n[3], e.ab.mat4.multiply(i, i, o), s || e.ab.mat4.rotateZ(i, i, -r.angle), i;
                }
            }
            return r.glCoordMatrix;
        }
        function Ht(t1, i, o, s) {
            const r = [
                t1,
                i,
                o,
                1
            ];
            o ? e.ab.vec4.transformMat4(r, r, s) : ii(r, r, s);
            const a = r[3];
            return r[0] /= a, r[1] /= a, r[2] /= a, r;
        }
        function Zt(e, t1) {
            return Math.min(.5 + e / t1 * .5, 1.5);
        }
        function Wt(e, t1) {
            const i = e[0] / e[3], o = e[1] / e[3];
            return i >= -t1[0] && i <= t1[0] && o >= -t1[1] && o <= t1[1];
        }
        function $t(t1, i, o, s, r, a, n, l, c, h) {
            const u = o.transform, d = s ? t1.textSizeData : t1.iconSizeData, _ = e.bp(d, o.transform.zoom), p = "globe" === u.projection.name, f = [
                256 / o.width * 2 + 1,
                256 / o.height * 2 + 1
            ], m = s ? t1.text.dynamicLayoutVertexArray : t1.icon.dynamicLayoutVertexArray;
            m.clear();
            let g = null;
            p && (g = s ? t1.text.globeExtVertexArray : t1.icon.globeExtVertexArray);
            const v = t1.lineVertexArray, y = s ? t1.text.placedSymbolArray : t1.icon.placedSymbolArray, x = o.transform.width / o.transform.height;
            let b, w = !1;
            for(let s = 0; s < y.length; s++){
                const p = y.get(s), { numGlyphs: T, writingMode: E } = p;
                if (E !== e.bq.vertical || w || b === e.bq.horizontal || (w = !0), b = E, (p.hidden || E === e.bq.vertical) && !w) {
                    ti(T, m);
                    continue;
                }
                w = !1;
                const S = new e.P(p.tileAnchorX, p.tileAnchorY);
                let { x: C, y: I, z: R } = u.projection.projectTilePoint(S.x, S.y, h.canonical);
                if (c) {
                    const [e, t1, i] = c(S);
                    C += e, I += t1, R += i;
                }
                const D = [
                    C,
                    I,
                    R,
                    1
                ];
                if (e.ab.vec4.transformMat4(D, D, i), !Wt(D, f)) {
                    ti(T, m);
                    continue;
                }
                const L = D[3], A = Zt(o.transform.getCameraToCenterDistance(u.projection), L), z = e.br(d, _, p), P = n ? z / A : z * A, M = Ht(C, I, R, r);
                if (M[3] <= 0) {
                    ti(T, m);
                    continue;
                }
                let O = {};
                const F = n ? null : c, k = Yt(p, P, !1, l, i, r, a, t1.glyphOffsetArray, v, m, g, M, S, O, x, F, u.projection, h, n);
                w = k.useVertical, F && k.needsFlipping && (O = {}), (k.notEnoughRoom || w || k.needsFlipping && Yt(p, P, !0, l, i, r, a, t1.glyphOffsetArray, v, m, g, M, S, O, x, F, u.projection, h, n).notEnoughRoom) && ti(T, m);
            }
            s ? (t1.text.dynamicLayoutVertexBuffer.updateData(m), g && t1.text.globeExtVertexBuffer && t1.text.globeExtVertexBuffer.updateData(g)) : (t1.icon.dynamicLayoutVertexBuffer.updateData(m), g && t1.icon.globeExtVertexBuffer && t1.icon.globeExtVertexBuffer.updateData(g));
        }
        function Xt(e, t1, i, o, s, r, a, n, l, c, h, u, d, _, p, f) {
            const { lineStartIndex: m, glyphStartIndex: g, segment: v } = n, y = g + n.numGlyphs, x = m + n.lineLength, b = t1.getoffsetX(g), w = t1.getoffsetX(y - 1), T = ei(e * b, i, o, s, r, a, v, m, x, l, c, h, u, d, !0, _, p, f);
            if (!T) return null;
            const E = ei(e * w, i, o, s, r, a, v, m, x, l, c, h, u, d, !0, _, p, f);
            return E ? {
                first: T,
                last: E
            } : null;
        }
        function Kt(t1, i, o, s) {
            return t1 === e.bq.horizontal && Math.abs(s) > Math.abs(o) ? {
                useVertical: !0
            } : t1 === e.bq.vertical ? s > 0 ? {
                needsFlipping: !0
            } : null : i !== Ut.unknown && function(e, t1) {
                return 0 === e || Math.abs(t1 / e) > Gt;
            }(o, s) ? i === Ut.flipRequired ? {
                needsFlipping: !0
            } : null : o < 0 ? {
                needsFlipping: !0
            } : null;
        }
        function Yt(t1, i, o, s, r, a, n, l, c, h, u, d, _, p, f, m, g, v, y) {
            const x = i / 24, b = t1.lineOffsetX * x, w = t1.lineOffsetY * x, { lineStartIndex: T, glyphStartIndex: E, numGlyphs: S, segment: C, writingMode: I, flipState: R } = t1, D = T + t1.lineLength, L = (t1)=>{
                if (u) {
                    const [i, o, s] = t1.up, r = h.length;
                    e.bs(u, r + 0, i, o, s), e.bs(u, r + 1, i, o, s), e.bs(u, r + 2, i, o, s), e.bs(u, r + 3, i, o, s);
                }
                const [i, o, s] = t1.point;
                e.bt(h, i, o, s, t1.angle);
            };
            if (S > 1) {
                const e = Xt(x, l, b, w, o, d, _, t1, c, a, p, m, !1, g, v, y);
                if (!e) return {
                    notEnoughRoom: !0
                };
                if (s && !o) {
                    let [i, o, s] = e.first.point, [r, a, l] = e.last.point;
                    [i, o] = Ht(i, o, s, n), [r, a] = Ht(r, a, l, n);
                    const c = Kt(I, R, (r - i) * f, a - o);
                    if (t1.flipState = c && c.needsFlipping ? Ut.flipRequired : Ut.flipNotRequired, c) return c;
                }
                L(e.first);
                for(let e = E + 1; e < E + S - 1; e++){
                    const t1 = ei(x * l.getoffsetX(e), b, w, o, d, _, C, T, D, c, a, p, m, !1, !1, g, v, y);
                    if (!t1) return h.length -= 4 * (e - E), {
                        notEnoughRoom: !0
                    };
                    L(t1);
                }
                L(e.last);
            } else {
                if (s && !o) {
                    const i = Ht(_.x, _.y, 0, r), o = T + C + 1, s = new e.P(c.getx(o), c.gety(o)), a = Ht(s.x, s.y, 0, r), n = a[3] > 0 ? a : Qt(_, s, i, 1, r, void 0, g, v.canonical), l = Kt(I, R, (n[0] - i[0]) * f, n[1] - i[1]);
                    if (t1.flipState = l && l.needsFlipping ? Ut.flipRequired : Ut.flipNotRequired, l) return l;
                }
                const i = ei(x * l.getoffsetX(E), b, w, o, d, _, C, T, D, c, a, p, m, !1, !1, g, v, y);
                if (!i) return {
                    notEnoughRoom: !0
                };
                L(i);
            }
            return {};
        }
        function Jt(e, t1, i, o, s) {
            const { x: r, y: a, z: n } = o.projectTilePoint(e.x, e.y, t1);
            if (!s) return Ht(r, a, n, i);
            const [l, c, h] = s(e);
            return Ht(r + l, a + c, n + h, i);
        }
        function Qt(t1, i, o, s, r, a, n, l) {
            const c = Jt(t1.sub(i)._unit()._add(t1), l, r, n, a);
            return e.ab.vec3.sub(c, o, c), e.ab.vec3.normalize(c, c), e.ab.vec3.scaleAndAdd(c, o, c, s);
        }
        function ei(t1, i, o, s, r, a, n, l, c, h, u, d, _, p, f, m, g, v) {
            const y = s ? t1 - i : t1 + i;
            let x = y > 0 ? 1 : -1, b = 0;
            s && (x *= -1, b = Math.PI), x < 0 && (b += Math.PI);
            let w = l + n + (x > 0 ? 0 : 1) | 0, T = r, E = r, S = 0, C = 0;
            const I = Math.abs(y), R = [], D = [];
            let L = a, A = L;
            const z = ()=>Qt(A, L, E, I - S + 1, u, _, m, g.canonical);
            for(; S + C <= I;){
                if (w += x, w < l || w >= c) return null;
                if (E = T, A = L, R.push(E), p && D.push(A), L = new e.P(h.getx(w), h.gety(w)), T = d[w], !T) {
                    const e = Jt(L, g.canonical, u, m, _);
                    T = e[3] > 0 ? d[w] = e : z();
                }
                S += C, C = e.ab.vec3.distance(E, T);
            }
            f && _ && (d[w] && (T = z(), C = e.ab.vec3.distance(E, T)), d[w] = T);
            const P = (I - S) / C, M = L.sub(A)._mult(P)._add(A), O = e.ab.vec3.sub([], T, E), F = e.ab.vec3.scaleAndAdd([], E, O, P);
            let k = [
                0,
                0,
                1
            ], B = O[0], N = O[1];
            if (v && (k = m.upVector(g.canonical, M.x, M.y), 0 !== k[0] || 0 !== k[1] || 1 !== k[2])) {
                const t1 = [
                    k[2],
                    0,
                    -k[0]
                ], i = e.ab.vec3.cross([], k, t1);
                e.ab.vec3.normalize(t1, t1), e.ab.vec3.normalize(i, i), B = e.ab.vec3.dot(O, t1), N = e.ab.vec3.dot(O, i);
            }
            if (o) {
                const t1 = e.ab.vec3.cross([], k, O);
                e.ab.vec3.normalize(t1, t1), e.ab.vec3.scaleAndAdd(F, F, t1, o * x);
            }
            const U = b + Math.atan2(N, B);
            return R.push(F), p && D.push(M), {
                point: F,
                angle: U,
                path: R,
                tilePath: D,
                up: k
            };
        }
        function ti(e, t1) {
            const i = t1.length, o = i + 4 * e;
            t1.resize(o), t1.float32.fill(-1 / 0, 4 * i, 4 * o);
        }
        function ii(e, t1, i) {
            const o = t1[0], s = t1[1];
            return e[0] = i[0] * o + i[4] * s + i[12], e[1] = i[1] * o + i[5] * s + i[13], e[3] = i[3] * o + i[7] * s + i[15], e;
        }
        const oi = 100;
        class si {
            constructor(e, t1, i = new Nt(e.width + 200, e.height + 200, 25), o = new Nt(e.width + 200, e.height + 200, 25)){
                this.transform = e, this.grid = i, this.ignoredGrid = o, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + oi, this.screenBottomBoundary = e.height + oi, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.fogState = t1;
            }
            placeCollisionBox(e, t1, i, o, s, r, a, n) {
                let l = i.projectedAnchorX, c = i.projectedAnchorY, h = i.projectedAnchorZ;
                const u = i.elevation, d = i.tileID, _ = e.getProjection();
                if (u && d) {
                    const [e, t1, o] = _.upVector(d.canonical, i.tileAnchorX, i.tileAnchorY), s = _.upVectorScale(d.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                    l += e * u * s, c += t1 * u * s, h += o * u * s;
                }
                const p = this.projectAndGetPerspectiveRatio(a, l, c, h, i.tileID, "globe" === _.name || !!u || this.transform.pitch > 0, _), f = r * p.perspectiveRatio, m = (i.x1 * t1 + o.x - i.padding) * f + p.point.x, g = (i.y1 * t1 + o.y - i.padding) * f + p.point.y, v = (i.x2 * t1 + o.x + i.padding) * f + p.point.x, y = (i.y2 * t1 + o.y + i.padding) * f + p.point.y, x = p.perspectiveRatio <= .55 || p.occluded;
                return !this.isInsideGrid(m, g, v, y) || !s && this.grid.hitTest(m, g, v, y, n) || x ? {
                    box: [],
                    offscreen: !1,
                    occluded: p.occluded
                } : {
                    box: [
                        m,
                        g,
                        v,
                        y
                    ],
                    offscreen: this.isOffscreen(m, g, v, y),
                    occluded: !1
                };
            }
            placeCollisionCircles(t1, i, o, s, r, a, n, l, c, h, u, d, _, p, f) {
                const m = [], g = this.transform.elevation, v = t1.getProjection(), y = g ? g.getAtTileOffsetFunc(f, this.transform.center.lat, this.transform.worldSize, v) : null, x = new e.P(o.tileAnchorX, o.tileAnchorY);
                let { x: b, y: w, z: T } = v.projectTilePoint(x.x, x.y, f.canonical);
                if (y) {
                    const [e, t1, i] = y(x);
                    b += e, w += t1, T += i;
                }
                const E = "globe" === v.name, S = this.projectAndGetPerspectiveRatio(n, b, w, T, f, E || !!g || this.transform.pitch > 0, v), { perspectiveRatio: C } = S, I = (u ? a / C : a * C) / e.bw, R = Ht(b, w, T, l), D = S.signedDistanceFromCamera > 0 ? Xt(I, r, o.lineOffsetX * I, o.lineOffsetY * I, !1, R, x, o, s, l, {}, g && !u ? y : null, u && !!g, v, f, u) : null;
                let L = !1, A = !1, z = !0;
                if (D && !S.occluded) {
                    const t1 = .5 * _ * C + p, o = new e.P(-100, -100), s = new e.P(this.screenRightBoundary, this.screenBottomBoundary), r = new Bt, { first: a, last: n } = D, l = a.path.length;
                    let u = [];
                    for(let e = l - 1; e >= 1; e--)u.push(a.path[e]);
                    for(let e = 1; e < n.path.length; e++)u.push(n.path[e]);
                    const f = 2.5 * t1;
                    c && (u = u.map(([e, t1, i], o)=>(y && !E && (i = y(o < l - 1 ? a.tilePath[l - 1 - o] : n.tilePath[o - l + 2])[2]), Ht(e, t1, i, c))), u.some((e)=>e[3] <= 0) && (u = []));
                    let g = [];
                    if (u.length > 0) {
                        let t1 = 1 / 0, i = -1 / 0, r = 1 / 0, a = -1 / 0;
                        for (const e of u)t1 = Math.min(t1, e[0]), r = Math.min(r, e[1]), i = Math.max(i, e[0]), a = Math.max(a, e[1]);
                        i >= o.x && t1 <= s.x && a >= o.y && r <= s.y && (g = [
                            u.map((t1)=>new e.P(t1[0], t1[1]))
                        ], (t1 < o.x || i > s.x || r < o.y || a > s.y) && (g = e.bu(g, o.x, o.y, s.x, s.y)));
                    }
                    for (const e of g){
                        r.reset(e, .25 * t1);
                        let o = 0;
                        o = r.length <= .5 * t1 ? 1 : Math.ceil(r.paddedLength / f) + 1;
                        for(let e = 0; e < o; e++){
                            const s = e / Math.max(o - 1, 1), a = r.lerp(s), n = a.x + oi, l = a.y + oi;
                            m.push(n, l, t1, 0);
                            const c = n - t1, u = l - t1, _ = n + t1, p = l + t1;
                            if (z = z && this.isOffscreen(c, u, _, p), A = A || this.isInsideGrid(c, u, _, p), !i && this.grid.hitTestCircle(n, l, t1, d) && (L = !0, !h)) return {
                                circles: [],
                                offscreen: !1,
                                collisionDetected: L,
                                occluded: !1
                            };
                        }
                    }
                }
                return {
                    circles: !h && L || !A ? [] : m,
                    offscreen: z,
                    collisionDetected: L,
                    occluded: S.occluded
                };
            }
            queryRenderedSymbols(t1) {
                if (0 === t1.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
                const i = [];
                let o = 1 / 0, s = 1 / 0, r = -1 / 0, a = -1 / 0;
                for (const n of t1){
                    const t1 = new e.P(n.x + oi, n.y + oi);
                    o = Math.min(o, t1.x), s = Math.min(s, t1.y), r = Math.max(r, t1.x), a = Math.max(a, t1.y), i.push(t1);
                }
                const n = this.grid.query(o, s, r, a).concat(this.ignoredGrid.query(o, s, r, a)), l = {}, c = {};
                for (const t1 of n){
                    const o = t1.key;
                    if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;
                    const s = [
                        new e.P(t1.x1, t1.y1),
                        new e.P(t1.x2, t1.y1),
                        new e.P(t1.x2, t1.y2),
                        new e.P(t1.x1, t1.y2)
                    ];
                    e.bv(i, s) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));
                }
                return c;
            }
            insertCollisionBox(e, t1, i, o, s) {
                (t1 ? this.ignoredGrid : this.grid).insert({
                    bucketInstanceId: i,
                    featureIndex: o,
                    collisionGroupID: s
                }, e[0], e[1], e[2], e[3]);
            }
            insertCollisionCircles(e, t1, i, o, s) {
                const r = t1 ? this.ignoredGrid : this.grid, a = {
                    bucketInstanceId: i,
                    featureIndex: o,
                    collisionGroupID: s
                };
                for(let t1 = 0; t1 < e.length; t1 += 4)r.insertCircle(a, e[t1], e[t1 + 1], e[t1 + 2]);
            }
            projectAndGetPerspectiveRatio(t1, i, o, s, r, a, n) {
                const l = [
                    i,
                    o,
                    s,
                    1
                ];
                let c = !1;
                if (s || this.transform.pitch > 0) {
                    if (e.ab.vec4.transformMat4(l, l, t1), this.fogState && r && "globe" !== n.name) {
                        const t1 = function(t1, i, o, s, r, a) {
                            const n = a.calculateFogTileMatrix(r), l = [
                                i,
                                o,
                                s
                            ];
                            return e.ab.vec3.transformMat4(l, l, n), ke(t1, e.ab.vec3.length(l), a.pitch, a._fov);
                        }(this.fogState, i, o, s, r.toUnwrapped(), this.transform);
                        c = t1 > .9;
                    }
                } else ii(l, l, t1);
                const h = l[3];
                return {
                    point: new e.P((l[0] / h + 1) / 2 * this.transform.width + oi, (-l[1] / h + 1) / 2 * this.transform.height + oi),
                    perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(n) / h * .5, 1.5),
                    signedDistanceFromCamera: h,
                    occluded: a && l[2] > h || c
                };
            }
            isOffscreen(e, t1, i, o) {
                return i < oi || e >= this.screenRightBoundary || o < oi || t1 > this.screenBottomBoundary;
            }
            isInsideGrid(e, t1, i, o) {
                return i >= 0 && e < this.gridRightBoundary && o >= 0 && t1 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
                const t1 = e.ab.mat4.identity([]);
                return e.ab.mat4.translate(t1, t1, [
                    -100,
                    -100,
                    0
                ]), t1;
            }
        }
        function ri(t1, i, o) {
            const s = i.createTileMatrix(t1, t1.worldSize, o.toUnwrapped());
            return e.ab.mat4.multiply(new Float32Array(16), t1.projMatrix, s);
        }
        function ai(e, t1, i) {
            if (t1.projection.name === i.projection.name) return e.projMatrix;
            const o = i.clone();
            return o.setProjection(t1.projection), ri(o, t1.getProjection(), e);
        }
        function ni(e, t1, i) {
            return t1.name === i.projection.name ? e.projMatrix : ri(i, t1, e);
        }
        class li {
            constructor(e, t1, i, o){
                this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t1 : -t1))) : o && i ? 1 : 0, this.placed = i;
            }
            isHidden() {
                return 0 === this.opacity && !this.placed;
            }
        }
        class ci {
            constructor(e, t1, i, o, s, r = !1){
                this.text = new li(e ? e.text : null, t1, i, s), this.icon = new li(e ? e.icon : null, t1, o, s), this.clipped = r;
            }
            isHidden() {
                return this.text.isHidden() && this.icon.isHidden();
            }
        }
        class hi {
            constructor(e, t1, i, o = !1){
                this.text = e, this.icon = t1, this.skipFade = i, this.clipped = o;
            }
        }
        class ui {
            constructor(){
                this.invProjMatrix = e.ab.mat4.create(), this.viewportMatrix = e.ab.mat4.create(), this.circles = [];
            }
        }
        class di {
            constructor(e, t1, i, o, s){
                this.bucketInstanceId = e, this.featureIndex = t1, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = s;
            }
        }
        class _i {
            constructor(e){
                this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(e) {
                if (this.crossSourceCollisions) return {
                    ID: 0,
                    predicate: null
                };
                if (!this.collisionGroups[e]) {
                    const t1 = ++this.maxGroupID;
                    this.collisionGroups[e] = {
                        ID: t1,
                        predicate: (e)=>e.collisionGroupID === t1
                    };
                }
                return this.collisionGroups[e];
            }
        }
        function pi(t1, i, o, s, r) {
            const { horizontalAlign: a, verticalAlign: n } = e.bD(t1), l = -(a - .5) * i, c = -(n - .5) * o, h = e.bC(t1, s);
            return new e.P(l + h[0] * r, c + h[1] * r);
        }
        function fi(t1, i, o, s, r) {
            const a = new e.P(t1, i);
            return o && a._rotate(s ? r : -r), a;
        }
        class mi {
            constructor(e, t1, i, o, s, r){
                this.transform = e.clone(), this.projection = e.projection.name, this.collisionIndex = new si(this.transform, s), this.buildingIndex = r, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t1, this.retainedQueryData = {}, this.collisionGroups = new _i(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};
            }
            getBucketParts(t1, i, o, s, r = 1) {
                const a = o.getBucket(i), n = o.latestFeatureIndex;
                if (!a || !n || i.fqid !== a.layerIds[0]) return;
                const l = a.layers[0].layout, c = a.layers[0].paint, h = o.collisionBoxArray, u = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ), d = o.tileSize / e.ag, _ = o.tileID.toUnwrapped();
                this.transform.setProjection(a.projection);
                const p = (f = o.tileID, m = a.getProjection(), g = this.transform, m.name === this.projection ? g.calculateProjMatrix(f.toUnwrapped()) : ri(g, m, f));
                var f, m, g;
                const v = "map" === l.get("text-pitch-alignment"), y = "map" === l.get("text-rotation-alignment");
                i.compileFilter(i.options);
                const x = i.dynamicFilter(), b = i.dynamicFilterNeedsFeature(), w = this.transform.calculatePixelsToTileUnitsMatrix(o), T = Vt(p, o.tileID.canonical, v, y, this.transform, a.getProjection(), w);
                let E = null;
                if (v) {
                    const t1 = qt(p, o.tileID.canonical, v, y, this.transform, a.getProjection(), w);
                    E = e.ab.mat4.multiply([], this.transform.labelPlaneMatrix, t1);
                }
                let S = null;
                x && o.latestFeatureIndex && (S = {
                    unwrappedTileID: _,
                    dynamicFilter: x,
                    dynamicFilterNeedsFeature: b
                }), this.retainedQueryData[a.bucketInstanceId] = new di(a.bucketInstanceId, n, a.sourceLayerIndex, a.index, o.tileID);
                const [C, I] = a.layers[0].layout.get("text-size-scale-range"), R = e.aw(r, C, I), [D, L] = l.get("icon-size-scale-range"), A = e.aw(r, D, L), z = {
                    bucket: a,
                    layout: l,
                    paint: c,
                    posMatrix: p,
                    textLabelPlaneMatrix: T,
                    labelToScreenMatrix: E,
                    clippingData: S,
                    scale: u,
                    textPixelRatio: d,
                    holdingForFade: o.holdingForFade(),
                    collisionBoxArray: h,
                    partiallyEvaluatedTextSize: e.bp(a.textSizeData, this.transform.zoom, R),
                    partiallyEvaluatedIconSize: e.bp(a.iconSizeData, this.transform.zoom, A),
                    collisionGroup: this.collisionGroups.get(a.sourceID),
                    latestFeatureIndex: o.latestFeatureIndex
                };
                if (s) for (const e of a.sortKeyRanges){
                    const { sortKey: i, symbolInstanceStart: o, symbolInstanceEnd: s } = e;
                    t1.push({
                        sortKey: i,
                        symbolInstanceStart: o,
                        symbolInstanceEnd: s,
                        parameters: z
                    });
                }
                else t1.push({
                    symbolInstanceStart: 0,
                    symbolInstanceEnd: a.symbolInstances.length,
                    parameters: z
                });
            }
            attemptAnchorPlacement(e, t1, i, o, s, r, a, n, l, c, h, u, d, _, p, f, m, g) {
                const { textOffset0: v, textOffset1: y, crossTileID: x } = u, b = [
                    v,
                    y
                ], w = pi(e, i, o, b, s), T = this.collisionIndex.placeCollisionBox(_, s, t1, fi(w.x, w.y, r, a, this.transform.angle), h, n, l, c.predicate);
                if (f) {
                    const e = _.getSymbolInstanceIconSize(g, this.transform.zoom, u.placedIconSymbolIndex);
                    if (0 === this.collisionIndex.placeCollisionBox(_, e, f, fi(w.x, w.y, r, a, this.transform.angle), h, n, l, c.predicate).box.length) return;
                }
                if (T.box.length > 0) {
                    let t1;
                    return this.prevPlacement && this.prevPlacement.variableOffsets[x] && this.prevPlacement.placements[x] && this.prevPlacement.placements[x].text && (t1 = this.prevPlacement.variableOffsets[x].anchor), this.variableOffsets[x] = {
                        textOffset: b,
                        width: i,
                        height: o,
                        anchor: e,
                        textScale: s,
                        prevAnchor: t1
                    }, this.markUsedJustification(_, e, u, p), _.allowVerticalPlacement && (this.markUsedOrientation(_, p, u), this.placedOrientations[x] = p), {
                        shift: w,
                        placedGlyphBoxes: T
                    };
                }
            }
            placeLayerBucketPart(t1, i, o, s, r = 1) {
                const { bucket: a, layout: n, paint: l, posMatrix: c, textLabelPlaneMatrix: h, labelToScreenMatrix: u, clippingData: d, textPixelRatio: _, holdingForFade: p, collisionBoxArray: f, partiallyEvaluatedTextSize: m, partiallyEvaluatedIconSize: g, collisionGroup: v, latestFeatureIndex: y } = t1.parameters, x = n.get("text-optional"), b = n.get("icon-optional"), w = n.get("text-allow-overlap"), T = n.get("icon-allow-overlap"), E = "map" === n.get("text-rotation-alignment"), S = "map" === n.get("text-pitch-alignment"), C = n.get("symbol-z-elevate"), I = l.get("symbol-z-offset"), R = "sea" === n.get("symbol-elevation-reference"), [D, L] = n.get("text-size-scale-range"), [A, z] = n.get("icon-size-scale-range"), P = e.aw(r, D, L), M = e.aw(r, A, z);
                this.transform.setProjection(a.projection);
                let O = w && (T || !a.hasIconData() || b), F = T && (w || !a.hasTextData() || x);
                const k = !I.isConstant();
                !a.collisionArrays && f && a.deserializeCollisionBoxes(f), o && s && a.updateCollisionDebugBuffers(this.transform.zoom, f, P, M);
                const B = (t1, s, l)=>{
                    const { crossTileID: f, numVerticalGlyphVertices: C } = t1;
                    let D = null;
                    if (d && d.dynamicFilterNeedsFeature || k) {
                        const e = this.retainedQueryData[a.bucketInstanceId];
                        D = y.loadFeature({
                            featureIndex: t1.featureIndex,
                            bucketIndex: e.bucketIndex,
                            sourceLayerIndex: e.sourceLayerIndex,
                            layoutVertexArrayOffset: 0
                        });
                    }
                    if (d && !(0, d.dynamicFilter)({
                        zoom: this.transform.zoom,
                        pitch: this.transform.pitch
                    }, D, this.retainedQueryData[a.bucketInstanceId].tileID.canonical, new e.P(t1.tileAnchorX, t1.tileAnchorY), this.transform.calculateDistanceTileData(d.unwrappedTileID))) return this.placements[f] = new hi(!1, !1, !1, !0), void i.add(f);
                    const L = I.evaluate(D, {});
                    if (i.has(f)) return;
                    if (p) return void (this.placements[f] = new hi(!1, !1, !1));
                    let A = !1, z = !1, P = !0, M = !1, B = !1, N = null, U = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }, G = {
                        box: null,
                        offscreen: null,
                        occluded: null
                    }, j = null, V = null, q = null, H = 0, Z = 0, W = 0;
                    l.textFeatureIndex ? H = l.textFeatureIndex : t1.useRuntimeCollisionCircles && (H = t1.featureIndex), l.verticalTextFeatureIndex && (Z = l.verticalTextFeatureIndex);
                    const $ = (e)=>{
                        e.tileID = this.retainedQueryData[a.bucketInstanceId].tileID;
                        const i = this.transform.elevation;
                        e.elevation = R ? L : L + (i ? i.getAtTileOffset(e.tileID, e.tileAnchorX, e.tileAnchorY) : 0), e.elevation += t1.zOffset;
                    }, X = l.textBox;
                    if (X) {
                        $(X);
                        const i = (i)=>{
                            let o = e.bq.horizontal;
                            if (a.allowVerticalPlacement && !i && this.prevPlacement) {
                                const e = this.prevPlacement.placedOrientations[f];
                                e && (this.placedOrientations[f] = e, o = e, this.markUsedOrientation(a, o, t1));
                            }
                            return o;
                        }, o = (t1, i)=>{
                            if (a.allowVerticalPlacement && C > 0 && l.verticalTextBox) {
                                for (const o of a.writingModes)if (o === e.bq.vertical ? (U = i(), G = U) : U = t1(), U && U.box && U.box.length) break;
                            } else U = t1();
                        };
                        if (n.get("text-variable-anchor")) {
                            let r = n.get("text-variable-anchor");
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[f]) {
                                const e = this.prevPlacement.variableOffsets[f];
                                r.indexOf(e.anchor) > 0 && (r = r.filter((t1)=>t1 !== e.anchor), r.unshift(e.anchor));
                            }
                            const h = (e, i, o)=>{
                                const n = a.getSymbolInstanceTextSize(m, t1, this.transform.zoom, s), l = (e.x2 - e.x1) * n + 2 * e.padding, h = (e.y2 - e.y1) * n + 2 * e.padding, u = t1.hasIconTextFit && !T ? i : null;
                                u && $(u);
                                let d = {
                                    box: [],
                                    offscreen: !1,
                                    occluded: !1
                                };
                                const p = w ? 2 * r.length : r.length;
                                for(let i = 0; i < p; ++i){
                                    const p = this.attemptAnchorPlacement(r[i % r.length], e, l, h, n, E, S, _, c, v, i >= r.length, t1, s, a, o, u, m, g);
                                    if (p && (d = p.placedGlyphBoxes, d && d.box && d.box.length)) {
                                        A = !0, N = p.shift;
                                        break;
                                    }
                                }
                                return d;
                            };
                            o(()=>h(X, l.iconBox, e.bq.horizontal), ()=>{
                                const t1 = l.verticalTextBox;
                                return t1 && $(t1), a.allowVerticalPlacement && !(U && U.box && U.box.length) && C > 0 && t1 ? h(t1, l.verticalIconBox, e.bq.vertical) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                };
                            }), U && (A = U.box, P = U.offscreen, M = U.occluded);
                            const u = i(!(!U || !U.box));
                            if (!A && this.prevPlacement) {
                                const e = this.prevPlacement.variableOffsets[f];
                                e && (this.variableOffsets[f] = e, this.markUsedJustification(a, e.anchor, t1, u));
                            }
                        } else {
                            const n = (i, o)=>{
                                const n = a.getSymbolInstanceTextSize(m, t1, this.transform.zoom, s, r), l = this.collisionIndex.placeCollisionBox(a, n, i, new e.P(0, 0), w, _, c, v.predicate);
                                return l && l.box && l.box.length && (this.markUsedOrientation(a, o, t1), this.placedOrientations[f] = o), l;
                            };
                            o(()=>n(X, e.bq.horizontal), ()=>{
                                const t1 = l.verticalTextBox;
                                return a.allowVerticalPlacement && C > 0 && t1 ? ($(t1), n(t1, e.bq.vertical)) : {
                                    box: null,
                                    offscreen: null,
                                    occluded: null
                                };
                            }), i(!!(U && U.box && U.box.length));
                        }
                    }
                    if (j = U, A = j && j.box && j.box.length > 0, P = j && j.offscreen, M = j && j.occluded, t1.useRuntimeCollisionCircles) {
                        const i = a.text.placedSymbolArray.get(t1.centerJustifiedTextSymbolIndex >= 0 ? t1.centerJustifiedTextSymbolIndex : t1.verticalPlacedTextSymbolIndex), s = e.br(a.textSizeData, m, i), r = n.get("text-padding");
                        V = this.collisionIndex.placeCollisionCircles(a, w, i, a.lineVertexArray, a.glyphOffsetArray, s, c, h, u, o, S, v.predicate, t1.collisionCircleDiameter * s / e.bw, r, this.retainedQueryData[a.bucketInstanceId].tileID), A = w || V.circles.length > 0 && !V.collisionDetected, P = P && V.offscreen, M = V.occluded;
                    }
                    if (l.iconFeatureIndex && (W = l.iconFeatureIndex), l.iconBox) {
                        const i = (i)=>{
                            $(i);
                            const o = t1.hasIconTextFit && N ? fi(N.x, N.y, E, S, this.transform.angle) : new e.P(0, 0), s = a.getSymbolInstanceIconSize(g, this.transform.zoom, t1.placedIconSymbolIndex);
                            return this.collisionIndex.placeCollisionBox(a, s, i, o, T, _, c, v.predicate);
                        };
                        G && G.box && G.box.length && l.verticalIconBox ? (q = i(l.verticalIconBox), z = q.box.length > 0) : (q = i(l.iconBox), z = q.box.length > 0), P = P && q.offscreen, B = q.occluded;
                    }
                    const K = x || 0 === t1.numHorizontalGlyphVertices && 0 === C, Y = b || 0 === t1.numIconVertices;
                    if (K || Y ? Y ? K || (z = z && A) : A = z && A : z = A = z && A, A && j && j.box && this.collisionIndex.insertCollisionBox(j.box, n.get("text-ignore-placement"), a.bucketInstanceId, G && G.box && Z ? Z : H, v.ID), z && q && this.collisionIndex.insertCollisionBox(q.box, n.get("icon-ignore-placement"), a.bucketInstanceId, W, v.ID), V && (A && this.collisionIndex.insertCollisionCircles(V.circles, n.get("text-ignore-placement"), a.bucketInstanceId, H, v.ID), o)) {
                        const e = a.bucketInstanceId;
                        let t1 = this.collisionCircleArrays[e];
                        void 0 === t1 && (t1 = this.collisionCircleArrays[e] = new ui);
                        for(let e = 0; e < V.circles.length; e += 4)t1.circles.push(V.circles[e + 0]), t1.circles.push(V.circles[e + 1]), t1.circles.push(V.circles[e + 2]), t1.circles.push(V.collisionDetected ? 1 : 0);
                    }
                    const J = "globe" !== a.projection.name;
                    O = O && (J || !M), F = F && (J || !B), this.placements[f] = new hi(A || O, z || F, P || a.justReloaded), i.add(f);
                };
                if (C && this.buildingIndex && (this.buildingIndex.updateZOffset(a, this.retainedQueryData[a.bucketInstanceId].tileID), a.updateZOffset()), a.sortFeaturesByY) {
                    const t1 = a.getSortedSymbolIndexes(this.transform.angle);
                    for(let e = t1.length - 1; e >= 0; --e){
                        const i = t1[e];
                        B(a.symbolInstances.get(i), i, a.collisionArrays[i]);
                    }
                    a.hasAnyZOffset && e.w(`${a.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
                } else if (a.hasAnyZOffset) {
                    const e = a.getSortedIndexesByZOffset();
                    for(let t1 = 0; t1 < e.length; ++t1){
                        const i = e[t1];
                        B(a.symbolInstances.get(i), i, a.collisionArrays[i]);
                    }
                } else for(let e = t1.symbolInstanceStart; e < t1.symbolInstanceEnd; e++)B(a.symbolInstances.get(e), e, a.collisionArrays[e]);
                if (o && a.bucketInstanceId in this.collisionCircleArrays) {
                    const t1 = this.collisionCircleArrays[a.bucketInstanceId];
                    e.ab.mat4.invert(t1.invProjMatrix, c), t1.viewportMatrix = this.collisionIndex.getViewportMatrix();
                }
                a.justReloaded = !1;
            }
            markUsedJustification(t1, i, o, s) {
                const { leftJustifiedTextSymbolIndex: r, centerJustifiedTextSymbolIndex: a, rightJustifiedTextSymbolIndex: n, verticalPlacedTextSymbolIndex: l, crossTileID: c } = o, h = e.bB(i), u = s === e.bq.vertical ? l : "left" === h ? r : "center" === h ? a : "right" === h ? n : -1;
                r >= 0 && (t1.text.placedSymbolArray.get(r).crossTileID = u >= 0 && r !== u ? 0 : c), a >= 0 && (t1.text.placedSymbolArray.get(a).crossTileID = u >= 0 && a !== u ? 0 : c), n >= 0 && (t1.text.placedSymbolArray.get(n).crossTileID = u >= 0 && n !== u ? 0 : c), l >= 0 && (t1.text.placedSymbolArray.get(l).crossTileID = u >= 0 && l !== u ? 0 : c);
            }
            markUsedOrientation(t1, i, o) {
                const s = i === e.bq.horizontal || i === e.bq.horizontalOnly ? i : 0, r = i === e.bq.vertical ? i : 0, { leftJustifiedTextSymbolIndex: a, centerJustifiedTextSymbolIndex: n, rightJustifiedTextSymbolIndex: l, verticalPlacedTextSymbolIndex: c } = o, h = t1.text.placedSymbolArray;
                a >= 0 && (h.get(a).placedOrientation = s), n >= 0 && (h.get(n).placedOrientation = s), l >= 0 && (h.get(l).placedOrientation = s), c >= 0 && (h.get(c).placedOrientation = r);
            }
            commit(e) {
                this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;
                const t1 = this.prevPlacement;
                let i = !1;
                this.prevZoomAdjustment = t1 ? t1.zoomAdjustment(this.transform.zoom) : 0;
                const o = t1 ? t1.symbolFadeChange(e) : 1, s = t1 ? t1.opacities : {}, r = t1 ? t1.variableOffsets : {}, a = t1 ? t1.placedOrientations : {};
                for(const e in this.placements){
                    const t1 = this.placements[e], r = s[e];
                    r ? (this.opacities[e] = new ci(r, o, t1.text, t1.icon, null, t1.clipped), i = i || t1.text !== r.text.placed || t1.icon !== r.icon.placed) : (this.opacities[e] = new ci(null, o, t1.text, t1.icon, t1.skipFade, t1.clipped), i = i || t1.text || t1.icon);
                }
                for(const e in s){
                    const t1 = s[e];
                    if (!this.opacities[e]) {
                        const s = new ci(t1, o, !1, !1);
                        s.isHidden() || (this.opacities[e] = s, i = i || t1.text.placed || t1.icon.placed);
                    }
                }
                for(const e in r)this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = r[e]);
                for(const e in a)this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = a[e]);
                i ? this.lastPlacementChangeTime = e : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t1 ? t1.lastPlacementChangeTime : e);
            }
            updateLayerOpacities(e, t1, i, o) {
                const s = new Set;
                for (const r of t1){
                    const t1 = r.getBucket(e);
                    t1 && r.latestFeatureIndex && e.fqid === t1.layerIds[0] && (this.updateBucketOpacities(t1, s, r, r.collisionBoxArray, i, o, r.tileID, e.scope), t1.layers[0].layout.get("symbol-z-elevate") && this.buildingIndex && (this.buildingIndex.updateZOffset(t1, r.tileID), t1.updateZOffset()));
                }
            }
            updateBucketOpacities(t1, i, o, s, r, a, n, l) {
                t1.hasTextData() && t1.text.opacityVertexArray.clear(), t1.hasIconData() && t1.icon.opacityVertexArray.clear(), t1.hasIconCollisionBoxData() && t1.iconCollisionBox.collisionVertexArray.clear(), t1.hasTextCollisionBoxData() && t1.textCollisionBox.collisionVertexArray.clear();
                const c = t1.layers[0].layout, h = t1.layers[0].paint, u = !!t1.layers[0].dynamicFilter(), d = new ci(null, 0, !1, !1, !0), _ = c.get("text-allow-overlap"), p = c.get("icon-allow-overlap"), f = c.get("text-variable-anchor"), m = "map" === c.get("text-rotation-alignment"), g = "map" === c.get("text-pitch-alignment"), v = h.get("symbol-z-offset"), y = "sea" === c.get("symbol-elevation-reference"), x = !v.isConstant(), b = new ci(null, 0, _ && (p || !t1.hasIconData() || c.get("icon-optional")), p && (_ || !t1.hasTextData() || c.get("text-optional")), !0);
                !t1.collisionArrays && s && (t1.hasIconCollisionBoxData() || t1.hasTextCollisionBoxData()) && t1.deserializeCollisionBoxes(s);
                const w = (e, t1, i)=>{
                    for(let o = 0; o < t1 / 4; o++)e.opacityVertexArray.emplaceBack(i);
                };
                let T = 0;
                a && t1.updateReplacement(n, a);
                for(let s = 0; s < t1.symbolInstances.length; s++){
                    const c = t1.symbolInstances.get(s), { numHorizontalGlyphVertices: h, numVerticalGlyphVertices: _, crossTileID: p, numIconVertices: E, tileAnchorX: S, tileAnchorY: C } = c;
                    let I = null;
                    const R = this.retainedQueryData[t1.bucketInstanceId];
                    x && c && R && (I = o.latestFeatureIndex.loadFeature({
                        featureIndex: c.featureIndex,
                        bucketIndex: R.bucketIndex,
                        sourceLayerIndex: R.sourceLayerIndex,
                        layoutVertexArrayOffset: 0
                    }));
                    const D = v.evaluate(I, {}), L = i.has(p);
                    let A = this.opacities[p];
                    L ? A = d : A || (A = b, this.opacities[p] = A), i.add(p);
                    const z = h > 0 || _ > 0, P = E > 0, M = this.placedOrientations[p], O = M === e.bq.vertical, F = M === e.bq.horizontal || M === e.bq.horizontalOnly;
                    !z && !P || A.isHidden() || T++;
                    let k = !1;
                    if ((z || P) && a) for (const i of t1.activeReplacements){
                        if (e.bx(i, r, e.by.Symbol, l)) continue;
                        if (i.min.x > S || S > i.max.x || i.min.y > C || C > i.max.y) continue;
                        const t1 = e.bz(S, C, n.canonical, i.footprintTileId.canonical);
                        if (k = e.bA(t1, i.footprint), k) break;
                    }
                    if (z) {
                        const e = k ? Ci : Si(A.text);
                        w(t1.text, h, O ? Ci : e), w(t1.text, _, F ? Ci : e);
                        const i = A.text.isHidden(), { leftJustifiedTextSymbolIndex: o, centerJustifiedTextSymbolIndex: s, rightJustifiedTextSymbolIndex: r, verticalPlacedTextSymbolIndex: a } = c, n = t1.text.placedSymbolArray, l = i || O ? 1 : 0;
                        o >= 0 && (n.get(o).hidden = l), s >= 0 && (n.get(s).hidden = l), r >= 0 && (n.get(r).hidden = l), a >= 0 && (n.get(a).hidden = i || F ? 1 : 0);
                        const u = this.variableOffsets[p];
                        u && this.markUsedJustification(t1, u.anchor, c, M);
                        const d = this.placedOrientations[p];
                        d && (this.markUsedJustification(t1, "left", c, d), this.markUsedOrientation(t1, d, c));
                    }
                    if (P) {
                        const e = k ? Ci : Si(A.icon), { placedIconSymbolIndex: i, verticalPlacedIconSymbolIndex: o } = c, s = t1.icon.placedSymbolArray, r = A.icon.isHidden() ? 1 : 0;
                        i >= 0 && (w(t1.icon, E, O ? Ci : e), s.get(i).hidden = r), o >= 0 && (w(t1.icon, c.numVerticalIconVertices, F ? Ci : e), s.get(o).hidden = r);
                    }
                    if (t1.hasIconCollisionBoxData() || t1.hasTextCollisionBoxData()) {
                        const i = t1.collisionArrays[s];
                        if (i) {
                            let o = new e.P(0, 0), s = !0;
                            if (i.textBox || i.verticalTextBox) {
                                if (f) {
                                    const e = this.variableOffsets[p];
                                    e ? (o = pi(e.anchor, e.width, e.height, e.textOffset, e.textScale), m && o._rotate(g ? this.transform.angle : -this.transform.angle)) : s = !1;
                                }
                                u && (s = !A.clipped), i.textBox && gi(t1.textCollisionBox.collisionVertexArray, A.text.placed, !s || O, D, y, o.x, o.y), i.verticalTextBox && gi(t1.textCollisionBox.collisionVertexArray, A.text.placed, !s || F, D, y, o.x, o.y);
                            }
                            const r = s && Boolean(!F && i.verticalIconBox);
                            i.iconBox && gi(t1.iconCollisionBox.collisionVertexArray, A.icon.placed, r, D, y, c.hasIconTextFit ? o.x : 0, c.hasIconTextFit ? o.y : 0), i.verticalIconBox && gi(t1.iconCollisionBox.collisionVertexArray, A.icon.placed, !r, D, y, c.hasIconTextFit ? o.x : 0, c.hasIconTextFit ? o.y : 0);
                        }
                    }
                }
                if (t1.fullyClipped = 0 === T, t1.sortFeatures(this.transform.angle), this.retainedQueryData[t1.bucketInstanceId] && (this.retainedQueryData[t1.bucketInstanceId].featureSortOrder = t1.featureSortOrder), t1.hasTextData() && t1.text.opacityVertexBuffer && t1.text.opacityVertexBuffer.updateData(t1.text.opacityVertexArray), t1.hasIconData() && t1.icon.opacityVertexBuffer && t1.icon.opacityVertexBuffer.updateData(t1.icon.opacityVertexArray), t1.hasIconCollisionBoxData() && t1.iconCollisionBox.collisionVertexBuffer && t1.iconCollisionBox.collisionVertexBuffer.updateData(t1.iconCollisionBox.collisionVertexArray), t1.hasTextCollisionBoxData() && t1.textCollisionBox.collisionVertexBuffer && t1.textCollisionBox.collisionVertexBuffer.updateData(t1.textCollisionBox.collisionVertexArray), t1.bucketInstanceId in this.collisionCircleArrays) {
                    const e = this.collisionCircleArrays[t1.bucketInstanceId];
                    t1.placementInvProjMatrix = e.invProjMatrix, t1.placementViewportMatrix = e.viewportMatrix, t1.collisionCircleArray = e.circles, delete this.collisionCircleArrays[t1.bucketInstanceId];
                }
            }
            symbolFadeChange(e) {
                return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(e) {
                return Math.max(0, (this.transform.zoom - e) / 1.5);
            }
            hasTransitions(e) {
                return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(e, t1) {
                const i = this.zoomAtLastRecencyCheck === t1 ? 1 - this.zoomAdjustment(t1) : 1;
                return this.zoomAtLastRecencyCheck = t1, this.commitTime + this.fadeDuration * i > e;
            }
            setStale() {
                this.stale = !0;
            }
        }
        function gi(e, t1, i, o, s, r, a) {
            e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, r || 0, a || 0, o, s ? 1 : 0), e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, r || 0, a || 0, o, s ? 1 : 0), e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, r || 0, a || 0, o, s ? 1 : 0), e.emplaceBack(t1 ? 1 : 0, i ? 1 : 0, r || 0, a || 0, o, s ? 1 : 0);
        }
        const vi = Math.pow(2, 25), yi = Math.pow(2, 24), xi = Math.pow(2, 17), bi = Math.pow(2, 16), wi = Math.pow(2, 9), Ti = Math.pow(2, 8), Ei = Math.pow(2, 1);
        function Si(e) {
            if (0 === e.opacity && !e.placed) return 0;
            if (1 === e.opacity && e.placed) return 4294967295;
            const t1 = e.placed ? 1 : 0, i = Math.floor(127 * e.opacity);
            return i * vi + t1 * yi + i * xi + t1 * bi + i * wi + t1 * Ti + i * Ei + t1;
        }
        const Ci = 0;
        class Ii {
            constructor(e){
                this._sortAcrossTiles = "viewport-y" !== e.layout.get("symbol-z-order") && void 0 !== e.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = new Set, this._bucketParts = [];
            }
            continuePlacement(e, t1, i, o, s, r) {
                const a = this._bucketParts;
                for(; this._currentTileIndex < e.length;)if (t1.getBucketParts(a, o, e[this._currentTileIndex], this._sortAcrossTiles, r), this._currentTileIndex++, s()) return !0;
                for(this._sortAcrossTiles && (this._sortAcrossTiles = !1, a.sort((e, t1)=>e.sortKey - t1.sortKey)); this._currentPartIndex < a.length;){
                    const e = a[this._currentPartIndex];
                    if (t1.placeLayerBucketPart(e, this._seenCrossTileIDs, i, 0 === e.symbolInstanceStart, r), this._currentPartIndex++, s()) return !0;
                }
                return !1;
            }
        }
        class Ri {
            constructor(e, t1, i, o, s, r, a, n, l){
                this.placement = new mi(e, s, r, a, n, l), this._currentPlacementIndex = t1.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;
            }
            isDone() {
                return this._done;
            }
            continuePlacement(t1, i, o, s, r) {
                const a = e.q.now(), n = ()=>{
                    const t1 = e.q.now() - a;
                    return !this._forceFullPlacement && t1 > 2;
                };
                for(; this._currentPlacementIndex >= 0;){
                    const a = i[t1[this._currentPlacementIndex]], l = this.placement.collisionIndex.transform.zoom;
                    if ("symbol" === a.type && (!a.minzoom || a.minzoom <= l) && (!a.maxzoom || a.maxzoom > l)) {
                        const t1 = a, i = t1.layout.get("symbol-z-elevate"), l = void 0 !== t1.layout.get("symbol-sort-key").constantOr(1), c = t1.layout.get("symbol-z-order"), h = "viewport-y" === c || "auto" === c && !("viewport-y" !== c && l), u = t1.layout.get("text-allow-overlap") || t1.layout.get("icon-allow-overlap") || t1.layout.get("text-ignore-placement") || t1.layout.get("icon-ignore-placement"), d = h && u, _ = this._inProgressLayer = this._inProgressLayer || new Ii(t1), p = e.aC(a.source, a.scope);
                        if (_.continuePlacement(i || d ? s[p] : o[p], this.placement, this._showCollisionBoxes, a, n, r)) return;
                        delete this._inProgressLayer;
                    }
                    this._currentPlacementIndex--;
                }
                this._done = !0;
            }
            commit(e) {
                return this.placement.commit(e), this.placement;
            }
        }
        const Di = 512 / e.ag / 2;
        class Li {
            constructor(t1, i, o){
                this.tileID = t1, this.bucketInstanceId = o, this.index = new e.bE(i.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
                const s = t1.canonical.x * e.ag, r = t1.canonical.y * e.ag;
                for(let e = 0; e < i.length; e++){
                    const { key: t1, crossTileID: o, tileAnchorX: a, tileAnchorY: n } = i.get(e), l = Math.floor((s + a) * Di), c = Math.floor((r + n) * Di);
                    this.index.add(l, c), this.keys.push(t1), this.crossTileIDs.push(o);
                }
                this.index.finish();
            }
            findMatches(t1, i, o) {
                const s = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z), r = Di / Math.pow(2, i.canonical.z - this.tileID.canonical.z), a = i.canonical.x * e.ag, n = i.canonical.y * e.ag;
                for(let e = 0; e < t1.length; e++){
                    const i = t1.get(e);
                    if (i.crossTileID) continue;
                    const { key: l, tileAnchorX: c, tileAnchorY: h } = i, u = Math.floor((a + c) * r), d = Math.floor((n + h) * r), _ = this.index.range(u - s, d - s, u + s, d + s);
                    for (const e of _){
                        const t1 = this.crossTileIDs[e];
                        if (this.keys[e] === l && !o.has(t1)) {
                            o.add(t1), i.crossTileID = t1;
                            break;
                        }
                    }
                }
            }
        }
        class Ai {
            constructor(){
                this.maxCrossTileID = 0;
            }
            generate() {
                return ++this.maxCrossTileID;
            }
        }
        class zi {
            constructor(){
                this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(e) {
                const t1 = Math.round((e - this.lng) / 360);
                if (0 !== t1) for(const e in this.indexes){
                    const i = this.indexes[e], o = {};
                    for(const e in i){
                        const s = i[e];
                        s.tileID = s.tileID.unwrapTo(s.tileID.wrap + t1), o[s.tileID.key] = s;
                    }
                    this.indexes[e] = o;
                }
                this.lng = e;
            }
            addBucket(e, t1, i) {
                if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
                    if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t1.bucketInstanceId) return !1;
                    this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);
                }
                for(let e = 0; e < t1.symbolInstances.length; e++)t1.symbolInstances.get(e).crossTileID = 0;
                this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = new Set);
                const o = this.usedCrossTileIDs[e.overscaledZ];
                for(const i in this.indexes){
                    const s = this.indexes[i];
                    if (Number(i) > e.overscaledZ) for(const i in s){
                        const r = s[i];
                        r.tileID.isChildOf(e) && r.findMatches(t1.symbolInstances, e, o);
                    }
                    else {
                        const r = s[e.scaledTo(Number(i)).key];
                        r && r.findMatches(t1.symbolInstances, e, o);
                    }
                }
                for(let e = 0; e < t1.symbolInstances.length; e++){
                    const s = t1.symbolInstances.get(e);
                    s.crossTileID || (s.crossTileID = i.generate(), o.add(s.crossTileID));
                }
                return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Li(e, t1.symbolInstances, t1.bucketInstanceId), !0;
            }
            removeBucketCrossTileIDs(e, t1) {
                for (const i of t1.crossTileIDs)this.usedCrossTileIDs[e].delete(i);
            }
            removeStaleBuckets(e) {
                let t1 = !1;
                for(const i in this.indexes){
                    const o = this.indexes[i];
                    for(const s in o)e[o[s].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[s]), delete o[s], t1 = !0);
                }
                return t1;
            }
        }
        class Pi {
            constructor(){
                this.layerIndexes = {}, this.crossTileIDs = new Ai, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(e, t1, i, o) {
                let s = this.layerIndexes[e.fqid];
                void 0 === s && (s = this.layerIndexes[e.fqid] = new zi);
                let r = !1;
                const a = {};
                "globe" !== o.name && s.handleWrapJump(i);
                for (const i of t1){
                    const t1 = i.getBucket(e);
                    t1 && e.fqid === t1.layerIds[0] && (t1.bucketInstanceId || (t1.bucketInstanceId = ++this.maxBucketInstanceId), s.addBucket(i.tileID, t1, this.crossTileIDs) && (r = !0), a[t1.bucketInstanceId] = !0);
                }
                return s.removeStaleBuckets(a) && (r = !0), r;
            }
            pruneUnusedLayers(e) {
                const t1 = {};
                e.forEach((e)=>{
                    t1[e] = !0;
                });
                for(const e in this.layerIndexes)t1[e] || delete this.layerIndexes[e];
            }
        }
        const Mi = 771;
        class Oi {
            constructor(e, t1, i, o){
                this.blendFunction = e, this.blendColor = t1, this.mask = i, this.blendEquation = o;
            }
        }
        Oi.Replace = [
            1,
            0,
            1,
            0
        ], Oi.disabled = new Oi(Oi.Replace, e.aj.transparent, [
            !1,
            !1,
            !1,
            !1
        ]), Oi.unblended = new Oi(Oi.Replace, e.aj.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), Oi.alphaBlended = new Oi([
            1,
            Mi,
            1,
            Mi
        ], e.aj.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), Oi.alphaBlendedNonPremultiplied = new Oi([
            770,
            Mi,
            770,
            Mi
        ], e.aj.transparent, [
            !0,
            !0,
            !0,
            !0
        ]), Oi.multiply = new Oi([
            774,
            0,
            774,
            0
        ], e.aj.transparent, [
            !0,
            !0,
            !0,
            !0
        ]);
        class Fi {
            constructor(e, t1, i){
                this.func = e, this.mask = t1, this.range = i;
            }
        }
        Fi.ReadOnly = !1, Fi.ReadWrite = !0, Fi.disabled = new Fi(519, Fi.ReadOnly, [
            0,
            1
        ]);
        const ki = 7680;
        class Bi {
            constructor(e, t1, i, o, s, r){
                this.test = e, this.ref = t1, this.mask = i, this.fail = o, this.depthFail = s, this.pass = r;
            }
        }
        Bi.disabled = new Bi({
            func: 519,
            mask: 0
        }, 0, 0, ki, ki, ki);
        const Ni = 1029, Ui = 2305;
        class Gi {
            constructor(e, t1, i){
                this.enable = e, this.mode = t1, this.frontFace = i;
            }
        }
        function ji(t1, i) {
            const o = e.bG(t1, 3);
            e.ab.mat4.fromQuat(t1, i), e.bI(t1, 3, o);
        }
        function Vi(t1, i) {
            const o = e.ab.quat.identity([]);
            return e.ab.quat.rotateZ(o, o, -i), e.ab.quat.rotateX(o, o, -t1), o;
        }
        function qi(t1, i) {
            const o = [
                t1[0],
                t1[1],
                0
            ], s = [
                i[0],
                i[1],
                0
            ];
            if (e.ab.vec3.length(o) >= 1e-15) {
                const t1 = e.ab.vec3.normalize([], o);
                e.ab.vec3.scale(s, t1, e.ab.vec3.dot(s, t1)), i[0] = s[0], i[1] = s[1];
            }
            const r = e.ab.vec3.cross([], i, t1);
            if (e.ab.vec3.len(r) < 1e-15) return null;
            const a = Math.atan2(-r[1], r[0]);
            return Vi(Math.atan2(Math.sqrt(t1[0] * t1[0] + t1[1] * t1[1]), -t1[2]), a);
        }
        Gi.disabled = new Gi(!1, Ni, Ui), Gi.backCCW = new Gi(!0, Ni, Ui), Gi.backCW = new Gi(!0, Ni, 2304), Gi.frontCW = new Gi(!0, 1028, 2304), Gi.frontCCW = new Gi(!0, 1028, Ui);
        class Hi {
            constructor(e, t1){
                this.position = e, this.orientation = t1;
            }
            get position() {
                return this._position;
            }
            set position(t1) {
                if (t1) {
                    const i = t1 instanceof e.aa ? t1 : new e.aa(t1[0], t1[1], t1[2]);
                    this._renderWorldCopies && (i.x = e.bF(i.x, 0, 1)), this._position = i;
                } else this._position = null;
            }
            lookAtPoint(t1, i) {
                if (this.orientation = null, !this.position) return;
                const o = this.position, s = this._elevation ? this._elevation.getAtPointOrZero(e.aa.fromLngLat(t1)) : 0, r = e.aa.fromLngLat(t1, s), a = [
                    r.x - o.x,
                    r.y - o.y,
                    r.z - o.z
                ];
                i || (i = [
                    0,
                    0,
                    1
                ]), i[2] = Math.abs(i[2]), this.orientation = qi(a, i);
            }
            setPitchBearing(t1, i) {
                this.orientation = Vi(e.ai(t1), e.ai(-i));
            }
        }
        class Zi {
            constructor(t1, i){
                this._transform = e.ab.mat4.identity([]), this.orientation = i, this.position = t1;
            }
            get mercatorPosition() {
                const t1 = this.position;
                return new e.aa(t1[0], t1[1], t1[2]);
            }
            get position() {
                const t1 = e.bG(this._transform, 3);
                return [
                    t1[0],
                    t1[1],
                    t1[2]
                ];
            }
            set position(t1) {
                var i;
                t1 && e.bI(this._transform, 3, [
                    (i = t1)[0],
                    i[1],
                    i[2],
                    1
                ]);
            }
            get orientation() {
                return this._orientation;
            }
            set orientation(t1) {
                this._orientation = t1 || e.ab.quat.identity([]), t1 && ji(this._transform, this._orientation);
            }
            getPitchBearing() {
                const e = this.forward(), t1 = this.right();
                return {
                    bearing: Math.atan2(-t1[1], t1[0]),
                    pitch: Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2])
                };
            }
            setPitchBearing(e, t1) {
                this._orientation = Vi(e, t1), ji(this._transform, this._orientation);
            }
            forward() {
                const t1 = e.bG(this._transform, 2);
                return [
                    -t1[0],
                    -t1[1],
                    -t1[2]
                ];
            }
            up() {
                const t1 = e.bG(this._transform, 1);
                return [
                    -t1[0],
                    -t1[1],
                    -t1[2]
                ];
            }
            right() {
                const t1 = e.bG(this._transform, 0);
                return [
                    t1[0],
                    t1[1],
                    t1[2]
                ];
            }
            getCameraToWorld(t1, i) {
                const o = new Float64Array(16);
                return e.ab.mat4.invert(o, this.getWorldToCamera(t1, i)), o;
            }
            getCameraToWorldMercator() {
                return this._transform;
            }
            getWorldToCameraPosition(t1, i, o) {
                const s = this.position;
                e.ab.vec3.scale(s, s, -t1);
                const r = new Float64Array(16);
                return e.ab.mat4.fromScaling(r, [
                    o,
                    o,
                    o
                ]), e.ab.mat4.translate(r, r, s), r[10] *= i, r;
            }
            getWorldToCamera(t1, i) {
                const o = new Float64Array(16), s = new Float64Array(4), r = this.position;
                return e.ab.quat.conjugate(s, this._orientation), e.ab.vec3.scale(r, r, -t1), e.ab.mat4.fromQuat(o, s), e.ab.mat4.translate(o, o, r), o[1] *= -1, o[5] *= -1, o[9] *= -1, o[13] *= -1, o[8] *= i, o[9] *= i, o[10] *= i, o[11] *= i, o;
            }
            getCameraToClipPerspective(t1, i, o, s) {
                const r = new Float64Array(16);
                return e.ab.mat4.perspective(r, t1, i, o, s), r;
            }
            getCameraToClipOrthographic(t1, i, o, s, r, a) {
                const n = new Float64Array(16);
                return e.ab.mat4.ortho(n, t1, i, o, s, r, a), n;
            }
            getDistanceToElevation(t1, i = !1) {
                const o = 0 === t1 ? 0 : e.bH(t1, i ? e.aS(this.position[1]) : this.position[1]), s = this.forward();
                return (o - this.position[2]) / s[2];
            }
            clone() {
                return new Zi([
                    ...this.position
                ], [
                    ...this.orientation
                ]);
            }
        }
        const Wi = {
            BaseColor: 5,
            MetallicRoughness: 6,
            Normal: 7,
            Occlusion: 8,
            Emission: 9,
            LUT: 10,
            ShadowMap0: 11
        };
        class $i {
            constructor(e = 0, t1 = 0, i = 0, o = 0){
                if (isNaN(e) || e < 0 || isNaN(t1) || t1 < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                this.top = e, this.bottom = t1, this.left = i, this.right = o;
            }
            interpolate(t1, i, o) {
                return null != i.top && null != t1.top && (this.top = e.af(t1.top, i.top, o)), null != i.bottom && null != t1.bottom && (this.bottom = e.af(t1.bottom, i.bottom, o)), null != i.left && null != t1.left && (this.left = e.af(t1.left, i.left, o)), null != i.right && null != t1.right && (this.right = e.af(t1.right, i.right, o)), this;
            }
            getCenter(t1, i) {
                const o = e.aw((this.left + t1 - this.right) / 2, 0, t1), s = e.aw((this.top + i - this.bottom) / 2, 0, i);
                return new e.P(o, s);
            }
            equals(e) {
                return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;
            }
            clone() {
                return new $i(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
                return {
                    top: this.top,
                    bottom: this.bottom,
                    left: this.left,
                    right: this.right
                };
            }
        }
        const Xi = (e, t1, i)=>(1 - i) * e + i * t1, Ki = (e)=>e * e * e * e * e;
        class Yi {
            constructor(t1, i, o, s, r, a, n){
                this.tileSize = 512, this._renderWorldCopies = void 0 === r || r, this._minZoom = t1 || 0, this._maxZoom = i || 22, this._minPitch = o ?? 0, this._maxPitch = s ?? 60, this.setProjection(a), this.setMaxBounds(n), this.width = 0, this.height = 0, this._center = new e.bO(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new $i, this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Zi, this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [
                    0,
                    0,
                    0
                ], this._tileCoverLift = 0, this.freezeTileCoverage = !1, this._horizonShift = .1, this._orthographicProjectionAtLowPitch = !1;
            }
            clone() {
                const e = new Yi(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
                return e._elevation = this._elevation, e._centerAltitude = this._centerAltitude, e._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e.tileSize = this.tileSize, e.mercatorFromTransition = this.mercatorFromTransition, e.width = this.width, e.height = this.height, e.cameraElevationReference = this.cameraElevationReference, e._center = this._center, e._setZoom(this.zoom), e._seaLevelZoom = this._seaLevelZoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._nearZ = this._nearZ, e._farZ = this._farZ, e._averageElevation = this._averageElevation, e._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e._unmodified = this._unmodified, e._edgeInsets = this._edgeInsets.clone(), e._camera = this._camera.clone(), e._calcMatrices(), e.freezeTileCoverage = this.freezeTileCoverage, e.frustumCorners = this.frustumCorners, e;
            }
            get isOrthographic() {
                return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < 15;
            }
            get elevation() {
                return this._elevation;
            }
            set elevation(e) {
                this._elevation !== e && (this._elevation = e, this._updateCameraOnTerrain(), this._calcMatrices());
            }
            get depthOcclusionForSymbolsAndCircles() {
                return "globe" !== this.projection.name && !this.isOrthographic;
            }
            updateElevation(e, t1 = !1) {
                const i = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
                (null == this._seaLevelZoom || i) && this._updateCameraOnTerrain(), (e || i) && this._constrainCamera(t1), this._calcMatrices();
            }
            getProjection() {
                return e.ay(this.projection, [
                    "name",
                    "center",
                    "parallels"
                ]);
            }
            setProjection(t1) {
                this.projectionOptions = t1 || {
                    name: "mercator"
                };
                const i = this.projection ? this.getProjection() : void 0;
                this.projection = e.bP(this.projectionOptions);
                const o = this.getProjection(), s = !e.bn(i, o);
                return s && this._calcMatrices(), this.mercatorFromTransition = !1, s;
            }
            setOrthographicProjectionAtLowPitch(e) {
                return this._orthographicProjectionAtLowPitch !== e && (this._orthographicProjectionAtLowPitch = e, this._calcMatrices(), !0);
            }
            setMercatorFromTransition() {
                const t1 = this.projection.name;
                this.mercatorFromTransition = !0, this.projectionOptions = {
                    name: "mercator"
                }, this.projection = e.bP({
                    name: "mercator"
                });
                const i = t1 !== this.projection.name;
                return i && this._calcMatrices(), i;
            }
            get minZoom() {
                return this._minZoom;
            }
            set minZoom(e) {
                this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));
            }
            get maxZoom() {
                return this._maxZoom;
            }
            set maxZoom(e) {
                this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));
            }
            get minPitch() {
                return this._minPitch;
            }
            set minPitch(e) {
                this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));
            }
            get maxPitch() {
                return this._maxPitch;
            }
            set maxPitch(e) {
                this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));
            }
            get renderWorldCopies() {
                return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;
            }
            set renderWorldCopies(e) {
                void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e;
            }
            get worldSize() {
                return this.tileSize * this.scale;
            }
            get cameraWorldSizeForFog() {
                const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));
            }
            get cameraWorldSize() {
                const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
                return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));
            }
            get pixelsPerMeter() {
                return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
            }
            get cameraPixelsPerMeter() {
                return e.bH(1, this.center.lat) * this.cameraWorldSizeForFog;
            }
            get centerOffset() {
                return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
                return new e.P(this.width, this.height);
            }
            get bearing() {
                return e.bF(this.rotation, -180, 180);
            }
            set bearing(e) {
                this.rotation = e;
            }
            get rotation() {
                return -this.angle / Math.PI * 180;
            }
            set rotation(t1) {
                const i = -t1 * Math.PI / 180;
                this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = e.ab.mat2.create(), e.ab.mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
                return this._pitch / Math.PI * 180;
            }
            set pitch(t1) {
                const i = e.aw(t1, this.minPitch, this.maxPitch) / 180 * Math.PI;
                this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());
            }
            get aspect() {
                return this.width / this.height;
            }
            get fov() {
                return this._fov / Math.PI * 180;
            }
            get fovX() {
                return this._fov;
            }
            get fovY() {
                const e = 1 / Math.tan(.5 * this.fovX);
                return 2 * Math.atan(1 / this.aspect / e);
            }
            set fov(t1) {
                t1 = Math.max(.01, Math.min(60, t1)), this._fov !== t1 && (this._unmodified = !1, this._fov = e.ai(t1), this._calcMatrices());
            }
            get averageElevation() {
                return this._averageElevation;
            }
            set averageElevation(e) {
                this._averageElevation = e, this._calcFogMatrices(), this._distanceTileDataCache = {};
            }
            get zoom() {
                return this._zoom;
            }
            set zoom(e) {
                const t1 = Math.min(Math.max(e, this.minZoom), this.maxZoom);
                this._zoom !== t1 && (this._unmodified = !1, this._setZoom(t1), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
            }
            _setZoom(e) {
                this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom;
            }
            get tileCoverLift() {
                return this._tileCoverLift;
            }
            set tileCoverLift(e) {
                this._tileCoverLift !== e && (this._tileCoverLift = e);
            }
            _updateCameraOnTerrain() {
                const e = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, t1 = this.elevation && e === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
                if (!this._elevation || e === Number.NEGATIVE_INFINITY && (!t1 || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
                const i = this._elevation;
                t1 || this._centerAltitude && this._centerAltitudeValidForExaggeration && i.exaggeration() && this._centerAltitudeValidForExaggeration !== i.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i.exaggeration(), this._centerAltitudeValidForExaggeration = i.exaggeration()) : (this._centerAltitude = e || 0, this._centerAltitudeValidForExaggeration = i.exaggeration()), this._updateSeaLevelZoom();
            }
            _updateSeaLevelZoom() {
                void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
            }
            sampleAverageElevation() {
                if (!this._elevation) return 0;
                const t1 = this._elevation, i = [
                    [
                        .5,
                        .2
                    ],
                    [
                        .3,
                        .5
                    ],
                    [
                        .5,
                        .5
                    ],
                    [
                        .7,
                        .5
                    ],
                    [
                        .5,
                        .8
                    ]
                ], o = this.horizonLineFromTop();
                let s = 0, r = 0;
                for(let a = 0; a < i.length; a++){
                    const n = new e.P(i[a][0] * this.width, o + i[a][1] * (this.height - o)), l = t1.pointCoordinate(n);
                    if (!l) continue;
                    const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);
                    s += l[3] * c, r += c;
                }
                return 0 === r ? NaN : s / r;
            }
            get center() {
                return this._center;
            }
            set center(e) {
                e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
            }
            _updateZoomFromElevation() {
                if (null == this._seaLevelZoom || !this._elevation) return;
                const e = this._seaLevelZoom, t1 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i = this.pixelsPerMeter / this.worldSize * t1, o = this._mercatorZfromZoom(e), s = this._mercatorZfromZoom(this._maxZoom), r = Math.max(o - i, s);
                this._setZoom(this._zoomFromMercatorZ(r));
            }
            get padding() {
                return this._edgeInsets.toJSON();
            }
            set padding(e) {
                this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());
            }
            computeZoomRelativeTo(t1) {
                const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t1.toAltitude()));
                let o;
                o = t1.z < this._camera.position[2] ? [
                    i.x,
                    i.y,
                    i.z
                ] : [
                    t1.x,
                    t1.y,
                    t1.z
                ];
                const s = e.ab.vec3.length(e.ab.vec3.sub([], this._camera.position, o));
                return e.aw(this._zoomFromMercatorZ(s), this._minZoom, this._maxZoom);
            }
            setFreeCameraOptions(t1) {
                if (!this.height) return;
                if (!t1.position && !t1.orientation) return;
                this._updateCameraState();
                let i = !1;
                if (t1.orientation && !e.ab.quat.exactEquals(t1.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t1.orientation)), t1.position) {
                    const o = [
                        t1.position.x,
                        t1.position.y,
                        t1.position.z
                    ];
                    e.ab.vec3.exactEquals(o, this._camera.position) || (this._setCameraPosition(o), i = !0);
                }
                i && (this._updateStateFromCamera(), this.recenterOnTerrain());
            }
            getFreeCameraOptions() {
                this._updateCameraState();
                const t1 = this._camera.position, i = new Hi;
                return i.position = new e.aa(t1[0], t1[1], t1[2]), i.orientation = this._camera.orientation, i._elevation = this.elevation, i._renderWorldCopies = this.renderWorldCopies, i;
            }
            _setCameraOrientation(t1) {
                if (!e.ab.quat.length(t1)) return !1;
                e.ab.quat.normalize(t1, t1);
                const i = e.ab.vec3.transformQuat([], [
                    0,
                    0,
                    -1
                ], t1), o = e.ab.vec3.transformQuat([], [
                    0,
                    -1,
                    0
                ], t1);
                if (o[2] < 0) return !1;
                const s = qi(i, o);
                return !!s && (this._camera.orientation = s, !0);
            }
            _setCameraPosition(t1) {
                const i = this.zoomScale(this.minZoom) * this.tileSize, o = this.zoomScale(this.maxZoom) * this.tileSize, s = this.cameraToCenterDistance;
                t1[2] = e.aw(t1[2], s / o, s / i), this._camera.position = t1;
            }
            get centerPoint() {
                return this._edgeInsets.getCenter(this.width, this.height);
            }
            get fovAboveCenter() {
                return this._fov * (.5 + this.centerOffset.y / this.height);
            }
            isPaddingEqual(e) {
                return this._edgeInsets.equals(e);
            }
            interpolatePadding(e, t1, i) {
                this._unmodified = !1, this._edgeInsets.interpolate(e, t1, i), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(e) {
                const t1 = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));
                return Math.max(0, t1);
            }
            getVisibleUnwrappedCoordinates(t1) {
                const i = [
                    new e.bQ(0, t1)
                ];
                if (this.renderWorldCopies) {
                    const o = this.pointCoordinate(new e.P(0, 0)), s = this.pointCoordinate(new e.P(this.width, 0)), r = this.pointCoordinate(new e.P(this.width, this.height)), a = this.pointCoordinate(new e.P(0, this.height)), n = Math.floor(Math.min(o.x, s.x, r.x, a.x)), l = Math.floor(Math.max(o.x, s.x, r.x, a.x)), c = 1;
                    for(let o = n - c; o <= l + c; o++)0 !== o && i.push(new e.bQ(o, t1));
                }
                return i;
            }
            isLODDisabled(e) {
                return (!e || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
            }
            extendTileCover(t1, i, o) {
                let s = [];
                const r = void 0 !== o, a = !r;
                if (a && this.zoom < i) return s;
                if (r && 0 === o[0] && 0 === o[1]) return s;
                const n = new Set, l = (t1, i, o, r, a)=>{
                    const l = e.c5(i, t1, o, r, a);
                    n.has(l) || (s.push(new e.aG(t1, i, o, r, a)), n.add(l));
                };
                for(let e = 0; e < t1.length; e++){
                    const s = t1[e];
                    if (a && s.canonical.z !== i) continue;
                    const n = s.canonical, c = s.overscaledZ, h = s.wrap, u = 1 << n.z, d = n.x + 1 < u, _ = n.x > 0, p = n.y + 1 < u, f = n.y > 0, m = s.wrap - (_ ? 0 : 1), g = s.wrap + (d ? 0 : 1), v = _ ? n.x - 1 : u - 1, y = d ? n.x + 1 : 0;
                    if (r) o[0] < 0 ? (l(c, g, n.z, y, n.y), o[1] < 0 && p && (l(c, h, n.z, n.x, n.y + 1), l(c, g, n.z, y, n.y + 1)), o[1] > 0 && f && (l(c, h, n.z, n.x, n.y - 1), l(c, g, n.z, y, n.y - 1))) : o[0] > 0 ? (l(c, m, n.z, v, n.y), o[1] < 0 && p && (l(c, h, n.z, n.x, n.y + 1), l(c, m, n.z, v, n.y + 1)), o[1] > 0 && f && (l(c, h, n.z, n.x, n.y - 1), l(c, m, n.z, v, n.y - 1))) : o[1] < 0 && p ? l(c, h, n.z, n.x, n.y + 1) : f && l(c, h, n.z, n.x, n.y - 1);
                    else {
                        const e = s.visibleQuadrants;
                        1 & e && (l(c, m, n.z, v, n.y), f && (l(c, h, n.z, n.x, n.y - 1), l(c, m, n.z, v, n.y - 1))), 2 & e && (l(c, g, n.z, y, n.y), f && (l(c, h, n.z, n.x, n.y - 1), l(c, g, n.z, y, n.y - 1))), 4 & e && (l(c, m, n.z, v, n.y), p && (l(c, h, n.z, n.x, n.y + 1), l(c, m, n.z, v, n.y + 1))), 8 & e && (l(c, g, n.z, y, n.y), p && (l(c, h, n.z, n.x, n.y + 1), l(c, g, n.z, y, n.y + 1)));
                    }
                }
                const c = [];
                for (const e of s)s.some((t1)=>e.isChildOf(t1)) || c.push(e);
                if (s = c.filter((e)=>!t1.some((t1)=>!!(e.overscaledZ < i && t1.isChildOf(e)) || e.equals(t1) || e.isChildOf(t1))), a) {
                    const e = 1 << i, t1 = "globe" === this.projection.name ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), o = [
                        e * t1.x,
                        e * t1.y
                    ], r = 4, a = r * r;
                    s = s.filter((e)=>{
                        const t1 = e.canonical.x + .5 - o[0], i = e.canonical.y + .5 - o[1];
                        return t1 * t1 + i * i < a;
                    });
                }
                return s;
            }
            coveringTiles(t1) {
                let i = this.coveringZoomLevel(t1);
                const o = i, s = this.elevation && this.elevation.exaggeration(), r = s && !t1.isTerrainDEM, a = "mercator" === this.projection.name;
                if (void 0 !== t1.minzoom && i < t1.minzoom) return [];
                void 0 !== t1.maxzoom && i > t1.maxzoom && (i = t1.maxzoom);
                const n = this.locationCoordinate(this.center), l = this.center.lat, c = 1 << i, h = [
                    c * n.x,
                    c * n.y,
                    0
                ], u = "globe" === this.projection.name, d = !u, _ = e.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, d), p = u ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), f = c * e.bH(1, this.center.lat), m = this._camera.position[2] / e.bH(1, this.center.lat), g = [
                    c * p.x,
                    c * p.y,
                    m * (d ? 1 : f)
                ], v = u || s, y = this.cameraToCenterDistance / t1.tileSize * (t1.roundZoom ? 1 : .502), x = this.isLODDisabled(!0) ? i : 0;
                let b;
                if (this._elevation && t1.isTerrainDEM) b = 1e4 * this._elevation.exaggeration();
                else if (this._elevation) {
                    const e = this._elevation.getMinMaxForVisibleTiles();
                    b = e ? e.max : this._centerAltitude;
                } else b = this._centerAltitude;
                const w = t1.isTerrainDEM ? -b : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, T = this.projection.isReprojectedInTileSpace ? e.bS(this) : 1, E = (t1)=>{
                    const i = 1 / 4e4, o = new e.aa(t1.x + i, t1.y, t1.z), s = new e.aa(t1.x, t1.y + i, t1.z), r = t1.toLngLat(), a = o.toLngLat(), n = s.toLngLat(), l = this.locationCoordinate(r), c = this.locationCoordinate(a), h = this.locationCoordinate(n), u = Math.hypot(c.x - l.x, c.y - l.y), d = Math.hypot(h.x - l.x, h.y - l.y);
                    return Math.sqrt(u * d) * T / i;
                }, S = (t1)=>{
                    const i = b, o = w;
                    return {
                        aabb: e.bV(this, c, 0, 0, 0, t1, o, i, this.projection),
                        zoom: 0,
                        x: 0,
                        y: 0,
                        minZ: o,
                        maxZ: i,
                        wrap: t1,
                        fullyVisible: !1
                    };
                }, C = [];
                let I = [];
                const R = i, D = t1.reparseOverscaled ? o : i, L = (m - this._centerAltitude) * f, A = (e)=>{
                    if (!this._elevation || !e.tileID || !a) return;
                    const t1 = this._elevation.getMinMaxForTile(e.tileID), i = e.aabb;
                    t1 ? (i.min[2] = t1.min, i.max[2] = t1.max, i.center[2] = (i.min[2] + i.max[2]) / 2) : (e.shouldSplit = P(e), e.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));
                }, z = (e, t1)=>{
                    if (.707 * t1 < e) return 1;
                    const i = t1 / e;
                    return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
                }, P = (t1)=>{
                    if (t1.zoom < x) return !0;
                    if (t1.zoom === R) return !1;
                    if (null != t1.shouldSplit) return t1.shouldSplit;
                    const i = t1.aabb.distanceX(g), s = t1.aabb.distanceY(g);
                    let n = L, c = 1;
                    if (u) {
                        n = t1.aabb.distanceZ(g);
                        const i = Math.pow(2, t1.zoom), o = e.aS((t1.y + 1) / i), s = e.aS(t1.y / i), r = Math.min(Math.max(l, o), s), a = e.c9(r) / e.c9(l);
                        if (c = r === l ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, a / this._mercatorScaleRatio), this.zoom <= e.c6 && t1.zoom === R - 1 && a >= .9) return !0;
                    } else if (r && (n = t1.aabb.distanceZ(g) * f), this.projection.isReprojectedInTileSpace && o <= 5) {
                        const i = Math.pow(2, t1.zoom), o = E(new e.aa((t1.x + .5) / i, (t1.y + .5) / i));
                        c = o > .85 ? 1 : o;
                    }
                    if (!a) {
                        const e = Math.sqrt(i * i + s * s + n * n);
                        let o = (1 << R - t1.zoom) * y * c;
                        return o *= z(Math.max(n, L), e), e < o;
                    }
                    let d = Number.MAX_VALUE, _ = 0;
                    const p = t1.aabb.getCorners(), m = [];
                    for (const t1 of p){
                        e.ab.vec3.sub(m, t1, g), u || (r ? m[2] *= f : m[2] = L);
                        const i = e.ab.vec3.dot(m, this._camera.forward());
                        i < d && (d = i, _ = Math.abs(m[2]));
                    }
                    let v = (1 << R - t1.zoom) * y * c;
                    if (v *= z(Math.max(_, L), d), d < v) return !0;
                    const b = t1.aabb.closestPoint(h);
                    return b[0] === h[0] && b[1] === h[1];
                };
                if (this.renderWorldCopies) for(let e = 1; e <= 3; e++)C.push(S(-e)), C.push(S(e));
                for(C.push(S(0)); C.length > 0;){
                    const o = C.pop(), s = o.x, n = o.y;
                    let l = o.fullyVisible;
                    const d = ()=>"globe" === this.projection.name && (0 === o.y || o.y === (1 << o.zoom) - 1);
                    if (!l) {
                        let t1 = v ? o.aabb.intersects(_) : o.aabb.intersectsFlat(_);
                        if (0 === t1 && d()) {
                            const i = new e.bT(o.zoom, s, n);
                            t1 = e.bU(this, c, i, !0).intersects(_);
                        }
                        if (0 === t1) continue;
                        l = 2 === t1;
                    }
                    if (o.zoom !== R && P(o)) for(let t1 = 0; t1 < 4; t1++){
                        const i = (s << 1) + t1 % 2, h = (n << 1) + (t1 >> 1), d = {
                            aabb: a ? o.aabb.quadrant(t1) : e.bV(this, c, o.zoom + 1, i, h, o.wrap, o.minZ, o.maxZ, this.projection),
                            zoom: o.zoom + 1,
                            x: i,
                            y: h,
                            wrap: o.wrap,
                            fullyVisible: l,
                            tileID: void 0,
                            shouldSplit: void 0,
                            minZ: o.minZ,
                            maxZ: o.maxZ
                        };
                        r && !u && (d.tileID = new e.aG(o.zoom + 1 === R ? D : o.zoom + 1, o.wrap, o.zoom + 1, i, h), A(d)), C.push(d);
                    }
                    else {
                        const r = o.zoom === R ? D : o.zoom;
                        if (t1.minzoom && t1.minzoom > r) continue;
                        let a = 0;
                        if (!l) {
                            let i = v ? o.aabb.intersectsPrecise(_) : o.aabb.intersectsPreciseFlat(_);
                            if (0 === i && d()) {
                                const t1 = new e.bT(o.zoom, s, n);
                                i = e.bU(this, c, t1, !0).intersectsPrecise(_);
                            }
                            if (0 === i) continue;
                            if (t1.calculateQuadrantVisibility) if (_.containsPoint(o.aabb.center)) a = 15;
                            else for(let e = 0; e < 4; e++)0 !== o.aabb.quadrant(e).intersects(_) && (a |= 1 << e);
                        }
                        const u = h[0] - (.5 + s + (o.wrap << o.zoom)) * (1 << i - o.zoom), p = h[1] - .5 - n, f = o.tileID ? o.tileID : new e.aG(r, o.wrap, o.zoom, s, n);
                        t1.calculateQuadrantVisibility && (f.visibleQuadrants = a), I.push({
                            tileID: f,
                            distanceSq: u * u + p * p
                        });
                    }
                }
                if (this.fogCullDistSq) {
                    const i = this.fogCullDistSq, o = this.horizonLineFromTop();
                    I = I.filter((s)=>{
                        const r = [
                            0,
                            0,
                            0,
                            1
                        ], a = [
                            e.ag,
                            e.ag,
                            0,
                            1
                        ], n = this.calculateFogTileMatrix(s.tileID.toUnwrapped());
                        e.ab.vec4.transformMat4(r, r, n), e.ab.vec4.transformMat4(a, a, n);
                        const l = e.ab.vec4.min([], r, a), c = e.ab.vec4.max([], r, a), h = e.bW(l, c);
                        if (0 === h) return !0;
                        let u = !1;
                        const d = this._elevation;
                        if (d && h > i && 0 !== o) {
                            const i = this.calculateProjMatrix(s.tileID.toUnwrapped());
                            let r;
                            t1.isTerrainDEM || (r = d.getMinMaxForTile(s.tileID)), r || (r = {
                                min: w,
                                max: b
                            });
                            const a = e.c7(this.rotation), n = [
                                a[0] * e.ag,
                                a[1] * e.ag,
                                r.max
                            ];
                            e.ab.vec3.transformMat4(n, n, i), u = (1 - n[1]) * this.height * .5 < o;
                        }
                        return h < i || u;
                    });
                }
                return I.sort((e, t1)=>e.distanceSq - t1.distanceSq).map((e)=>e.tileID);
            }
            resize(e, t1) {
                this.width = e, this.height = t1, this.pixelsToGLUnits = [
                    2 / e,
                    -2 / t1
                ], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
                return this._unmodified;
            }
            zoomScale(e) {
                return Math.pow(2, e);
            }
            scaleZoom(e) {
                return Math.log(e) / Math.LN2;
            }
            project(t1) {
                const i = e.aw(t1.lat, -e.bX, e.bX), o = this.projection.project(t1.lng, i);
                return new e.P(o.x * this.worldSize, o.y * this.worldSize);
            }
            unproject(e) {
                return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize);
            }
            get point() {
                return this.project(this.center);
            }
            get pointMerc() {
                return this.point._div(this.worldSize);
            }
            get pixelsPerMeterRatio() {
                return this.pixelsPerMeter / e.bH(1, this.center.lat) / this.worldSize;
            }
            setLocationAtPoint(t1, i) {
                let o, s;
                const r = this.centerPoint;
                if ("globe" === this.projection.name) {
                    const e = this.worldSize;
                    o = (i.x - r.x) / e, s = (i.y - r.y) / e;
                } else {
                    const e = this.pointCoordinate(i), t1 = this.pointCoordinate(r);
                    o = e.x - t1.x, s = e.y - t1.y;
                }
                const a = this.locationCoordinate(t1);
                this.setLocation(new e.aa(a.x - o, a.y - s));
            }
            setLocation(e) {
                this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap());
            }
            locationPoint(e) {
                return this.projection.locationPoint(this, e);
            }
            locationPoint3D(e) {
                return this.projection.locationPoint(this, e, !0);
            }
            pointLocation(e) {
                return this.coordinateLocation(this.pointCoordinate(e));
            }
            pointLocation3D(e) {
                return this.coordinateLocation(this.pointCoordinate3D(e));
            }
            locationCoordinate(t1, i) {
                const o = i ? e.bH(i, t1.lat) : void 0, s = this.projection.project(t1.lng, t1.lat);
                return new e.aa(s.x, s.y, o);
            }
            coordinateLocation(e) {
                return this.projection.unproject(e.x, e.y);
            }
            pointRayIntersection(t1, i) {
                const o = null != i ? i : this._centerAltitude, s = [
                    t1.x,
                    t1.y,
                    0,
                    1
                ], r = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                e.ab.vec4.transformMat4(s, s, this.pixelMatrixInverse), e.ab.vec4.transformMat4(r, r, this.pixelMatrixInverse);
                const a = r[3];
                e.ab.vec4.scale(s, s, 1 / s[3]), e.ab.vec4.scale(r, r, 1 / a);
                const n = s[2], l = r[2];
                return {
                    p0: s,
                    p1: r,
                    t: n === l ? 0 : (o - n) / (l - n)
                };
            }
            screenPointToMercatorRay(t1) {
                const i = [
                    t1.x,
                    t1.y,
                    0,
                    1
                ], o = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                return e.ab.vec4.transformMat4(i, i, this.pixelMatrixInverse), e.ab.vec4.transformMat4(o, o, this.pixelMatrixInverse), e.ab.vec4.scale(i, i, 1 / i[3]), e.ab.vec4.scale(o, o, 1 / o[3]), i[2] = e.bH(i[2], this._center.lat) * this.worldSize, o[2] = e.bH(o[2], this._center.lat) * this.worldSize, e.ab.vec4.scale(i, i, 1 / this.worldSize), e.ab.vec4.scale(o, o, 1 / this.worldSize), new e.aq([
                    i[0],
                    i[1],
                    i[2]
                ], e.ab.vec3.normalize([], e.ab.vec3.sub([], o, i)));
            }
            rayIntersectionCoordinate(t1) {
                const { p0: i, p1: o, t: s } = t1, r = e.bH(i[2], this._center.lat), a = e.bH(o[2], this._center.lat);
                return new e.aa(e.af(i[0], o[0], s) / this.worldSize, e.af(i[1], o[1], s) / this.worldSize, e.af(r, a, s));
            }
            pointCoordinate(e, t1 = this._centerAltitude) {
                return this.projection.pointCoordinate(this, e.x, e.y, t1);
            }
            pointCoordinate3D(t1) {
                if (!this.elevation) return this.pointCoordinate(t1);
                let i = this.projection.pointCoordinate3D(this, t1.x, t1.y);
                if (i) return new e.aa(i[0], i[1], i[2]);
                let o = 0, s = this.horizonLineFromTop();
                if (t1.y > s) return this.pointCoordinate(t1);
                const r = .02 * s, a = t1.clone();
                for(let t1 = 0; t1 < 10 && s - o > r; t1++){
                    a.y = e.af(o, s, .66);
                    const t1 = this.projection.pointCoordinate3D(this, a.x, a.y);
                    t1 ? (s = a.y, i = t1) : o = a.y;
                }
                return i ? new e.aa(i[0], i[1], i[2]) : this.pointCoordinate(t1);
            }
            isPointAboveHorizon(e) {
                return this.projection.isPointAboveHorizon(this, e);
            }
            isPointOnSurface(t1) {
                if (t1.y < 0 || t1.y > this.height || t1.x < 0 || t1.x > this.width) return !1;
                if (this.elevation || this.zoom >= e.bY) return !this.isPointAboveHorizon(t1);
                const i = this.pointCoordinate(t1);
                return i.y >= 0 && i.y <= 1;
            }
            _coordinatePoint(t1, i) {
                const o = i && this.elevation ? this.elevation.getAtPointOrZero(t1, this._centerAltitude) : this._centerAltitude, s = [
                    t1.x * this.worldSize,
                    t1.y * this.worldSize,
                    o + t1.toAltitude(),
                    1
                ];
                return e.ab.vec4.transformMat4(s, s, this.pixelMatrix), s[3] > 0 ? new e.P(s[0] / s[3], s[1] / s[3]) : new e.P(Number.MAX_VALUE, Number.MAX_VALUE);
            }
            _getBoundsNonRectangular() {
                const { top: t1, left: i } = this._edgeInsets, o = this.height - this._edgeInsets.bottom, s = this.width - this._edgeInsets.right, r = this.pointLocation3D(new e.P(i, t1)), a = this.pointLocation3D(new e.P(s, t1)), n = this.pointLocation3D(new e.P(s, o)), l = this.pointLocation3D(new e.P(i, o));
                let c = Math.min(r.lng, a.lng, n.lng, l.lng), h = Math.max(r.lng, a.lng, n.lng, l.lng), u = Math.min(r.lat, a.lat, n.lat, l.lat), d = Math.max(r.lat, a.lat, n.lat, l.lat);
                const _ = Math.pow(2, -this.zoom) / 16 * 270, p = "globe" === this.projection.name ? 1 : 4, f = (t1, i, o, s, r)=>{
                    const a = (t1 + o) / 2, n = (i + s) / 2, l = new e.P(a, n), { lng: m, lat: g } = this.pointLocation3D(l), v = Math.max(0, c - m, u - g, m - h, g - d);
                    c = Math.min(c, m), h = Math.max(h, m), u = Math.min(u, g), d = Math.max(d, g), (r < p || v > _) && (f(t1, i, a, n, r + 1), f(a, n, o, s, r + 1));
                };
                if (f(i, t1, s, t1, 1), f(s, t1, s, o, 1), f(s, o, i, o, 1), f(i, o, i, t1, 1), "globe" === this.projection.name) {
                    const [t1, i] = e.bZ(this);
                    t1 ? (d = 90, h = 180, c = -180) : i && (u = -90, h = 180, c = -180);
                }
                return new e.az(new e.bO(c, u), new e.bO(h, d));
            }
            _getBoundsRectangular(t1, i) {
                const { top: o, left: s } = this._edgeInsets, r = this.height - this._edgeInsets.bottom, a = this.width - this._edgeInsets.right, n = new e.P(s, o), l = new e.P(a, o), c = new e.P(a, r), h = new e.P(s, r);
                let u = this.pointCoordinate(n, t1), d = this.pointCoordinate(l, t1);
                const _ = this.pointCoordinate(c, i), p = this.pointCoordinate(h, i), f = (e, t1)=>(t1.y - e.y) / (t1.x - e.x);
                return u.y > 1 && d.y >= 0 ? u = new e.aa((1 - p.y) / f(p, u) + p.x, 1) : u.y < 0 && d.y <= 1 && (u = new e.aa(-p.y / f(p, u) + p.x, 0)), d.y > 1 && u.y >= 0 ? d = new e.aa((1 - _.y) / f(_, d) + _.x, 1) : d.y < 0 && u.y <= 1 && (d = new e.aa(-_.y / f(_, d) + _.x, 0)), (new e.az).extend(this.coordinateLocation(u)).extend(this.coordinateLocation(d)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(_));
            }
            _getBoundsRectangularTerrain() {
                const e = this.elevation;
                if (!e.visibleDemTiles.length || e.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
                const t1 = e.visibleDemTiles.reduce((e, t1)=>{
                    if (t1.dem) {
                        const i = t1.dem.tree;
                        e.min = Math.min(e.min, i.minimums[0]), e.max = Math.max(e.max, i.maximums[0]);
                    }
                    return e;
                }, {
                    min: Number.MAX_VALUE,
                    max: 0
                });
                return this._getBoundsRectangular(t1.min * e.exaggeration(), t1.max * e.exaggeration());
            }
            getBounds() {
                return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
            }
            horizonLineFromTop(e = !0) {
                const t1 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) - this.centerOffset.y, i = this.height / 2 - t1 * (1 - this._horizonShift);
                return e ? Math.max(0, i) : i;
            }
            getMaxBounds() {
                return this.maxBounds;
            }
            setMaxBounds(t1) {
                this.maxBounds = t1, this.minLat = -e.bX, this.maxLat = e.bX, this.minLng = -180, this.maxLng = 180, t1 && (this.minLat = t1.getSouth(), this.maxLat = t1.getNorth(), this.minLng = t1.getWest(), this.maxLng = t1.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.at(this.minLng) * this.tileSize, this.worldMaxX = e.at(this.maxLng) * this.tileSize, this.worldMinY = e.aA(this.maxLat) * this.tileSize, this.worldMaxY = e.aA(this.minLat) * this.tileSize, this._constrain();
            }
            calculatePosMatrix(e, t1) {
                return this.projection.createTileMatrix(this, t1, e);
            }
            calculateDistanceTileData(t1) {
                const i = t1.key, o = this._distanceTileDataCache;
                if (o[i]) return o[i];
                const s = t1.canonical, r = 1 / this.height, a = this.cameraWorldSize, n = a / this.zoomScale(s.z), l = (s.x + Math.pow(2, s.z) * t1.wrap) * n, c = s.y * n, h = this.point;
                h.x *= a / this.worldSize, h.y *= a / this.worldSize;
                const u = this.angle, d = Math.sin(-u), _ = -Math.cos(-u);
                return o[i] = {
                    bearing: [
                        d,
                        _
                    ],
                    center: [
                        (h.x - l) * r,
                        (h.y - c) * r
                    ],
                    scale: n / e.ag * r
                }, o[i];
            }
            calculateFogTileMatrix(t1) {
                const i = t1.key, o = this._fogTileMatrixCache;
                if (o[i]) return o[i];
                const s = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t1);
                return e.ab.mat4.multiply(s, this.worldToFogMatrix, s), o[i] = new Float32Array(s), o[i];
            }
            calculateProjMatrix(t1, i = !1, o = !1) {
                const s = t1.key;
                let r;
                if (r = o ? this._expandedProjMatrixCache : i ? this._alignedProjMatrixCache : this._projMatrixCache, r[s]) return r[s];
                const a = this.calculatePosMatrix(t1, this.worldSize);
                let n;
                return n = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o ? this.expandedFarZProjMatrix : i ? this.alignedProjMatrix : this.projMatrix, e.ab.mat4.multiply(a, n, a), r[s] = new Float32Array(a), r[s];
            }
            calculatePixelsToTileUnitsMatrix(t1) {
                const i = t1.tileID.key, o = this._pixelsToTileUnitsCache;
                if (o[i]) return o[i];
                const s = e.b_(t1, this);
                return o[i] = s, o[i];
            }
            customLayerMatrix() {
                return this.mercatorMatrix.slice();
            }
            globeToMercatorMatrix() {
                if ("globe" === this.projection.name) {
                    const t1 = 1 / this.worldSize, i = e.ab.mat4.fromScaling([], [
                        t1,
                        t1,
                        t1
                    ]);
                    return e.ab.mat4.multiply(i, i, this.globeMatrix), i;
                }
            }
            recenterOnTerrain() {
                if (!this._elevation || "globe" === this.projection.name) return;
                const t1 = this._elevation;
                this._updateCameraState();
                const i = e.bH(1, this._center.lat) * this.worldSize, o = this._computeCameraPosition(i), s = this._camera.forward(), r = e.bH(1, this._center.lat);
                o[2] /= r, s[2] /= r, e.ab.vec3.normalize(s, s);
                const a = t1.raycast(o, s, t1.exaggeration());
                if (a) {
                    const t1 = e.ab.vec3.scaleAndAdd([], o, s, a), i = new e.aa(t1[0], t1[1], e.bH(t1[2], e.aS(t1[1]))), n = (i.z + e.ab.vec3.length([
                        i.x - o[0],
                        i.y - o[1],
                        i.z - o[2] * r
                    ])) * this._pixelsPerMercatorPixel;
                    this._seaLevelZoom = this._zoomFromMercatorZ(n), this._centerAltitude = i.toAltitude(), this._center = this.coordinateLocation(i), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
                }
            }
            _constrainCamera(t1 = !1) {
                if (!this._elevation) return;
                const i = this._elevation, o = e.bH(1, this._center.lat) * this.worldSize, s = this._computeCameraPosition(o), r = i.getAtPointOrZero(new e.aa(...s)), a = this.pixelsPerMeter / this.worldSize * r, n = this._minimumHeightOverTerrain(), l = s[2] - a;
                if (l <= n) if (l < 0 || t1) {
                    const t1 = this.locationCoordinate(this._center, this._centerAltitude), i = [
                        s[0],
                        s[1],
                        t1.z - s[2]
                    ], o = e.ab.vec3.length(i);
                    i[2] -= (n - l) / this._pixelsPerMercatorPixel;
                    const r = e.ab.vec3.length(i);
                    if (0 === r) return;
                    e.ab.vec3.scale(i, i, o / r * this._pixelsPerMercatorPixel), this._camera.position = [
                        s[0],
                        s[1],
                        t1.z * this._pixelsPerMercatorPixel - i[2]
                    ], this._updateStateFromCamera();
                } else this._isCameraConstrained = !0;
            }
            _constrain() {
                if (!this.center || !this.width || !this.height || this._constraining) return;
                this._constraining = !0;
                const t1 = "globe" === this.projection.name || this.mercatorFromTransition;
                if (this.projection.isReprojectedInTileSpace || t1) {
                    const i = this.center;
                    return i.lat = e.aw(i.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t1) && (i.lng = e.aw(i.lng, this.minLng, this.maxLng)), this.center = i, void (this._constraining = !1);
                }
                const i = this._unmodified, { x: o, y: s } = this.point;
                let r = 0, a = o, n = s;
                const l = this.width / 2, c = this.height / 2, h = this.worldMinY * this.scale, u = this.worldMaxY * this.scale;
                if (s - c < h && (n = h + c), s + c > u && (n = u - c), u - h < this.height && (r = Math.max(r, this.height / (u - h)), n = (u + h) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                    const e = this.worldMinX * this.scale, t1 = this.worldMaxX * this.scale, i = this.worldSize / 2 - (e + t1) / 2;
                    a = (o + i + this.worldSize) % this.worldSize - i, a - l < e && (a = e + l), a + l > t1 && (a = t1 - l), t1 - e < this.width && (r = Math.max(r, this.width / (t1 - e)), a = (t1 + e) / 2);
                }
                a === o && n === s || (this.center = this.unproject(new e.P(a, n))), r && (this.zoom += this.scaleZoom(r)), this._constrainCamera(), this._unmodified = i, this._constraining = !1;
            }
            _minZoomForBounds() {
                let e = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
                return this.maxBounds && (e = Math.max(e, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e;
            }
            _maxCameraBoundsDistance() {
                return this._mercatorZfromZoom(this._minZoomForBounds());
            }
            _calcMatrices() {
                if (!this.height) return;
                const t1 = this.centerOffset, i = "globe" === this.projection.name, o = this.pixelsPerMeter;
                "globe" === this.projection.name && (this._mercatorScaleRatio = e.bH(1, this.center.lat) / e.bH(1, e.c8));
                const s = e.b$(this.projection, this.zoom, this.width, this.height, 1024);
                this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, s), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
                const r = "meters" === this.projection.zAxisUnit ? o : 1, a = this._camera.getWorldToCamera(this.worldSize, r);
                let n;
                const l = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
                if (l[8] = 2 * -t1.x / this.width, l[9] = 2 * t1.y / this.height, this.isOrthographic) {
                    let e = .5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(.5 * this._fov), i = e * this.aspect, o = -i, s = -e;
                    i -= t1.x, o -= t1.x, e += t1.y, s += t1.y, n = this._camera.getCameraToClipOrthographic(o, i, s, e, this._nearZ, this._farZ), ((e, t1, i, o)=>{
                        for(let s = 0; s < 16; s++)e[s] = Xi(t1[s], i[s], o);
                    })(n, n, l, Ki(this.pitch >= 15 ? 1 : this.pitch / 15));
                } else n = l;
                const c = e.ab.mat4.mul([], l, a);
                let h = e.ab.mat4.mul([], n, a);
                if (this.projection.isReprojectedInTileSpace) {
                    const t1 = this.locationCoordinate(this.center), i = e.ab.mat4.identity([]);
                    e.ab.mat4.translate(i, i, [
                        t1.x * this.worldSize,
                        t1.y * this.worldSize,
                        0
                    ]), e.ab.mat4.multiply(i, i, e.c0(this)), e.ab.mat4.translate(i, i, [
                        -t1.x * this.worldSize,
                        -t1.y * this.worldSize,
                        0
                    ]), e.ab.mat4.multiply(h, h, i), e.ab.mat4.multiply(c, c, i), this.inverseAdjustmentMatrix = e.c1(this);
                } else this.inverseAdjustmentMatrix = [
                    1,
                    0,
                    0,
                    1
                ];
                if (this.mercatorMatrix = e.ab.mat4.scale([], h, [
                    this.worldSize,
                    this.worldSize,
                    this.worldSize / r,
                    1
                ]), this.projMatrix = h, this.invProjMatrix = e.ab.mat4.invert(new Float64Array(16), this.projMatrix), i) {
                    const i = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
                    i[8] = 2 * -t1.x / this.width, i[9] = 2 * t1.y / this.height, this.expandedFarZProjMatrix = e.ab.mat4.mul([], i, a);
                } else this.expandedFarZProjMatrix = this.projMatrix;
                const u = e.ab.mat4.invert([], n);
                this.frustumCorners = e.c2.fromInvProjectionMatrix(u, this.horizonLineFromTop(), this.height), this.cameraFrustum = e.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i);
                const d = new Float32Array(16);
                e.ab.mat4.identity(d), e.ab.mat4.scale(d, d, [
                    1,
                    -1,
                    1
                ]), e.ab.mat4.rotateX(d, d, this._pitch), e.ab.mat4.rotateZ(d, d, this.angle);
                const _ = e.ab.mat4.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
                this.starsProjMatrix = e.ab.mat4.clone(_);
                const p = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
                _[8] = 2 * -t1.x / this.width, _[9] = 2 * (t1.y + p) / this.height, this.skyboxMatrix = e.ab.mat4.multiply(d, _, d);
                const f = this.point, m = f.x, g = f.y, v = this.width % 2 / 2, y = this.height % 2 / 2, x = Math.cos(this.angle), b = Math.sin(this.angle), w = m - Math.round(m) + x * v + b * y, T = g - Math.round(g) + x * y + b * v, E = new Float64Array(h);
                if (e.ab.mat4.translate(E, E, [
                    w > .5 ? w - 1 : w,
                    T > .5 ? T - 1 : T,
                    0
                ]), this.alignedProjMatrix = E, h = e.ab.mat4.create(), e.ab.mat4.scale(h, h, [
                    this.width / 2,
                    -this.height / 2,
                    1
                ]), e.ab.mat4.translate(h, h, [
                    1,
                    -1,
                    0
                ]), this.labelPlaneMatrix = h, h = e.ab.mat4.create(), e.ab.mat4.scale(h, h, [
                    1,
                    -1,
                    1
                ]), e.ab.mat4.translate(h, h, [
                    -1,
                    -1,
                    0
                ]), e.ab.mat4.scale(h, h, [
                    2 / this.width,
                    2 / this.height,
                    1
                ]), this.glCoordMatrix = h, this.pixelMatrix = e.ab.mat4.multiply(new Float64Array(16), this.labelPlaneMatrix, c), this._calcFogMatrices(), this._distanceTileDataCache = {}, h = e.ab.mat4.invert(new Float64Array(16), this.pixelMatrix), !h) throw new Error("failed to invert matrix");
                if (this.pixelMatrixInverse = h, "globe" === this.projection.name || this.mercatorFromTransition) {
                    this.globeMatrix = e.c3(this);
                    const t1 = [
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14]
                    ];
                    this.globeCenterInViewSpace = e.ab.vec3.transformMat4(t1, t1, a), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
                } else this.globeMatrix = h;
                this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
            }
            _calcFogMatrices() {
                this._fogTileMatrixCache = {};
                const t1 = this.cameraWorldSizeForFog, i = this.cameraPixelsPerMeter, o = this._camera.position, s = 1 / this.height / this._pixelsPerMercatorPixel, r = [
                    t1,
                    t1,
                    i
                ];
                e.ab.vec3.scale(r, r, s), e.ab.vec3.scale(o, o, -1), e.ab.vec3.multiply(o, o, r);
                const a = e.ab.mat4.create();
                e.ab.mat4.translate(a, a, o), e.ab.mat4.scale(a, a, r), this.mercatorFogMatrix = a, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t1, i, s);
            }
            _computeCameraPosition(e) {
                const t1 = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter, i = this._camera.forward(), o = this.point, s = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t1 - e / this.worldSize * this._centerAltitude;
                return [
                    o.x / this.worldSize - i[0] * s,
                    o.y / this.worldSize - i[1] * s,
                    e / this.worldSize * this._centerAltitude - i[2] * s
                ];
            }
            _updateCameraState() {
                this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
            }
            _translateCameraConstrained(t1) {
                const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o = this._camera.position[2], s = t1[2];
                let r = 1;
                this.projection.wrap && (this.center = this.center.wrap()), s > 0 && (r = Math.min((i - o) / s, 1)), this._camera.position = e.ab.vec3.scaleAndAdd([], this._camera.position, t1, r), this._updateStateFromCamera();
            }
            _updateStateFromCamera() {
                const t1 = this._camera.position, i = this._camera.forward(), { pitch: o, bearing: s } = this._camera.getPitchBearing(), r = e.bH(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, a = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.ai(this._maxPitch)), n = Math.max((t1[2] - r) / Math.cos(o), a), l = this._zoomFromMercatorZ(n);
                e.ab.vec3.scaleAndAdd(t1, t1, i, n), this._pitch = e.aw(o, e.ai(this.minPitch), e.ai(this.maxPitch)), this.angle = e.bF(s, -Math.PI, Math.PI), this._setZoom(e.aw(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.aa(t1[0], t1[1], t1[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();
            }
            _worldSizeFromZoom(e) {
                return Math.pow(2, e) * this.tileSize;
            }
            _mercatorZfromZoom(e) {
                return this.cameraToCenterDistance / this._worldSizeFromZoom(e);
            }
            _minimumHeightOverTerrain() {
                const e = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
                return this._mercatorZfromZoom(e);
            }
            _zoomFromMercatorZ(e) {
                return this.scaleZoom(this.cameraToCenterDistance / (e * this.tileSize));
            }
            zoomFromMercatorZAdjusted(t1) {
                let i = 0, o = e.bY, s = 0, r = 1 / 0;
                for(; o - i > 1e-6 && o > i;){
                    const e = i + .5 * (o - i), a = this.tileSize * Math.pow(2, e), n = this.getCameraToCenterDistance(this.projection, e, a), l = this.scaleZoom(n / (t1 * this.tileSize)), c = Math.abs(e - l);
                    c < r && (r = c, s = e), e < l ? i = e : o = e;
                }
                return s;
            }
            _terrainEnabled() {
                return !(!this._elevation || !this.projection.supportsTerrain && (e.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
            }
            anyCornerOffEdge(t1, i) {
                const o = Math.min(t1.x, i.x), s = Math.max(t1.x, i.x), r = Math.min(t1.y, i.y), a = Math.max(t1.y, i.y);
                if (r < this.horizonLineFromTop(!1)) return !0;
                if ("mercator" !== this.projection.name) return !1;
                const n = [
                    new e.P(o, r),
                    new e.P(s, a),
                    new e.P(o, a),
                    new e.P(s, r)
                ], l = this.renderWorldCopies ? -3 : 0, c = this.renderWorldCopies ? 4 : 1;
                for (const e of n){
                    const t1 = this.pointRayIntersection(e);
                    if (t1.t < 0) return !0;
                    const i = this.rayIntersectionCoordinate(t1);
                    if (i.x < l || i.y < 0 || i.x > c || i.y > 1) return !0;
                }
                return !1;
            }
            isHorizonVisible() {
                return this.pitch + e.c4(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.P(0, 0), new e.P(this.width, this.height));
            }
            zoomDeltaToMovement(t1, i) {
                const o = e.ab.vec3.length(e.ab.vec3.sub([], this._camera.position, t1)), s = this._zoomFromMercatorZ(o) + i;
                return o - this._mercatorZfromZoom(s);
            }
            getCameraPoint() {
                if ("globe" === this.projection.name) {
                    const t1 = function([t1, i, o], s) {
                        const r = [
                            t1,
                            i,
                            o,
                            1
                        ];
                        e.ab.vec4.transformMat4(r, r, s);
                        const a = r[3] = Math.max(r[3], 1e-6);
                        return r[0] /= a, r[1] /= a, r[2] /= a, r;
                    }([
                        this.globeMatrix[12],
                        this.globeMatrix[13],
                        this.globeMatrix[14]
                    ], this.pixelMatrix);
                    return new e.P(t1[0], t1[1]);
                }
                {
                    const t1 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                    return this.centerPoint.add(new e.P(0, t1));
                }
            }
            getCameraToCenterDistance(t1, i = this.zoom, o = this.worldSize) {
                const s = e.b$(t1, i, this.width, this.height, 1024), r = t1.pixelSpaceConversion(this.center.lat, o, s);
                let a = .5 / Math.tan(.5 * this._fov) * this.height * r;
                return this.isOrthographic && (a = Xi(1, a, Ki(this.pitch >= 15 ? 1 : this.pitch / 15))), a;
            }
            getWorldToCameraMatrix() {
                const t1 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
                return "globe" === this.projection.name && e.ab.mat4.multiply(t1, t1, this.globeMatrix), t1;
            }
            getFrustum(t1) {
                return e.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t1, "meters" === this.projection.zAxisUnit);
            }
        }
        const Ji = (t1, i)=>{
            if (i > 0 && t1.terrain && e.w("Cutoff is currently disabled on terrain"), i <= 0 || t1.terrain) return {
                shouldRenderCutoff: !1,
                uniformValues: {
                    u_cutoff_params: [
                        0,
                        0,
                        0,
                        1
                    ]
                }
            };
            const o = t1.transform, s = Math.max(Math.abs(o._zoom - (t1.minCutoffZoom - 1)), 1), r = o.isLODDisabled(!1) ? e.ac(60, 45, o.pitch) : e.ac(30, 15, o.pitch), a = o._farZ - o._nearZ, n = i * o.height, l = ((1 - (c = r)) * o.cameraToCenterDistance + c * (o._farZ + n)) * s;
            var c;
            return {
                shouldRenderCutoff: r < 1,
                uniformValues: {
                    u_cutoff_params: [
                        o._nearZ,
                        o._farZ,
                        (l - o._nearZ) / a,
                        (l - n - o._nearZ) / a
                    ]
                }
            };
        }, Qi = {
            cascadeCount: 2,
            normalOffset: 3,
            shadowMapResolution: 2048
        };
        class eo {
            constructor(e, t1){
                this.aabb = e, this.lastCascade = t1;
            }
        }
        class to {
            add(e, t1) {
                const i = this.receivers[e.key];
                void 0 !== i ? (i.aabb.min[0] = Math.min(i.aabb.min[0], t1.min[0]), i.aabb.min[1] = Math.min(i.aabb.min[1], t1.min[1]), i.aabb.min[2] = Math.min(i.aabb.min[2], t1.min[2]), i.aabb.max[0] = Math.max(i.aabb.max[0], t1.max[0]), i.aabb.max[1] = Math.max(i.aabb.max[1], t1.max[1]), i.aabb.max[2] = Math.max(i.aabb.max[2], t1.max[2])) : this.receivers[e.key] = new eo(t1, null);
            }
            clear() {
                this.receivers = {};
            }
            get(e) {
                return this.receivers[e.key];
            }
            computeRequiredCascades(t1, i, o) {
                const s = e.cd.fromPoints(t1.points);
                let r = 0;
                for(const t1 in this.receivers){
                    const a = this.receivers[t1];
                    if (!a) continue;
                    if (!s.intersectsAabb(a.aabb)) continue;
                    a.aabb.min = s.closestPoint(a.aabb.min), a.aabb.max = s.closestPoint(a.aabb.max);
                    const n = a.aabb.getCorners();
                    for(let t1 = 0; t1 < o.length; t1++){
                        let s = !0;
                        for (const r of n){
                            const a = [
                                r[0] * i,
                                r[1] * i,
                                r[2]
                            ];
                            if (e.ab.vec3.transformMat4(a, a, o[t1].matrix), a[0] < -1 || a[0] > 1 || a[1] < -1 || a[1] > 1) {
                                s = !1;
                                break;
                            }
                        }
                        if (a.lastCascade = t1, r = Math.max(r, t1), s) break;
                    }
                }
                return r + 1;
            }
        }
        class io {
            constructor(e){
                this.painter = e, this._enabled = !1, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new to, this._depthMode = new Fi(e.context.gl.LEQUAL, Fi.ReadWrite, [
                    0,
                    1
                ]), this._uniformValues = {
                    u_light_matrix_0: new Float32Array(16),
                    u_light_matrix_1: new Float32Array(16),
                    u_shadow_intensity: 0,
                    u_fade_range: [
                        0,
                        0
                    ],
                    u_shadow_normal_offset: [
                        1,
                        1,
                        1
                    ],
                    u_shadow_texel_size: 1,
                    u_shadow_map_resolution: 1,
                    u_shadow_direction: [
                        0,
                        0,
                        1
                    ],
                    u_shadow_bias: [
                        36e-5,
                        .0012,
                        .012
                    ],
                    u_shadowmap_0: 0,
                    u_shadowmap_1: 0
                }, this._forceDisable = !1, this.useNormalOffset = !1, e.tp.registerParameter(this, [
                    "Shadows"
                ], "_forceDisable", {
                    label: "forceDisable"
                }, ()=>{
                    this.painter.style.map.triggerRepaint();
                }), e.tp.registerParameter(Qi, [
                    "Shadows"
                ], "cascadeCount", {
                    min: 1,
                    max: 2,
                    step: 1
                }), e.tp.registerParameter(Qi, [
                    "Shadows"
                ], "normalOffset", {
                    min: 0,
                    max: 10,
                    step: .05
                }), e.tp.registerParameter(Qi, [
                    "Shadows"
                ], "shadowMapResolution", {
                    min: 32,
                    max: 2048,
                    step: 32
                }), e.tp.registerBinding(this, [
                    "Shadows"
                ], "_numCascadesToRender", {
                    readonly: !0,
                    label: "numCascadesToRender"
                });
            }
            destroy() {
                for (const e of this._cascades)e.texture.destroy(), e.framebuffer.destroy();
                this._cascades = [];
            }
            updateShadowParameters(t1, i) {
                const o = this.painter;
                if (this._enabled = !1, this._shadowLayerCount = 0, this._receivers.clear(), !i || !i.properties) return;
                const s = i.properties.get("shadow-intensity");
                if (!i.shadowsEnabled() || s <= 0) return;
                if (this._shadowLayerCount = o.style.order.reduce((e, i)=>{
                    const s = o.style._mergedLayers[i];
                    return e + (s.hasShadowPass() && !s.isHidden(t1.zoom) ? 1 : 0);
                }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled) return;
                const r = o.context, a = Qi.shadowMapResolution, n = Qi.shadowMapResolution;
                if (0 === this._cascades.length || Qi.shadowMapResolution !== this._cascades[0].texture.size[0]) {
                    this._cascades = [];
                    for(let t1 = 0; t1 < Qi.cascadeCount; ++t1){
                        const t1 = o._shadowMapDebug, i = r.gl, s = r.createFramebuffer(a, n, t1, "texture"), l = new e.T(r, {
                            width: a,
                            height: n,
                            data: null
                        }, i.DEPTH_COMPONENT16);
                        if (s.depthAttachment.set(l.texture), t1) {
                            const t1 = new e.T(r, {
                                width: a,
                                height: n,
                                data: null
                            }, i.RGBA8);
                            s.colorAttachment.set(t1.texture);
                        }
                        this._cascades.push({
                            framebuffer: s,
                            texture: l,
                            matrix: [],
                            far: 0,
                            boundingSphereRadius: 0,
                            frustum: new e.bR,
                            scale: 0
                        });
                    }
                }
                this.shadowDirection = so(i);
                let l = 0;
                if (t1.elevation) {
                    const e = t1.elevation, i = [
                        1e4,
                        -1e4
                    ];
                    e.visibleDemTiles.filter((e)=>e.dem).forEach((e)=>{
                        const t1 = e.dem.tree;
                        i[0] = Math.min(i[0], t1.minimums[0]), i[1] = Math.max(i[1], t1.maximums[0]);
                    }), 1e4 !== i[0] && (l = (i[1] - i[0]) * e.exaggeration());
                }
                const c = 1.5 * t1.cameraToCenterDistance, h = 3 * c, u = new Float64Array(16);
                for(let i = 0; i < this._cascades.length; ++i){
                    const o = this._cascades[i];
                    let s = t1.height / 50, r = 1;
                    1 === Qi.cascadeCount ? r = h : 0 === i ? r = c : (s = c, r = h);
                    const [a, n] = ao(t1, this.shadowDirection, s, r, Qi.shadowMapResolution, l);
                    o.scale = t1.scale, o.matrix = a, o.boundingSphereRadius = n, e.ab.mat4.invert(u, o.matrix), o.frustum = e.bR.fromInvProjectionMatrix(u, 1, 0, !0), o.far = r;
                }
                const d = this._cascades.length - 1;
                this._uniformValues.u_fade_range = [
                    .75 * this._cascades[d].far,
                    this._cascades[d].far
                ], this._uniformValues.u_shadow_intensity = s, this._uniformValues.u_shadow_direction = [
                    this.shadowDirection[0],
                    this.shadowDirection[1],
                    this.shadowDirection[2]
                ], this._uniformValues.u_shadow_texel_size = 1 / Qi.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = Qi.shadowMapResolution, this._uniformValues.u_shadowmap_0 = Wi.ShadowMap0, this._uniformValues.u_shadowmap_1 = Wi.ShadowMap0 + 1, this._groundShadowTiles = o.transform.coveringTiles({
                    tileSize: 512,
                    renderWorldCopies: !0
                });
                const _ = o.transform.elevation;
                for (const e of this._groundShadowTiles){
                    let t1 = {
                        min: 0,
                        max: 0
                    };
                    if (_) {
                        const i = _.getMinMaxForTile(e);
                        i && (t1 = i);
                    }
                    this.addShadowReceiver(e.toUnwrapped(), t1.min, t1.max);
                }
            }
            get enabled() {
                return this._enabled && !this._forceDisable;
            }
            set enabled(e) {
                this._enabled = e;
            }
            drawShadowPass(t1, i) {
                if (!this.enabled) return;
                const o = this.painter, s = o.context;
                this._numCascadesToRender = this._receivers.computeRequiredCascades(o.transform.getFrustum(0), o.transform.worldSize, this._cascades), s.viewport.set([
                    0,
                    0,
                    Qi.shadowMapResolution,
                    Qi.shadowMapResolution
                ]);
                for(let r = 0; r < this._numCascadesToRender; ++r){
                    o.currentShadowCascade = r, s.bindFramebuffer.set(this._cascades[r].framebuffer.framebuffer), s.clear({
                        color: e.aj.white,
                        depth: 1
                    });
                    for (const e of t1.order){
                        const s = t1._mergedLayers[e];
                        if (!s.hasShadowPass() || s.isHidden(o.transform.zoom)) continue;
                        const r = t1.getLayerSourceCache(s), a = r ? i[r.id] : void 0;
                        ("model" === s.type || a && a.length) && o.renderLayer(o, r, s, a);
                    }
                }
                o.currentShadowCascade = 0;
            }
            drawGroundShadows() {
                if (!this.enabled) return;
                const e = this.painter, t1 = e.style, i = e.context, o = t1.directionalLight, s = t1.ambientLight;
                if (!o || !s) return;
                const r = [], a = Ji(e, e.longestCutoffRange);
                a.shouldRenderCutoff && r.push("RENDER_CUTOFF"), r.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), this.useNormalOffset && r.push("NORMAL_OFFSET");
                const n = ro(t1, o, s), l = new Fi(i.gl.LEQUAL, Fi.ReadOnly, e.depthRangeFor3D);
                for (const t1 of this._groundShadowTiles){
                    const o = t1.toUnwrapped(), s = e.isTileAffectedByFog(t1), c = e.getOrCreateProgram("groundShadow", {
                        defines: r,
                        overrideFog: s
                    });
                    this.setupShadows(o, c), e.uploadCommonUniforms(i, c, o, null, a);
                    const h = {
                        u_matrix: e.transform.calculateProjMatrix(o),
                        u_ground_shadow_factor: n
                    };
                    c.draw(e, i.gl.TRIANGLES, l, Bi.disabled, Oi.multiply, Gi.disabled, h, "ground_shadow", e.tileExtentBuffer, e.quadTriangleIndexBuffer, e.tileExtentSegments, {}, e.transform.zoom, null, null);
                }
            }
            getShadowPassColorMode() {
                return this.painter._shadowMapDebug ? Oi.unblended : Oi.disabled;
            }
            getShadowPassDepthMode() {
                return this._depthMode;
            }
            getShadowCastingLayerCount() {
                return this._shadowLayerCount;
            }
            calculateShadowPassMatrixFromTile(t1) {
                const i = this.painter.transform, o = i.calculatePosMatrix(t1, i.worldSize);
                return e.ab.mat4.multiply(o, this._cascades[this.painter.currentShadowCascade].matrix, o), Float32Array.from(o);
            }
            calculateShadowPassMatrixFromMatrix(t1) {
                return e.ab.mat4.multiply(t1, this._cascades[this.painter.currentShadowCascade].matrix, t1), Float32Array.from(t1);
            }
            setupShadows(t1, i, o, s = 0) {
                if (!this.enabled) return;
                const r = this.painter.transform, a = this.painter.context, n = a.gl, l = this._uniformValues, c = new Float64Array(16), h = r.calculatePosMatrix(t1, r.worldSize);
                for(let t1 = 0; t1 < this._cascades.length; t1++)e.ab.mat4.multiply(c, this._cascades[t1].matrix, h), l[0 === t1 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(c), a.activeTexture.set(n.TEXTURE0 + Wi.ShadowMap0 + t1), this._cascades[t1].texture.bind(n.NEAREST, n.CLAMP_TO_EDGE);
                if (this.useNormalOffset = !!o, this.useNormalOffset) {
                    const i = e.cc(t1.canonical), a = 2 / r.tileSize * e.ag / Qi.shadowMapResolution, n = a * this._cascades[0].boundingSphereRadius, c = a * this._cascades[this._cascades.length - 1].boundingSphereRadius, h = ("vector-tile" === o ? 1 : 3) / Math.pow(2, s - t1.canonical.z - (1 - r.zoom + Math.floor(r.zoom)));
                    l.u_shadow_normal_offset = [
                        i,
                        n * h,
                        c * h
                    ], l.u_shadow_bias = [
                        6e-5,
                        .0012,
                        .012
                    ];
                } else l.u_shadow_bias = [
                    36e-5,
                    .0012,
                    .012
                ];
                i.setShadowUniformValues(a, l);
            }
            setupShadowsFromMatrix(t1, i, o = !1) {
                if (!this.enabled) return;
                const s = this.painter.context, r = s.gl, a = this._uniformValues, n = new Float64Array(16);
                for(let i = 0; i < Qi.cascadeCount; i++)e.ab.mat4.multiply(n, this._cascades[i].matrix, t1), a[0 === i ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(n), s.activeTexture.set(r.TEXTURE0 + Wi.ShadowMap0 + i), this._cascades[i].texture.bind(r.NEAREST, r.CLAMP_TO_EDGE);
                if (this.useNormalOffset = o, o) {
                    const e = Qi.normalOffset;
                    a.u_shadow_normal_offset = [
                        1,
                        e,
                        e
                    ], a.u_shadow_bias = [
                        6e-5,
                        .0012,
                        .012
                    ];
                } else a.u_shadow_bias = [
                    36e-5,
                    .0012,
                    .012
                ];
                i.setShadowUniformValues(s, a);
            }
            getShadowUniformValues() {
                return this._uniformValues;
            }
            getCurrentCascadeFrustum() {
                return this._cascades[this.painter.currentShadowCascade].frustum;
            }
            computeSimplifiedTileShadowVolume(t1, i, o, s) {
                if (s[2] >= 0) return {};
                const r = (function(t1, i, o) {
                    const s = o / (1 << t1.canonical.z);
                    return new e.cd([
                        t1.canonical.x * s + t1.wrap * o,
                        t1.canonical.y * s + t1.wrap * o,
                        0
                    ], [
                        (t1.canonical.x + 1) * s + t1.wrap * o,
                        (t1.canonical.y + 1) * s + t1.wrap * o,
                        i
                    ]);
                })(t1, i, o).getCorners(), a = i / -s[2];
                s[0] < 0 ? (e.ab.vec3.add(r[0], r[0], [
                    s[0] * a,
                    0,
                    0
                ]), e.ab.vec3.add(r[3], r[3], [
                    s[0] * a,
                    0,
                    0
                ])) : s[0] > 0 && (e.ab.vec3.add(r[1], r[1], [
                    s[0] * a,
                    0,
                    0
                ]), e.ab.vec3.add(r[2], r[2], [
                    s[0] * a,
                    0,
                    0
                ])), s[1] < 0 ? (e.ab.vec3.add(r[0], r[0], [
                    0,
                    s[1] * a,
                    0
                ]), e.ab.vec3.add(r[1], r[1], [
                    0,
                    s[1] * a,
                    0
                ])) : s[1] > 0 && (e.ab.vec3.add(r[2], r[2], [
                    0,
                    s[1] * a,
                    0
                ]), e.ab.vec3.add(r[3], r[3], [
                    0,
                    s[1] * a,
                    0
                ]));
                const n = {};
                return n.vertices = r, n.planes = [
                    oo(r[1], r[0], r[4]),
                    oo(r[2], r[1], r[5]),
                    oo(r[3], r[2], r[6]),
                    oo(r[0], r[3], r[7])
                ], n;
            }
            addShadowReceiver(t1, i, o) {
                this._receivers.add(t1, e.cd.fromTileIdAndHeight(t1, i, o));
            }
            getMaxCascadeForTile(e) {
                const t1 = this._receivers.get(e);
                return t1 && t1.lastCascade ? t1.lastCascade : 0;
            }
        }
        function oo(t1, i, o) {
            const s = e.ab.vec3.sub([], o, i), r = e.ab.vec3.sub([], t1, i), a = e.ab.vec3.cross([], s, r), n = e.ab.vec3.length(a);
            return 0 === n ? [
                0,
                0,
                1,
                0
            ] : (e.ab.vec3.scale(a, a, 1 / n), [
                a[0],
                a[1],
                a[2],
                -e.ab.vec3.dot(a, i)
            ]);
        }
        function so(t1) {
            const i = t1.properties.get("direction"), o = e.cb(i.x, i.y, i.z);
            o[2] = e.aw(o[2], 0, 75);
            const s = e.ce([
                o[0],
                o[1],
                o[2]
            ]);
            return e.ab.vec3.fromValues(s.x, s.y, s.z);
        }
        function ro(t1, i, o) {
            const s = "none" === i.properties.get("color-use-theme"), r = i.properties.get("color"), a = i.properties.get("intensity"), n = i.properties.get("direction"), l = [
                n.x,
                n.y,
                n.z
            ], c = "none" === o.properties.get("color-use-theme"), h = o.properties.get("color"), u = o.properties.get("intensity"), d = Math.max(e.ab.vec3.dot([
                0,
                0,
                1
            ], l), 0), _ = [
                0,
                0,
                0
            ];
            e.ab.vec3.scale(_, h.toRenderColor(c ? null : t1.getLut(i.scope)).toArray01Linear().slice(0, 3), u);
            const p = [
                0,
                0,
                0
            ];
            return e.ab.vec3.scale(p, r.toRenderColor(s ? null : t1.getLut(o.scope)).toArray01Linear().slice(0, 3), d * a), e.cf([
                _[0] > 0 ? _[0] / (_[0] + p[0]) : 0,
                _[1] > 0 ? _[1] / (_[1] + p[1]) : 0,
                _[2] > 0 ? _[2] / (_[2] + p[2]) : 0
            ]);
        }
        function ao(t1, i, o, s, r, a) {
            const n = t1.zoom, l = t1.scale, c = t1.worldSize, h = 1 / c, u = t1.aspect, d = Math.sqrt(1 + u * u) * Math.tan(.5 * t1.fovX), _ = d * d, p = s - o, f = s + o;
            let m, g;
            _ > p / f ? (m = s, g = s * d) : (m = .5 * f * (1 + _), g = .5 * Math.sqrt(p * p + 2 * (s * s + o * o) * _ + f * f * _ * _));
            const v = t1.projection.pixelsPerMeter(t1.center.lat, c), y = t1._camera.getCameraToWorldMercator(), x = [
                0,
                0,
                -m * h
            ];
            e.ab.vec3.transformMat4(x, x, y);
            let b = g * h;
            const w = t1._edgeInsets;
            if (!(0 === w.left && 0 === w.top && 0 === w.right && 0 === w.bottom || w.left === w.right && w.top === w.bottom)) {
                const i = t1._camera.getWorldToCamera(t1.worldSize, "meters" === t1.projection.zAxisUnit ? v : 1), r = t1._camera.getCameraToClipPerspective(t1._fov, t1.width / t1.height, o, s);
                r[8] = 2 * -t1.centerOffset.x / t1.width, r[9] = 2 * t1.centerOffset.y / t1.height;
                const a = new Float64Array(16);
                e.ab.mat4.mul(a, r, i);
                const h = new Float64Array(16);
                e.ab.mat4.invert(h, a);
                const u = e.bR.fromInvProjectionMatrix(h, c, n, !0);
                for (const i of u.points){
                    const o = ((T = i)[0] /= l, T[1] /= l, T[2] = e.bH(T[2], t1._center.lat), T);
                    b = Math.max(b, e.ab.vec3.len(e.ab.vec3.subtract([], x, o)));
                }
            }
            var T;
            b *= r / (r - 1);
            const E = Math.acos(i[2]), S = Math.atan2(-i[0], -i[1]), C = new Zi;
            C.position = x, C.setPitchBearing(E, S);
            const I = C.getWorldToCamera(c, v), R = b * c, D = Math.min(t1._mercatorZfromZoom(17) * c * -2, -2 * R), L = C.getCameraToClipOrthographic(-R, R, -R, R, D, (R + a * v) / i[2]), A = new Float64Array(16);
            e.ab.mat4.multiply(A, L, I);
            const z = e.ab.vec3.fromValues(Math.floor(1e6 * x[0]) / 1e6 * c, Math.floor(1e6 * x[1]) / 1e6 * c, 0), P = .5 * r, M = [
                0,
                0,
                0
            ];
            e.ab.vec3.transformMat4(M, z, A), e.ab.vec3.scale(M, M, P);
            const O = [
                Math.floor(M[0]),
                Math.floor(M[1]),
                Math.floor(M[2])
            ], F = [
                0,
                0,
                0
            ];
            e.ab.vec3.sub(F, M, O), e.ab.vec3.scale(F, F, -1 / P);
            const k = new Float64Array(16);
            return e.ab.mat4.identity(k), e.ab.mat4.translate(k, k, F), e.ab.mat4.multiply(A, k, A), [
                A,
                R
            ];
        }
        class no extends e.E {
            constructor(e){
                super(), this.requestManager = e, this.models = {
                    "": {}
                }, this.numModelsLoading = {};
            }
            loadModel(t1, i) {
                return e.aM(this.requestManager.transformRequest(i, e.R.Model).url).then((i)=>{
                    if (!i) return;
                    const o = e.aN(i), s = new e.aO(t1, void 0, void 0, o);
                    return s.computeBoundsAndApplyParent(), s;
                }).catch((o)=>{
                    if (o && 404 === o.status) return null;
                    this.fire(new e.y(new Error(`Could not load model ${t1} from ${i}: ${o.message}`)));
                });
            }
            load(t1, i) {
                this.models[i] || (this.models[i] = {});
                const o = Object.keys(t1);
                this.numModelsLoading[i] = (this.numModelsLoading[i] || 0) + o.length;
                const s = [];
                for (const e of o)s.push(this.loadModel(e, t1[e]));
                Promise.allSettled(s).then((t1)=>{
                    for(let e = 0; e < t1.length; e++){
                        const { status: s, value: r } = t1[e];
                        "fulfilled" === s && r && (this.models[i][o[e]] = {
                            model: r,
                            numReferences: 1
                        });
                    }
                    this.numModelsLoading[i] -= o.length, this.fire(new e.z("data", {
                        dataType: "style"
                    }));
                }).catch((t1)=>{
                    this.fire(new e.y(new Error(`Could not load models: ${t1.message}`)));
                });
            }
            isLoaded() {
                for(const e in this.numModelsLoading)if (this.numModelsLoading[e] > 0) return !1;
                return !0;
            }
            hasModel(e, t1) {
                return !!this.getModel(e, t1);
            }
            getModel(e, t1) {
                return this.models[t1] || (this.models[t1] = {}), this.models[t1][e] ? this.models[t1][e].model : void 0;
            }
            addModel(e, t1, i) {
                this.models[i] || (this.models[i] = {}), this.hasModel(e, i) && this.models[i][e].numReferences++, this.load({
                    [e]: this.requestManager.normalizeModelURL(t1)
                }, i);
            }
            addModels(e, t1) {
                this.models[t1] || (this.models[t1] = {});
                const i = {};
                for(const o in e)this.models[t1][o] = {}, i[o] = this.requestManager.normalizeModelURL(e[o]);
                this.load(i, t1);
            }
            addModelsFromBucket(e, t1) {
                this.models[t1] || (this.models[t1] = {});
                const i = {};
                for (const o of e)this.hasModel(o, t1) ? this.models[t1][o].numReferences++ : i[o] = this.requestManager.normalizeModelURL(o);
                this.load(i, t1);
            }
            removeModel(e, t1) {
                if (this.models[t1] && this.models[t1][e] && (this.models[t1][e].numReferences--, 0 === this.models[t1][e].numReferences)) {
                    const i = this.models[t1][e].model;
                    delete this.models[t1][e], i.destroy();
                }
            }
            listModels(e) {
                return this.models[e] || (this.models[e] = {}), Object.keys(this.models[e]);
            }
            upload(e, t1) {
                this.models[t1] || (this.models[t1] = {});
                for(const i in this.models[t1])this.models[t1][i].model && this.models[t1][i].model.upload(e.context);
            }
        }
        const lo = new e.a5({
            data: new e.a6(e.a3.colorTheme.data)
        }), co = {
            "mbx-indoor-active-floorplans": {
                default: [
                    "literal",
                    []
                ]
            },
            "mbx-indoor-underground": {
                default: [
                    "literal",
                    !1
                ]
            },
            "mbx-indoor-loaded-levels": {
                default: [
                    "literal",
                    []
                ]
            },
            "mbx-indoor-level-height": {
                default: [
                    "literal",
                    {}
                ]
            },
            "mbx-indoor-level-base": {
                default: [
                    "literal",
                    {}
                ]
            },
            "mbx-indoor-level-selected": {
                default: [
                    "literal",
                    {}
                ]
            },
            "mbx-indoor-level-overlapped": {
                default: [
                    "literal",
                    {}
                ]
            }
        };
        function ho(e) {
            return e = e || {}, Object.assign(e, co);
        }
        class uo extends e.E {
            constructor(t1){
                super(), this.mergeFloors = !0, this._scope = void 0, this._queryFeatureSetId = void 0, this._buildingEntryFeatureSetId = void 0, this._selectedFloorplan = void 0, this._indoorData = void 0, this._selectedLevel = void 0, this._floorplanStates = {}, e.aP([
                    "_onLoad",
                    "_onMove",
                    "_checkFloorplanVisible"
                ], this), this._map = t1, this._checkFloorplanVisible(!0), this._map.on("load", this._onLoad), this._map.on("move", this._onMove);
            }
            destroy() {
                this._map.indoor.off("load", this._onLoad), this._map.indoor.off("move", this._onMove), this._map = void 0;
            }
            _onLoad() {
                this._map.style.forEachFragmentStyle((t1)=>{
                    t1.stylesheet.indoor && (this._queryFeatureSetId ? this.fire(new e.y(new Error("Multiple indoor map styles detected, simultaneous usage is not allowed currently."))) : (this._queryFeatureSetId = t1.stylesheet.indoor.floorplanFeaturesetId, this._buildingEntryFeatureSetId = t1.stylesheet.indoor.buildingFeaturesetId, this._scope = t1.scope));
                }), this._queryFeatureSetId && this._buildingEntryFeatureSetId && this._map.addInteraction("mbx-indoor-buildingclick", {
                    type: "click",
                    target: {
                        featuresetId: this._buildingEntryFeatureSetId,
                        importId: this._scope
                    },
                    handler: (e)=>(e.feature && e.feature.properties.floorplan && this.selectFloorplan(e.feature.properties.floorplan), !0)
                }), this._checkFloorplanVisible(!0);
            }
            _onMove() {
                this._checkFloorplanVisible(!1);
            }
            _checkFloorplanVisible(t1) {
                if (!this._queryFeatureSetId) return;
                if (!this._map.isStyleLoaded()) return;
                if (this._map.transform.zoom < 13) return;
                this._indoorData && !function(e, t1) {
                    const [i, o] = e, { center: s, radius: r } = t1, [a, n] = s, l = Math.abs(i - a);
                    return Math.sqrt((l > 180 ? 360 - l : l) ** 2 + (o - n) ** 2) <= r;
                }([
                    this._map.getCenter().lng,
                    this._map.getCenter().lat
                ], this._indoorData.circumCircle) && (this._indoorData = void 0, this._selectedFloorplan = void 0, this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !1), this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", [
                    "literal",
                    []
                ]), this.fire(new e.z("floorplangone")));
                const i = {
                    target: {
                        featuresetId: this._queryFeatureSetId,
                        importId: this._scope
                    }
                }, o = new e.P(this._map.transform.width / 2, this._map.transform.height / 2), s = [
                    new e.P(0, 0),
                    new e.P(this._map.transform.width, this._map.transform.height)
                ], r = this._map.queryRenderedFeatures(t1 ? s : o, i);
                r.length > 0 && (this._selectedFloorplan && r[0].properties.id === this._selectedFloorplan.properties.id || (this._selectedFloorplan = r[0], this._floorplanSelected(!1)));
            }
            _floorplanSelected(t1) {
                this._indoorData = JSON.parse(this._selectedFloorplan.properties["indoor-data"]), this._indoorData.id = this._selectedFloorplan.properties.id, this._indoorData.circumCircle = function(e) {
                    const [[t1, i], [o, s]] = e, r = (o - t1 + 360) % 360, a = r > 180 ? 360 - r : r;
                    return {
                        center: [
                            (t1 + a / 2 + 360) % 360,
                            (i + s) / 2
                        ],
                        radius: Math.sqrt(a ** 2 + (s - i) ** 2) / 2
                    };
                }(this._indoorData.extent), this._floorplanStates[this._indoorData.id] || (this._floorplanStates[this._indoorData.id] = {});
                const i = this._floorplanStates[this._indoorData.id].selectedBuilding, o = this._floorplanStates[this._indoorData.id].selectedLevel;
                let s;
                if (this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", this._indoorData.floorplanIDs), this._selectedLevel) for (const e of this._indoorData.levels)e.id === this._selectedLevel.id && (s = e.id);
                if (this.fire(new e.z("floorplanselected", {
                    buildings: this._indoorData.buildings,
                    levels: this._indoorData.levels,
                    selectedLevelId: s
                })), i) {
                    const e = this._indoorData.buildings.find((e)=>e.id === i);
                    this._buildingSelected(e, !1);
                } else this._indoorData.buildings.length > 0 && this._buildingSelected(this._indoorData.buildings[0], !1);
                if (o) {
                    const e = this._indoorData.levels.find((e)=>e.id === o);
                    this._updateLevels(e, t1);
                } else t1 && this._indoorData["default-levels"].length > 0 && this.selectLevel(this._indoorData["default-levels"][0]);
            }
            _buildingSelected(t1, i) {
                i && t1 && t1.extent && this._map.fitBounds(t1.extent, {
                    pitch: this._map.getPitch(),
                    bearing: this._map.getBearing()
                }), this._floorplanStates[this._indoorData.id].selectedBuilding = t1 ? t1.id : void 0;
                const o = this._indoorData.levels.filter((e)=>t1.levels.includes(e.id));
                this.fire(new e.z("buildingselected", {
                    buildingId: t1.id,
                    levels: o
                }));
            }
            _levelSelected(t1) {
                if ("overview" === t1) this._updateLevels(void 0, !0);
                else {
                    const e = this._indoorData.levels.find((e)=>e.id === t1);
                    this._updateLevels(e, !0);
                }
                this.fire(new e.z("levelselected", {
                    levelId: "overview" === t1 ? void 0 : t1
                }));
            }
            _updateLevels(e, t1) {
                if (!e) return this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", [
                    "literal",
                    []
                ]), this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !1), this._floorplanStates[this._indoorData.id].selectedLevel = void 0, void (t1 && this._indoorData.extent && this._map.fitBounds(this._indoorData.extent, {
                    pitch: this._map.getPitch(),
                    bearing: this._map.getBearing()
                }));
                function i(e) {
                    const t1 = e.indexOf("/floor/");
                    if (-1 === t1) return e;
                    const i = t1 + 7, o = e.indexOf("/", i);
                    return -1 === o ? e.slice(i) : e.slice(i, o);
                }
                this._selectedLevel = e, this._floorplanStates[this._indoorData.id].selectedLevel = e ? e.id : void 0;
                const o = [], s = {}, r = {}, a = {}, n = {};
                for (const t1 of this._indoorData.levels)if (o.push(t1.id), s[t1.id] = t1.height, r[t1.id] = t1.base, e) {
                    if (this.mergeFloors) {
                        const o = i(e.id), s = i(t1.id);
                        a[t1.id] = s === o ? "true" : "false";
                    } else a[t1.id] = t1.id === e.id ? "true" : "false";
                    n[t1.id] = t1.base < e.base ? "true" : "false";
                } else n[t1.id] = !0;
                if (this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", [
                    "literal",
                    o
                ]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-height", [
                    "literal",
                    s
                ]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-base", [
                    "literal",
                    r
                ]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-selected", [
                    "literal",
                    a
                ]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-overlapped", [
                    "literal",
                    n
                ]), e && (this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !!e.isUnderground), t1 && e.extent)) {
                    const t1 = this._map.cameraForBounds(e.extent, {
                        pitch: this._map.getPitch(),
                        bearing: this._map.getBearing()
                    }), i = this._map.getZoom(), o = t1.zoom ? Math.abs(i - t1.zoom) : 0;
                    this._map.fitBounds(e.extent, o >= 1 ? {
                        pitch: this._map.getPitch(),
                        bearing: this._map.getBearing()
                    } : {
                        pitch: this._map.getPitch(),
                        bearing: this._map.getBearing(),
                        zoom: i
                    });
                }
            }
            selectFloorplan(t1) {
                const i = {
                    target: {
                        featuresetId: this._queryFeatureSetId,
                        importId: this._scope
                    }
                }, o = [
                    new e.P(0, 0),
                    new e.P(this._map.transform.width, this._map.transform.height)
                ], s = this._map.queryRenderedFeatures(o, i);
                if (s.length > 0) {
                    for (const e of s)if (JSON.parse(e.properties["indoor-data"]).floorplanIDs.includes(t1)) {
                        this._selectedFloorplan = e, this._floorplanSelected(!0);
                        break;
                    }
                }
            }
            selectBuilding(e) {
                const t1 = this._indoorData.buildings.find((t1)=>t1.id === e);
                this._buildingSelected(t1, !0);
            }
            selectLevel(e) {
                this._levelSelected(e);
            }
        }
        function _o(t1) {
            if (!t1.metadata || !t1.metadata.content_area) return;
            const i = e.q.devicePixelRatio, { left: o, top: s, width: r, height: a } = t1.metadata.content_area, n = o * i, l = s * i;
            return [
                n,
                l,
                n + r * i,
                l + a * i
            ];
        }
        function po(t1) {
            if (t1) return t1.map(([t1, i])=>[
                    t1 * e.q.devicePixelRatio,
                    i * e.q.devicePixelRatio
                ]);
        }
        const fo = (e, t1)=>Le(e, t1 && t1.filter((e)=>"source.canvas" !== e.identifier)), mo = e.ay(Lt, [
            "addLayer",
            "removeLayer",
            "setLights",
            "setPaintProperty",
            "setLayoutProperty",
            "setSlot",
            "setFilter",
            "addSource",
            "removeSource",
            "setLayerZoomRange",
            "setLight",
            "setTransition",
            "setGeoJSONSourceData",
            "setTerrain",
            "setFog",
            "setSnow",
            "setRain",
            "setProjection",
            "setCamera",
            "addImport",
            "removeImport",
            "updateImport"
        ]), go = e.ay(Lt, [
            "setCenter",
            "setZoom",
            "setBearing",
            "setPitch"
        ]), vo = new Set([
            "background",
            "sky",
            "slot",
            "custom"
        ]), yo = {
            version: 8,
            layers: [],
            sources: {}
        }, xo = {
            duration: 300,
            delay: 0
        };
        class bo extends e.E {
            constructor(t1, i = {}){
                super(), this.map = t1, this.scope = i.scope || "", this.globalId = null, this.fragments = [], this.importDepth = i.importDepth || 0, this.importsCache = i.importsCache || new Map, this.resolvedImports = i.resolvedImports || new Set, this.transition = e.l({}, xo), this._buildingIndex = new It(this), this.crossTileSymbolIndex = new Pi, this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = !1, this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this._changes = i.styleChanges || new j, this.dispatcher = i.dispatcher ? i.dispatcher : new e.D(e.ci(), this), i.imageManager ? this.imageManager = i.imageManager : (this.imageManager = new q(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), this.glyphManager = i.glyphManager ? i.glyphManager : new e.cj(t1._requestManager, i.localFontFamily ? e.ck.all : i.localIdeographFontFamily ? e.ck.ideographs : e.ck.none, i.localFontFamily || i.localIdeographFontFamily), i.modelManager ? this.modelManager = i.modelManager : (this.modelManager = new no(t1._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._precompileDone = !1, this._shouldPrecompile = !1, this._availableImages = [], this._order = [], this._markersNeedUpdate = !1, this.options = i.configOptions ? i.configOptions : new Map, this._configDependentLayers = i.configDependentLayers ? i.configDependentLayers : new Set, this._config = i.config, this._styleColorTheme = {
                    lut: null,
                    lutLoading: !1,
                    lutLoadingCorrelationID: 0,
                    colorTheme: null,
                    colorThemeOverride: i.colorThemeOverride
                }, this._styleColorThemeForScope = {}, this._initialConfig = i.initialConfig, this.dispatcher.broadcast("setReferrer", e.cl());
                const o = this;
                this._rtlTextPluginCallback = bo.registerForPluginStateChange((t1)=>{
                    o.dispatcher.broadcast("syncRTLPluginState", {
                        pluginStatus: t1.pluginStatus,
                        pluginURL: t1.pluginURL
                    }, (t1, i)=>{
                        if (e.cm(t1), i && i.every((e)=>e)) for(const e in o._sourceCaches){
                            const t1 = o._sourceCaches[e], i = t1.getSource().type;
                            "vector" !== i && "geojson" !== i || t1.reload();
                        }
                    });
                }), this.on("data", (e)=>{
                    if ("source" !== e.dataType || "metadata" !== e.sourceDataType) return;
                    const t1 = this.getOwnSource(e.sourceId);
                    if (t1 && t1.vectorLayerIds) for(const e in this._layers){
                        const i = this._layers[e];
                        i.source === t1.id && this._validateLayer(i);
                    }
                });
            }
            load(e) {
                return e ? ("string" == typeof e ? this.loadURL(e) : this.loadJSON(e), this) : this;
            }
            _getGlobalId(t1) {
                if (!t1) return null;
                if ("string" == typeof t1) {
                    if (e.f(t1)) return t1;
                    const i = e.cn(t1);
                    if (!i.startsWith("http")) try {
                        return new URL(i, location.href).toString();
                    } catch (e) {
                        return i;
                    }
                    return i;
                }
                return `json://${e.co(JSON.stringify(t1))}`;
            }
            _diffStyle(t1, i, o) {
                this.globalId = this._getGlobalId(t1);
                const s = (e, t1)=>{
                    try {
                        t1(null, this.setState(e, o));
                    } catch (e) {
                        t1(e, !1);
                    }
                };
                if ("string" == typeof t1) {
                    const o = this.map._requestManager.normalizeStyleURL(t1), r = this.map._requestManager.transformRequest(o, e.R.Style);
                    e.n(r, (t1, o)=>{
                        t1 ? this.fire(new e.y(t1)) : o && s(o, i);
                    });
                } else "object" == typeof t1 && s(t1, i);
            }
            loadURL(t1, i = {}) {
                this.fire(new e.z("dataloading", {
                    dataType: "style"
                }));
                const o = "boolean" == typeof i.validate ? i.validate : !e.f(t1);
                this.globalId = this._getGlobalId(t1), t1 = this.map._requestManager.normalizeStyleURL(t1, i.accessToken), this.resolvedImports.add(t1);
                const s = this.importsCache.get(t1);
                if (s) return this._load(s, o);
                const r = this.map._requestManager.transformRequest(t1, e.R.Style);
                this._request = e.n(r, (i, s)=>{
                    if (this._request = null, i) this.fire(new e.y(i));
                    else if (s) return this.importsCache.set(t1, s), this._load(s, o);
                });
            }
            loadJSON(t1, i = {}) {
                this.fire(new e.z("dataloading", {
                    dataType: "style"
                })), this.globalId = this._getGlobalId(t1), this._request = e.q.frame(()=>{
                    this._request = null, this._load(t1, !1 !== i.validate);
                });
            }
            loadEmpty() {
                this.fire(new e.z("dataloading", {
                    dataType: "style"
                })), this._load(yo, !1);
            }
            _loadImports(t1, i, o) {
                if (this.importDepth >= 4) return e.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
                const s = [];
                for (const e of t1){
                    const t1 = this._createFragmentStyle(e), r = new Promise((e)=>{
                        t1.once("style.import.load", e), t1.once("error", e);
                    }).then(()=>this.mergeAll());
                    if (s.push(r), this.resolvedImports.has(e.url)) {
                        t1.loadEmpty();
                        continue;
                    }
                    const a = e.data || this.importsCache.get(e.url);
                    a ? (t1.loadJSON(a, {
                        validate: i
                    }), this._isInternalStyle(a) && (t1.globalId = null)) : e.url ? t1.loadURL(e.url, {
                        validate: i
                    }) : t1.loadEmpty();
                    const n = {
                        style: t1,
                        id: e.id,
                        config: e.config
                    };
                    if (o) {
                        const e = this.fragments.findIndex(({ id: e })=>e === o);
                        this.fragments = this.fragments.slice(0, e).concat(n).concat(this.fragments.slice(e));
                    } else this.fragments.push(n);
                }
                return Promise.allSettled(s);
            }
            getImportGlobalIds(e = this, t1 = new Set) {
                for (const i of e.fragments)i.style.globalId && t1.add(i.style.globalId), this.getImportGlobalIds(i.style, t1);
                return [
                    ...t1.values()
                ];
            }
            _createFragmentStyle(t1) {
                const i = this.scope ? e.aC(t1.id, this.scope) : t1.id;
                let o;
                const s = this._initialConfig && this._initialConfig[i];
                (t1.config || s) && (o = e.l({}, t1.config, s));
                const r = new bo(this.map, {
                    scope: i,
                    styleChanges: this._changes,
                    importDepth: this.importDepth + 1,
                    importsCache: this.importsCache,
                    resolvedImports: new Set(this.resolvedImports),
                    dispatcher: this.dispatcher,
                    imageManager: this.imageManager,
                    glyphManager: this.glyphManager,
                    modelManager: this.modelManager,
                    config: o,
                    configOptions: this.options,
                    colorThemeOverride: t1["color-theme"],
                    configDependentLayers: this._configDependentLayers
                });
                return r.setEventedParent(this.map, {
                    style: r
                }), r;
            }
            _reloadImports() {
                this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", {
                    layers: this._serializeLayers(this._order),
                    scope: this.scope,
                    options: this.options
                }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();
            }
            _isInternalStyle(e) {
                return this.isRootStyle() && (e.fragment || !!e.schema && !1 !== e.fragment);
            }
            _load(t1, i) {
                const o = t1.indoor ? ho(t1.schema) : t1.schema;
                if (this._isInternalStyle(t1)) {
                    const o = e.l({}, yo, {
                        imports: [
                            {
                                id: "basemap",
                                data: t1,
                                url: ""
                            }
                        ]
                    });
                    return void this._load(o, i);
                }
                if (this.updateConfig(this._config, o), i && fo(this, me(t1))) return;
                this._loaded = !0, this.stylesheet = e.cp(t1);
                const s = ()=>{
                    for(const e in t1.sources)this.addSource(e, t1.sources[e], {
                        validate: !1,
                        isInitialLoad: !0
                    });
                    t1.sprite ? this._loadIconset(t1.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast("spriteLoaded", {
                        scope: this.scope,
                        isLoaded: !0
                    })), this.glyphManager.setURL(t1.glyphs, this.scope);
                    const o = Dt(this.stylesheet.layers);
                    if (this._order = o.map((e)=>e.id), this.stylesheet.light && e.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights) if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
                        const e = this.stylesheet.lights[0];
                        this.light = new ze(e.properties, e.id);
                    } else this.setLights(this.stylesheet.lights);
                    this.light || (this.light = new ze(this.stylesheet.light)), this._layers = {};
                    for (const t1 of o){
                        const i = e.cu(t1, this.scope, this._styleColorTheme.lut, this.options);
                        0 !== i.configDependencies.size && this._configDependentLayers.add(i.fqid), i.setEventedParent(this, {
                            layer: {
                                id: i.id
                            }
                        }), this._layers[i.id] = i;
                        const o = this.getOwnLayerSourceCache(i), s = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                        o && i.canCastShadows() && s && (o.castsShadows = !0);
                    }
                    this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);
                    const s = this.stylesheet.terrain;
                    s && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(s, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e.z("data", {
                        dataType: "style"
                    }));
                    const r = this.isRootStyle();
                    t1.imports ? this._loadImports(t1.imports, i).then(()=>{
                        this._reloadImports(), this.fire(new e.z(r ? "style.load" : "style.import.load"));
                    }) : (this._reloadImports(), this.fire(new e.z(r ? "style.load" : "style.import.load")));
                };
                this._styleColorTheme.colorTheme = this.stylesheet["color-theme"];
                const r = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
                if (r) {
                    const t1 = this._evaluateColorThemeData(r);
                    this._loadColorTheme(t1).then(()=>{
                        s();
                    }).catch((t1)=>{
                        e.w(`Couldn't load color theme from the stylesheet: ${t1}`), s();
                    });
                } else this._styleColorTheme.lut = null, s();
            }
            isRootStyle() {
                return 0 === this.importDepth;
            }
            mergeAll() {
                let t1, i, o, s, r, a, n, l, c, h;
                const u = {};
                this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((e)=>{
                    if (e.stylesheet) {
                        if (null != e.light && (t1 = e.light), e.stylesheet.lights) for (const t1 of e.stylesheet.lights)"ambient" === t1.type && null != e.ambientLight && (i = e.ambientLight), "directional" === t1.type && null != e.directionalLight && (o = e.directionalLight);
                        s = this._prioritizeTerrain(s, e.terrain, e.stylesheet.terrain), e.stylesheet.fog && null != e.fog && (r = e.fog), e.stylesheet.snow && null != e.snow && (a = e.snow), e.stylesheet.rain && null != e.rain && (n = e.rain), null != e.stylesheet.camera && (h = e.stylesheet.camera), null != e.stylesheet.projection && (l = e.stylesheet.projection), null != e.stylesheet.transition && (c = e.stylesheet.transition), u[e.scope] = e._styleColorTheme;
                    }
                }), this.light = t1, this.ambientLight = i, this.directionalLight = o, this.fog = r, this.snow = a, this.rain = n, this._styleColorThemeForScope = u, null === s ? delete this.terrain : this.terrain = s, this.camera = h || {
                    "camera-projection": "perspective"
                }, this.projection = l || {
                    name: "mercator"
                }, this.transition = e.l({}, xo, c), this.mergeSources(), this.mergeLayers();
            }
            forEachFragmentStyle(e) {
                const t1 = (i)=>{
                    for (const e of i.fragments)t1(e.style);
                    e(i);
                };
                t1(this);
            }
            _prioritizeTerrain(e, t1, i) {
                const o = e && 0 === e.drapeRenderMode;
                return null === i ? t1 && 0 === t1.drapeRenderMode ? t1 : o ? e : null : null != t1 && (!e || o || t1 && 1 === t1.drapeRenderMode) ? t1 : e;
            }
            mergeTerrain() {
                let e;
                this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((t1)=>{
                    e = this._prioritizeTerrain(e, t1.terrain, t1.stylesheet.terrain);
                }), null === e ? delete this.terrain : this.terrain = e;
            }
            mergeProjection() {
                let e;
                this.forEachFragmentStyle((t1)=>{
                    null != t1.stylesheet.projection && (e = t1.stylesheet.projection);
                }), this.projection = e || {
                    name: "mercator"
                };
            }
            mergeSources() {
                const t1 = {}, i = {}, o = {};
                this.forEachFragmentStyle((s)=>{
                    for(const i in s._sourceCaches){
                        const o = e.aC(i, s.scope);
                        t1[o] = s._sourceCaches[i];
                    }
                    for(const t1 in s._otherSourceCaches){
                        const o = e.aC(t1, s.scope);
                        i[o] = s._otherSourceCaches[t1];
                    }
                    for(const t1 in s._symbolSourceCaches){
                        const i = e.aC(t1, s.scope);
                        o[i] = s._symbolSourceCaches[t1];
                    }
                }), this._mergedSourceCaches = t1, this._mergedOtherSourceCaches = i, this._mergedSymbolSourceCaches = o;
            }
            mergeLayers() {
                const t1 = {}, i = [], o = {};
                this._mergedSlots = [], this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this.forEachFragmentStyle((o)=>{
                    for (const s of o._order){
                        const r = o._layers[s];
                        if ("slot" === r.type) {
                            const i = e.cq(s);
                            if (t1[i]) continue;
                            t1[i] = [];
                        }
                        r.slot && t1[r.slot] ? t1[r.slot].push(r) : i.push(r);
                    }
                }), this._mergedOrder = [];
                const s = (i = [])=>{
                    for (const r of i)if ("slot" === r.type) {
                        const i = e.cq(r.id);
                        t1[i] && s(t1[i]), this._mergedSlots.push(i);
                    } else {
                        const t1 = e.aC(r.id, r.scope);
                        this._mergedOrder.push(t1), o[t1] = r, r.is3D() && (this._has3DLayers = !0), "circle" === r.type && (this._hasCircleLayers = !0), "symbol" === r.type && (this._hasSymbolLayers = !0), "clip" === r.type && (this._clipLayerPresent = !0);
                    }
                };
                s(i), this._mergedOrder.sort((e, t1)=>{
                    const i = o[e], s = o[t1];
                    return i.hasInitialOcclusionOpacityProperties ? s.is3D() ? 1 : 0 : i.is3D() && s.hasInitialOcclusionOpacityProperties ? -1 : 0;
                }), this._mergedLayers = o, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
            }
            terrainSetForDrapingOnly() {
                return !!this.terrain && 0 === this.terrain.drapeRenderMode;
            }
            getCamera() {
                return this.stylesheet.camera;
            }
            setCamera(t1) {
                return this.stylesheet.camera = e.l({}, this.stylesheet.camera, t1), this.camera = this.stylesheet.camera, this;
            }
            _evaluateColorThemeData(t1) {
                return t1.data ? (function(t1, i, o) {
                    const s = e.l({}, i);
                    for (const t1 of Object.keys(e.a3.colorTheme))void 0 === s[t1] && (s[t1] = e.a3.colorTheme[t1].default);
                    const r = new e.a4(lo, t1, new Map(o));
                    return r.setTransitionOrValue(s, o), r.untransitioned().possiblyEvaluate(new e.a8(0));
                })(this.scope, t1, this.options).get("data") : null;
            }
            _loadColorTheme(t1) {
                this._styleColorTheme.lutLoading = !0, this._styleColorTheme.lutLoadingCorrelationID += 1;
                const i = this._styleColorTheme.lutLoadingCorrelationID;
                return new Promise((o, s)=>{
                    const r = "data:image/png;base64,";
                    if (!t1 || 0 === t1.length) return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = !1, void o();
                    let a = t1;
                    a.startsWith(r) || (a = r + a);
                    const n = "mapbox-reserved-lut", l = new Image;
                    l.src = a, l.onerror = ()=>{
                        this._styleColorTheme.lutLoading = !1, s(new Error("Failed to load image data"));
                    }, l.onload = ()=>{
                        if (this._styleColorTheme.lutLoadingCorrelationID !== i) return void o();
                        this._styleColorTheme.lutLoading = !1;
                        const { width: r, height: a, data: c } = e.q.getImageData(l);
                        if (a > 32) return void s(new Error("The height of the image must be less than or equal to 32 pixels."));
                        if (r !== a * a) return void s(new Error("The width of the image must be equal to the height squared."));
                        this.getImage(n) && this.removeImage(n), this.addImage(n, {
                            data: new e.r({
                                width: r,
                                height: a
                            }, c),
                            pixelRatio: 1,
                            sdf: !1,
                            usvg: !1,
                            version: 0
                        });
                        const h = this.imageManager.getImage(n, this.scope);
                        h ? (this._styleColorTheme.lut = {
                            image: h.data,
                            data: t1
                        }, o()) : s(new Error("Missing LUT image."));
                    };
                });
            }
            getLut(e) {
                const t1 = this._styleColorThemeForScope[e];
                return t1 ? t1.lut : null;
            }
            setProjection(e) {
                e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
            }
            applyProjectionUpdate() {
                this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
            }
            _updateMapProjection() {
                this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
            }
            _loadSprite(t1) {
                this._spriteRequest = function(t1, i, o) {
                    let s, r, a;
                    const n = e.q.devicePixelRatio > 1 ? "@2x" : "";
                    let l = e.n(i.transformRequest(i.normalizeSpriteURL(t1, n, ".json"), e.R.SpriteJSON), (e, t1)=>{
                        l = null, a || (a = e, s = t1, h());
                    }), c = e.o(i.transformRequest(i.normalizeSpriteURL(t1, n, ".png"), e.R.SpriteImage), (e, t1)=>{
                        c = null, a || (a = e, r = t1, h());
                    });
                    function h() {
                        if (a) o(a);
                        else if (s && r) {
                            const t1 = e.q.getImageData(r), i = {};
                            for(const o in s){
                                const { width: r, height: a, x: n, y: l, sdf: c, pixelRatio: h, stretchX: u, stretchY: d, content: _ } = s[o], p = new e.r({
                                    width: r,
                                    height: a
                                });
                                e.r.copy(t1, p, {
                                    x: n,
                                    y: l
                                }, {
                                    x: 0,
                                    y: 0
                                }, {
                                    width: r,
                                    height: a
                                }, null), i[o] = {
                                    data: p,
                                    pixelRatio: h,
                                    sdf: c,
                                    stretchX: u,
                                    stretchY: d,
                                    content: _,
                                    usvg: !1
                                };
                            }
                            o(null, i);
                        }
                    }
                    return {
                        cancel () {
                            l && (l.cancel(), l = null), c && (c.cancel(), c = null);
                        }
                    };
                }(t1, this.map._requestManager, (t1, i)=>{
                    if (this._spriteRequest = null, t1) this.fire(new e.y(t1));
                    else if (i) for(const e in i)this.imageManager.addImage(e, this.scope, i[e]);
                    this.imageManager.setLoaded(!0, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", {
                        scope: this.scope,
                        images: this._availableImages
                    }), this.dispatcher.broadcast("spriteLoaded", {
                        scope: this.scope,
                        isLoaded: !0
                    }), this.fire(new e.z("data", {
                        dataType: "style"
                    }));
                });
            }
            _loadIconset(t1) {
                if (!e.f(t1) && "icon_set" !== this.map._spriteFormat || "raster" === this.map._spriteFormat) return void this._loadSprite(t1);
                const i = "auto" === this.map._spriteFormat;
                var o, s;
                this._spriteRequest = (s = (o, s)=>{
                    if (this._spriteRequest = null, o) i ? this._loadSprite(t1) : this.fire(new e.y(o));
                    else if (s) for(const e in s)this.imageManager.addImage(e, this.scope, s[e]);
                    this.imageManager.setLoaded(!0, this.scope), this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", {
                        scope: this.scope,
                        images: this._availableImages
                    }), this.dispatcher.broadcast("spriteLoaded", {
                        scope: this.scope,
                        isLoaded: !0
                    }), this.fire(new e.z("data", {
                        dataType: "style"
                    }));
                }, e.bi((o = this.map._requestManager).transformRequest(o.normalizeIconsetURL(t1), e.R.Iconset), (t1, i)=>{
                    if (t1) return void s(t1);
                    const o = {}, r = e.cg(new e.bh(i));
                    for (const t1 of r.icons){
                        const i = {
                            version: 1,
                            pixelRatio: e.q.devicePixelRatio,
                            content: _o(t1),
                            stretchX: t1.metadata ? po(t1.metadata.stretch_x_areas) : void 0,
                            stretchY: t1.metadata ? po(t1.metadata.stretch_y_areas) : void 0,
                            sdf: !1,
                            usvg: !0,
                            icon: t1
                        };
                        o[t1.name] = i;
                    }
                    s(null, o);
                }));
            }
            _validateLayer(t1) {
                const i = this.getOwnSource(t1.source);
                if (!i) return;
                const o = t1.sourceLayer;
                o && ("geojson" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(o)) && this.fire(new e.y(new Error(`Source layer "${o}" does not exist on source "${i.id}" as specified by style layer "${t1.id}"`)));
            }
            loaded() {
                if (!this._loaded) return !1;
                if (Object.keys(this._changes.getUpdatedSourceCaches()).length) return !1;
                for(const e in this._sourceCaches)if (!this._sourceCaches[e].loaded()) return !1;
                if (!this.imageManager.isLoaded()) return !1;
                if (!this.modelManager.isLoaded()) return !1;
                if (this._styleColorTheme.lutLoading) return !1;
                for (const { style: e } of this.fragments)if (!e.loaded()) return !1;
                return !0;
            }
            _serializeImports() {
                if (this.stylesheet.imports) return this.stylesheet.imports.map((e, t1)=>{
                    const i = this.fragments[t1];
                    return i && i.style && (e.data = i.style.serialize()), e;
                });
            }
            _serializeSources() {
                const e = {};
                for(const t1 in this._sourceCaches){
                    const i = this._sourceCaches[t1].getSource();
                    e[i.id] || (e[i.id] = i.serialize());
                }
                return e;
            }
            _serializeLayers(e) {
                const t1 = [];
                for (const i of e){
                    const e = this._layers[i];
                    e && "custom" !== e.type && t1.push(e.serialize());
                }
                return t1;
            }
            hasLightTransitions() {
                return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
            }
            hasFogTransition() {
                return !!this.fog && this.fog.hasTransition();
            }
            hasSnowTransition() {
                return !!this.snow && this.snow.hasTransition();
            }
            hasRainTransition() {
                return !!this.rain && this.rain.hasTransition();
            }
            hasTransitions() {
                if (this.hasLightTransitions()) return !0;
                if (this.hasFogTransition()) return !0;
                if (this.hasSnowTransition()) return !0;
                if (this.hasRainTransition()) return !0;
                for(const e in this._sourceCaches)if (this._sourceCaches[e].hasTransition()) return !0;
                for(const e in this._layers)if (this._layers[e].hasTransition()) return !0;
                return !1;
            }
            get order() {
                return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
            }
            _getOrder(e) {
                return e ? this.order : this._mergedOrder;
            }
            isLayerDraped(e) {
                return !!this.terrain && e.isDraped(this.getLayerSourceCache(e));
            }
            _checkLoaded() {
                if (!this._loaded) throw new Error("Style is not done loading");
            }
            _checkLayer(t1) {
                const i = this.getOwnLayer(t1);
                if (i) return i;
                this.fire(new e.y(new Error(`The layer '${t1}' does not exist in the map's style.`)));
            }
            _checkSource(t1) {
                const i = this.getOwnSource(t1);
                if (i) return i;
                this.fire(new e.y(new Error(`The source '${t1}' does not exist in the map's style.`)));
            }
            precompilePrograms(e, t1) {
                const i = this.map.painter;
                if (i) for(let o = e.minzoom || 0; o < (e.maxzoom || 25.5); o++){
                    const o = e.getProgramIds();
                    if (o) for (const s of o){
                        const o = e.getDefaultProgramParams(s, t1.zoom, this._styleColorTheme.lut);
                        o && (i.style = this, this.fog && (i._fogVisible = !0, o.overrideFog = !0, i.getOrCreateProgram(s, o)), i._fogVisible = !1, o.overrideFog = !1, i.getOrCreateProgram(s, o), (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (o.overrideRtt = !0, i.getOrCreateProgram(s, o)));
                    }
                }
            }
            update(t1) {
                if (!this._loaded) return;
                this.ambientLight && this.ambientLight.recalculate(t1), this.directionalLight && this.directionalLight.recalculate(t1);
                const i = this.calculateLightsBrightness();
                t1.brightness = i || 0, i !== this._brightness && (this._brightness = i, this.dispatcher.broadcast("setBrightness", i));
                const o = this._changes.isDirty();
                let s = !1;
                if (this._changes.isDirty()) {
                    const e = this._changes.getLayerUpdatesByScope();
                    for(const t1 in e){
                        const { updatedIds: i, removedIds: o } = e[t1];
                        (i || o) && (this._updateWorkerLayers(t1, i, o), s = !0);
                    }
                    this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t1), this.light && this.light.updateTransitions(t1), this.ambientLight && this.ambientLight.updateTransitions(t1), this.directionalLight && this.directionalLight.updateTransitions(t1), this.fog && this.fog.updateTransitions(t1), this.snow && this.snow.updateTransitions(t1), this.rain && this.rain.updateTransitions(t1), this._changes.reset();
                }
                const r = {};
                for(const e in this._mergedSourceCaches){
                    const t1 = this._mergedSourceCaches[e];
                    r[e] = t1.used, t1.used = !1, t1.tileCoverLift = 0;
                }
                for (const e of this._mergedOrder){
                    const i = this._mergedLayers[e];
                    if (i.recalculate(t1, this._availableImages), !i.isHidden(t1.zoom)) {
                        const e = this.getLayerSourceCache(i);
                        e && (e.used = !0, e.tileCoverLift = Math.max(e.tileCoverLift, i.tileCoverLift()));
                    }
                    !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback(()=>{
                        this.precompilePrograms(i, t1);
                    }) : this.precompilePrograms(i, t1));
                }
                this._shouldPrecompile && (this._precompileDone = !0), this.terrain && s && this.mergeLayers();
                for(const t1 in r){
                    const i = this._mergedSourceCaches[t1];
                    r[t1] !== i.used && i.getSource().fire(new e.z("data", {
                        sourceDataType: "visibility",
                        dataType: "source",
                        sourceId: i.getSource().id
                    }));
                }
                this.light && this.light.recalculate(t1), this.terrain && this.terrain.recalculate(t1), this.fog && this.fog.recalculate(t1), this.snow && this.snow.recalculate(t1), this.rain && this.rain.recalculate(t1), this.z = t1.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), o && this.fire(new e.z("data", {
                    dataType: "style"
                }));
            }
            _updateTilesForChangedImages() {
                const e = this._changes.getUpdatedImages();
                if (e.length) {
                    for(const t1 in this._sourceCaches)this._sourceCaches[t1].reloadTilesForDependencies([
                        "icons",
                        "patterns"
                    ], e);
                    this._changes.resetUpdatedImages();
                }
            }
            _updateWorkerLayers(e, t1, i) {
                const o = this.getFragmentStyle(e);
                o && this.dispatcher.broadcast("updateLayers", {
                    layers: t1 ? o._serializeLayers(t1) : [],
                    scope: e,
                    removedIds: i || [],
                    options: o.options
                });
            }
            setState(t1, i) {
                if (this._checkLoaded(), fo(this, me(t1))) return !1;
                (t1 = e.cp(t1)).layers = Dt(t1.layers);
                const o = (function(t1, i) {
                    if (!t1) return [
                        {
                            command: Lt.setStyle,
                            args: [
                                i
                            ]
                        }
                    ];
                    let o = [];
                    try {
                        if (!e.bn(t1.version, i.version)) return [
                            {
                                command: Lt.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                        if (e.bn(t1.center, i.center) || o.push({
                            command: Lt.setCenter,
                            args: [
                                i.center
                            ]
                        }), e.bn(t1.zoom, i.zoom) || o.push({
                            command: Lt.setZoom,
                            args: [
                                i.zoom
                            ]
                        }), e.bn(t1.bearing, i.bearing) || o.push({
                            command: Lt.setBearing,
                            args: [
                                i.bearing
                            ]
                        }), e.bn(t1.pitch, i.pitch) || o.push({
                            command: Lt.setPitch,
                            args: [
                                i.pitch
                            ]
                        }), e.bn(t1.sprite, i.sprite) || o.push({
                            command: Lt.setSprite,
                            args: [
                                i.sprite
                            ]
                        }), e.bn(t1.glyphs, i.glyphs) || o.push({
                            command: Lt.setGlyphs,
                            args: [
                                i.glyphs
                            ]
                        }), e.bn(t1.imports, i.imports) || function(t1 = [], i = [], o) {
                            i = i || [];
                            const s = (t1 = t1 || []).map(Ft), r = i.map(Ft), a = t1.reduce(kt, {}), n = i.reduce(kt, {}), l = s.slice();
                            let c, h, u, d;
                            for(c = 0, h = 0; c < s.length; c++)u = s[c], n.hasOwnProperty(u) ? h++ : (o.push({
                                command: Lt.removeImport,
                                args: [
                                    u
                                ]
                            }), l.splice(l.indexOf(u, h), 1));
                            for(c = 0, h = 0; c < r.length; c++)u = r[r.length - 1 - c], l[l.length - 1 - c] !== u && (a.hasOwnProperty(u) ? (o.push({
                                command: Lt.removeImport,
                                args: [
                                    u
                                ]
                            }), l.splice(l.lastIndexOf(u, l.length - h), 1)) : h++, d = l[l.length - c], o.push({
                                command: Lt.addImport,
                                args: [
                                    n[u],
                                    d
                                ]
                            }), l.splice(l.length - c, 0, u));
                            for (const t1 of i){
                                const i = a[t1.id];
                                i && !e.bn(i, t1) && o.push({
                                    command: Lt.updateImport,
                                    args: [
                                        t1.id,
                                        t1
                                    ]
                                });
                            }
                        }(t1.imports, i.imports, o), e.bn(t1.transition, i.transition) || o.push({
                            command: Lt.setTransition,
                            args: [
                                i.transition
                            ]
                        }), e.bn(t1.light, i.light) || o.push({
                            command: Lt.setLight,
                            args: [
                                i.light
                            ]
                        }), e.bn(t1.fog, i.fog) || o.push({
                            command: Lt.setFog,
                            args: [
                                i.fog
                            ]
                        }), e.bn(t1.snow, i.snow) || o.push({
                            command: Lt.setSnow,
                            args: [
                                i.snow
                            ]
                        }), e.bn(t1.rain, i.rain) || o.push({
                            command: Lt.setRain,
                            args: [
                                i.rain
                            ]
                        }), e.bn(t1.projection, i.projection) || o.push({
                            command: Lt.setProjection,
                            args: [
                                i.projection
                            ]
                        }), e.bn(t1.lights, i.lights) || o.push({
                            command: Lt.setLights,
                            args: [
                                i.lights
                            ]
                        }), e.bn(t1.camera, i.camera) || o.push({
                            command: Lt.setCamera,
                            args: [
                                i.camera
                            ]
                        }), !e.bn(t1["color-theme"], i["color-theme"])) return [
                            {
                                command: Lt.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                        const s = {}, r = [];
                        !function(t1, i, o, s) {
                            let r;
                            for(r in i = i || {}, t1 = t1 || {})t1.hasOwnProperty(r) && (i.hasOwnProperty(r) || zt(r, o, s));
                            for(r in i){
                                if (!i.hasOwnProperty(r)) continue;
                                const a = i[r];
                                t1.hasOwnProperty(r) ? e.bn(t1[r], a) || ("geojson" === t1[r].type && "geojson" === a.type && Mt(t1, i, r) ? o.push({
                                    command: Lt.setGeoJSONSourceData,
                                    args: [
                                        r,
                                        a.data
                                    ]
                                }) : Pt(r, i, o, s)) : At(r, i, o);
                            }
                        }(t1.sources, i.sources, r, s);
                        const a = [];
                        t1.layers && t1.layers.forEach((e)=>{
                            e.source && s[e.source] ? o.push({
                                command: Lt.removeLayer,
                                args: [
                                    e.id
                                ]
                            }) : a.push(e);
                        });
                        let n = t1.terrain;
                        n && s[n.source] && (o.push({
                            command: Lt.setTerrain,
                            args: [
                                void 0
                            ]
                        }), n = void 0), o = o.concat(r), e.bn(n, i.terrain) || o.push({
                            command: Lt.setTerrain,
                            args: [
                                i.terrain
                            ]
                        }), function(t1, i, o) {
                            i = i || [];
                            const s = (t1 = t1 || []).map(Ft), r = i.map(Ft), a = t1.reduce(kt, {}), n = i.reduce(kt, {}), l = s.slice(), c = Object.create(null);
                            let h, u, d, _, p, f, m;
                            for(h = 0, u = 0; h < s.length; h++)d = s[h], n.hasOwnProperty(d) ? u++ : (o.push({
                                command: Lt.removeLayer,
                                args: [
                                    d
                                ]
                            }), l.splice(l.indexOf(d, u), 1));
                            for(h = 0, u = 0; h < r.length; h++)d = r[r.length - 1 - h], l[l.length - 1 - h] !== d && (a.hasOwnProperty(d) ? (o.push({
                                command: Lt.removeLayer,
                                args: [
                                    d
                                ]
                            }), l.splice(l.lastIndexOf(d, l.length - u), 1)) : u++, f = l[l.length - h], o.push({
                                command: Lt.addLayer,
                                args: [
                                    n[d],
                                    f
                                ]
                            }), l.splice(l.length - h, 0, d), c[d] = !0);
                            for(h = 0; h < r.length; h++)if (d = r[h], _ = a[d], p = n[d], !c[d] && !e.bn(_, p)) if (e.bn(_.source, p.source) && e.bn(_["source-layer"], p["source-layer"]) && e.bn(_.type, p.type)) {
                                for(m in Ot(_.layout, p.layout, o, d, null, Lt.setLayoutProperty), Ot(_.paint, p.paint, o, d, null, Lt.setPaintProperty), e.bn(_.slot, p.slot) || o.push({
                                    command: Lt.setSlot,
                                    args: [
                                        d,
                                        p.slot
                                    ]
                                }), e.bn(_.filter, p.filter) || o.push({
                                    command: Lt.setFilter,
                                    args: [
                                        d,
                                        p.filter
                                    ]
                                }), e.bn(_.minzoom, p.minzoom) && e.bn(_.maxzoom, p.maxzoom) || o.push({
                                    command: Lt.setLayerZoomRange,
                                    args: [
                                        d,
                                        p.minzoom,
                                        p.maxzoom
                                    ]
                                }), _)_.hasOwnProperty(m) && "layout" !== m && "paint" !== m && "filter" !== m && "metadata" !== m && "minzoom" !== m && "maxzoom" !== m && "slot" !== m && (0 === m.indexOf("paint.") ? Ot(_[m], p[m], o, d, m.slice(6), Lt.setPaintProperty) : e.bn(_[m], p[m]) || o.push({
                                    command: Lt.setLayerProperty,
                                    args: [
                                        d,
                                        m,
                                        p[m]
                                    ]
                                }));
                                for(m in p)p.hasOwnProperty(m) && !_.hasOwnProperty(m) && "layout" !== m && "paint" !== m && "filter" !== m && "metadata" !== m && "minzoom" !== m && "maxzoom" !== m && "slot" !== m && (0 === m.indexOf("paint.") ? Ot(_[m], p[m], o, d, m.slice(6), Lt.setPaintProperty) : e.bn(_[m], p[m]) || o.push({
                                    command: Lt.setLayerProperty,
                                    args: [
                                        d,
                                        m,
                                        p[m]
                                    ]
                                }));
                            } else o.push({
                                command: Lt.removeLayer,
                                args: [
                                    d
                                ]
                            }), f = l[l.lastIndexOf(d) + 1], o.push({
                                command: Lt.addLayer,
                                args: [
                                    p,
                                    f
                                ]
                            });
                        }(a, i.layers, o);
                    } catch (e) {
                        console.warn("Unable to compute style diff:", e), o = [
                            {
                                command: Lt.setStyle,
                                args: [
                                    i
                                ]
                            }
                        ];
                    }
                    return o;
                })(this.serialize(), t1).filter((e)=>!(e.command in go));
                if (0 === o.length) return !1;
                const s = o.filter((e)=>!(e.command in mo));
                if (s.length > 0) throw new Error(`Unimplemented: ${s.map((e)=>e.command).join(", ")}.`);
                const r = [];
                return o.forEach((e)=>{
                    r.push(this[e.command].apply(this, e.args));
                }), i && Promise.all(r).then(i), this.stylesheet = t1, this.mergeAll(), this.dispatcher.broadcast("setLayers", {
                    layers: this._serializeLayers(this._order),
                    scope: this.scope,
                    options: this.options
                }), !0;
            }
            addImage(t1, i) {
                return this.getImage(t1) ? this.fire(new e.y(new Error("An image with this name already exists."))) : (this.imageManager.addImage(t1, this.scope, i), this._afterImageUpdated(t1), this);
            }
            updateImage(e, t1, i = !1) {
                this.imageManager.updateImage(e, this.scope, t1), i && this._afterImageUpdated(e);
            }
            getImage(e) {
                return this.imageManager.getImage(e, this.scope);
            }
            removeImage(t1) {
                return this.getImage(t1) ? (this.imageManager.removeImage(t1, this.scope), this._afterImageUpdated(t1), this) : this.fire(new e.y(new Error("No image with this name exists.")));
            }
            _afterImageUpdated(t1) {
                this._availableImages = this.imageManager.listImages(this.scope), this._changes.updateImage(t1), this.dispatcher.broadcast("setImages", {
                    scope: this.scope,
                    images: this._availableImages
                }), this.fire(new e.z("data", {
                    dataType: "style"
                }));
            }
            listImages() {
                return this._checkLoaded(), this._availableImages.slice();
            }
            addModel(e, t1, i = {}) {
                return this._checkLoaded(), this._validate(Re, `models.${e}`, t1, null, i) || (this.modelManager.addModel(e, t1, this.scope), this._changes.setDirty()), this;
            }
            hasModel(e) {
                return this.modelManager.hasModel(e, this.scope);
            }
            removeModel(t1) {
                return this.hasModel(t1) ? (this.modelManager.removeModel(t1, this.scope), this) : this.fire(new e.y(new Error("No model with this ID exists.")));
            }
            listModels() {
                return this._checkLoaded(), this.modelManager.listModels(this.scope);
            }
            addSource(t1, i, o = {}) {
                if (this._checkLoaded(), void 0 !== this.getOwnSource(t1)) throw new Error(`There is already a source with ID "${t1}".`);
                if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
                if ([
                    "vector",
                    "raster",
                    "geojson",
                    "video",
                    "image"
                ].indexOf(i.type) >= 0 && this._validate(ge, `sources.${t1}`, i, null, o)) return;
                this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
                const s = rt(t1, i, this.dispatcher, this);
                s.scope = this.scope, s.setEventedParent(this, ()=>({
                        isSourceLoaded: this._isSourceCacheLoaded(s.id),
                        source: s.serialize(),
                        sourceId: s.id
                    }));
                const r = (t1)=>{
                    const i = (t1 ? "symbol:" : "other:") + s.id, o = e.aC(i, this.scope), r = this._sourceCaches[i] = new Tt(o, s, t1);
                    (t1 ? this._symbolSourceCaches : this._otherSourceCaches)[s.id] = r, r.onAdd(this.map);
                };
                r(!1), "vector" !== i.type && "geojson" !== i.type || r(!0), s.onAdd && s.onAdd(this.map), o.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
            }
            removeSource(t1) {
                this._checkLoaded();
                const i = this.getOwnSource(t1);
                if (!i) throw new Error("There is no source with this ID");
                for(const i in this._layers)if (this._layers[i].source === t1) return this.fire(new e.y(new Error(`Source "${t1}" cannot be removed while layer "${i}" is using it.`)));
                if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t1) return this.fire(new e.y(new Error(`Source "${t1}" cannot be removed while terrain is using it.`)));
                const o = this.getOwnSourceCaches(t1);
                for (const t1 of o){
                    const i = e.cq(t1.id);
                    delete this._sourceCaches[i], this._changes.discardSourceCacheUpdate(t1.id), t1.fire(new e.z("data", {
                        sourceDataType: "metadata",
                        dataType: "source",
                        sourceId: t1.getSource().id
                    })), t1.setEventedParent(null), t1.clearTiles();
                }
                return delete this._otherSourceCaches[t1], delete this._symbolSourceCaches[t1], this.mergeSources(), i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changes.setDirty(), this;
            }
            setGeoJSONSourceData(e, t1) {
                this._checkLoaded(), this.getOwnSource(e).setData(t1), this._changes.setDirty();
            }
            getOwnSource(e) {
                const t1 = this.getOwnSourceCache(e);
                return t1 && t1.getSource();
            }
            getOwnSources() {
                const e = [];
                for(const t1 in this._otherSourceCaches){
                    const i = this.getOwnSourceCache(t1);
                    i && e.push(i.getSource());
                }
                return e;
            }
            areTilesLoaded() {
                const e = this._mergedSourceCaches;
                for(const t1 in e){
                    const i = e[t1]._tiles;
                    for(const e in i){
                        const t1 = i[e];
                        if ("loaded" !== t1.state && "errored" !== t1.state) return !1;
                    }
                }
                return !0;
            }
            setLights(t1) {
                if (this._checkLoaded(), !t1) return delete this.ambientLight, void delete this.directionalLight;
                const i = this._getTransitionParameters();
                for (const o of t1){
                    if (this._validate(ye, "lights", o)) return;
                    switch(o.type){
                        case "ambient":
                            if (this.ambientLight) {
                                const e = this.ambientLight;
                                e.set(o), e.updateTransitions(i);
                            } else this.ambientLight = new $e(o, qe || (qe = new e.a5({
                                color: new e.a6(e.a3.properties_light_ambient.color),
                                "color-use-theme": new e.a6({
                                    type: "string",
                                    default: "default",
                                    "property-type": "data-constant"
                                }),
                                intensity: new e.a6(e.a3.properties_light_ambient.intensity)
                            })), this.scope, this.options);
                            break;
                        case "directional":
                            if (this.directionalLight) {
                                const e = this.directionalLight;
                                e.set(o), e.updateTransitions(i);
                            } else this.directionalLight = new $e(o, He || (He = new e.a5({
                                direction: new e.ak(e.a3.properties_light_directional.direction),
                                color: new e.a6(e.a3.properties_light_directional.color),
                                "color-use-theme": new e.a6({
                                    type: "string",
                                    default: "default",
                                    "property-type": "data-constant"
                                }),
                                intensity: new e.a6(e.a3.properties_light_directional.intensity),
                                "cast-shadows": new e.a6(e.a3.properties_light_directional["cast-shadows"]),
                                "shadow-quality": new e.a6(e.a3.properties_light_directional["shadow-quality"]),
                                "shadow-intensity": new e.a6(e.a3.properties_light_directional["shadow-intensity"])
                            })), this.scope, this.options);
                    }
                }
                const o = new e.a8(this.z || 0, i);
                this.ambientLight && this.ambientLight.recalculate(o), this.directionalLight && this.directionalLight.recalculate(o), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
            }
            calculateLightsBrightness() {
                const t1 = this.directionalLight, i = this.ambientLight;
                if (!t1 || !i) return;
                const o = (e)=>.2126 * (e[0] <= .03928 ? e[0] / 12.92 : Math.pow((e[0] + .055) / 1.055, 2.4)) + .7152 * (e[1] <= .03928 ? e[1] / 12.92 : Math.pow((e[1] + .055) / 1.055, 2.4)) + .0722 * (e[2] <= .03928 ? e[2] / 12.92 : Math.pow((e[2] + .055) / 1.055, 2.4)), s = t1.properties.get("color").toRenderColor(null).toArray01(), r = t1.properties.get("intensity"), a = t1.properties.get("direction"), n = 1 - e.cb(a.x, a.y, a.z)[2] / 90, l = o(s) * r * n, c = i.properties.get("color").toRenderColor(null).toArray01(), h = i.properties.get("intensity"), u = o(c) * h;
                return Number(((l + u) / 2).toFixed(6));
            }
            getBrightness() {
                return this._brightness;
            }
            getLights() {
                if (!this.enable3dLights()) return null;
                const e = [];
                return this.directionalLight && e.push(this.directionalLight.get()), this.ambientLight && e.push(this.ambientLight.get()), e;
            }
            enable3dLights() {
                return !!this.ambientLight && !!this.directionalLight;
            }
            getFragmentStyle(t1) {
                if (!t1) return this;
                if (e.cr(t1)) {
                    const i = e.cs(t1), o = this.fragments.find(({ id: e })=>e === i);
                    if (!o) throw new Error(`Style import '${t1}' not found`);
                    const s = e.cq(t1);
                    return o.style.getFragmentStyle(s);
                }
                {
                    const e = this.fragments.find(({ id: e })=>e === t1);
                    if (!e) throw new Error(`Style import '${t1}' not found`);
                    return e.style;
                }
            }
            setFeaturesetSelectors(t1) {
                if (!t1) return;
                const i = {}, o = (e, t1 = "")=>`${e}::${t1}`;
                this.featuresetSelectors = {};
                for(const s in t1){
                    const r = this.featuresetSelectors[s] = [];
                    for (const a of t1[s].selectors){
                        if (a.featureNamespace) {
                            const t1 = this.getOwnLayer(a.layer);
                            if (!t1) {
                                e.w(`Layer is undefined for selector: ${a.layer}`);
                                continue;
                            }
                            const r = o(t1.source, t1.sourceLayer);
                            if (r in i && i[r] !== a.featureNamespace) {
                                e.w(`"featureNamespace ${a.featureNamespace} of featureset ${s}'s selector is not associated to the same source, skip this selector`);
                                continue;
                            }
                            i[r] = a.featureNamespace;
                        }
                        let t1;
                        if (a.properties) for(const i in a.properties){
                            const o = e.U(a.properties[i]);
                            "success" === o.result && (t1 = t1 || {}, t1[i] = o.value);
                        }
                        r.push({
                            layerId: a.layer,
                            namespace: a.featureNamespace,
                            properties: t1
                        });
                    }
                }
            }
            getFeaturesetDescriptors(e) {
                const t1 = this.getFragmentStyle(e);
                if (!t1 || !t1.stylesheet.featuresets) return [];
                const i = [];
                for(const e in t1.stylesheet.featuresets)i.push({
                    featuresetId: e,
                    importId: t1.scope ? t1.scope : void 0
                });
                return i;
            }
            getFeaturesetLayers(t1, i) {
                const o = this.getFragmentStyle(i), s = o.stylesheet.featuresets;
                if (!s || !s[t1]) return this.fire(new e.y(new Error(`The featureset '${t1}' does not exist in the map's style and cannot be queried.`))), [];
                const r = [];
                for (const e of s[t1].selectors){
                    const t1 = o.getOwnLayer(e.layer);
                    t1 && r.push(t1);
                }
                return r;
            }
            getConfigProperty(t1, i) {
                const o = this.getFragmentStyle(t1);
                if (!o) return null;
                const s = e.aC(i, o.scope), r = o.options.get(s), a = r ? r.value || r.default : null;
                return a ? a.serialize() : null;
            }
            setConfigProperty(t1, i, o) {
                const s = this.getFragmentStyle(t1);
                if (!s) return;
                const r = s.stylesheet.indoor ? ho(s.stylesheet.schema) : s.stylesheet.schema;
                if (!r || !r[i]) return;
                const a = e.U(o);
                if ("success" !== a.result) return void fo(this, a.value);
                const n = a.value.expression, l = e.aC(i, s.scope), c = s.options.get(l);
                if (!c) return;
                let h;
                const { minValue: u, maxValue: d, stepValue: _, type: p, values: f } = r[i], m = e.U(r[i].default);
                "success" === m.result && (h = m.value.expression), h ? (this.options.set(l, {
                    ...c,
                    value: n,
                    default: h,
                    minValue: u,
                    maxValue: d,
                    stepValue: _,
                    type: p,
                    values: f
                }), this.updateConfigDependencies(i)) : this.fire(new e.y(new Error(`No schema defined for the config option "${i}" in the "${t1}" fragment.`)));
            }
            getConfig(t1) {
                const i = this.getFragmentStyle(t1);
                if (!i) return null;
                const o = i.stylesheet.schema;
                if (!o) return null;
                const s = {};
                for(const t1 in o){
                    const o = e.aC(t1, i.scope), r = i.options.get(o), a = r ? r.value || r.default : null;
                    s[t1] = a ? a.serialize() : null;
                }
                return s;
            }
            setConfig(e, t1) {
                const i = this.getFragmentStyle(e);
                i && (i.updateConfig(t1, i.stylesheet.schema), this.updateConfigDependencies());
            }
            getSchema(e) {
                const t1 = this.getFragmentStyle(e);
                return t1 ? t1.stylesheet.schema : null;
            }
            setSchema(e, t1) {
                const i = this.getFragmentStyle(e);
                i && (i.stylesheet.schema = t1, i.updateConfig(i._config, t1), this.updateConfigDependencies());
            }
            updateConfig(t1, i) {
                if (this._config = t1, t1 || i) if (i) for(const o in i){
                    let s, r;
                    const a = e.U(i[o].default);
                    if ("success" === a.result && (s = a.value.expression), t1 && void 0 !== t1[o]) {
                        const i = e.U(t1[o]);
                        "success" === i.result && (r = i.value.expression);
                    }
                    const { minValue: n, maxValue: l, stepValue: c, type: h, values: u } = i[o];
                    if (s) {
                        const t1 = e.aC(o, this.scope);
                        this.options.set(t1, {
                            default: s,
                            value: r,
                            minValue: n,
                            maxValue: l,
                            stepValue: c,
                            type: h,
                            values: u
                        });
                    } else this.fire(new e.y(new Error(`No schema defined for config option "${o}".`)));
                }
                else this.fire(new e.y(new Error("Attempting to set config for a style without schema.")));
            }
            updateConfigDependencies(e) {
                for (const t1 of this._configDependentLayers){
                    const i = this.getLayer(t1);
                    if (i) {
                        if (e && !i.configDependencies.has(e)) continue;
                        i.possiblyEvaluateVisibility(), this._updateLayer(i);
                    }
                }
                this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle((e)=>{
                    const t1 = e._styleColorTheme.colorThemeOverride ? e._styleColorTheme.colorThemeOverride : e._styleColorTheme.colorTheme;
                    if (t1) {
                        const i = e._evaluateColorThemeData(t1);
                        (!e._styleColorTheme.lut && "" !== i || e._styleColorTheme.lut && i !== e._styleColorTheme.lut.data) && e.setColorTheme(t1);
                    }
                }), this._changes.setDirty();
            }
            addLayer(t1, i, o = {}) {
                this._checkLoaded();
                const s = t1.id;
                if (this._layers[s]) return void this.fire(new e.y(new Error(`Layer with id "${s}" already exists on this map`)));
                let r;
                if ("custom" === t1.type) {
                    if (fo(this, e.ct(t1))) return;
                    r = e.cu(t1, this.scope, this._styleColorTheme.lut, this.options);
                } else {
                    if ("object" == typeof t1.source && (this.addSource(s, t1.source), t1 = e.cp(t1), t1 = e.l(t1, {
                        source: s
                    })), this._validate(Ee, `layers.${s}`, t1, {
                        arrayIndex: -1
                    }, o)) return;
                    r = e.cu(t1, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(r), r.setEventedParent(this, {
                        layer: {
                            id: s
                        }
                    });
                }
                0 !== r.configDependencies.size && this._configDependentLayers.add(r.fqid);
                let a = this._order.length;
                if (i) {
                    const t1 = this._order.indexOf(i);
                    if (-1 === t1) return void this.fire(new e.y(new Error(`Layer with id "${i}" does not exist on this map.`)));
                    r.slot === this._layers[i].slot ? a = t1 : e.w(`Layer with id "${i}" has a different slot. Layers can only be rearranged within the same slot.`);
                }
                this._order.splice(a, 0, s), this._layerOrderChanged = !0, this._layers[s] = r;
                const n = this.getOwnLayerSourceCache(r), l = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                n && r.canCastShadows() && l && (n.castsShadows = !0);
                const c = this._changes.getRemovedLayer(r);
                if (c && r.source && n && "custom" !== r.type) {
                    this._changes.discardLayerRemoval(r);
                    const t1 = e.aC(r.source, r.scope);
                    c.type !== r.type ? this._changes.updateSourceCache(t1, "clear") : (this._changes.updateSourceCache(t1, "reload"), n.pause());
                }
                this._updateLayer(r), r.onAdd && r.onAdd(this.map), r.scope = this.scope, this.mergeLayers();
            }
            moveLayer(t1, i) {
                this._checkLoaded();
                const o = this._checkLayer(t1);
                if (!o) return;
                if (t1 === i) return;
                const s = this._order.indexOf(t1);
                this._order.splice(s, 1);
                let r = this._order.length;
                if (i) {
                    const t1 = this._order.indexOf(i);
                    if (-1 === t1) return void this.fire(new e.y(new Error(`Layer with id "${i}" does not exist on this map.`)));
                    o.slot === this._layers[i].slot ? r = t1 : e.w(`Layer with id "${i}" has a different slot. Layers can only be rearranged within the same slot.`);
                }
                this._order.splice(r, 0, t1), this._changes.setDirty(), this._layerOrderChanged = !0, this.mergeLayers();
            }
            removeLayer(e) {
                this._checkLoaded();
                const t1 = this._checkLayer(e);
                if (!t1) return;
                t1.setEventedParent(null);
                const i = this._order.indexOf(e);
                this._order.splice(i, 1), delete this._layers[e], this._changes.setDirty(), this._layerOrderChanged = !0, this._configDependentLayers.delete(t1.fqid), this._changes.removeLayer(t1);
                const o = this.getOwnLayerSourceCache(t1);
                if (o && o.castsShadows) {
                    let e = !1;
                    for(const i in this._layers)if (this._layers[i].source === t1.source && this._layers[i].canCastShadows()) {
                        e = !0;
                        break;
                    }
                    o.castsShadows = e;
                }
                t1.onRemove && t1.onRemove(this.map), this.mergeLayers();
            }
            getOwnLayer(e) {
                return this._layers[e];
            }
            hasLayer(e) {
                return e in this._mergedLayers;
            }
            hasLayerType(e) {
                for(const t1 in this._layers)if (this._layers[t1].type === e) return !0;
                return !1;
            }
            setLayerZoomRange(e, t1, i) {
                this._checkLoaded();
                const o = this._checkLayer(e);
                o && (o.minzoom === t1 && o.maxzoom === i || (null != t1 && (o.minzoom = t1), null != i && (o.maxzoom = i), this._updateLayer(o)));
            }
            getSlots() {
                return this._checkLoaded(), this._mergedSlots;
            }
            setSlot(e, t1) {
                this._checkLoaded();
                const i = this._checkLayer(e);
                i && i.slot !== t1 && (i.slot = t1, this._updateLayer(i));
            }
            setFilter(t1, i, o = {}) {
                this._checkLoaded();
                const s = this._checkLayer(t1);
                if (s && !e.bn(s.filter, i)) return null == i ? (s.filter = void 0, void this._updateLayer(s)) : void (this._validate(Se, `layers.${s.id}.filter`, i, {
                    layerType: s.type
                }, o) || (s.filter = e.cp(i), this._updateLayer(s)));
            }
            getFilter(t1) {
                const i = this._checkLayer(t1);
                if (i) return e.cp(i.filter);
            }
            setLayoutProperty(t1, i, o, s = {}) {
                this._checkLoaded();
                const r = this._checkLayer(t1);
                if (r && !e.bn(r.getLayoutProperty(i), o)) {
                    if (null != o && (!s || !1 !== s.validate) && fo(r, Ie.call(me, {
                        key: `layers.${t1}.layout.${i}`,
                        layerType: r.type,
                        objectKey: i,
                        value: o,
                        styleSpec: e.a3,
                        style: {
                            glyphs: !0,
                            sprite: !0
                        }
                    }))) return;
                    r.setLayoutProperty(i, o), 0 !== r.configDependencies.size && this._configDependentLayers.add(r.fqid), this._updateLayer(r);
                }
            }
            getLayoutProperty(e, t1) {
                const i = this._checkLayer(e);
                if (i) return i.getLayoutProperty(t1);
            }
            setPaintProperty(t1, i, o, s = {}) {
                this._checkLoaded();
                const r = this._checkLayer(t1);
                if (!r) return;
                if (e.bn(r.getPaintProperty(i), o)) return;
                if (null != o && (!s || !1 !== s.validate) && fo(r, Ce.call(me, {
                    key: `layers.${t1}.paint.${i}`,
                    layerType: r.type,
                    objectKey: i,
                    value: o,
                    styleSpec: e.a3
                }))) return;
                const a = r.setPaintProperty(i, o);
                0 !== r.configDependencies.size && this._configDependentLayers.add(r.fqid), a && this._updateLayer(r), this._changes.updatePaintProperties(r);
            }
            getPaintProperty(e, t1) {
                const i = this._checkLayer(e);
                if (i) return i.getPaintProperty(t1);
            }
            setFeatureState(t1, i) {
                if (this._checkLoaded(), "target" in t1) {
                    if ("featuresetId" in t1.target) {
                        const { featuresetId: e, importId: o } = t1.target, s = this.getFragmentStyle(o), r = s.getFeaturesetLayers(e);
                        for (const { source: e, sourceLayer: o } of r)s.setFeatureState({
                            id: t1.id,
                            source: e,
                            sourceLayer: o
                        }, i);
                    } else if ("layerId" in t1.target) {
                        const { layerId: e } = t1.target, o = this.getLayer(e);
                        this.setFeatureState({
                            id: t1.id,
                            source: o.source,
                            sourceLayer: o.sourceLayer
                        }, i);
                    }
                    return;
                }
                const o = t1.source, s = t1.sourceLayer, r = this._checkSource(o);
                if (!r) return;
                const a = r.type;
                if ("geojson" === a && s) return void this.fire(new e.y(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
                if ("vector" === a && !s) return void this.fire(new e.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
                void 0 === t1.id && this.fire(new e.y(new Error("The feature id parameter must be provided.")));
                const n = this.getOwnSourceCaches(o);
                for (const e of n)e.setFeatureState(s, t1.id, i);
            }
            removeFeatureState(t1, i) {
                if (this._checkLoaded(), "target" in t1) {
                    if ("featuresetId" in t1.target) {
                        const { featuresetId: e, importId: o } = t1.target, s = this.getFragmentStyle(o), r = s.getFeaturesetLayers(e);
                        for (const { source: e, sourceLayer: o } of r)s.removeFeatureState({
                            id: t1.id,
                            source: e,
                            sourceLayer: o
                        }, i);
                    } else if ("layerId" in t1.target) {
                        const { layerId: e } = t1.target, o = this.getLayer(e);
                        this.removeFeatureState({
                            id: t1.id,
                            source: o.source,
                            sourceLayer: o.sourceLayer
                        }, i);
                    }
                    return;
                }
                const o = t1.source, s = this._checkSource(o);
                if (!s) return;
                const r = s.type, a = "vector" === r ? t1.sourceLayer : void 0;
                if ("vector" === r && !a) return void this.fire(new e.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
                if (i && "string" != typeof t1.id && "number" != typeof t1.id) return void this.fire(new e.y(new Error("A feature id is required to remove its specific state property.")));
                const n = this.getOwnSourceCaches(o);
                for (const e of n)e.removeFeatureState(a, t1.id, i);
            }
            getFeatureState(t1) {
                if (this._checkLoaded(), "target" in t1) {
                    let i;
                    if ("featuresetId" in t1.target) {
                        const { featuresetId: o, importId: s } = t1.target, r = this.getFragmentStyle(s), a = r.getFeaturesetLayers(o);
                        for (const { source: o, sourceLayer: s } of a){
                            const a = r.getFeatureState({
                                id: t1.id,
                                source: o,
                                sourceLayer: s
                            });
                            if (a && !i) i = a;
                            else if (!e.bn(i, a)) return void this.fire(new e.y(new Error("The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.")));
                        }
                    } else if ("layerId" in t1.target) {
                        const { layerId: e } = t1.target, o = this.getLayer(e);
                        i = this.getFeatureState({
                            id: t1.id,
                            source: o.source,
                            sourceLayer: o.sourceLayer
                        });
                    }
                    return i;
                }
                const i = t1.source, o = t1.sourceLayer, s = this._checkSource(i);
                if (s) {
                    if ("vector" !== s.type || o) return void 0 === t1.id && this.fire(new e.y(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(i)[0].getFeatureState(o, t1.id);
                    this.fire(new e.y(new Error("The sourceLayer parameter must be provided for vector source types.")));
                }
            }
            setTransition(t1) {
                return this.stylesheet.transition = e.l({}, this.stylesheet.transition, t1), this.transition = this.stylesheet.transition, this;
            }
            getTransition() {
                return e.l({}, this.stylesheet.transition);
            }
            serialize() {
                this._checkLoaded();
                const t1 = this.getTerrain(), i = t1 && this.terrain && this.terrain.scope === this.scope ? t1 : this.stylesheet.terrain;
                return e.cv({
                    version: this.stylesheet.version,
                    name: this.stylesheet.name,
                    metadata: this.stylesheet.metadata,
                    fragment: this.stylesheet.fragment,
                    imports: this._serializeImports(),
                    schema: this.stylesheet.schema,
                    camera: this.stylesheet.camera,
                    light: this.stylesheet.light,
                    lights: this.stylesheet.lights,
                    terrain: i,
                    fog: this.stylesheet.fog,
                    snow: this.stylesheet.snow,
                    rain: this.stylesheet.rain,
                    center: this.stylesheet.center,
                    "color-theme": this.stylesheet["color-theme"],
                    zoom: this.stylesheet.zoom,
                    bearing: this.stylesheet.bearing,
                    pitch: this.stylesheet.pitch,
                    sprite: this.stylesheet.sprite,
                    glyphs: this.stylesheet.glyphs,
                    transition: this.stylesheet.transition,
                    projection: this.stylesheet.projection,
                    sources: this._serializeSources(),
                    layers: this._serializeLayers(this._order)
                }, (e)=>void 0 !== e);
            }
            _updateFilteredLayers(e) {
                for (const t1 of Object.values(this._mergedLayers))e(t1) && this._updateLayer(t1);
            }
            _updateLayer(t1) {
                this._changes.updateLayer(t1);
                const i = this.getLayerSourceCache(t1), o = e.aC(t1.source, t1.scope), s = this._changes.getUpdatedSourceCaches();
                t1.source && !s[o] && i && "raster" !== i.getSource().type && (this._changes.updateSourceCache(o, "reload"), i.pause()), t1.invalidateCompiledFilter();
            }
            _flattenAndSortRenderedFeatures(e) {
                const t1 = (e)=>this._mergedLayers[e].is3D(), i = this.order, o = {}, s = [];
                for(let r = i.length - 1; r >= 0; r--){
                    const a = i[r];
                    if (t1(a)) {
                        o[a] = r;
                        for (const t1 of e){
                            const e = t1[a];
                            if (e) for (const t1 of e)s.push(t1);
                        }
                    }
                }
                s.sort((e, t1)=>t1.intersectionZ - e.intersectionZ);
                const r = [];
                for(let a = i.length - 1; a >= 0; a--){
                    const n = i[a];
                    if (t1(n)) for(let e = s.length - 1; e >= 0; e--){
                        const t1 = s[e].feature;
                        if (t1.layer && o[t1.layer.id] < a) break;
                        r.push(t1), s.pop();
                    }
                    else for (const t1 of e){
                        const e = t1[n];
                        if (e) for (const t1 of e)r.push(t1.feature);
                    }
                }
                return r;
            }
            queryRenderedFeatures(t1, i, o) {
                let s;
                i && !Array.isArray(i) && i.filter && (this._validate(Se, "queryRenderedFeatures.filter", i.filter, null, i), s = e.aZ(i.filter));
                const r = {}, a = (e)=>{
                    if (vo.has(e.type)) return;
                    const t1 = this.getOwnLayerSourceCache(e), i = r[t1.id] = r[t1.id] || {
                        sourceCache: t1,
                        layers: {},
                        has3DLayers: !1
                    };
                    e.is3D() && (i.has3DLayers = !0), i.layers[e.fqid] = i.layers[e.fqid] || {
                        styleLayer: e,
                        targets: []
                    }, i.layers[e.fqid].targets.push({
                        filter: s
                    });
                };
                if (i && i.layers) {
                    if (!Array.isArray(i.layers)) return this.fire(new e.y(new Error("parameters.layers must be an Array."))), [];
                    for (const t1 of i.layers){
                        const i = this._layers[t1];
                        if (!i) return this.fire(new e.y(new Error(`The layer '${t1}' does not exist in the map's style and cannot be queried for features.`))), [];
                        a(i);
                    }
                } else for(const e in this._layers)a(this._layers[e]);
                const n = this._queryRenderedFeatures(t1, r, o), l = this._flattenAndSortRenderedFeatures(n), c = [];
                for (const t1 of l)e.cs(t1.layer.id) === this.scope && c.push(t1);
                return c;
            }
            queryRenderedFeatureset(t1, i, o) {
                let s;
                i && !Array.isArray(i) && i.filter && (this._validate(Se, "queryRenderedFeatures.filter", i.filter, null, i), s = e.aZ(i.filter));
                const r = "mock", a = [];
                if (i && i.target) a.push({
                    ...i,
                    targetId: r,
                    filter: s
                });
                else {
                    const e = this.getFeaturesetDescriptors();
                    for (const t1 of e)a.push({
                        targetId: r,
                        filter: s,
                        target: t1
                    });
                    for (const { style: e } of this.fragments){
                        const t1 = e.getFeaturesetDescriptors();
                        for (const e of t1)a.push({
                            targetId: r,
                            filter: s,
                            target: e
                        });
                    }
                }
                const n = this.queryRenderedTargets(t1, a, o), l = [];
                for (const t1 of n)for (const i of t1.variants[r])l.push(new e.cw(t1, i));
                return l;
            }
            queryRenderedTargets(t1, i, o) {
                const s = {}, r = (e, t1, i, o)=>{
                    const r = s[t1.id] = s[t1.id] || {
                        sourceCache: t1,
                        layers: {},
                        has3DLayers: !1
                    };
                    r.layers[e.fqid] = r.layers[e.fqid] || {
                        styleLayer: e,
                        targets: []
                    }, e.is3D() && (r.has3DLayers = !0), r.layers[e.fqid].targets.push(o ? {
                        ...i,
                        namespace: o.namespace,
                        properties: o.properties
                    } : i);
                };
                for (const t1 of i)if ("featuresetId" in t1.target) {
                    const { featuresetId: i, importId: o } = t1.target, s = this.getFragmentStyle(o), a = s.featuresetSelectors[i];
                    if (!a) {
                        this.fire(new e.y(new Error(`The featureset '${i}' does not exist in the map's style and cannot be queried for features.`)));
                        continue;
                    }
                    for (const e of a){
                        const i = s.getOwnLayer(e.layerId);
                        i && !vo.has(i.type) && r(i, s.getOwnLayerSourceCache(i), t1, e);
                    }
                } else if ("layerId" in t1.target) {
                    const { layerId: e } = t1.target, i = this.getLayer(e);
                    if (!i || vo.has(i.type)) continue;
                    r(i, this.getLayerSourceCache(i), t1);
                }
                const a = this._queryRenderedFeatures(t1, s, o);
                return this._flattenAndSortRenderedFeatures(a);
            }
            _queryRenderedFeatures(e, t1, i) {
                const o = [], s = !!this.map._showQueryGeometry, r = Xe.createFromScreenPoints(e, i);
                for(const e in t1){
                    const a = at(r, t1[e], this._availableImages, i, s);
                    Object.keys(a).length && o.push(a);
                }
                if (this.placement) for(const e in t1){
                    if (!t1[e].sourceCache._onlySymbols) continue;
                    const i = nt(r.screenGeometry, t1[e], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData);
                    Object.keys(i).length && o.push(i);
                }
                return o;
            }
            querySourceFeatures(e, t1) {
                const i = t1 && t1.filter;
                i && this._validate(Se, "querySourceFeatures.filter", i, null, t1);
                let o = [];
                const s = this.getOwnSourceCaches(e);
                for (const e of s)o = o.concat(lt(e, t1));
                return o;
            }
            addSourceType(e, t1, i) {
                return bo.getSourceType(e) ? i(new Error(`A source type called "${e}" already exists.`)) : (bo.setSourceType(e, t1), t1.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                    name: e,
                    url: t1.workerSourceURL
                }, i) : i(null, null));
            }
            getFlatLight() {
                return this.light.getLight();
            }
            setFlatLight(t1, i, o = {}) {
                this._checkLoaded();
                const s = this.light.getLight();
                let r = !1;
                for(const i in t1)if (!e.bn(t1[i], s[i])) {
                    r = !0;
                    break;
                }
                if (!r) return;
                const a = this._getTransitionParameters();
                this.light.setLight(t1, i, o), this.light.updateTransitions(a);
            }
            getTerrain() {
                return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
            }
            setTerrainForDraping() {
                this.setTerrain({
                    source: "",
                    exaggeration: 0
                }, 0);
            }
            checkCanvasFingerprintNoise() {
                void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e.q.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && e.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."));
            }
            setTerrain(t1, i = 1) {
                if (this._checkLoaded(), !t1) return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), 0 === i && delete this.terrain, null === t1 ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
                this.checkCanvasFingerprintNoise();
                let o = t1;
                const s = null == t1.source;
                if (1 === i) {
                    if (this.disableElevatedTerrain) return;
                    if ("object" == typeof o.source) {
                        const t1 = "terrain-dem-src";
                        this.addSource(t1, o.source), o = e.cp(o), o = e.l(o, {
                            source: t1
                        });
                    }
                    const t1 = e.l({}, o), i = {};
                    if (this.terrain && s) {
                        t1.source = this.terrain.get().source;
                        const e = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
                        e && (i.style = e.serialize());
                    }
                    if (this._validate(xe, "terrain", t1, i)) return;
                }
                if (!this.terrain || this.terrain.scope !== this.scope && !s || this.terrain && i !== this.terrain.drapeRenderMode) {
                    if (!o) return;
                    this._createTerrain(o, i), this.fire(new e.z("data", {
                        dataType: "style"
                    }));
                } else {
                    const i = this.terrain, s = i.get();
                    for (const t1 of Object.keys(e.a3.terrain))!o.hasOwnProperty(t1) && e.a3.terrain[t1].default && (o[t1] = e.a3.terrain[t1].default);
                    for(const o in t1)if (!e.bn(t1[o], s[o])) {
                        i.set(t1, this.options), this.stylesheet.terrain = t1;
                        const o = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(o), this.fire(new e.z("data", {
                            dataType: "style"
                        }));
                        break;
                    }
                }
                this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = !0;
            }
            _createFog(e) {
                const t1 = this.fog = new Ge(e, this.map.transform, this.scope, this.options);
                this.stylesheet.fog = t1.get();
                const i = this._getTransitionParameters({
                    duration: 0
                });
                t1.updateTransitions(i);
            }
            _createSnow(e) {
                const t1 = this.snow = new Ze(e, this.map.transform, this.scope, this.options);
                this.stylesheet.snow = t1.get();
                const i = this._getTransitionParameters({
                    duration: 0
                });
                t1.updateTransitions(i);
            }
            _createRain(e) {
                const t1 = this.rain = new We(e, this.map.transform, this.scope, this.options);
                this.stylesheet.rain = t1.get();
                const i = this._getTransitionParameters({
                    duration: 0
                });
                t1.updateTransitions(i);
            }
            _updateMarkersOpacity() {
                0 !== this.map._markers.length && this.map._requestDomTask(()=>{
                    for (const e of this.map._markers)e._evaluateOpacity();
                });
            }
            getFog() {
                return this.fog ? this.fog.get() : null;
            }
            setFog(t1) {
                if (this._checkLoaded(), !t1) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
                if (this.fog) {
                    const i = this.fog;
                    if (!e.bn(i.get(), t1)) {
                        i.set(t1, this.options), this.stylesheet.fog = i.get();
                        const e = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(e);
                    }
                } else this._createFog(t1);
                this._markersNeedUpdate = !0;
            }
            getSnow() {
                return this.snow ? this.snow.get() : null;
            }
            setSnow(t1) {
                if (this._checkLoaded(), !t1) return delete this.snow, void delete this.stylesheet.snow;
                if (this.snow) {
                    const i = this.snow;
                    if (!e.bn(i.get(), t1)) {
                        i.set(t1, this.options), this.stylesheet.snow = i.get();
                        const e = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(e);
                    }
                } else this._createSnow(t1);
                this._markersNeedUpdate = !0;
            }
            getRain() {
                return this.rain ? this.rain.get() : null;
            }
            setRain(t1) {
                if (this._checkLoaded(), !t1) return delete this.rain, void delete this.stylesheet.rain;
                if (this.rain) {
                    const i = this.rain;
                    if (!e.bn(i.get(), t1)) {
                        i.set(t1, this.options), this.stylesheet.rain = i.get();
                        const e = this._getTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(e);
                    }
                } else this._createRain(t1);
                this._markersNeedUpdate = !0;
            }
            _reloadColorTheme() {
                const t1 = ()=>{
                    for(const e in this._layers)this._layers[e].lut = this._styleColorTheme.lut;
                    for(const e in this._sourceCaches)this._sourceCaches[e].clearTiles();
                }, i = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
                if (!i) return this._styleColorTheme.lut = null, void t1();
                const o = this._evaluateColorThemeData(i);
                this._loadColorTheme(o).then(()=>{
                    this.fire(new e.z("colorthemeset")), t1();
                }).catch((t1)=>{
                    e.w(`Couldn't set color theme: ${t1}`);
                });
            }
            setColorTheme(t1) {
                this._checkLoaded(), this._styleColorTheme.colorThemeOverride && e.w("Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible."), this._styleColorTheme.colorTheme = t1, this._reloadColorTheme();
            }
            setImportColorTheme(e, t1) {
                const i = this.getFragmentStyle(e);
                i && (i._styleColorTheme.colorThemeOverride = t1, i._reloadColorTheme());
            }
            _getTransitionParameters(t1) {
                return {
                    now: e.q.now(),
                    transition: e.l(this.transition, t1)
                };
            }
            updateDrapeFirstLayers() {
                if (!this.terrain) return;
                const e = [], t1 = [];
                for (const i of this._mergedOrder)this.isLayerDraped(this._mergedLayers[i]) ? e.push(i) : t1.push(i);
                this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e), this._drapedFirstOrder.push(...t1);
            }
            _createTerrain(e, t1) {
                const i = this.terrain = new Pe(e, t1, this.scope, this.options);
                1 === t1 && (this.stylesheet.terrain = e), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
                const o = this._getTransitionParameters({
                    duration: 0
                });
                i.updateTransitions(o);
            }
            _force3DLayerUpdate() {
                for(const e in this._layers){
                    const t1 = this._layers[e];
                    "fill-extrusion" === t1.type && this._updateLayer(t1);
                }
            }
            _forceSymbolLayerUpdate() {
                for(const e in this._layers){
                    const t1 = this._layers[e];
                    "symbol" === t1.type && this._updateLayer(t1);
                }
            }
            _validate(t1, i, o, s, r = {}) {
                if (r && !1 === r.validate) return !1;
                const a = e.l({}, this.serialize());
                return fo(this, t1.call(me, e.l({
                    key: i,
                    style: a,
                    value: o,
                    styleSpec: e.a3
                }, s)));
            }
            _remove() {
                this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.cx.off("pluginStateChange", this._rtlTextPluginCallback);
                for(const e in this._mergedLayers)this._mergedLayers[e].setEventedParent(null);
                for(const e in this._mergedSourceCaches)this._mergedSourceCaches[e].clearTiles(), this._mergedSourceCaches[e].setEventedParent(null);
                this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());
            }
            clearSource(e) {
                const t1 = this.getSourceCaches(e);
                for (const e of t1)e.clearTiles();
            }
            clearSources() {
                for(const e in this._mergedSourceCaches)this._mergedSourceCaches[e].clearTiles();
            }
            reloadSource(e) {
                const t1 = this.getSourceCaches(e);
                for (const e of t1)e.resume(), e.reload();
            }
            reloadSources() {
                for (const e of this.getSources())e.reload && e.reload();
            }
            updateSources(e) {
                let t1;
                this.directionalLight && (t1 = so(this.directionalLight));
                for(const i in this._mergedSourceCaches)this._mergedSourceCaches[i].update(e, void 0, void 0, t1);
            }
            _generateCollisionBoxes() {
                for(const e in this._sourceCaches){
                    const t1 = this._sourceCaches[e];
                    t1.resume(), t1.reload();
                }
            }
            _updatePlacement(t1, i, o, s, r, a, n = !1) {
                let l = !1, c = !1;
                const h = {}, u = {};
                for (const t1 of this._mergedOrder){
                    const o = this._mergedLayers[t1];
                    if ("symbol" !== o.type) continue;
                    const s = e.aC(o.source, o.scope);
                    let r = h[s];
                    if (!r) {
                        const e = this.getLayerSourceCache(o);
                        if (!e) continue;
                        const t1 = e.getRenderableIds(!0).map((t1)=>e.getTileByID(t1));
                        u[s] = t1.slice(), r = h[s] = t1.sort((e, t1)=>t1.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t1.tileID) ? -1 : 1));
                    }
                    const a = this.crossTileSymbolIndex.addLayer(o, r, i.center.lng, i.projection);
                    l = l || a;
                }
                if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), n = n || this._layerOrderChanged || 0 === s, this._layerOrderChanged && this.fire(new e.z("neworder")), (n || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.q.now(), i.zoom)) && (this.pauseablePlacement = new Ri(i, this._mergedOrder, n, o, s, r, this.placement, this.fog && i.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, h, u, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.q.now()), c = !0), l && this.pauseablePlacement.placement.setStale()), c || l) {
                    this._buildingIndex.onNewFrame(i.zoom);
                    for(let t1 = 0; t1 < this._mergedOrder.length; t1++){
                        const i = this._mergedLayers[this._mergedOrder[t1]];
                        if ("symbol" !== i.type) continue;
                        const o = this.isLayerClipped(i);
                        this.placement.updateLayerOpacities(i, h[e.aC(i.source, i.scope)], t1, o ? a : null);
                    }
                }
                return {
                    needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.q.now())
                };
            }
            _releaseSymbolFadeTiles() {
                for(const e in this._sourceCaches)this._sourceCaches[e].releaseSymbolFadeTiles();
            }
            addImport(t1, i) {
                this._checkLoaded();
                const o = this.stylesheet.imports = this.stylesheet.imports || [];
                if (-1 !== o.findIndex(({ id: e })=>e === t1.id)) return void this.fire(new e.y(new Error(`Import with id '${t1.id}' already exists in the map's style.`)));
                if (!i) return o.push(t1), this._loadImports([
                    t1
                ], !0);
                const s = o.findIndex(({ id: e })=>e === i);
                return -1 === s && this.fire(new e.y(new Error(`Import with id "${i}" does not exist on this map.`))), this.stylesheet.imports = o.slice(0, s).concat(t1).concat(o.slice(s)), this._loadImports([
                    t1
                ], !0, i);
            }
            updateImport(t1, i) {
                this._checkLoaded();
                const o = this.stylesheet.imports || [], s = this.getImportIndex(t1);
                return -1 === s ? this : "string" == typeof i ? (this.setImportUrl(t1, i), this) : (i.url && i.url !== o[s].url && this.setImportUrl(t1, i.url), e.bn(i.config, o[s].config) || this.setImportConfig(t1, i.config), e.bn(i.data, o[s].data) || this.setImportData(t1, i.data), this);
            }
            moveImport(e, t1) {
                this._checkLoaded();
                let i = this.stylesheet.imports || [];
                const o = this.getImportIndex(e);
                if (-1 === o) return this;
                const s = this.getImportIndex(t1);
                if (-1 === s) return this;
                const r = i[o], a = this.fragments[o];
                return i = i.filter(({ id: t1 })=>t1 !== e), this.fragments = this.fragments.filter(({ id: t1 })=>t1 !== e), this.stylesheet.imports = i.slice(0, s).concat(r).concat(i.slice(s)), this.fragments = this.fragments.slice(0, s).concat(a).concat(this.fragments.slice(s)), this.mergeLayers(), this;
            }
            setImportUrl(e, t1) {
                this._checkLoaded();
                const i = this.stylesheet.imports || [], o = this.getImportIndex(e);
                if (-1 === o) return this;
                i[o].url = t1;
                const s = this.fragments[o];
                return s.style = this._createFragmentStyle(i[o]), s.style.on("style.import.load", ()=>this.mergeAll()), s.style.loadURL(t1), this;
            }
            setImportData(e, t1) {
                this._checkLoaded();
                const i = this.getImportIndex(e), o = this.stylesheet.imports || [];
                return -1 === i ? this : t1 ? (this.fragments[i].style.setState(t1), this._reloadImports(), this) : (delete o[i].data, this.setImportUrl(e, o[i].url));
            }
            setImportConfig(e, t1) {
                this._checkLoaded();
                const i = this.getImportIndex(e), o = this.stylesheet.imports || [];
                if (-1 === i) return this;
                t1 ? o[i].config = t1 : delete o[i].config;
                const s = this.fragments[i], r = s.style.stylesheet && s.style.stylesheet.schema;
                return s.config = t1, s.style.updateConfig(t1, r), this.updateConfigDependencies(), this;
            }
            removeImport(e) {
                this._checkLoaded();
                const t1 = this.stylesheet.imports || [], i = this.getImportIndex(e);
                -1 !== i && (t1.splice(i, 1), this.fragments[i].style._remove(), this.fragments.splice(i, 1), this._reloadImports());
            }
            getImportIndex(t1) {
                const i = (this.stylesheet.imports || []).findIndex((e)=>e.id === t1);
                return -1 === i && this.fire(new e.y(new Error(`Import '${t1}' does not exist in the map's style and cannot be updated.`))), i;
            }
            getLayer(e) {
                return this._mergedLayers[e];
            }
            getSources() {
                const e = [];
                for(const t1 in this._mergedOtherSourceCaches){
                    const i = this._mergedOtherSourceCaches[t1];
                    i && e.push(i.getSource());
                }
                return e;
            }
            getSource(e, t1) {
                const i = this.getSourceCache(e, t1);
                return i && i.getSource();
            }
            getLayerSource(e) {
                const t1 = this.getLayerSourceCache(e);
                return t1 && t1.getSource();
            }
            getSourceCache(t1, i) {
                const o = e.aC(t1, i);
                return this._mergedOtherSourceCaches[o];
            }
            getLayerSourceCache(t1) {
                const i = e.aC(t1.source, t1.scope);
                return "symbol" === t1.type ? this._mergedSymbolSourceCaches[i] : this._mergedOtherSourceCaches[i];
            }
            getSourceCaches(e) {
                if (null == e) return Object.values(this._mergedSourceCaches);
                const t1 = [];
                return this._mergedOtherSourceCaches[e] && t1.push(this._mergedOtherSourceCaches[e]), this._mergedSymbolSourceCaches[e] && t1.push(this._mergedSymbolSourceCaches[e]), t1;
            }
            updateSourceCaches() {
                const e = this._changes.getUpdatedSourceCaches();
                for(const t1 in e){
                    const i = e[t1];
                    "reload" === i ? this.reloadSource(t1) : "clear" === i && this.clearSource(t1);
                }
            }
            updateLayers(e) {
                const t1 = this._changes.getUpdatedPaintProperties();
                for (const i of t1){
                    const t1 = this.getLayer(i);
                    t1 && t1.updateTransitions(e);
                }
            }
            getImages(e, t1, i) {
                this.imageManager.getImages(t1.icons, t1.scope, i), this._updateTilesForChangedImages();
                const o = (e)=>{
                    e && e.setDependencies(t1.tileID.key, t1.type, t1.icons);
                };
                o(this._otherSourceCaches[t1.source]), o(this._symbolSourceCaches[t1.source]);
            }
            rasterizeImages(e, t1, i) {
                this.imageManager.rasterizeImages(t1, i);
            }
            getGlyphs(e, t1, i) {
                this.glyphManager.getGlyphs(t1.stacks, t1.scope, i);
            }
            getResource(t1, i, o) {
                return e.cy(i, o);
            }
            getOwnSourceCache(e) {
                return this._otherSourceCaches[e];
            }
            getOwnLayerSourceCache(e) {
                return "symbol" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source];
            }
            getOwnSourceCaches(e) {
                const t1 = [];
                return this._otherSourceCaches[e] && t1.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t1.push(this._symbolSourceCaches[e]), t1;
            }
            _isSourceCacheLoaded(t1) {
                const i = this.getOwnSourceCaches(t1);
                return 0 === i.length ? (this.fire(new e.y(new Error(`There is no source with ID '${t1}'`))), !1) : i.every((e)=>e.loaded());
            }
            has3DLayers() {
                return this._has3DLayers;
            }
            hasSymbolLayers() {
                return this._hasSymbolLayers;
            }
            hasCircleLayers() {
                return this._hasCircleLayers;
            }
            isLayerClipped(e, t1) {
                if (!this._clipLayerPresent && "fill-extrusion" !== e.type) return !1;
                const i = "fill-extrusion" === e.type && "building" === e.sourceLayer;
                if (e.is3D()) {
                    if (i || t1 && "batched-model" === t1.type) return !0;
                    if ("model" === e.type) return !0;
                } else if ("symbol" === e.type) return !0;
                return !1;
            }
            _clearWorkerCaches() {
                this.dispatcher.broadcast("clearCaches");
            }
            destroy() {
                this._clearWorkerCaches(), this.fragments.forEach((e)=>{
                    e.style._remove();
                }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
            }
        }
        bo.getSourceType = function(e) {
            return st[e];
        }, bo.setSourceType = function(e, t1) {
            st[e] = t1;
        }, bo.registerForPluginStateChange = e.ch;
        var wo = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif", To = "\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color,float height) {\n#ifdef INDICATOR_CUTOUT\nfloat verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}", Eo = "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}", So = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", Co = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nvec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }\n#endif\n#ifdef DEPTH_OCCLUSION\nuniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;\n#ifdef DEPTH_D24\nfloat unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}\n#else\nhighp float unpack_depth_rgba(vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;\n#ifdef DEPTH_D24\nfloat depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);\n#else\nfloat depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));\n#endif\nreturn coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;\n#ifdef DEPTH_D24\nhighp vec4 depth=vec4(\ntexture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r\n);depth=unpack_depth4(depth);\n#else\nhighp vec4 depth=vec4(\nunpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))\n);\n#endif\nreturn depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));\n#endif\nres+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}\n#else\nbool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }\n#endif//DEPTH_OCCLUSION", Io = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", Ro = "highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}\n#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {\n#ifdef FOG_DITHERING\nvec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);\n#else\nreturn color;\n#endif\n}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", Do = "#ifdef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif", Lo = "#ifdef RASTER_ARRAY\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}\n#endif\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}", Ao = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif//RENDER_SHADOWS", zo = "#ifdef RENDER_SHADOWS\n#ifdef DEPTH_TEXTURE\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\n#else\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\n#endif\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_1,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_0,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\n#ifdef TEXTURE_GATHER\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\n#else\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\n);\n#endif\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\n#ifdef SHADOWS_SINGLE_CASCADE\nlight_view_pos0.xyz/=light_view_pos0.w;vec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\n#else\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)\n{highp vec2 biasUV=vec2(\npos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
        const Po = [];
        No(wo, Po), No(Eo, Po), No(To, Po);
        const Mo = {
            "_prelude_fog.vertex.glsl": Io,
            "_prelude_terrain.vertex.glsl": Co,
            "_prelude_shadow.vertex.glsl": Ao,
            "_prelude_fog.fragment.glsl": Ro,
            "_prelude_shadow.fragment.glsl": zo,
            "_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif//LIGHTING_3D_MODE",
            "_prelude_raster_array.glsl": Do,
            "_prelude_raster_particle.glsl": Lo
        }, Oo = {};
        Uo("", Co), Uo(Ro, Io), Uo(zo, Ao), Uo(Do, ""), Uo(Lo, "");
        const Fo = Uo(To, Eo), ko = wo;
        var Bo = {
            background: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            backgroundPattern: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            circle: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float opacity_t=smoothstep((1.0-blur_positive)*antialiased_blur,blur_positive*antialiased_blur,extrude_length-1.0)-smoothstep(0.0,antialiasblur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'),
            clippingMask: Uo("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
            heatmap: Uo('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),
            heatmapTexture: Uo("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
            collisionBox: Uo("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", '#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'),
            collisionCircle: Uo("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
            debug: Uo("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", '#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'),
            fill: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=opacity;\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=z_offset;\n#endif\n}'),
            fillOutline: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nuniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fillOutlinePattern: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nin highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fillPattern: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;in highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            fillExtrusion: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nin float v_height;\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float emissive_strength\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor;\n#ifdef RENDER_CUTOFF\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\n#else\nshadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\n#endif\ncolor.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,h);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp float emissive_strength\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=cutoff_opacity(u_cutoff_params,ground.z);if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\ngl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'),
            fillExtrusionDepth: Uo("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nin vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp vec4 color\nout highp float v_depth;void main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp vec4 color\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'),
            fillExtrusionPattern: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\nin highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,height);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nout highp vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define highp float pixel_ratio\n#pragma mapbox: define highp float line_width\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize highp float pixel_ratio\n#pragma mapbox: initialize highp float line_width\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'),
            groundShadow: Uo('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);\n#endif\nglFragColor=vec4(shadow,1.0);}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'),
            fillExtrusionGroundEffect: Uo("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;\n#endif\nHANDLE_WIREFRAME_DEBUG;\n#endif\n}", '#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'),
            hillshadePrepare: Uo("precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
            hillshade: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'),
            line: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec4 v_uv;\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trim_alpha=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\nout_color.rgb*=mix(v_road_z_offset > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)\nin vec2 a_z_offset_width;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec4 v_uv;\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;\n#ifdef VARIABLE_LINE_WIDTH\nhalfwidth=(u_width_scale*a_z_offset_width.y)/2.0;\n#else\nhalfwidth=(u_width_scale*width)/2.0;\n#endif\noffset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset+0.01*step(0.01,a_z_offset),1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}'),
            linePattern: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef LINE_JOIN_NONE\nin vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nuniform float u_emissive_strength;\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define mediump float pixel_ratio\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize mediump float pixel_ratio\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}\n#endif\n#ifdef LINE_JOIN_NONE\nhighp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\n#endif\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_with_emission_ground(color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\ncolor.rgb*=mix(v_road_z_offset > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\ncolor.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,v_z_offset);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\nin vec2 a_z_offset_width;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec4 a_packed;\n#endif\nin highp float a_linesofar;\n#ifdef LINE_JOIN_NONE\nin highp vec3 a_pattern_data;out vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nout highp vec4 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\n#pragma mapbox: define mediump float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define mediump float floorwidth\n#pragma mapbox: define mediump vec4 pattern\n#pragma mapbox: define mediump float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\n#pragma mapbox: initialize mediump float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize mediump float pixel_ratio\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset+0.01*step(0.01,a_z_offset),1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nfloat a_uv_x=a_packed[0];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);\n#ifdef LINE_JOIN_NONE\nv_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}'),
            raster: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nin float v_split_fade;\n#endif\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;\n#ifdef GLOBE_POLES\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\n#endif\nvec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef PROJECTION_GLOBE_VIEW\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\n#endif\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nout float v_split_fade;\n#endif\nvoid main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'),
            rasterParticle: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'),
            rasterParticleDraw: Uo("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", '#include "_prelude_raster_particle.glsl"\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}'),
            rasterParticleTexture: Uo("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"),
            rasterParticleUpdate: Uo('#include "_prelude_raster_particle.glsl"\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(\nlinearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)\n);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}', "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"),
            symbol: Uo('#include "_prelude_lighting.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\n#ifdef COLOR_ADJUSTMENT\nuniform mat4 u_color_adj_mat;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\nin vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\nin float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nin float is_sdf;in vec2 v_tex_a_icon;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];\n#ifdef RENDER_TEXT_AND_SYMBOL\nif (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}\n#endif\n#ifdef RENDER_SDF\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;\n#else\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\n#else\nout_color=texture(u_texture,v_tex_a);\n#endif\n#ifdef COLOR_ADJUSTMENT\nout_color=u_color_adj_mat*out_color;\n#endif\n#endif\nout_color*=opacity*fade_opacity;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_auto_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\n#ifdef OCCLUSION_QUERIES\nin float a_occlusion_query_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nout float is_sdf;out vec2 v_tex_a_icon;\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\n#pragma mapbox: define lowp float occlusion_opacity\n#pragma mapbox: define lowp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\n#pragma mapbox: initialize lowp float occlusion_opacity\n#pragma mapbox: initialize lowp float z_offset\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_auto_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;\n#endif\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\n#ifdef Z_OFFSET\nz+=u_pitch_with_map ? a_auto_z_offset+(u_elevation_from_sea ? z_offset : z_offset) : 0.0;\n#else\nz+=u_pitch_with_map ? (u_elevation_from_sea ? z_offset : z_offset) : 0.0;\n#endif\nfloat occlusion_fade=globe_occlusion_fade;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;\n#ifdef DEPTH_OCCLUSION\nfloat depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;\n#endif\n#ifdef OCCLUSION_QUERIES\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;\n#endif\nfloat alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\n#endif\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;\n#ifdef RENDER_TEXT_AND_SYMBOL\nis_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;\n#endif\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=e;\n#endif\n}'),
            terrainRaster: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\n#endif\n}'),
            terrainDepth: Uo("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'),
            skybox: Uo('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', So),
            skyboxGradient: Uo('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', So),
            skyboxCapture: Uo("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
            globeRaster: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'),
            globeAtmosphere: Uo('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;\n#ifndef NATIVE\nc=dither(c,gl_FragCoord.xy+u_temporal_offset);\n#endif\nglFragColor=vec4(c*t,t);\n#endif\n}', "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"),
            model: Uo('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;\n#ifdef DEPTH_D24\nhighp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}\n#else\nhighp float unpack_depth_rgba(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depthTexture,coord).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));\n#endif\nreturn v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nvec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);\n#ifdef APPLY_LUT_ON_GPU\ncolor=applyLUT(u_lutTexture,color);\n#endif\nreturn color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\n#ifdef APPLY_LUT_ON_GPU\nfloat emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;\n#ifdef APPLY_LUT_ON_GPU\ncolor_mix=applyLUT(u_lutTexture,color_mix);\n#endif\ncolor=mix(color,color_mix,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor,v_position_height.w);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\n#endif\n}'),
            modelDepth: Uo("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"),
            stars: Uo("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}"),
            snowParticle: Uo("in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; \nuniform float u_horizontalOscillationRate; \nuniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}"),
            rainParticle: Uo("in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity; \nuniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; \npos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}"),
            vignette: Uo("uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}", "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}"),
            occlusion: Uo("uniform vec4 u_color;void main() {glFragColor=u_color;}", '#include "_prelude_terrain.vertex.glsl"\nin highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;\n#ifdef TERRAIN\nfloat e=elevation(world_pos.xy);world_pos.z+=e;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}')
        };
        function No(e, t1) {
            const i = e.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
            for (let e of i)if (e = e.trim(), "#" === e[0] && e.includes("if") && !e.includes("endif")) {
                e = e.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                const i = e.split(" ");
                for (const e of i)t1.includes(e) || t1.push(e);
            }
        }
        function Uo(e, t1) {
            const i = /#include\s+"([^"]+)"/g, o = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
            let s = t1.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
            s && (s = s.map((e)=>{
                const t1 = e.split(" ");
                return t1[t1.length - 1];
            }), s = [
                ...new Set(s)
            ]);
            const r = {}, a = [], n = [];
            if (e = e.replace(i, (e, t1)=>(n.push(t1), "")), (t1 = t1.replace(i, (e, t1)=>(a.push(t1), ""))).includes("flat out")) return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
            let l = [
                ...Po
            ];
            No(e, l), No(t1, l);
            for (const e of [
                ...a,
                ...n
            ])Mo[e] || console.error(`Undefined include: ${e}`), Oo[e] || (Oo[e] = [], No(Mo[e], Oo[e])), l = [
                ...l,
                ...Oo[e]
            ];
            return {
                fragmentSource: e = e.replace(o, (e, t1, i, o, s)=>(r[s] = !0, "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${s}\nin ${i} ${o} ${s};\n#else\nuniform ${i} ${o} u_${s};\n#endif\n` : "initialize" === t1 ? `\n#ifdef HAS_UNIFORM_u_${s}\n    ${i} ${o} ${s} = u_${s};\n#endif\n` : "define-attribute" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${s}\n    in ${i} ${o} ${s};\n#endif\n` : "initialize-attribute" === t1 ? "" : void 0)),
                vertexSource: t1 = t1.replace(o, (e, t1, i, o, s)=>{
                    const a = "float" === o ? "vec2" : o, n = s.match(/color/) ? "color" : a;
                    return "define-attribute-vertex-shader-only" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${s}\nin ${i} ${o} a_${s};\n#endif\n` : r[s] ? "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${s}\nuniform lowp float u_${s}_t;\nin ${i} ${a} a_${s};\nout ${i} ${o} ${s};\n#else\nuniform ${i} ${o} u_${s};\n#endif\n` : "initialize" === t1 ? "vec4" === n ? `\n#ifndef HAS_UNIFORM_u_${s}\n    ${s} = a_${s};\n#else\n    ${i} ${o} ${s} = u_${s};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${s}\n    ${s} = unpack_mix_${n}(a_${s}, u_${s}_t);\n#else\n    ${i} ${o} ${s} = u_${s};\n#endif\n` : "define-attribute" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${s}\n    in ${i} ${o} a_${s};\n    out ${i} ${o} ${s};\n#endif\n` : "initialize-attribute" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${s}\n    ${s} = a_${s};\n#endif\n` : void 0 : "define" === t1 ? `\n#ifndef HAS_UNIFORM_u_${s}\nuniform lowp float u_${s}_t;\nin ${i} ${a} a_${s};\n#else\nuniform ${i} ${o} u_${s};\n#endif\n` : "define-instanced" === t1 ? "mat4" === n ? `\n#ifdef INSTANCED_ARRAYS\nin vec4 a_${s}0;\nin vec4 a_${s}1;\nin vec4 a_${s}2;\nin vec4 a_${s}3;\n#else\nuniform ${i} ${o} u_${s};\n#endif\n` : `\n#ifdef INSTANCED_ARRAYS\nin ${i} ${a} a_${s};\n#else\nuniform ${i} ${o} u_${s};\n#endif\n` : "initialize-attribute-custom" === t1 ? `\n#ifdef HAS_ATTRIBUTE_a_${s}\n    ${i} ${o} ${s} = a_${s};\n#endif\n` : "vec4" === n ? `\n#ifndef HAS_UNIFORM_u_${s}\n    ${i} ${o} ${s} = a_${s};\n#else\n    ${i} ${o} ${s} = u_${s};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${s}\n    ${i} ${o} ${s} = unpack_mix_${n}(a_${s}, u_${s}_t);\n#else\n    ${i} ${o} ${s} = u_${s};\n#endif\n`;
                }),
                staticAttributes: s,
                usedDefines: l,
                vertexIncludes: a,
                fragmentIncludes: n
            };
        }
        class Go {
            constructor(){
                this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
            }
            bind(e, t1, i, o, s, r, a, n) {
                this.context = e;
                let l = this.boundPaintVertexBuffers.length !== o.length;
                for(let e = 0; !l && e < o.length; e++)this.boundPaintVertexBuffers[e] !== o[e] && (l = !0);
                let c = this.boundDynamicVertexBuffers.length !== a.length;
                for(let e = 0; !c && e < a.length; e++)this.boundDynamicVertexBuffers[e] !== a[e] && (c = !0);
                if (!this.vao || this.boundProgram !== t1 || this.boundLayoutVertexBuffer !== i || l || c || this.boundIndexBuffer !== s || this.boundVertexOffset !== r) this.freshBind(t1, i, o, s, r, a, n);
                else {
                    e.bindVertexArrayOES.set(this.vao);
                    for (const i of a)i && (i.bind(), n && i.instanceCount && i.setVertexAttribDivisor(e.gl, t1, n));
                    s && s.dynamicDraw && s.bind();
                }
            }
            freshBind(e, t1, i, o, s, r, a) {
                const n = e.numAttributes, l = this.context, c = l.gl;
                this.vao && this.destroy(), this.vao = l.gl.createVertexArray(), l.bindVertexArrayOES.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = t1, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = s, this.boundDynamicVertexBuffers = r, t1.enableAttributes(c, e), t1.bind(), t1.setVertexAttribPointers(c, e, s);
                for (const t1 of i)t1.enableAttributes(c, e), t1.bind(), t1.setVertexAttribPointers(c, e, s);
                for (const t1 of r)t1 && (t1.enableAttributes(c, e), t1.bind(), t1.setVertexAttribPointers(c, e, s), a && t1.instanceCount && t1.setVertexAttribDivisor(c, e, a));
                o && o.bind(), l.currentNumAttributes = n;
            }
            destroy() {
                this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
            }
        }
        function jo(t1, i) {
            const o = Math.pow(2, i.canonical.z), s = i.canonical.y;
            return [
                new e.aa(0, s / o).toLngLat().lat,
                new e.aa(0, (s + 1) / o).toLngLat().lat
            ];
        }
        function Vo(t1, i, o, s, r, a, n) {
            const l = t1.context, c = l.gl, h = o.hillshadeFBO;
            if (!h) return;
            t1.prepareDrawTile();
            const u = t1.isTileAffectedByFog(i), d = t1.getOrCreateProgram("hillshade", {
                overrideFog: u
            });
            l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());
            const _ = ((t1, i, o, s)=>{
                const r = o.paint.get("hillshade-shadow-color"), a = "none" === o.paint.get("hillshade-shadow-color-use-theme").constantOr("default"), n = o.paint.get("hillshade-highlight-color"), l = "none" === o.paint.get("hillshade-highlight-color-use-theme").constantOr("default"), c = o.paint.get("hillshade-accent-color"), h = "none" === o.paint.get("hillshade-accent-color-use-theme").constantOr("default"), u = o.paint.get("hillshade-emissive-strength");
                let d = e.ai(o.paint.get("hillshade-illumination-direction"));
                if ("viewport" === o.paint.get("hillshade-illumination-anchor")) d -= t1.transform.angle;
                else if (t1.style && t1.style.enable3dLights() && t1.style.directionalLight) {
                    const i = t1.style.directionalLight.properties.get("direction"), o = e.cb(i.x, i.y, i.z);
                    d = e.ai(o[1]);
                }
                const _ = !t1.options.moving;
                return {
                    u_matrix: s || t1.transform.calculateProjMatrix(i.tileID.toUnwrapped(), _),
                    u_image: 0,
                    u_latrange: jo(0, i.tileID),
                    u_light: [
                        o.paint.get("hillshade-exaggeration"),
                        d
                    ],
                    u_shadow: r.toRenderColor(a ? null : o.lut),
                    u_highlight: n.toRenderColor(l ? null : o.lut),
                    u_emissive_strength: u,
                    u_accent: c.toRenderColor(h ? null : o.lut)
                };
            })(t1, o, s, t1.terrain ? i.projMatrix : null);
            t1.uploadCommonUniforms(l, d, i.toUnwrapped());
            const { tileBoundsBuffer: p, tileBoundsIndexBuffer: f, tileBoundsSegments: m } = t1.getTileBoundsBuffers(o);
            d.draw(t1, c.TRIANGLES, r, a, n, Gi.disabled, _, s.id, p, f, m);
        }
        function qo(t1, i, o) {
            if (!i.needsDEMTextureUpload) return;
            const s = t1.context, r = s.gl;
            s.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || t1.getTileTexture(o.stride);
            const a = o.getPixels();
            i.demTexture ? i.demTexture.update(a, {
                premultiply: !1
            }) : i.demTexture = new e.T(s, a, r.R32F, {
                premultiply: !1
            }), i.needsDEMTextureUpload = !1;
        }
        function Ho(t1, i, o) {
            const s = t1.context, r = s.gl;
            if (!i.dem) return;
            const a = i.dem;
            if (s.activeTexture.set(r.TEXTURE1), qo(t1, i, a), !i.demTexture) return;
            i.demTexture.bind(r.NEAREST, r.CLAMP_TO_EDGE);
            const n = a.dim;
            s.activeTexture.set(r.TEXTURE0);
            let l = i.hillshadeFBO;
            if (!l) {
                const t1 = new e.T(s, {
                    width: n,
                    height: n,
                    data: null
                }, r.RGBA8);
                t1.bind(r.LINEAR, r.CLAMP_TO_EDGE), l = i.hillshadeFBO = s.createFramebuffer(n, n, !0, "renderbuffer"), l.colorAttachment.set(t1.texture);
            }
            s.bindFramebuffer.set(l.framebuffer), s.viewport.set([
                0,
                0,
                n,
                n
            ]);
            const { tileBoundsBuffer: c, tileBoundsIndexBuffer: h, tileBoundsSegments: u } = t1.getMercatorTileBoundsBuffers(), d = [];
            t1.linearFloatFilteringSupported() && d.push("TERRAIN_DEM_FLOAT_FORMAT"), t1.getOrCreateProgram("hillshadePrepare", {
                defines: d
            }).draw(t1, r.TRIANGLES, Fi.disabled, Bi.disabled, Oi.unblended, Gi.disabled, ((t1, i)=>{
                const o = i.stride, s = e.ab.mat4.create();
                return e.ab.mat4.ortho(s, 0, e.ag, -e.ag, 0, 0, 1), e.ab.mat4.translate(s, s, [
                    0,
                    -e.ag,
                    0
                ]), {
                    u_matrix: s,
                    u_image: 1,
                    u_dimension: [
                        o,
                        o
                    ],
                    u_zoom: t1.overscaledZ
                };
            })(i.tileID, a), o.id, c, h, u), i.needsHillshadePrepare = !1;
        }
        class Zo {
            constructor(e){
                this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
            }
            get() {
                return this.current;
            }
            set(e) {}
            getDefault() {
                return this.default;
            }
            setDefault() {
                this.set(this.default);
            }
        }
        class Wo extends Zo {
            getDefault() {
                return e.aj.transparent;
            }
            set(e) {
                const t1 = this.current;
                (e.r !== t1.r || e.g !== t1.g || e.b !== t1.b || e.a !== t1.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
            }
        }
        class $o extends Zo {
            getDefault() {
                return 1;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);
            }
        }
        class Xo extends Zo {
            getDefault() {
                return 0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);
            }
        }
        class Ko extends Zo {
            getDefault() {
                return [
                    !0,
                    !0,
                    !0,
                    !0
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || e[3] !== t1[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }
        class Yo extends Zo {
            getDefault() {
                return !0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);
            }
        }
        class Jo extends Zo {
            getDefault() {
                return 255;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);
            }
        }
        class Qo extends Zo {
            getDefault() {
                return {
                    func: this.gl.ALWAYS,
                    ref: 0,
                    mask: 255
                };
            }
            set(e) {
                const t1 = this.current;
                (e.func !== t1.func || e.ref !== t1.ref || e.mask !== t1.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);
            }
        }
        class es extends Zo {
            getDefault() {
                const e = this.gl;
                return [
                    e.KEEP,
                    e.KEEP,
                    e.KEEP
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);
            }
        }
        class ts extends Zo {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.STENCIL_TEST) : t1.disable(t1.STENCIL_TEST), this.current = e, this.dirty = !1;
            }
        }
        class is extends Zo {
            getDefault() {
                return [
                    0,
                    1
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);
            }
        }
        class os extends Zo {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.DEPTH_TEST) : t1.disable(t1.DEPTH_TEST), this.current = e, this.dirty = !1;
            }
        }
        class ss extends Zo {
            getDefault() {
                return this.gl.LESS;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);
            }
        }
        class rs extends Zo {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.BLEND) : t1.disable(t1.BLEND), this.current = e, this.dirty = !1;
            }
        }
        class as extends Zo {
            getDefault() {
                const e = this.gl;
                return [
                    e.ONE,
                    e.ZERO,
                    e.ONE,
                    e.ZERO
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || e[3] !== t1[3] || this.dirty) && (this.gl.blendFuncSeparate(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }
        class ns extends Zo {
            getDefault() {
                return e.aj.transparent;
            }
            set(e) {
                const t1 = this.current;
                (e.r !== t1.r || e.g !== t1.g || e.b !== t1.b || e.a !== t1.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);
            }
        }
        class ls extends Zo {
            getDefault() {
                return this.gl.FUNC_ADD;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e, e), this.current = e, this.dirty = !1);
            }
        }
        class cs extends Zo {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                e ? t1.enable(t1.CULL_FACE) : t1.disable(t1.CULL_FACE), this.current = e, this.dirty = !1;
            }
        }
        class hs extends Zo {
            getDefault() {
                return this.gl.BACK;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);
            }
        }
        class us extends Zo {
            getDefault() {
                return this.gl.CCW;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);
            }
        }
        let ds = class extends Zo {
            getDefault() {
                return null;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);
            }
        };
        class _s extends Zo {
            getDefault() {
                return this.gl.TEXTURE0;
            }
            set(e) {
                (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);
            }
        }
        class ps extends Zo {
            getDefault() {
                const e = this.gl;
                return [
                    0,
                    0,
                    e.drawingBufferWidth,
                    e.drawingBufferHeight
                ];
            }
            set(e) {
                const t1 = this.current;
                (e[0] !== t1[0] || e[1] !== t1[1] || e[2] !== t1[2] || e[3] !== t1[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);
            }
        }
        class fs extends Zo {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindFramebuffer(t1.FRAMEBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class ms extends Zo {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindRenderbuffer(t1.RENDERBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class gs extends Zo {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindTexture(t1.TEXTURE_2D, e), this.current = e, this.dirty = !1;
            }
        }
        class vs extends Zo {
            getDefault() {
                return null;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.bindBuffer(t1.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class ys extends Zo {
            getDefault() {
                return null;
            }
            set(e) {
                const t1 = this.gl;
                t1.bindBuffer(t1.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class xs extends Zo {
            getDefault() {
                return null;
            }
            set(e) {
                this.gl && (e !== this.current || this.dirty) && (this.gl.bindVertexArray(e), this.current = e, this.dirty = !1);
            }
        }
        class bs extends Zo {
            getDefault() {
                return 4;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;
            }
        }
        class ws extends Zo {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;
            }
        }
        class Ts extends Zo {
            getDefault() {
                return !1;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                const t1 = this.gl;
                t1.pixelStorei(t1.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;
            }
        }
        class Es extends Zo {
            constructor(e, t1){
                super(e), this.context = e, this.parent = t1;
            }
            getDefault() {
                return null;
            }
        }
        class Ss extends Es {
            setDirty() {
                this.dirty = !0;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferTexture2D(t1.FRAMEBUFFER, t1.COLOR_ATTACHMENT0, t1.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
            }
        }
        class Cs extends Es {
            attachment() {
                return this.gl.DEPTH_ATTACHMENT;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferRenderbuffer(t1.FRAMEBUFFER, this.attachment(), t1.RENDERBUFFER, e), this.current = e, this.dirty = !1;
            }
        }
        class Is extends Es {
            attachment() {
                return this.gl.DEPTH_ATTACHMENT;
            }
            set(e) {
                if (e === this.current && !this.dirty) return;
                this.context.bindFramebuffer.set(this.parent);
                const t1 = this.gl;
                t1.framebufferTexture2D(t1.FRAMEBUFFER, this.attachment(), t1.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;
            }
        }
        class Rs extends Cs {
            attachment() {
                return this.gl.DEPTH_STENCIL_ATTACHMENT;
            }
        }
        const Ds = (e, t1, i)=>({
                u_matrix: e,
                u_image0: 0,
                u_skirt_height: t1,
                u_ground_shadow_factor: i
            }), Ls = (e, t1, i, o, s, r, a, n, l, c, h, u, d, _, p, f)=>({
                u_proj_matrix: Float32Array.from(e),
                u_globe_matrix: t1,
                u_normalize_matrix: Float32Array.from(o),
                u_merc_matrix: i,
                u_zoom_transition: s,
                u_merc_center: r,
                u_image0: 0,
                u_frustum_tl: a,
                u_frustum_tr: n,
                u_frustum_br: l,
                u_frustum_bl: c,
                u_globe_pos: h,
                u_globe_radius: u,
                u_viewport: d,
                u_grid_matrix: f ? Float32Array.from(f) : new Float32Array(9),
                u_skirt_height: _,
                u_far_z_cutoff: p
            });
        function As(e, t1) {
            return null != e && null != t1 && !(!e.hasData() || !t1.hasData()) && null != e.demTexture && null != t1.demTexture && e.tileID.key !== t1.tileID.key;
        }
        const zs = new class {
            constructor(){
                this.operations = {};
            }
            newMorphing(e, t1, i, o, s) {
                if (e in this.operations) {
                    const t1 = this.operations[e];
                    t1.to.tileID.key !== i.tileID.key && (t1.queued = i);
                } else this.operations[e] = {
                    startTime: o,
                    phase: 0,
                    duration: s,
                    from: t1,
                    to: i,
                    queued: null
                };
            }
            getMorphValuesForProxy(e) {
                if (!(e in this.operations)) return null;
                const t1 = this.operations[e];
                return {
                    from: t1.from,
                    to: t1.to,
                    phase: t1.phase
                };
            }
            update(e) {
                for(const t1 in this.operations){
                    const i = this.operations[t1];
                    for(i.phase = (e - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i);)if (!this._nextOp(i, e)) {
                        delete this.operations[t1];
                        break;
                    }
                }
            }
            _nextOp(e, t1) {
                return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t1, !0);
            }
            _validOp(e) {
                return e.from.hasData() && e.to.hasData();
            }
        }, Ps = {
            0: null,
            1: "TERRAIN_VERTEX_MORPHING"
        };
        function Ms(e, t1, i) {
            if (0 === t1) return 0;
            const o = t1 < 1 && 514 === i ? .25 / t1 : 1;
            return 6 * Math.pow(1.5, 22 - e) * Math.max(t1, 1) * o;
        }
        function Os(e, t1) {
            const i = 1 << e.z;
            return !t1 && (0 === e.x || e.x === i - 1) || 0 === e.y || e.y === i - 1;
        }
        const Fs = (e)=>({
                u_matrix: e
            });
        function ks(t1, i, o, s, r) {
            if (r > 0) {
                const a = e.q.now(), n = (a - t1.timeAdded) / r, l = i ? (a - i.timeAdded) / r : -1, c = o.getSource(), h = s.coveringZoomLevel({
                    tileSize: c.tileSize,
                    roundZoom: c.roundZoom
                }), u = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(t1.tileID.overscaledZ - h), d = u && t1.refreshedUponExpiration ? 1 : e.aw(u ? n : 1 - l, 0, 1);
                return t1.refreshedUponExpiration && n >= 1 && (t1.refreshedUponExpiration = !1), i ? {
                    opacity: 1,
                    mix: 1 - d
                } : {
                    opacity: d,
                    mix: 0
                };
            }
            return {
                opacity: 1,
                mix: 0
            };
        }
        class Bs extends Tt {
            constructor(t1){
                const i = {
                    type: "raster-dem",
                    maxzoom: t1.transform.maxZoom
                }, o = new e.D(e.ci(), null), s = rt("mock-dem", i, o, t1.style);
                super("mock-dem", s, !1), s.setEventedParent(this), this._sourceLoaded = !0;
            }
            _loadTile(e, t1) {
                e.state = "loaded", t1(null);
            }
        }
        class Ns extends Tt {
            constructor(t1){
                const i = rt("proxy", {
                    type: "geojson",
                    maxzoom: t1.transform.maxZoom
                }, new e.D(e.ci(), null), t1.style);
                super("proxy", i, !1), i.setEventedParent(this), this.map = this.getSource().map = t1, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
            update(e, t1, i) {
                if (e.freezeTileCoverage) return;
                this.transform = e;
                const o = e.coveringTiles({
                    tileSize: this._source.tileSize,
                    minzoom: this._source.minzoom,
                    maxzoom: this._source.maxzoom,
                    roundZoom: this._source.roundZoom,
                    reparseOverscaled: this._source.reparseOverscaled
                }).reduce((t1, i)=>{
                    if (t1[i.key] = "", !this._tiles[i.key]) {
                        const t1 = new yt(i, this._source.tileSize * i.overscaleFactor(), e.tileZoom);
                        t1.state = "loaded", this._tiles[i.key] = t1;
                    }
                    return t1;
                }, {});
                for(const e in this._tiles)e in o || (this.freeFBO(e), this._tiles[e].unloadVectorData(), delete this._tiles[e]);
            }
            freeFBO(e) {
                const t1 = this.proxyCachedFBO[e];
                if (void 0 !== t1) {
                    const i = Object.values(t1);
                    this.renderCachePool.push(...i), delete this.proxyCachedFBO[e];
                }
            }
            deallocRenderCache() {
                this.renderCache.forEach((e)=>e.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
        }
        class Us extends e.aG {
            constructor(e, t1, i){
                super(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y), this.proxyTileKey = t1, this.projMatrix = i;
            }
        }
        class Gs extends e.cJ {
            constructor(t1, i){
                super(), this._debugParams = {
                    sortTilesHiZFirst: !0,
                    disableRenderCache: !1
                }, t1.tp.registerParameter(this._debugParams, [
                    "Terrain"
                ], "sortTilesHiZFirst", {}, ()=>{
                    this._style.map.triggerRepaint();
                }), t1.tp.registerParameter(this._debugParams, [
                    "Terrain"
                ], "disableRenderCache", {}, ()=>{
                    this._style.map.triggerRepaint();
                }), t1.tp.registerButton([
                    "Terrain"
                ], "Invalidate Render Cache", ()=>{
                    this.invalidateRenderCache = !0, this._style.map.triggerRepaint();
                }), this.painter = t1, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
                const [o, s, r] = function(t1) {
                    const i = new e.b4, o = new e.aU, s = 131;
                    i.reserve(17161), o.reserve(33800);
                    const r = e.ag / 128, a = e.ag + r / 2, n = a + r;
                    for(let t1 = -r; t1 < n; t1 += r)for(let o = -r; o < n; o += r){
                        const s = o < 0 || o > a || t1 < 0 || t1 > a ? 24575 : 0, r = e.aw(Math.round(o), 0, e.ag), n = e.aw(Math.round(t1), 0, e.ag);
                        i.emplaceBack(r + s, n);
                    }
                    const l = (e, t1)=>{
                        const i = t1 * s + e;
                        o.emplaceBack(i + 1, i, i + s), o.emplaceBack(i + s, i + s + 1, i + 1);
                    };
                    for(let e = 1; e < 129; e++)for(let t1 = 1; t1 < 129; t1++)l(t1, e);
                    return [
                        0,
                        129
                    ].forEach((e)=>{
                        for(let t1 = 0; t1 < 130; t1++)l(t1, e), l(e, t1);
                    }), [
                        i,
                        o,
                        32768
                    ];
                }(), a = t1.context;
                this.gridBuffer = a.createVertexBuffer(o, e.b6.members), this.gridIndexBuffer = a.createIndexBuffer(s), this.gridSegments = e.b7.simpleSegment(0, 0, o.length, s.length), this.gridNoSkirtSegments = e.b7.simpleSegment(0, 0, o.length, r), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Ns(i.map), this.orthoMatrix = e.ab.mat4.create(), e.ab.mat4.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? .015 : 0, e.ag, 0, e.ag, 0, 1);
                const n = a.gl;
                this._overlapStencilMode = new Bi({
                    func: n.GEQUAL,
                    mask: 255
                }, 0, 255, n.KEEP, n.KEEP, n.REPLACE), this._previousZoom = t1.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new Bs(i.map), this._pendingGroundEffectLayers = [];
            }
            set style(e) {
                e.on("data", this._onStyleDataEvent.bind(this)), this._style = e, this._style.map.on("moveend", ()=>{
                    this._clearLineLayersFromRenderCache();
                });
            }
            update(t1, i, o) {
                if (t1 && t1.terrain) {
                    this._style !== t1 && (this.style = t1, this._evaluationZoom = void 0);
                    const s = t1.terrain.properties, r = 0 === t1.terrain.drapeRenderMode, a = t1.terrain.isZoomDependent();
                    this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e.q.now();
                    const n = t1.terrain && t1.terrain.scope, l = s.get("source"), c = r ? this._mockSourceCache : t1.getSourceCache(l, n);
                    if (!c) return void e.w(`Couldn't find terrain source "${l}".`);
                    if (this.sourceCache = c, this._attenuationRange = t1.terrain.getAttenuationRange(), this._exaggeration = a ? this.calculateExaggeration(i) : s.get("exaggeration"), !i.projection.requiresDraping && a && 0 === this._exaggeration) return void this._disable();
                    this.enabled = !0;
                    const h = ()=>{
                        this.sourceCache.used && e.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                        const t1 = this.getScaledDemTileSize();
                        this.sourceCache.update(i, t1, !0), this.resetTileLookupCache(this.sourceCache.id);
                    };
                    this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, h(), this._initializing = !0), h(), i.updateElevation(!0, o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0, this._previousZoom = i.zoom;
                } else this._disable();
            }
            calculateExaggeration(t1) {
                if (this._attenuationRange && t1.zoom >= Math.ceil(this._attenuationRange[1])) return this._style.terrain.getExaggeration(t1.zoom);
                const i = this._previousCameraAltitude, o = t1.getFreeCameraOptions().position.z / t1.pixelsPerMeter * t1.worldSize;
                this._previousCameraAltitude = o;
                const s = null != i ? o - i : Number.MAX_VALUE;
                if (Math.abs(s) < 2) return this._exaggeration;
                const r = t1.zoom, a = this._style.terrain;
                if (!this._previousUpdateTimestamp) return a.getExaggeration(r);
                let n = r - this._previousZoom;
                const l = this._previousUpdateTimestamp;
                let c = r;
                null != this._evaluationZoom && (c = this._evaluationZoom, Math.abs(r - c) > .5 && (n = .5 * (r - c + n)), n * s < 0 && (c += n)), this._evaluationZoom = c;
                const h = a.getExaggeration(c), u = h === a.getExaggeration(Math.max(0, c - .1));
                if (u && Math.abs(h - this._exaggeration) < .01) return h;
                let d = Math.min(.1, .00375 * (this._updateTimestamp - l));
                return (u || h < .1 || Math.abs(n) < 1e-4) && (d = Math.min(.2, 4 * d)), e.af(this._exaggeration, h, d);
            }
            resetTileLookupCache(e) {
                this._findCoveringTileCache[e] = {};
            }
            attenuationRange() {
                return this._attenuationRange;
            }
            getDemUpscale() {
                return this.proxySourceCache.getSource().tileSize / 128;
            }
            getScaledDemTileSize() {
                return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
            }
            _onStyleDataEvent(e) {
                e.coord && "source" === e.dataType ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : "style" === e.dataType && (this.invalidateRenderCache = !0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
            }
            _disable() {
                if (this.enabled && (this.enabled = !1, this._emptyDEMTextureDirty = !0, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for(const e in this._style._mergedSourceCaches)this._style._mergedSourceCaches[e].usedForTerrain = !1;
            }
            destroy() {
                this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach((e)=>e.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
            }
            _source() {
                return this.enabled ? this.sourceCache : null;
            }
            isUsingMockSource() {
                return this.sourceCache === this._mockSourceCache;
            }
            exaggeration() {
                return this.enabled ? this._exaggeration : 0;
            }
            get visibleDemTiles() {
                return this._visibleDemTiles;
            }
            get drapeBufferSize() {
                const e = 2 * this.proxySourceCache.getSource().tileSize;
                return [
                    e,
                    e
                ];
            }
            set useVertexMorphing(e) {
                this._useVertexMorphing = e;
            }
            updateTileBinding(t1) {
                if (!this.enabled) return;
                this.prevTerrainTileForTile = this.terrainTileForTile;
                const i = this.proxySourceCache, o = this.painter.transform;
                this._initializing && (this._initializing = 0 === o._centerAltitude && -1 === this.getAtPointOrZero(e.aa.fromLngLat(o.center), -1), this._emptyDEMTextureDirty = !this._initializing);
                const s = this.proxyCoords = i.getIds().map((e)=>{
                    const t1 = i.getTileByID(e).tileID;
                    return t1.projMatrix = o.calculateProjMatrix(t1.toUnwrapped()), t1;
                });
                !function(t1, i) {
                    const o = i.transform.pointCoordinate(i.transform.getCameraPoint()), s = new e.P(o.x, o.y);
                    t1.sort((t1, i)=>{
                        if (i.overscaledZ - t1.overscaledZ) return i.overscaledZ - t1.overscaledZ;
                        const o = new e.P(t1.canonical.x + (1 << t1.canonical.z) * t1.wrap, t1.canonical.y), r = new e.P(i.canonical.x + (1 << i.canonical.z) * i.wrap, i.canonical.y), a = s.mult(1 << t1.canonical.z);
                        return a.x -= .5, a.y -= .5, a.distSqr(o) - a.distSqr(r);
                    });
                }(s, this.painter);
                const r = this.proxyToSource || {};
                this.proxyToSource = {}, s.forEach((e)=>{
                    this.proxyToSource[e.key] = {};
                }), this.terrainTileForTile = {};
                const a = this._style._mergedSourceCaches;
                for(const e in a){
                    const i = a[e];
                    if (!i.used) continue;
                    if (i !== this.sourceCache && this.resetTileLookupCache(i.id), this._setupProxiedCoordsForOrtho(i, t1[e], r), i.usedForTerrain) continue;
                    const o = t1[e];
                    i.getSource().reparseOverscaled && this._assignTerrainTiles(o);
                }
                this.proxiedCoords[i.id] = s.map((e)=>new Us(e, e.key, this.orthoMatrix)), this._assignTerrainTiles(s), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(r), this.renderingToTexture = !1;
                const n = {};
                this._visibleDemTiles = [];
                for (const e of this.proxyCoords){
                    const t1 = this.terrainTileForTile[e.key];
                    if (!t1) continue;
                    const i = t1.tileID.key;
                    i in n || (this._visibleDemTiles.push(t1), n[i] = i);
                }
            }
            _assignTerrainTiles(e) {
                this._initializing || e.forEach((e)=>{
                    if (this.terrainTileForTile[e.key]) return;
                    const t1 = this._findTileCoveringTileID(e, this.sourceCache);
                    t1 && (this.terrainTileForTile[e.key] = t1);
                });
            }
            _prepareDEMTextures() {
                const e = this.painter.context, t1 = e.gl;
                for(const i in this.terrainTileForTile){
                    const o = this.terrainTileForTile[i], s = o.dem;
                    !s || o.demTexture && !o.needsDEMTextureUpload || (e.activeTexture.set(t1.TEXTURE1), qo(this.painter, o, s));
                }
            }
            _prepareDemTileUniforms(e, t1, i, o) {
                if (!t1 || null == t1.demTexture) return !1;
                const s = e.tileID.canonical, r = Math.pow(2, t1.tileID.canonical.z - s.z), a = o || "";
                return i[`u_dem_tl${a}`] = [
                    s.x * r % 1,
                    s.y * r % 1
                ], i[`u_dem_scale${a}`] = r, !0;
            }
            get emptyDEMTexture() {
                return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
            }
            _getLoadedAreaMinimum() {
                if (!this.enabled) return 0;
                let e = 0;
                const t1 = this._visibleDemTiles.reduce((t1, i)=>{
                    if (!i.dem) return t1;
                    const o = i.dem.tree.minimums[0];
                    return o > 0 && e++, t1 + o;
                }, 0);
                return e ? t1 / e : 0;
            }
            _updateEmptyDEMTexture() {
                const t1 = this.painter.context, i = t1.gl;
                t1.activeTexture.set(i.TEXTURE2);
                const o = this._getLoadedAreaMinimum(), s = new e.cK({
                    width: 1,
                    height: 1
                }, new Float32Array([
                    o
                ]));
                this._emptyDEMTextureDirty = !1;
                let r = this._emptyDEMTexture;
                return r ? r.update(s, {
                    premultiply: !1
                }) : r = this._emptyDEMTexture = new e.T(t1, s, i.R32F, {
                    premultiply: !1
                }), r;
            }
            setupElevationDraw(t1, i, o) {
                const s = this.painter.context, r = s.gl, a = {
                    u_dem: 2,
                    u_dem_prev: 4,
                    u_dem_tl: [
                        0,
                        0
                    ],
                    u_dem_tl_prev: [
                        0,
                        0
                    ],
                    u_dem_scale: 0,
                    u_dem_scale_prev: 0,
                    u_dem_size: 0,
                    u_dem_lerp: 1,
                    u_depth: 3,
                    u_depth_size_inv: [
                        0,
                        0
                    ],
                    u_depth_range_unpack: [
                        0,
                        1
                    ],
                    u_occluder_half_size: 16,
                    u_occlusion_depth_offset: -1e-4,
                    u_exaggeration: 0
                };
                a.u_exaggeration = this.exaggeration();
                let n = null, l = null, c = 1;
                if (o && o.morphing && this._useVertexMorphing) {
                    const e = o.morphing.srcDemTile, i = o.morphing.dstDemTile;
                    c = o.morphing.phase, e && i && (this._prepareDemTileUniforms(t1, e, a, "_prev") && (l = e), this._prepareDemTileUniforms(t1, i, a) && (n = i));
                }
                const h = (e)=>e && e.demTexture && this.painter.linearFloatFilteringSupported() ? r.LINEAR : r.NEAREST;
                let u = null;
                var d;
                if (this.enabled ? l && n ? (u = n.demTexture, s.activeTexture.set(r.TEXTURE4), l.demTexture.bind(h(l), r.CLAMP_TO_EDGE), a.u_dem_lerp = c) : (n = this.terrainTileForTile[t1.tileID.key], u = this._prepareDemTileUniforms(t1, n, a) ? n.demTexture : this.emptyDEMTexture) : u = this.emptyDEMTexture, s.activeTexture.set(r.TEXTURE2), u && (a.u_dem_size = 1 === (d = u).size[0] ? 1 : d.size[0] - 2, u.bind(h(n), r.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(o && o.useDepthForOcclusion, i, a), o && o.useMeterToDem && n) {
                    const t1 = (1 << n.tileID.canonical.z) * e.bH(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                    a.u_meter_to_dem = t1;
                }
                if (o && o.labelPlaneMatrixInv && (a.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(s, a), "globe" === this.painter.transform.projection.name) {
                    const e = this.globeUniformValues(this.painter.transform, t1.tileID.canonical, o && o.useDenormalizedUpVectorScale);
                    i.setGlobeUniformValues(s, e);
                }
            }
            globeUniformValues(t1, i, o) {
                const s = t1.projection;
                return {
                    u_tile_tl_up: s.upVector(i, 0, 0),
                    u_tile_tr_up: s.upVector(i, e.ag, 0),
                    u_tile_br_up: s.upVector(i, e.ag, e.ag),
                    u_tile_bl_up: s.upVector(i, 0, e.ag),
                    u_tile_up_scale: o ? e.cL(1) : s.upVectorScale(i, t1.center.lat, t1.worldSize).metersToTile
                };
            }
            renderToBackBuffer(t1) {
                const i = this.painter, o = this.painter.context;
                0 !== t1.length && (o.bindFramebuffer.set(null), o.viewport.set([
                    0,
                    0,
                    i.width,
                    i.height
                ]), i.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function(t1, i, o, s, r) {
                    if ("globe" === t1.transform.projection.name) !function(t1, i, o, s, r) {
                        const a = t1.context, n = a.gl;
                        let l, c;
                        const h = t1.transform, u = e.cC(t1, a, h), d = (e, i)=>{
                            if (c === i) return;
                            const o = [
                                Ps[i],
                                "PROJECTION_GLOBE_VIEW"
                            ];
                            u && o.push("CUSTOM_ANTIALIASING");
                            const s = t1.isTileAffectedByFog(e);
                            l = t1.getOrCreateProgram("globeRaster", {
                                defines: o,
                                overrideFog: s
                            }), c = i;
                        }, _ = t1.colorModeForRenderPass(), p = new Fi(n.LEQUAL, Fi.ReadWrite, t1.depthRangeFor3D);
                        zs.update(r);
                        const f = e.cD(h), m = [
                            e.at(h.center.lng),
                            e.aA(h.center.lat)
                        ], g = t1.globeSharedBuffers, v = [
                            h.width * e.q.devicePixelRatio,
                            h.height * e.q.devicePixelRatio
                        ], y = Float32Array.from(h.globeMatrix), x = {
                            useDenormalizedUpVectorScale: !0
                        };
                        {
                            const h = t1.transform, u = Ms(h.zoom, i.exaggeration(), i.sourceCache._source.tileSize);
                            c = -1;
                            const b = n.TRIANGLES;
                            for (const c of s){
                                const s = o.getTile(c), w = Bi.disabled, T = i.prevTerrainTileForTile[c.key], E = i.terrainTileForTile[c.key];
                                As(T, E) && zs.newMorphing(c.key, T, E, r, 250), a.activeTexture.set(n.TEXTURE0), s.texture && s.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE);
                                const S = zs.getMorphValuesForProxy(c.key), C = S ? 1 : 0;
                                S && e.J(x, {
                                    morphing: {
                                        srcDemTile: S.from,
                                        dstDemTile: S.to,
                                        phase: e.cB(S.phase)
                                    }
                                });
                                const I = e.cE(c.canonical), R = e.cF(I.getCenter().lat), D = e.cG(c.canonical, I, R, h.worldSize / h._pixelsPerMercatorPixel), L = e.bb(e.cH(c.canonical)), A = Ls(h.expandedFarZProjMatrix, y, f, L, e.ae(h.zoom), m, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, u, h._farZ, D);
                                if (d(c, C), l && (i.setupElevationDraw(s, l, x), t1.uploadCommonUniforms(a, l, c.toUnwrapped()), g)) {
                                    const [e, i, o] = g.getGridBuffers(R, 0 !== u);
                                    l.draw(t1, b, p, w, _, Gi.backCCW, A, "globe_raster", e, i, o);
                                }
                            }
                        }
                        if (g && (t1.renderDefaultNorthPole || t1.renderDefaultSouthPole)) {
                            const r = [
                                "GLOBE_POLES",
                                "PROJECTION_GLOBE_VIEW"
                            ];
                            u && r.push("CUSTOM_ANTIALIASING"), l = t1.getOrCreateProgram("globeRaster", {
                                defines: r
                            });
                            for (const r of s){
                                const { x: s, y: c, z: u } = r.canonical, d = 0 === c, f = c === (1 << u) - 1, [y, b, w, T] = g.getPoleBuffers(u, !1);
                                if (T && (d || f)) {
                                    const c = o.getTile(r);
                                    a.activeTexture.set(n.TEXTURE0), c.texture && c.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE);
                                    let g = e.cI(u, s, h);
                                    const E = e.bb(e.cH(r.canonical)), S = (e, i)=>e.draw(t1, n.TRIANGLES, p, Bi.disabled, _, Gi.disabled, Ls(h.expandedFarZProjMatrix, g, g, E, 0, m, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, 0, h._farZ), "globe_pole_raster", i, w, T);
                                    i.setupElevationDraw(c, l, x), t1.uploadCommonUniforms(a, l, r.toUnwrapped()), d && t1.renderDefaultNorthPole && S(l, y), f && t1.renderDefaultSouthPole && (g = e.ab.mat4.scale(e.ab.mat4.create(), g, [
                                        1,
                                        -1,
                                        1
                                    ]), S(l, b));
                                }
                            }
                        }
                    }(t1, i, o, s, r);
                    else {
                        const a = t1.context, n = a.gl;
                        let l, c;
                        const h = t1.shadowRenderer, u = Ji(t1, t1.longestCutoffRange), d = (e)=>{
                            if (c === e) return;
                            const i = [];
                            i.push(Ps[e]), u.shouldRenderCutoff && i.push("RENDER_CUTOFF"), h && (i.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), h.useNormalOffset && i.push("NORMAL_OFFSET")), l = t1.getOrCreateProgram("terrainRaster", {
                                defines: i
                            }), c = e;
                        }, _ = t1.colorModeForRenderPass(), p = new Fi(n.LEQUAL, Fi.ReadWrite, t1.depthRangeFor3D);
                        zs.update(r);
                        const f = t1.transform, m = Ms(f.zoom, i.exaggeration(), i.sourceCache._source.tileSize);
                        let g = [
                            0,
                            0,
                            0
                        ];
                        if (h) {
                            const e = t1.style.directionalLight, i = t1.style.ambientLight;
                            e && i && (g = ro(t1.style, e, i));
                        }
                        {
                            c = -1;
                            const v = n.TRIANGLES, [y, x] = [
                                i.gridIndexBuffer,
                                i.gridSegments
                            ];
                            for (const c of s){
                                const s = o.getTile(c), b = Bi.disabled, w = i.prevTerrainTileForTile[c.key], T = i.terrainTileForTile[c.key];
                                As(w, T) && zs.newMorphing(c.key, w, T, r, 250), a.activeTexture.set(n.TEXTURE0), s.texture && s.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE);
                                const E = zs.getMorphValuesForProxy(c.key), S = E ? 1 : 0;
                                let C;
                                E && (C = {
                                    morphing: {
                                        srcDemTile: E.from,
                                        dstDemTile: E.to,
                                        phase: e.cB(E.phase)
                                    }
                                });
                                const I = Ds(c.projMatrix, Os(c.canonical, f.renderWorldCopies) ? m / 10 : m, g);
                                if (d(S), !l) continue;
                                i.setupElevationDraw(s, l, C);
                                const R = c.toUnwrapped();
                                h && h.setupShadows(R, l), t1.uploadCommonUniforms(a, l, R, null, u), l.draw(t1, v, p, b, _, Gi.backCCW, I, "terrain_raster", i.gridBuffer, y, x);
                            }
                        }
                    }
                }(i, this, this.proxySourceCache, t1, this._updateTimestamp), this.renderingToTexture = !0, i.gpuTimingDeferredRenderEnd(), t1.splice(0, t1.length));
            }
            renderBatch(t1) {
                if (0 === this._drapedRenderBatches.length) return t1 + 1;
                this.renderingToTexture = !0;
                const i = this.painter, o = this.painter.context, s = this.proxySourceCache, r = this.proxiedCoords[s.id], a = this._drapedRenderBatches.shift(), n = i.style.order, l = [];
                let c = 0;
                for (const h of r){
                    const r = s.getTileByID(h.proxyTileKey), u = s.proxyCachedFBO[h.key] ? s.proxyCachedFBO[h.key][t1] : void 0, d = void 0 !== u ? s.renderCache[u] : this.pool[c++], _ = void 0 !== u;
                    if (r.texture = d.tex, _ && !d.dirty) {
                        l.push(r.tileID);
                        continue;
                    }
                    let p;
                    o.bindFramebuffer.set(d.fb.framebuffer), this.renderedToTile = !1, d.dirty && (o.clear({
                        color: e.aj.transparent,
                        stencil: 0
                    }), d.dirty = !1);
                    for(let e = a.start; e <= a.end; ++e){
                        const t1 = i.style._mergedLayers[n[e]];
                        if (t1.isHidden(i.transform.zoom)) continue;
                        const s = i.style.getLayerSourceCache(t1), r = s ? this.proxyToSource[h.key][s.id] : [
                            h
                        ];
                        if (!r) continue;
                        const a = r;
                        o.viewport.set([
                            0,
                            0,
                            d.fb.width,
                            d.fb.height
                        ]), p !== (s ? s.id : null) && (this._setupStencil(d, r, t1, s), p = s ? s.id : null), i.renderLayer(i, s, t1, a);
                    }
                    if (0 === this._drapedRenderBatches.length) for (const e of this._pendingGroundEffectLayers){
                        const t1 = i.style._mergedLayers[n[e]];
                        if (t1.isHidden(i.transform.zoom)) continue;
                        const s = i.style.getLayerSourceCache(t1), r = s ? this.proxyToSource[h.key][s.id] : [
                            h
                        ];
                        if (!r) continue;
                        const a = r;
                        o.viewport.set([
                            0,
                            0,
                            d.fb.width,
                            d.fb.height
                        ]), p !== (s ? s.id : null) && (this._setupStencil(d, r, t1, s), p = s ? s.id : null), i.renderLayer(i, s, t1, a);
                    }
                    this.renderedToTile ? (d.dirty = !0, l.push(r.tileID)) : _ || --c, 5 === c && (c = 0, this.renderToBackBuffer(l));
                }
                return this.renderToBackBuffer(l), this.renderingToTexture = !1, o.bindFramebuffer.set(null), o.viewport.set([
                    0,
                    0,
                    i.width,
                    i.height
                ]), a.end + 1;
            }
            postRender() {}
            isLayerOrderingCorrect(e) {
                const t1 = e.order.length;
                let i = -1, o = t1;
                for(let s = 0; s < t1; ++s)this._style.isLayerDraped(e._mergedLayers[e.order[s]]) ? i = Math.max(i, s) : o = Math.min(o, s);
                return o > i;
            }
            getMinElevationBelowMSL() {
                let e = 0;
                return this._visibleDemTiles.filter((e)=>e.dem).forEach((t1)=>{
                    e = Math.min(e, t1.dem.tree.minimums[0]);
                }), 0 === e ? e : (e - 30) * this._exaggeration;
            }
            raycast(e, t1, i) {
                if (!this._visibleDemTiles) return null;
                const o = this._visibleDemTiles.filter((e)=>e.dem).map((o)=>{
                    const s = o.tileID, r = 1 << s.overscaledZ, { x: a, y: n } = s.canonical, l = a / r, c = (a + 1) / r, h = n / r, u = (n + 1) / r;
                    return {
                        minx: l,
                        miny: h,
                        maxx: c,
                        maxy: u,
                        t: o.dem.tree.raycastRoot(l, h, c, u, e, t1, i),
                        tile: o
                    };
                });
                o.sort((e, t1)=>(null !== e.t ? e.t : Number.MAX_VALUE) - (null !== t1.t ? t1.t : Number.MAX_VALUE));
                for (const s of o){
                    if (null == s.t) return null;
                    const o = s.tile.dem.tree.raycast(s.minx, s.miny, s.maxx, s.maxy, e, t1, i);
                    if (null != o) return o;
                }
                return null;
            }
            _createFBO() {
                const t1 = this.painter.context, i = t1.gl, o = this.drapeBufferSize;
                t1.activeTexture.set(i.TEXTURE0);
                const s = new e.T(t1, {
                    width: o[0],
                    height: o[1],
                    data: null
                }, i.RGBA8);
                s.bind(i.LINEAR, i.CLAMP_TO_EDGE);
                const r = t1.createFramebuffer(o[0], o[1], !0, null);
                return r.colorAttachment.set(s.texture), r.depthAttachment = new Rs(t1, r.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t1.createRenderbuffer(t1.gl.DEPTH_STENCIL, o[0], o[1]), this._stencilRef = 0, r.depthAttachment.set(this._sharedDepthStencil), t1.clear({
                    stencil: 0
                })) : r.depthAttachment.set(this._sharedDepthStencil), t1.extTextureFilterAnisotropic && i.texParameterf(i.TEXTURE_2D, t1.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t1.extTextureFilterAnisotropicMax), {
                    fb: r,
                    tex: s,
                    dirty: !1
                };
            }
            _initFBOPool() {
                for(; this.pool.length < Math.min(5, this.proxyCoords.length);)this.pool.push(this._createFBO());
            }
            _shouldDisableRenderCache() {
                if (this._debugParams.disableRenderCache) return !0;
                if (this._style.hasLightTransitions()) return !0;
                for(const e in this._style._mergedSourceCaches)if (this._style._mergedSourceCaches[e].hasTransition()) return !0;
                return this._style.order.some((e)=>{
                    const t1 = this._style._mergedLayers[e], i = t1.isHidden(this.painter.transform.zoom);
                    return "hillshade" === t1.type || "custom" === t1.type ? !i && t1.shouldRedrape() : !i && t1.hasTransition();
                });
            }
            _clearLineLayersFromRenderCache() {
                let t1 = !1;
                for (const e of this._style.getSources())if (e instanceof tt) {
                    t1 = !0;
                    break;
                }
                if (!t1) return;
                const i = {};
                for(let t1 = 0; t1 < this._style.order.length; ++t1){
                    const o = this._style._mergedLayers[this._style.order[t1]], s = this._style.getLayerSourceCache(o);
                    if (s && !i[s.id] && !o.isHidden(this.painter.transform.zoom) && "line" === o.type && o.widthExpression() instanceof e.a9) {
                        i[s.id] = !0;
                        for (const e of this.proxyCoords){
                            const t1 = this.proxyToSource[e.key][s.id];
                            if (t1) for (const e of t1)this._clearRenderCacheForTile(s.id, e);
                        }
                    }
                }
            }
            _clearRasterLayersFromRenderCache() {
                let e = !1;
                for(const t1 in this._style._mergedSourceCaches)if (this._style._mergedSourceCaches[t1]._source instanceof it) {
                    e = !0;
                    break;
                }
                if (!e) return;
                const t1 = {};
                for(let e = 0; e < this._style.order.length; ++e){
                    const i = this._style._mergedLayers[this._style.order[e]], o = this._style.getLayerSourceCache(i);
                    if (!o || t1[o.id]) continue;
                    if (i.isHidden(this.painter.transform.zoom) || "raster" !== i.type) continue;
                    const s = i.paint.get("raster-fade-duration");
                    for (const e of this.proxyCoords){
                        const t1 = this.proxyToSource[e.key][o.id];
                        if (t1) for (const e of t1){
                            const t1 = ks(o.getTile(e), o.findLoadedParent(e, 0), o, this.painter.transform, s);
                            (1 !== t1.opacity || 0 !== t1.mix) && this._clearRenderCacheForTile(o.id, e);
                        }
                    }
                }
            }
            _setupDrapedRenderBatches() {
                this._style.updateDrapeFirstLayers();
                const t1 = this._style.order, i = t1.length;
                if (0 === i) return;
                const o = [];
                this._pendingGroundEffectLayers = [];
                let s, r = 0, a = this._style._mergedLayers[t1[r]];
                for(; !this._style.isLayerDraped(a) && a.isHidden(this.painter.transform.zoom) && ++r < i;)a = this._style._mergedLayers[t1[r]];
                for(; r < i; ++r){
                    const e = this._style._mergedLayers[t1[r]];
                    e.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e) ? void 0 === s && (s = r) : ("fill-extrusion" === e.type && this._pendingGroundEffectLayers.push(r), void 0 !== s && (o.push({
                        start: s,
                        end: r - 1
                    }), s = void 0)));
                }
                if (void 0 !== s && o.push({
                    start: s,
                    end: r - 1
                }), 0 !== o.length) {
                    const t1 = o[o.length - 1];
                    this._pendingGroundEffectLayers.every((e)=>e > t1.end) || e.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
                }
                this._drapedRenderBatches = o;
            }
            _setupRenderCache(e) {
                const t1 = this.proxySourceCache;
                if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
                    if (this.invalidateRenderCache = !1, t1.renderCache.length > t1.renderCachePool.length) {
                        const e = Object.values(t1.proxyCachedFBO);
                        t1.proxyCachedFBO = {};
                        for(let i = 0; i < e.length; ++i){
                            const o = Object.values(e[i]);
                            t1.renderCachePool.push(...o);
                        }
                    }
                    return;
                }
                this._clearRasterLayersFromRenderCache();
                const i = this.proxyCoords, o = this._tilesDirty;
                for(let s = i.length - 1; s >= 0; s--){
                    const r = i[s];
                    if (t1.getTileByID(r.key), void 0 !== t1.proxyCachedFBO[r.key]) {
                        const i = e[r.key], s = this.proxyToSource[r.key];
                        let a = 0;
                        for(const e in s){
                            const t1 = s[e], r = i[e];
                            if (!r || r.length !== t1.length || t1.some((t1, i)=>t1 !== r[i] || o[e] && o[e].hasOwnProperty(t1.key))) {
                                a = -1;
                                break;
                            }
                            ++a;
                        }
                        for(const e in t1.proxyCachedFBO[r.key])t1.renderCache[t1.proxyCachedFBO[r.key][e]].dirty = a < 0 || a !== Object.values(i).length;
                    }
                }
                const s = [
                    ...this._drapedRenderBatches
                ];
                s.sort((e, t1)=>t1.end - t1.start - (e.end - e.start));
                for (const e of s)for (const o of i){
                    if (t1.proxyCachedFBO[o.key]) continue;
                    let i = t1.renderCachePool.pop();
                    void 0 === i && t1.renderCache.length < 50 && (i = t1.renderCache.length, t1.renderCache.push(this._createFBO())), void 0 !== i && (t1.proxyCachedFBO[o.key] = {}, t1.proxyCachedFBO[o.key][e.start] = i, t1.renderCache[i].dirty = !0);
                }
                this._tilesDirty = {};
            }
            _setupStencil(e, t1, i, o) {
                if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
                const s = this.painter.context, r = s.gl;
                if (t1.length <= 1) return void (this._overlapStencilType = !1);
                let a;
                if (i.isTileClipped()) a = t1.length, this._overlapStencilMode.test = {
                    func: r.EQUAL,
                    mask: 255
                }, this._overlapStencilType = "Clip";
                else {
                    if (!(t1[0].overscaledZ > t1[t1.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
                    a = 1, this._overlapStencilMode.test = {
                        func: r.GREATER,
                        mask: 255
                    }, this._overlapStencilType = "Mask";
                }
                this._stencilRef + a > 255 && (s.clear({
                    stencil: 0
                }), this._stencilRef = 0), this._stencilRef += a, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t1, this._overlapStencilMode.ref);
            }
            clipOrMaskOverlapStencilType() {
                return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
            }
            stencilModeForRTTOverlap(e) {
                return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e.key]), this._overlapStencilMode) : Bi.disabled;
            }
            _renderTileClippingMasks(e, t1) {
                const i = this.painter, o = this.painter.context, s = o.gl;
                i._tileClippingMaskIDs = {}, o.setColorMode(Oi.disabled), o.setDepthMode(Fi.disabled);
                const r = i.getOrCreateProgram("clippingMask");
                for (const o of e){
                    const e = i._tileClippingMaskIDs[o.key] = --t1;
                    r.draw(i, s.TRIANGLES, Fi.disabled, new Bi({
                        func: s.ALWAYS,
                        mask: 0
                    }, e, 255, s.KEEP, s.KEEP, s.REPLACE), Oi.disabled, Gi.disabled, Fs(o.projMatrix), "$clipping", i.tileExtentBuffer, i.quadTriangleIndexBuffer, i.tileExtentSegments);
                }
            }
            pointCoordinate(t1) {
                const i = this.painter.transform;
                if (t1.x < 0 || t1.x > i.width || t1.y < 0 || t1.y > i.height) return null;
                const o = [
                    t1.x,
                    t1.y,
                    1,
                    1
                ];
                e.ab.vec4.transformMat4(o, o, i.pixelMatrixInverse), e.ab.vec4.scale(o, o, 1 / o[3]), o[0] /= i.worldSize, o[1] /= i.worldSize;
                const s = i._camera.position, r = e.bH(1, i.center.lat), a = [
                    s[0],
                    s[1],
                    s[2] / r,
                    0
                ], n = e.ab.vec3.subtract([], o.slice(0, 3), a);
                e.ab.vec3.normalize(n, n);
                const l = this.raycast(a, n, this._exaggeration);
                return null !== l && l ? (e.ab.vec3.scaleAndAdd(a, a, n, l), a[3] = a[2], a[2] *= r, a) : null;
            }
            _setupProxiedCoordsForOrtho(t1, i, o) {
                if (t1.getSource() instanceof e.aJ) return this._setupProxiedCoordsForImageSource(t1, i, o);
                this._findCoveringTileCache[t1.id] = this._findCoveringTileCache[t1.id] || {};
                const s = this.proxiedCoords[t1.id] = [], r = this.proxyCoords;
                for(let e = 0; e < r.length; e++){
                    const i = r[e], a = this._findTileCoveringTileID(i, t1);
                    if (a) {
                        const e = this._createProxiedId(i, a, o[i.key] && o[i.key][t1.id]);
                        s.push(e), this.proxyToSource[i.key][t1.id] = [
                            e
                        ];
                    }
                }
                let a = !1;
                const n = new Set;
                for(let e = 0; e < i.length; e++){
                    const r = t1.getTile(i[e]);
                    if (!r || !r.hasData()) continue;
                    const l = this._findTileCoveringTileID(r.tileID, this.proxySourceCache);
                    if (l && l.tileID.canonical.z !== r.tileID.canonical.z) {
                        const e = this.proxyToSource[l.tileID.key][t1.id], i = this._createProxiedId(l.tileID, r, o[l.tileID.key] && o[l.tileID.key][t1.id]);
                        e ? e.splice(e.length - 1, 0, i) : this.proxyToSource[l.tileID.key][t1.id] = [
                            i
                        ];
                        const c = this.proxyToSource[l.tileID.key][t1.id];
                        n.has(c) || n.add(c), s.push(i), a = !0;
                    }
                }
                if (this._sourceTilesOverlap[t1.id] = a, a && this._debugParams.sortTilesHiZFirst) for (const e of n)e.sort((e, t1)=>t1.overscaledZ - e.overscaledZ);
            }
            _setupProxiedCoordsForImageSource(t1, i, o) {
                if (!t1.getSource().loaded()) return;
                const s = this.proxiedCoords[t1.id] = [], r = this.proxyCoords, a = t1.getSource(), n = a.tileID;
                if (!n) return;
                const l = new e.P(n.x, n.y)._div(1 << n.z), c = a.coordinates.map(e.aa.fromLngLat).reduce((e, t1)=>(e.min.x = Math.min(e.min.x, t1.x - l.x), e.min.y = Math.min(e.min.y, t1.y - l.y), e.max.x = Math.max(e.max.x, t1.x - l.x), e.max.y = Math.max(e.max.y, t1.y - l.y), e), {
                    min: new e.P(Number.MAX_VALUE, Number.MAX_VALUE),
                    max: new e.P(-Number.MAX_VALUE, -Number.MAX_VALUE)
                }), h = (t1, i)=>{
                    const o = t1.wrap + t1.canonical.x / (1 << t1.canonical.z), s = t1.canonical.y / (1 << t1.canonical.z), r = e.ag / (1 << t1.canonical.z), a = i.wrap + i.canonical.x / (1 << i.canonical.z), n = i.canonical.y / (1 << i.canonical.z);
                    return o + r < a + c.min.x || o > a + c.max.x || s + r < n + c.min.y || s > n + c.max.y;
                };
                for(let e = 0; e < r.length; e++){
                    const a = r[e];
                    for(let e = 0; e < i.length; e++){
                        const r = t1.getTile(i[e]);
                        if (!r || !r.hasData()) continue;
                        if (h(a, r.tileID)) continue;
                        const n = this._createProxiedId(a, r, o[a.key] && o[a.key][t1.id]), l = this.proxyToSource[a.key][t1.id];
                        l ? l.push(n) : this.proxyToSource[a.key][t1.id] = [
                            n
                        ], s.push(n);
                    }
                }
            }
            _createProxiedId(t1, i, o) {
                let s = this.orthoMatrix;
                if (o) {
                    const e = o.find((e)=>e.key === i.tileID.key);
                    if (e) return e;
                }
                if (i.tileID.key !== t1.key) {
                    const o = t1.canonical.z - i.tileID.canonical.z;
                    let r, a, n;
                    s = e.ab.mat4.create();
                    const l = i.tileID.wrap - t1.wrap << t1.overscaledZ;
                    o > 0 ? (r = e.ag >> o, a = r * ((i.tileID.canonical.x << o) - t1.canonical.x + l), n = r * ((i.tileID.canonical.y << o) - t1.canonical.y)) : (r = e.ag << -o, a = e.ag * (i.tileID.canonical.x - (t1.canonical.x + l << -o)), n = e.ag * (i.tileID.canonical.y - (t1.canonical.y << -o))), e.ab.mat4.ortho(s, 0, r, 0, r, 0, 1), e.ab.mat4.translate(s, s, [
                        a,
                        n,
                        0
                    ]);
                }
                return new Us(i.tileID, t1.key, s);
            }
            _findTileCoveringTileID(t1, i) {
                let o = i.getTile(t1);
                if (o && o.hasData()) return o;
                const s = this._findCoveringTileCache[i.id], r = s[t1.key];
                if (o = r ? i.getTileByID(r) : null, o && o.hasData() || null === r) return o;
                let a = o ? o.tileID : t1, n = a.overscaledZ;
                const l = i.getSource().minzoom, c = [];
                if (!r) {
                    const s = i.getSource().maxzoom;
                    if (t1.canonical.z >= s) {
                        const o = t1.canonical.z - s;
                        i.getSource().reparseOverscaled ? (n = Math.max(t1.canonical.z + 2, i.transform.tileZoom), a = new e.aG(n, t1.wrap, s, t1.canonical.x >> o, t1.canonical.y >> o)) : 0 !== o && (n = s, a = new e.aG(n, t1.wrap, s, t1.canonical.x >> o, t1.canonical.y >> o));
                    }
                    a.key !== t1.key && (c.push(a.key), o = i.getTile(a));
                }
                const h = (e)=>{
                    c.forEach((t1)=>{
                        s[t1] = e;
                    }), c.length = 0;
                };
                for(n -= 1; n >= l && (!o || !o.hasData()); n--){
                    o && h(o.tileID.key);
                    const e = a.calculateScaledKey(n);
                    if (o = i.getTileByID(e), o && o.hasData()) break;
                    const t1 = s[e];
                    if (null === t1) break;
                    void 0 === t1 ? c.push(e) : o = i.getTileByID(t1);
                }
                return h(o ? o.tileID.key : null), o && o.hasData() ? o : null;
            }
            findDEMTileFor(e) {
                return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null;
            }
            prepareDrawTile() {
                this.renderedToTile = !0;
            }
            _clearRenderCacheForTile(e, t1) {
                let i = this._tilesDirty[e];
                i || (i = this._tilesDirty[e] = {}), i[t1.key] = !0;
            }
        }
        function js(t1, i, o) {
            const s = function(t1, i, o) {
                const s = e.ab.vec3.dot(i, t1), r = e.ab.vec3.dot(o, [
                    .2126,
                    .7152,
                    .0722
                ]), a = (e, t1, i)=>(1 - i) * e + i * t1, n = a(1 - .3 * Math.min(r, 1), 1, Math.min(s + 1, 1));
                return a(.92, 1, Math.asin(e.aw(i[2], -1, 1)) / Math.PI + .5) * n;
            }(t1, [
                0,
                0,
                1
            ], i), r = [
                0,
                0,
                0
            ];
            e.ab.vec3.scale(r, o.slice(0, 3), s);
            const a = [
                0,
                0,
                0
            ];
            e.ab.vec3.scale(a, i.slice(0, 3), t1[2]);
            const n = [
                0,
                0,
                0
            ];
            return e.ab.vec3.add(n, r, a), e.cf(n);
        }
        const Vs = [
            "fill",
            "fillOutline",
            "fillPattern",
            "line",
            "linePattern",
            "background",
            "backgroundPattern",
            "hillshade",
            "raster"
        ], qs = [
            "stars",
            "rainParticle",
            "snowParticle",
            "fillExtrusion",
            "fillExtrusionGroundEffect",
            "model",
            "symbol"
        ];
        class Hs {
            static cacheKey(e, t1, i, o) {
                let s = `${t1}${o ? o.cacheKey : ""}`;
                for (const t1 of i)e.usedDefines.includes(t1) && (s += `/${t1}`);
                return s;
            }
            constructor(t1, i, o, s, r, a){
                const n = t1.gl;
                this.program = n.createProgram(), this.configuration = s, this.name = i, this.fixedDefines = [
                    ...a
                ];
                const l = s ? s.getBinderAttributes() : [], c = (o.staticAttributes || []).concat(l);
                let h = s ? s.defines() : [];
                h = h.concat(a.map((e)=>`#define ${e}`));
                const u = "#version 300 es\n";
                let d = u + h.concat("precision mediump float;", ko, Fo.fragmentSource).join("\n");
                for (const e of o.fragmentIncludes)d += `\n${Mo[e]}`;
                d += `\n${o.fragmentSource}`;
                let _ = u + h.concat("precision highp float;", ko, Fo.vertexSource).join("\n");
                for (const e of o.vertexIncludes)_ += `\n${Mo[e]}`;
                this.forceManualRenderingForInstanceIDShaders = t1.forceManualRenderingForInstanceIDShaders && -1 !== o.vertexSource.indexOf("gl_InstanceID"), this.forceManualRenderingForInstanceIDShaders && (_ += "\nuniform int u_instanceID;\n"), _ += `\n${o.vertexSource}`, this.forceManualRenderingForInstanceIDShaders && (_ = _.replaceAll("gl_InstanceID", "u_instanceID"));
                const p = n.createShader(n.FRAGMENT_SHADER);
                if (n.isContextLost()) return void (this.failedToCreate = !0);
                n.shaderSource(p, d), n.compileShader(p), n.attachShader(this.program, p);
                const f = n.createShader(n.VERTEX_SHADER);
                if (n.isContextLost()) this.failedToCreate = !0;
                else {
                    n.shaderSource(f, _), n.compileShader(f), n.attachShader(this.program, f), this.attributes = {}, this.numAttributes = c.length;
                    for(let e = 0; e < this.numAttributes; e++)if (c[e]) {
                        const t1 = c[e].startsWith("a_") ? c[e] : `a_${c[e]}`;
                        n.bindAttribLocation(this.program, e, t1), this.attributes[t1] = e;
                    }
                    n.linkProgram(this.program), n.deleteShader(f), n.deleteShader(p), this.fixedUniforms = r(t1), this.binderUniforms = s ? s.getUniforms(t1) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = ((t1)=>({
                            u_instanceID: new e.bN(t1)
                        }))(t1)), (a.includes("TERRAIN") || -1 !== i.indexOf("symbol") || -1 !== i.indexOf("circle")) && (this.terrainUniforms = ((t1)=>({
                            u_dem: new e.bN(t1),
                            u_dem_prev: new e.bN(t1),
                            u_dem_tl: new e.bK(t1),
                            u_dem_scale: new e.bM(t1),
                            u_dem_tl_prev: new e.bK(t1),
                            u_dem_scale_prev: new e.bM(t1),
                            u_dem_size: new e.bM(t1),
                            u_dem_lerp: new e.bM(t1),
                            u_exaggeration: new e.bM(t1),
                            u_depth: new e.bN(t1),
                            u_depth_size_inv: new e.bK(t1),
                            u_depth_range_unpack: new e.bK(t1),
                            u_occluder_half_size: new e.bM(t1),
                            u_occlusion_depth_offset: new e.bM(t1),
                            u_meter_to_dem: new e.bM(t1),
                            u_label_plane_matrix_inv: new e.bJ(t1)
                        }))(t1)), a.includes("GLOBE") && (this.globeUniforms = ((t1)=>({
                            u_tile_tl_up: new e.bL(t1),
                            u_tile_tr_up: new e.bL(t1),
                            u_tile_br_up: new e.bL(t1),
                            u_tile_bl_up: new e.bL(t1),
                            u_tile_up_scale: new e.bM(t1)
                        }))(t1)), a.includes("FOG") && (this.fogUniforms = ((t1)=>({
                            u_fog_matrix: new e.bJ(t1),
                            u_fog_range: new e.bK(t1),
                            u_fog_color: new e.ca(t1),
                            u_fog_horizon_blend: new e.bM(t1),
                            u_fog_vertical_limit: new e.bK(t1),
                            u_fog_temporal_offset: new e.bM(t1),
                            u_frustum_tl: new e.bL(t1),
                            u_frustum_tr: new e.bL(t1),
                            u_frustum_br: new e.bL(t1),
                            u_frustum_bl: new e.bL(t1),
                            u_globe_pos: new e.bL(t1),
                            u_globe_radius: new e.bM(t1),
                            u_globe_transition: new e.bM(t1),
                            u_is_globe: new e.bN(t1),
                            u_viewport: new e.bK(t1)
                        }))(t1)), a.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((t1)=>({
                            u_cutoff_params: new e.ca(t1)
                        }))(t1)), a.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((t1)=>({
                            u_lighting_ambient_color: new e.bL(t1),
                            u_lighting_directional_dir: new e.bL(t1),
                            u_lighting_directional_color: new e.bL(t1),
                            u_ground_radiance: new e.bL(t1)
                        }))(t1)), a.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((t1)=>({
                            u_light_matrix_0: new e.bJ(t1),
                            u_light_matrix_1: new e.bJ(t1),
                            u_fade_range: new e.bK(t1),
                            u_shadow_normal_offset: new e.bL(t1),
                            u_shadow_intensity: new e.bM(t1),
                            u_shadow_texel_size: new e.bM(t1),
                            u_shadow_map_resolution: new e.bM(t1),
                            u_shadow_direction: new e.bL(t1),
                            u_shadow_bias: new e.bL(t1),
                            u_shadowmap_0: new e.bN(t1),
                            u_shadowmap_1: new e.bN(t1)
                        }))(t1));
                }
            }
            setTerrainUniformValues(e, t1) {
                if (!this.terrainUniforms) return;
                const i = this.terrainUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e] && i[e].set(this.program, e, t1[e]);
                }
            }
            setGlobeUniformValues(e, t1) {
                if (!this.globeUniforms) return;
                const i = this.globeUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e] && i[e].set(this.program, e, t1[e]);
                }
            }
            setFogUniformValues(e, t1) {
                if (!this.fogUniforms) return;
                const i = this.fogUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e].set(this.program, e, t1[e]);
                }
            }
            setCutoffUniformValues(e, t1) {
                if (!this.cutoffUniforms) return;
                const i = this.cutoffUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e].set(this.program, e, t1[e]);
                }
            }
            setLightsUniformValues(e, t1) {
                if (!this.lightsUniforms) return;
                const i = this.lightsUniforms;
                if (!this.failedToCreate) {
                    e.program.set(this.program);
                    for(const e in t1)i[e].set(this.program, e, t1[e]);
                }
            }
            setShadowUniformValues(e, t1) {
                if (this.failedToCreate || !this.shadowUniforms) return;
                const i = this.shadowUniforms;
                e.program.set(this.program);
                for(const e in t1)i[e].set(this.program, e, t1[e]);
            }
            _drawDebugWireframe(t1, i, o, s, r, a, n, l, c, h) {
                const u = t1.options.wireframe;
                if (!1 === u.terrain && !1 === u.layers2D && !1 === u.layers3D) return;
                const d = t1.context;
                if (!(()=>!(!u.terrain || "terrainRaster" !== this.name && "globeRaster" !== this.name) || !(!u.layers2D || t1._terrain && t1._terrain.renderingToTexture || !Vs.includes(this.name)) || !(!u.layers3D || !qs.includes(this.name)))()) return;
                const _ = d.gl, p = t1.wireframeDebugCache.getLinesFromTrianglesBuffer(t1.frameCounter, r, d);
                if (!p) return;
                const f = [
                    ...this.fixedDefines
                ];
                f.push("DEBUG_WIREFRAME");
                const m = t1.getOrCreateProgram(this.name, {
                    config: this.configuration,
                    defines: f
                });
                d.program.set(m.program);
                const g = (e, t1, i)=>{
                    if (t1[e] && i[e]) for(const o in t1[e])i[e][o] && i[e][o].set(i.program, o, t1[e][o].current);
                };
                c && c.setUniforms(m.program, d, m.binderUniforms, n, {
                    zoom: l
                }), g("fixedUniforms", this, m), g("terrainUniforms", this, m), g("globeUniforms", this, m), g("fogUniforms", this, m), g("lightsUniforms", this, m), g("shadowUniforms", this, m), p.bind(), d.setColorMode(new Oi([
                    _.ONE,
                    _.ONE_MINUS_SRC_ALPHA,
                    _.ZERO,
                    _.ONE
                ], e.aj.transparent, [
                    !0,
                    !0,
                    !0,
                    !1
                ])), d.setDepthMode(new Fi(i.func === _.LESS ? _.LEQUAL : i.func, Fi.ReadOnly, i.range)), d.setStencilMode(Bi.disabled);
                const v = 3 * a.primitiveLength * 2, y = 3 * a.primitiveOffset * 2 * 2;
                if (this.forceManualRenderingForInstanceIDShaders) {
                    const e = h || 1;
                    for(let t1 = 0; t1 < e; ++t1)m.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", t1), _.drawElements(_.LINES, v, _.UNSIGNED_SHORT, y);
                } else h && h > 1 ? _.drawElementsInstanced(_.LINES, v, _.UNSIGNED_SHORT, y, h) : _.drawElements(_.LINES, v, _.UNSIGNED_SHORT, y);
                r.bind(), d.program.set(this.program), d.setDepthMode(i), d.setStencilMode(o), d.setColorMode(s);
            }
            checkUniforms(e, t1, i) {
                if (this.fixedDefines.includes(t1)) {
                    for (const o of Object.keys(i))if (!i[o].initialized) throw new Error(`Program '${this.name}', from draw '${e}': uniform ${o} not set but required by ${t1} being defined`);
                }
            }
            draw(e, t1, i, o, s, r, a, n, l, c, h, u, d, _, p, f) {
                const m = e.context, g = m.gl;
                if (this.failedToCreate) return;
                m.program.set(this.program), m.setDepthMode(i), m.setStencilMode(o), m.setColorMode(s), m.setCullFace(r);
                for (const e of Object.keys(this.fixedUniforms))this.fixedUniforms[e].set(this.program, e, a[e]);
                _ && _.setUniforms(this.program, m, this.binderUniforms, u, {
                    zoom: d
                });
                const v = {
                    [g.POINTS]: 1,
                    [g.LINES]: 2,
                    [g.TRIANGLES]: 3,
                    [g.LINE_STRIP]: 1
                }[t1];
                this.checkUniforms(n, "RENDER_SHADOWS", this.shadowUniforms);
                const y = f && f > 0 ? 1 : void 0;
                for (const r of h.get()){
                    const a = r.vaos || (r.vaos = {});
                    if ((a[n] || (a[n] = new Go)).bind(m, this, l, _ ? _.getPaintVertexBuffers() : [], c, r.vertexOffset, p || [], y), this.forceManualRenderingForInstanceIDShaders) {
                        const e = f || 1;
                        for(let i = 0; i < e; ++i)this.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", i), c ? g.drawElements(t1, r.primitiveLength * v, g.UNSIGNED_SHORT, r.primitiveOffset * v * 2) : g.drawArrays(t1, r.vertexOffset, r.vertexLength);
                    } else f && f > 1 ? g.drawElementsInstanced(t1, r.primitiveLength * v, g.UNSIGNED_SHORT, r.primitiveOffset * v * 2, f) : c ? g.drawElements(t1, r.primitiveLength * v, g.UNSIGNED_SHORT, r.primitiveOffset * v * 2) : g.drawArrays(t1, r.vertexOffset, r.vertexLength);
                    t1 === g.TRIANGLES && c && this._drawDebugWireframe(e, i, o, s, c, r, u, d, _, f);
                }
            }
        }
        function Zs(t1, i) {
            const o = Math.pow(2, i.tileID.overscaledZ), s = i.tileSize * Math.pow(2, t1.transform.tileZoom) / o, r = s * (i.tileID.canonical.x + i.tileID.wrap * o), a = s * i.tileID.canonical.y;
            return {
                u_image: 0,
                u_texsize: i.imageAtlasTexture ? i.imageAtlasTexture.size : [
                    0,
                    0
                ],
                u_tile_units_to_pixels: 1 / e.ar(i, 1, t1.transform.tileZoom),
                u_pixel_coord_upper: [
                    r >> 16,
                    a >> 16
                ],
                u_pixel_coord_lower: [
                    65535 & r,
                    65535 & a
                ]
            };
        }
        const Ws = {
            terrain: 0,
            flat: 1
        }, $s = e.ab.mat4.create(), Xs = (t1, i, o, s, r, a, n, l, c, h, u, d, _, p, f, m, g, v)=>{
            const y = i.style.light, x = y.properties.get("position"), b = [
                x.x,
                x.y,
                x.z
            ], w = e.ab.mat3.create();
            "viewport" === y.properties.get("anchor") && (e.ab.mat3.fromRotation(w, -i.transform.angle), e.ab.vec3.transformMat3(b, b, w));
            const T = y.properties.get("color"), E = i.transform, S = {
                u_matrix: t1,
                u_lightpos: b,
                u_lightintensity: y.properties.get("intensity"),
                u_lightcolor: [
                    T.r,
                    T.g,
                    T.b
                ],
                u_vertical_gradient: +o,
                u_opacity: s,
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_inv_rot_matrix: $s,
                u_merc_center: [
                    0,
                    0
                ],
                u_up_dir: [
                    0,
                    0,
                    0
                ],
                u_height_lift: 0,
                u_height_type: Ws[h],
                u_base_type: Ws[u],
                u_ao: r,
                u_edge_radius: a,
                u_width_scale: n,
                u_flood_light_color: f,
                u_vertical_scale: m,
                u_flood_light_intensity: g,
                u_ground_shadow_factor: v
            };
            return "globe" === E.projection.name && (S.u_tile_id = [
                l.canonical.x,
                l.canonical.y,
                1 << l.canonical.z
            ], S.u_zoom_transition = d, S.u_inv_rot_matrix = p, S.u_merc_center = _, S.u_up_dir = E.projection.upVector(new e.bT(0, 0, 0), _[0] * e.ag, _[1] * e.ag), S.u_height_lift = c), S;
        }, Ks = (e, t1, i, o, s, r)=>({
                u_matrix: e,
                u_edge_radius: t1,
                u_width_scale: i,
                u_vertical_scale: o,
                u_height_type: Ws[s],
                u_base_type: Ws[r]
            }), Ys = (t1, i, o, s, r, a, n, l, c, h, u, d, _, p, f, m, g)=>{
            const v = Xs(t1, i, o, s, r, a, n, l, h, u, d, _, p, f, m, g, 1, [
                0,
                0,
                0
            ]), y = {
                u_height_factor: -Math.pow(2, l.overscaledZ) / c.tileSize / 8
            };
            return e.l(v, Zs(i, c), y);
        }, Js = (e, t1)=>({
                u_matrix: e,
                u_emissive_strength: t1
            }), Qs = (t1, i, o, s)=>e.l(Js(t1, i), Zs(o, s)), er = (e, t1, i)=>({
                u_matrix: e,
                u_world: i,
                u_emissive_strength: t1
            }), tr = (t1, i, o, s, r)=>e.l(Qs(t1, i, o, s), {
                u_world: r
            }), ir = (t1, i, o, s)=>{
            const r = e.ag / o.tileSize;
            return {
                u_matrix: t1,
                u_camera_to_center_distance: i.getCameraToCenterDistance(s),
                u_extrude_scale: [
                    i.pixelsToGLUnits[0] / r,
                    i.pixelsToGLUnits[1] / r
                ]
            };
        }, or = (e, t1, i = 1)=>({
                u_matrix: e,
                u_color: t1.toRenderColor(null),
                u_overlay: 0,
                u_overlay_scale: i
            }), sr = e.ab.mat4.create(), rr = (t1, i, o, s, r, a, n)=>{
            const l = t1.transform, c = "globe" === l.projection.name, h = c ? e.cN(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : e.ar(o, 1, a), u = {
                u_matrix: i.projMatrix,
                u_extrude_scale: h,
                u_intensity: n,
                u_inv_rot_matrix: sr,
                u_merc_center: [
                    0,
                    0
                ],
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_up_dir: [
                    0,
                    0,
                    0
                ]
            };
            if (c) {
                u.u_inv_rot_matrix = s, u.u_merc_center = r, u.u_tile_id = [
                    i.canonical.x,
                    i.canonical.y,
                    1 << i.canonical.z
                ], u.u_zoom_transition = e.ae(l.zoom);
                const t1 = r[0] * e.ag, o = r[1] * e.ag;
                u.u_up_dir = l.projection.upVector(new e.bT(0, 0, 0), t1, o);
            }
            return u;
        };
        function ar(e, [t1, i, o, s], [r, a]) {
            if (r === a) return [
                0,
                0,
                0,
                0
            ];
            const n = 255 * (e - 1) / (e * (a - r));
            return [
                t1 * n,
                i * n,
                o * n,
                s * n
            ];
        }
        function nr(e, t1, [i, o]) {
            return i === o ? 0 : .5 / e + (t1 - i) * (e - 1) / (e * (o - i));
        }
        const lr = (t1, i, o, s, r, a, n, l, c, h, u, d, _, p, f, m, g, v, y, x, b)=>({
                u_matrix: t1,
                u_normalize_matrix: i,
                u_globe_matrix: o,
                u_merc_matrix: s,
                u_grid_matrix: r,
                u_tl_parent: a,
                u_scale_parent: h,
                u_fade_t: u.mix,
                u_opacity: u.opacity * d.paint.get("raster-opacity"),
                u_image0: 0,
                u_image1: 1,
                u_brightness_low: d.paint.get("raster-brightness-min"),
                u_brightness_high: d.paint.get("raster-brightness-max"),
                u_saturation_factor: e.cO(d.paint.get("raster-saturation")),
                u_contrast_factor: e.cP(d.paint.get("raster-contrast")),
                u_spin_weights: cr(d.paint.get("raster-hue-rotate")),
                u_perspective_transform: _,
                u_raster_elevation: p,
                u_zoom_transition: n,
                u_merc_center: l,
                u_cutoff_params: c,
                u_colorization_mix: ar(e.cQ, m, v),
                u_colorization_offset: nr(e.cQ, g, v),
                u_color_ramp: f,
                u_texture_offset: [
                    x / (y + 2 * x),
                    y / (y + 2 * x)
                ],
                u_texture_res: [
                    y + 2 * x,
                    y + 2 * x
                ],
                u_emissive_strength: b
            });
        function cr(e) {
            e *= Math.PI / 180;
            const t1 = Math.sin(e), i = Math.cos(e);
            return [
                (2 * i + 1) / 3,
                (-Math.sqrt(3) * t1 - i + 1) / 3,
                (Math.sqrt(3) * t1 - i + 1) / 3
            ];
        }
        const hr = .05, ur = (e, t1, i, o, s, r, a, n, l, c, h, u)=>({
                u_matrix: e,
                u_normalize_matrix: t1,
                u_globe_matrix: i,
                u_merc_matrix: o,
                u_grid_matrix: s,
                u_tl_parent: r,
                u_scale_parent: c,
                u_fade_t: h.mix,
                u_opacity: h.opacity,
                u_image0: 0,
                u_image1: 1,
                u_raster_elevation: u,
                u_zoom_transition: a,
                u_merc_center: n,
                u_cutoff_params: l
            }), dr = (e, t1, i, o, s, r, a, n, l, c)=>({
                u_particle_texture: e,
                u_particle_texture_side_len: t1,
                u_tile_offset: i,
                u_velocity: o,
                u_color_ramp: r,
                u_velocity_res: s,
                u_max_speed: a,
                u_uv_offset: n,
                u_data_scale: [
                    255 * l[0],
                    255 * l[1]
                ],
                u_data_offset: c,
                u_particle_pos_scale: 1.1,
                u_particle_pos_offset: [
                    hr,
                    hr
                ]
            }), _r = (e, t1, i, o, s, r, a, n, l, c)=>({
                u_particle_texture: e,
                u_particle_texture_side_len: t1,
                u_velocity: i,
                u_velocity_res: o,
                u_max_speed: s,
                u_speed_factor: r,
                u_reset_rate: a,
                u_rand_seed: Math.random(),
                u_uv_offset: n,
                u_data_scale: [
                    255 * l[0],
                    255 * l[1]
                ],
                u_data_offset: c,
                u_particle_pos_scale: 1.1,
                u_particle_pos_offset: [
                    hr,
                    hr
                ]
            }), pr = e.ab.mat4.create(), fr = (t1, i, o, s, r, a, n, l, c, h, u, d, _, p, f, m, g, v, y, x, b, w)=>{
            const T = r.transform, E = {
                u_is_size_zoom_constant: +("constant" === t1 || "source" === t1),
                u_is_size_feature_constant: +("constant" === t1 || "camera" === t1),
                u_size_t: i ? i.uSizeT : 0,
                u_size: i ? i.uSize : 0,
                u_camera_to_center_distance: T.getCameraToCenterDistance(y),
                u_rotate_symbol: +o,
                u_aspect_ratio: T.width / T.height,
                u_fade_change: r.options.fadeDuration ? r.symbolFadeChange : 1,
                u_matrix: a,
                u_label_plane_matrix: n,
                u_coord_matrix: l,
                u_is_text: +h,
                u_elevation_from_sea: c ? 1 : 0,
                u_pitch_with_map: +s,
                u_texsize: u,
                u_texsize_icon: d,
                u_texture: 0,
                u_texture_icon: 1,
                u_tile_id: [
                    0,
                    0,
                    0
                ],
                u_zoom_transition: 0,
                u_inv_rot_matrix: pr,
                u_merc_center: [
                    0,
                    0
                ],
                u_camera_forward: [
                    0,
                    0,
                    0
                ],
                u_ecef_origin: [
                    0,
                    0,
                    0
                ],
                u_tile_matrix: pr,
                u_up_vector: [
                    0,
                    -1,
                    0
                ],
                u_color_adj_mat: x,
                u_icon_transition: b || 0,
                u_gamma_scale: s ? r.transform.getCameraToCenterDistance(y) * Math.cos(r.terrain ? 0 : r.transform._pitch) : 1,
                u_device_pixel_ratio: e.q.devicePixelRatio,
                u_is_halo: +_,
                u_scale_factor: w || 1
            };
            return "globe" === y.name && (E.u_tile_id = [
                p.canonical.x,
                p.canonical.y,
                1 << p.canonical.z
            ], E.u_zoom_transition = f, E.u_inv_rot_matrix = g, E.u_merc_center = m, E.u_camera_forward = T._camera.forward(), E.u_ecef_origin = e.cR(T.globeMatrix, p.toUnwrapped()), E.u_tile_matrix = Float32Array.from(T.globeMatrix), E.u_up_vector = v), E;
        }, mr = (e, t1, i, o)=>({
                u_matrix: e,
                u_emissive_strength: t1,
                u_opacity: i,
                u_color: o
            }), gr = (t1, i, o, s, r, a, n, l, c)=>e.l(function(t1, i, o, s, r, a) {
                const { width: n, height: l } = s.imageManager.getPixelSize(i), c = Math.pow(2, a.tileID.overscaledZ), h = a.tileSize * Math.pow(2, s.transform.tileZoom) / c, u = h * (a.tileID.canonical.x + a.tileID.wrap * c), d = h * a.tileID.canonical.y;
                return {
                    u_image: 0,
                    u_pattern_tl: o.tl,
                    u_pattern_br: o.br,
                    u_texsize: [
                        n,
                        l
                    ],
                    u_pattern_size: o.displaySize,
                    u_pattern_units_to_pixels: r ? [
                        s.transform.width,
                        -1 * s.transform.height
                    ] : [
                        1 / e.ar(a, 1, s.transform.tileZoom),
                        1 / e.ar(a, 1, s.transform.tileZoom)
                    ],
                    u_pixel_coord_upper: [
                        u >> 16,
                        d >> 16
                    ],
                    u_pixel_coord_lower: [
                        65535 & u,
                        65535 & d
                    ]
                };
            }(0, a, n, s, l, c), {
                u_matrix: t1,
                u_emissive_strength: i,
                u_opacity: o
            }), vr = new Float32Array(e.ab.mat4.identity([])), yr = (t1, i, o, s, r, a, n, l, c, h, u, d, _, p = [
            0,
            0,
            0
        ], f)=>{
            const m = r.style.light, g = m.properties.get("position"), v = [
                -g.x,
                -g.y,
                g.z
            ], y = e.ab.mat3.create();
            "viewport" === m.properties.get("anchor") && (e.ab.mat3.fromRotation(y, -r.transform.angle), e.ab.vec3.transformMat3(v, v, y));
            const x = "MASK" === u.alphaMode, b = m.properties.get("color").toRenderColor(null), w = _.paint.get("model-ambient-occlusion-intensity"), T = _.paint.get("model-color").constantOr(e.aj.white).toRenderColor(null), E = _.paint.get("model-color-mix-intensity").constantOr(0);
            return {
                u_matrix: t1,
                u_lighting_matrix: i,
                u_normal_matrix: o,
                u_node_matrix: s || vr,
                u_lightpos: v,
                u_lightintensity: m.properties.get("intensity"),
                u_lightcolor: [
                    b.r,
                    b.g,
                    b.b
                ],
                u_camera_pos: p,
                u_opacity: a,
                u_baseTextureIsAlpha: 0,
                u_alphaMask: +x,
                u_alphaCutoff: u.alphaCutoff,
                u_baseColorFactor: [
                    n.r,
                    n.g,
                    n.b,
                    n.a
                ],
                u_emissiveFactor: [
                    l[0],
                    l[1],
                    l[2],
                    1
                ],
                u_metallicFactor: c,
                u_roughnessFactor: h,
                u_baseColorTexture: Wi.BaseColor,
                u_metallicRoughnessTexture: Wi.MetallicRoughness,
                u_normalTexture: Wi.Normal,
                u_occlusionTexture: Wi.Occlusion,
                u_emissionTexture: Wi.Emission,
                u_lutTexture: Wi.LUT,
                u_color_mix: [
                    T.r,
                    T.g,
                    T.b,
                    E
                ],
                u_aoIntensity: w,
                u_emissive_strength: d,
                u_occlusionTextureTransform: f || [
                    0,
                    0,
                    0,
                    0
                ]
            };
        }, xr = (e, t1 = vr, i = vr)=>({
                u_matrix: e,
                u_instance: t1,
                u_node_matrix: i
            }), br = {
            fillExtrusion: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_lightpos: new e.bL(t1),
                    u_lightintensity: new e.bM(t1),
                    u_lightcolor: new e.bL(t1),
                    u_vertical_gradient: new e.bM(t1),
                    u_opacity: new e.bM(t1),
                    u_edge_radius: new e.bM(t1),
                    u_width_scale: new e.bM(t1),
                    u_ao: new e.bK(t1),
                    u_height_type: new e.bN(t1),
                    u_base_type: new e.bN(t1),
                    u_tile_id: new e.bL(t1),
                    u_zoom_transition: new e.bM(t1),
                    u_inv_rot_matrix: new e.bJ(t1),
                    u_merc_center: new e.bK(t1),
                    u_up_dir: new e.bL(t1),
                    u_height_lift: new e.bM(t1),
                    u_flood_light_color: new e.bL(t1),
                    u_vertical_scale: new e.bM(t1),
                    u_flood_light_intensity: new e.bM(t1),
                    u_ground_shadow_factor: new e.bL(t1)
                }),
            fillExtrusionDepth: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_edge_radius: new e.bM(t1),
                    u_width_scale: new e.bM(t1),
                    u_vertical_scale: new e.bM(t1),
                    u_height_type: new e.bN(t1),
                    u_base_type: new e.bN(t1)
                }),
            fillExtrusionPattern: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_lightpos: new e.bL(t1),
                    u_lightintensity: new e.bM(t1),
                    u_lightcolor: new e.bL(t1),
                    u_vertical_gradient: new e.bM(t1),
                    u_height_factor: new e.bM(t1),
                    u_edge_radius: new e.bM(t1),
                    u_width_scale: new e.bM(t1),
                    u_ao: new e.bK(t1),
                    u_height_type: new e.bN(t1),
                    u_base_type: new e.bN(t1),
                    u_tile_id: new e.bL(t1),
                    u_zoom_transition: new e.bM(t1),
                    u_inv_rot_matrix: new e.bJ(t1),
                    u_merc_center: new e.bK(t1),
                    u_up_dir: new e.bL(t1),
                    u_height_lift: new e.bM(t1),
                    u_image: new e.bN(t1),
                    u_texsize: new e.bK(t1),
                    u_pixel_coord_upper: new e.bK(t1),
                    u_pixel_coord_lower: new e.bK(t1),
                    u_tile_units_to_pixels: new e.bM(t1),
                    u_opacity: new e.bM(t1)
                }),
            fillExtrusionGroundEffect: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_opacity: new e.bM(t1),
                    u_ao_pass: new e.bM(t1),
                    u_meter_to_tile: new e.bM(t1),
                    u_ao: new e.bK(t1),
                    u_flood_light_intensity: new e.bM(t1),
                    u_flood_light_color: new e.bL(t1),
                    u_attenuation: new e.bM(t1),
                    u_edge_radius: new e.bM(t1),
                    u_fb: new e.bN(t1),
                    u_fb_size: new e.bM(t1),
                    u_dynamic_offset: new e.bM(t1)
                }),
            fill: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_emissive_strength: new e.bM(t1)
                }),
            fillPattern: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_emissive_strength: new e.bM(t1),
                    u_image: new e.bN(t1),
                    u_texsize: new e.bK(t1),
                    u_pixel_coord_upper: new e.bK(t1),
                    u_pixel_coord_lower: new e.bK(t1),
                    u_tile_units_to_pixels: new e.bM(t1)
                }),
            fillOutline: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_emissive_strength: new e.bM(t1),
                    u_world: new e.bK(t1)
                }),
            fillOutlinePattern: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_emissive_strength: new e.bM(t1),
                    u_world: new e.bK(t1),
                    u_image: new e.bN(t1),
                    u_texsize: new e.bK(t1),
                    u_pixel_coord_upper: new e.bK(t1),
                    u_pixel_coord_lower: new e.bK(t1),
                    u_tile_units_to_pixels: new e.bM(t1)
                }),
            circle: e.cS,
            collisionBox: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_camera_to_center_distance: new e.bM(t1),
                    u_extrude_scale: new e.bK(t1)
                }),
            collisionCircle: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_inv_matrix: new e.bJ(t1),
                    u_camera_to_center_distance: new e.bM(t1),
                    u_viewport_size: new e.bK(t1)
                }),
            debug: (t1)=>({
                    u_color: new e.cz(t1),
                    u_matrix: new e.bJ(t1),
                    u_overlay: new e.bN(t1),
                    u_overlay_scale: new e.bM(t1)
                }),
            clippingMask: (t1)=>({
                    u_matrix: new e.bJ(t1)
                }),
            heatmap: (t1)=>({
                    u_extrude_scale: new e.bM(t1),
                    u_intensity: new e.bM(t1),
                    u_matrix: new e.bJ(t1),
                    u_inv_rot_matrix: new e.bJ(t1),
                    u_merc_center: new e.bK(t1),
                    u_tile_id: new e.bL(t1),
                    u_zoom_transition: new e.bM(t1),
                    u_up_dir: new e.bL(t1)
                }),
            heatmapTexture: (t1)=>({
                    u_image: new e.bN(t1),
                    u_color_ramp: new e.bN(t1),
                    u_opacity: new e.bM(t1)
                }),
            hillshade: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_image: new e.bN(t1),
                    u_latrange: new e.bK(t1),
                    u_light: new e.bK(t1),
                    u_shadow: new e.cz(t1),
                    u_highlight: new e.cz(t1),
                    u_emissive_strength: new e.bM(t1),
                    u_accent: new e.cz(t1)
                }),
            hillshadePrepare: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_image: new e.bN(t1),
                    u_dimension: new e.bK(t1),
                    u_zoom: new e.bM(t1)
                }),
            line: e.cT,
            linePattern: e.cU,
            raster: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_normalize_matrix: new e.bJ(t1),
                    u_globe_matrix: new e.bJ(t1),
                    u_merc_matrix: new e.bJ(t1),
                    u_grid_matrix: new e.cA(t1),
                    u_tl_parent: new e.bK(t1),
                    u_scale_parent: new e.bM(t1),
                    u_fade_t: new e.bM(t1),
                    u_opacity: new e.bM(t1),
                    u_image0: new e.bN(t1),
                    u_image1: new e.bN(t1),
                    u_brightness_low: new e.bM(t1),
                    u_brightness_high: new e.bM(t1),
                    u_saturation_factor: new e.bM(t1),
                    u_contrast_factor: new e.bM(t1),
                    u_spin_weights: new e.bL(t1),
                    u_perspective_transform: new e.bK(t1),
                    u_raster_elevation: new e.bM(t1),
                    u_zoom_transition: new e.bM(t1),
                    u_merc_center: new e.bK(t1),
                    u_cutoff_params: new e.ca(t1),
                    u_colorization_mix: new e.ca(t1),
                    u_colorization_offset: new e.bM(t1),
                    u_color_ramp: new e.bN(t1),
                    u_texture_offset: new e.bK(t1),
                    u_texture_res: new e.bK(t1),
                    u_emissive_strength: new e.bM(t1)
                }),
            rasterParticle: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_normalize_matrix: new e.bJ(t1),
                    u_globe_matrix: new e.bJ(t1),
                    u_merc_matrix: new e.bJ(t1),
                    u_grid_matrix: new e.cA(t1),
                    u_tl_parent: new e.bK(t1),
                    u_scale_parent: new e.bM(t1),
                    u_fade_t: new e.bM(t1),
                    u_opacity: new e.bM(t1),
                    u_image0: new e.bN(t1),
                    u_image1: new e.bN(t1),
                    u_raster_elevation: new e.bM(t1),
                    u_zoom_transition: new e.bM(t1),
                    u_merc_center: new e.bK(t1),
                    u_cutoff_params: new e.ca(t1)
                }),
            rasterParticleTexture: (t1)=>({
                    u_texture: new e.bN(t1),
                    u_opacity: new e.bM(t1)
                }),
            rasterParticleDraw: (t1)=>({
                    u_particle_texture: new e.bN(t1),
                    u_particle_texture_side_len: new e.bM(t1),
                    u_tile_offset: new e.bK(t1),
                    u_velocity: new e.bN(t1),
                    u_color_ramp: new e.bN(t1),
                    u_velocity_res: new e.bK(t1),
                    u_max_speed: new e.bM(t1),
                    u_uv_offset: new e.bK(t1),
                    u_data_scale: new e.bK(t1),
                    u_data_offset: new e.bM(t1),
                    u_particle_pos_scale: new e.bM(t1),
                    u_particle_pos_offset: new e.bK(t1)
                }),
            rasterParticleUpdate: (t1)=>({
                    u_particle_texture: new e.bN(t1),
                    u_particle_texture_side_len: new e.bM(t1),
                    u_velocity: new e.bN(t1),
                    u_velocity_res: new e.bK(t1),
                    u_max_speed: new e.bM(t1),
                    u_speed_factor: new e.bM(t1),
                    u_reset_rate: new e.bM(t1),
                    u_rand_seed: new e.bM(t1),
                    u_uv_offset: new e.bK(t1),
                    u_data_scale: new e.bK(t1),
                    u_data_offset: new e.bM(t1),
                    u_particle_pos_scale: new e.bM(t1),
                    u_particle_pos_offset: new e.bK(t1)
                }),
            symbol: (t1)=>({
                    u_is_size_zoom_constant: new e.bN(t1),
                    u_is_size_feature_constant: new e.bN(t1),
                    u_size_t: new e.bM(t1),
                    u_size: new e.bM(t1),
                    u_camera_to_center_distance: new e.bM(t1),
                    u_rotate_symbol: new e.bN(t1),
                    u_aspect_ratio: new e.bM(t1),
                    u_fade_change: new e.bM(t1),
                    u_matrix: new e.bJ(t1),
                    u_label_plane_matrix: new e.bJ(t1),
                    u_coord_matrix: new e.bJ(t1),
                    u_is_text: new e.bN(t1),
                    u_elevation_from_sea: new e.bN(t1),
                    u_pitch_with_map: new e.bN(t1),
                    u_texsize: new e.bK(t1),
                    u_texsize_icon: new e.bK(t1),
                    u_texture: new e.bN(t1),
                    u_texture_icon: new e.bN(t1),
                    u_gamma_scale: new e.bM(t1),
                    u_device_pixel_ratio: new e.bM(t1),
                    u_tile_id: new e.bL(t1),
                    u_zoom_transition: new e.bM(t1),
                    u_inv_rot_matrix: new e.bJ(t1),
                    u_merc_center: new e.bK(t1),
                    u_camera_forward: new e.bL(t1),
                    u_tile_matrix: new e.bJ(t1),
                    u_up_vector: new e.bL(t1),
                    u_ecef_origin: new e.bL(t1),
                    u_is_halo: new e.bN(t1),
                    u_icon_transition: new e.bM(t1),
                    u_color_adj_mat: new e.bJ(t1),
                    u_scale_factor: new e.bM(t1)
                }),
            background: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_emissive_strength: new e.bM(t1),
                    u_opacity: new e.bM(t1),
                    u_color: new e.cz(t1)
                }),
            backgroundPattern: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_emissive_strength: new e.bM(t1),
                    u_opacity: new e.bM(t1),
                    u_image: new e.bN(t1),
                    u_pattern_tl: new e.bK(t1),
                    u_pattern_br: new e.bK(t1),
                    u_texsize: new e.bK(t1),
                    u_pattern_size: new e.bK(t1),
                    u_pixel_coord_upper: new e.bK(t1),
                    u_pixel_coord_lower: new e.bK(t1),
                    u_pattern_units_to_pixels: new e.bK(t1)
                }),
            terrainRaster: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_image0: new e.bN(t1),
                    u_skirt_height: new e.bM(t1),
                    u_ground_shadow_factor: new e.bL(t1)
                }),
            skybox: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_sun_direction: new e.bL(t1),
                    u_cubemap: new e.bN(t1),
                    u_opacity: new e.bM(t1),
                    u_temporal_offset: new e.bM(t1)
                }),
            skyboxGradient: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_color_ramp: new e.bN(t1),
                    u_center_direction: new e.bL(t1),
                    u_radius: new e.bM(t1),
                    u_opacity: new e.bM(t1),
                    u_temporal_offset: new e.bM(t1)
                }),
            skyboxCapture: (t1)=>({
                    u_matrix_3f: new e.cA(t1),
                    u_sun_direction: new e.bL(t1),
                    u_sun_intensity: new e.bM(t1),
                    u_color_tint_r: new e.ca(t1),
                    u_color_tint_m: new e.ca(t1),
                    u_luminance: new e.bM(t1)
                }),
            globeRaster: (t1)=>({
                    u_proj_matrix: new e.bJ(t1),
                    u_globe_matrix: new e.bJ(t1),
                    u_normalize_matrix: new e.bJ(t1),
                    u_merc_matrix: new e.bJ(t1),
                    u_zoom_transition: new e.bM(t1),
                    u_merc_center: new e.bK(t1),
                    u_image0: new e.bN(t1),
                    u_grid_matrix: new e.cA(t1),
                    u_skirt_height: new e.bM(t1),
                    u_far_z_cutoff: new e.bM(t1),
                    u_frustum_tl: new e.bL(t1),
                    u_frustum_tr: new e.bL(t1),
                    u_frustum_br: new e.bL(t1),
                    u_frustum_bl: new e.bL(t1),
                    u_globe_pos: new e.bL(t1),
                    u_globe_radius: new e.bM(t1),
                    u_viewport: new e.bK(t1)
                }),
            globeAtmosphere: (t1)=>({
                    u_frustum_tl: new e.bL(t1),
                    u_frustum_tr: new e.bL(t1),
                    u_frustum_br: new e.bL(t1),
                    u_frustum_bl: new e.bL(t1),
                    u_horizon: new e.bM(t1),
                    u_transition: new e.bM(t1),
                    u_fadeout_range: new e.bM(t1),
                    u_color: new e.ca(t1),
                    u_high_color: new e.ca(t1),
                    u_space_color: new e.ca(t1),
                    u_temporal_offset: new e.bM(t1),
                    u_horizon_angle: new e.bM(t1)
                }),
            model: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_lighting_matrix: new e.bJ(t1),
                    u_normal_matrix: new e.bJ(t1),
                    u_node_matrix: new e.bJ(t1),
                    u_lightpos: new e.bL(t1),
                    u_lightintensity: new e.bM(t1),
                    u_lightcolor: new e.bL(t1),
                    u_camera_pos: new e.bL(t1),
                    u_opacity: new e.bM(t1),
                    u_baseColorFactor: new e.ca(t1),
                    u_emissiveFactor: new e.ca(t1),
                    u_metallicFactor: new e.bM(t1),
                    u_roughnessFactor: new e.bM(t1),
                    u_baseTextureIsAlpha: new e.bN(t1),
                    u_alphaMask: new e.bN(t1),
                    u_alphaCutoff: new e.bM(t1),
                    u_baseColorTexture: new e.bN(t1),
                    u_metallicRoughnessTexture: new e.bN(t1),
                    u_normalTexture: new e.bN(t1),
                    u_occlusionTexture: new e.bN(t1),
                    u_emissionTexture: new e.bN(t1),
                    u_lutTexture: new e.bN(t1),
                    u_color_mix: new e.ca(t1),
                    u_aoIntensity: new e.bM(t1),
                    u_emissive_strength: new e.bM(t1),
                    u_occlusionTextureTransform: new e.ca(t1)
                }),
            modelDepth: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_instance: new e.bJ(t1),
                    u_node_matrix: new e.bJ(t1)
                }),
            groundShadow: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_ground_shadow_factor: new e.bL(t1)
                }),
            stars: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_up: new e.bL(t1),
                    u_right: new e.bL(t1),
                    u_intensity_multiplier: new e.bM(t1)
                }),
            snowParticle: (t1)=>({
                    u_modelview: new e.bJ(t1),
                    u_projection: new e.bJ(t1),
                    u_time: new e.bM(t1),
                    u_cam_pos: new e.bL(t1),
                    u_velocityConeAperture: new e.bM(t1),
                    u_velocity: new e.bM(t1),
                    u_horizontalOscillationRadius: new e.bM(t1),
                    u_horizontalOscillationRate: new e.bM(t1),
                    u_boxSize: new e.bM(t1),
                    u_billboardSize: new e.bM(t1),
                    u_simpleShapeParameters: new e.bK(t1),
                    u_screenSize: new e.bK(t1),
                    u_thinningCenterPos: new e.bK(t1),
                    u_thinningShape: new e.bL(t1),
                    u_thinningAffectedRatio: new e.bM(t1),
                    u_thinningParticleOffset: new e.bM(t1),
                    u_particleColor: new e.ca(t1),
                    u_direction: new e.bL(t1)
                }),
            rainParticle: (t1)=>({
                    u_modelview: new e.bJ(t1),
                    u_projection: new e.bJ(t1),
                    u_time: new e.bM(t1),
                    u_cam_pos: new e.bL(t1),
                    u_texScreen: new e.bN(t1),
                    u_velocityConeAperture: new e.bM(t1),
                    u_velocity: new e.bM(t1),
                    u_boxSize: new e.bM(t1),
                    u_rainDropletSize: new e.bK(t1),
                    u_distortionStrength: new e.bM(t1),
                    u_rainDirection: new e.bL(t1),
                    u_color: new e.ca(t1),
                    u_screenSize: new e.bK(t1),
                    u_thinningCenterPos: new e.bK(t1),
                    u_thinningShape: new e.bL(t1),
                    u_thinningAffectedRatio: new e.bM(t1),
                    u_thinningParticleOffset: new e.bM(t1),
                    u_shapeDirectionalPower: new e.bM(t1),
                    u_shapeNormalPower: new e.bM(t1),
                    u_mode: new e.bM(t1)
                }),
            vignette: (t1)=>({
                    u_vignetteShape: new e.bL(t1),
                    u_vignetteColor: new e.ca(t1)
                }),
            occlusion: (t1)=>({
                    u_matrix: new e.bJ(t1),
                    u_anchorPos: new e.bL(t1),
                    u_screenSizePx: new e.bK(t1),
                    u_occluderSizePx: new e.bK(t1),
                    u_color: new e.ca(t1)
                })
        };
        class wr {
            constructor(e, t1, i, o){
                this.id = wr.uniqueIdxCounter, wr.uniqueIdxCounter++, this.context = e;
                const s = e.gl;
                this.buffer = s.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), s.bufferData(s.ELEMENT_ARRAY_BUFFER, t1.arrayBuffer, this.dynamicDraw ? s.DYNAMIC_DRAW : s.STATIC_DRAW), this.dynamicDraw || o || t1.destroy();
            }
            bind() {
                this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(e) {
                this.id = wr.uniqueIdxCounter, wr.uniqueIdxCounter++;
                const t1 = this.context.gl;
                this.context.unbindVAO(), this.bind(), t1.bufferSubData(t1.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        wr.uniqueIdxCounter = 0;
        const Tr = {
            Int8: "BYTE",
            Uint8: "UNSIGNED_BYTE",
            Int16: "SHORT",
            Uint16: "UNSIGNED_SHORT",
            Int32: "INT",
            Uint32: "UNSIGNED_INT",
            Float32: "FLOAT"
        };
        class Er {
            constructor(e, t1, i, o, s, r){
                this.length = t1.length, this.attributes = i, this.itemSize = t1.bytesPerElement, this.dynamicDraw = o, this.instanceCount = r, this.context = e;
                const a = e.gl;
                this.buffer = a.createBuffer(), e.bindVertexBuffer.set(this.buffer), a.bufferData(a.ARRAY_BUFFER, t1.arrayBuffer, this.dynamicDraw ? a.DYNAMIC_DRAW : a.STATIC_DRAW), this.dynamicDraw || s || t1.destroy();
            }
            bind() {
                this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(e) {
                const t1 = this.context.gl;
                this.bind(), t1.bufferSubData(t1.ARRAY_BUFFER, 0, e.arrayBuffer);
            }
            enableAttributes(e, t1) {
                for(let i = 0; i < this.attributes.length; i++){
                    const o = t1.attributes[this.attributes[i].name];
                    void 0 !== o && e.enableVertexAttribArray(o);
                }
            }
            setVertexAttribPointers(e, t1, i) {
                for(let o = 0; o < this.attributes.length; o++){
                    const s = this.attributes[o], r = t1.attributes[s.name];
                    void 0 !== r && e.vertexAttribPointer(r, s.components, e[Tr[s.type]], !1, this.itemSize, s.offset + this.itemSize * (i || 0));
                }
            }
            setVertexAttribDivisor(e, t1, i) {
                for(let o = 0; o < this.attributes.length; o++){
                    const s = t1.attributes[this.attributes[o].name];
                    void 0 !== s && this.instanceCount && this.instanceCount > 0 && e.vertexAttribDivisor(s, i);
                }
            }
            destroy() {
                this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
        }
        class Sr {
            constructor(e, t1, i, o, s){
                this.context = e, this.width = t1, this.height = i;
                const r = this.framebuffer = e.gl.createFramebuffer();
                o && (this.colorAttachment = new Ss(e, r)), s && (this.depthAttachmentType = s, this.depthAttachment = "renderbuffer" === s ? new Cs(e, r) : new Is(e, r));
            }
            destroy() {
                const e = this.context.gl;
                if (this.colorAttachment) {
                    const t1 = this.colorAttachment.get();
                    t1 && e.deleteTexture(t1);
                }
                if (this.depthAttachment && this.depthAttachmentType) if ("renderbuffer" === this.depthAttachmentType) {
                    const t1 = this.depthAttachment.get();
                    t1 && e.deleteRenderbuffer(t1);
                } else {
                    const t1 = this.depthAttachment.get();
                    t1 && e.deleteTexture(t1);
                }
                e.deleteFramebuffer(this.framebuffer);
            }
        }
        class Cr {
            constructor(e, t1){
                this.gl = e, this.clearColor = new Wo(this), this.clearDepth = new $o(this), this.clearStencil = new Xo(this), this.colorMask = new Ko(this), this.depthMask = new Yo(this), this.stencilMask = new Jo(this), this.stencilFunc = new Qo(this), this.stencilOp = new es(this), this.stencilTest = new ts(this), this.depthRange = new is(this), this.depthTest = new os(this), this.depthFunc = new ss(this), this.blend = new rs(this), this.blendFunc = new as(this), this.blendColor = new ns(this), this.blendEquation = new ls(this), this.cullFace = new cs(this), this.cullFaceSide = new hs(this), this.frontFace = new us(this), this.program = new ds(this), this.activeTexture = new _s(this), this.viewport = new ps(this), this.bindFramebuffer = new fs(this), this.bindRenderbuffer = new ms(this), this.bindTexture = new gs(this), this.bindVertexBuffer = new vs(this), this.bindElementBuffer = new ys(this), this.bindVertexArrayOES = new xs(this), this.pixelStoreUnpack = new bs(this), this.pixelStoreUnpackPremultiplyAlpha = new ws(this), this.pixelStoreUnpackFlipY = new Ts(this), this.options = t1 ? {
                    ...t1
                } : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = t1 && !!t1.forceManualRenderingForInstanceIDShaders || this.renderer && -1 !== this.renderer.indexOf("PowerVR"), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = e.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = e.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.maxPointSize = e.getParameter(e.ALIASED_POINT_SIZE_RANGE)[1];
            }
            setDefault() {
                this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
                this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArrayOES.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
            }
            createIndexBuffer(e, t1, i) {
                return new wr(this, e, t1, i);
            }
            createVertexBuffer(e, t1, i, o, s) {
                return new Er(this, e, t1, i, o, s);
            }
            createRenderbuffer(e, t1, i) {
                const o = this.gl, s = o.createRenderbuffer();
                return this.bindRenderbuffer.set(s), o.renderbufferStorage(o.RENDERBUFFER, e, t1, i), this.bindRenderbuffer.set(null), s;
            }
            createFramebuffer(e, t1, i, o) {
                return new Sr(this, e, t1, i, o);
            }
            clear({ color: e, depth: t1, stencil: i, colorMask: o }) {
                const s = this.gl;
                let r = 0;
                e && (r |= s.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set(o || [
                    !0,
                    !0,
                    !0,
                    !0
                ])), void 0 !== t1 && (r |= s.DEPTH_BUFFER_BIT, this.depthRange.set([
                    0,
                    1
                ]), this.clearDepth.set(t1), this.depthMask.set(!0)), void 0 !== i && (r |= s.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), s.clear(r);
            }
            setCullFace(e) {
                !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));
            }
            setDepthMode(e) {
                e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);
            }
            setStencilMode(e) {
                e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([
                    e.fail,
                    e.depthFail,
                    e.pass
                ]), this.stencilFunc.set({
                    func: e.test.func,
                    ref: e.ref,
                    mask: e.test.mask
                })) : this.stencilTest.set(!1);
            }
            setColorMode(t1) {
                e.bn(t1.blendFunction, Oi.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t1.blendFunction), this.blendColor.set(t1.blendColor), t1.blendEquation ? this.blendEquation.set(t1.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t1.mask);
            }
            unbindVAO() {
                this.bindVertexArrayOES.set(null);
            }
        }
        let Ir;
        function Rr(t1, i, o, s, r, a, n) {
            const l = t1.context, c = l.gl, h = t1.transform, u = t1.getOrCreateProgram("collisionBox"), d = [];
            let _ = 0, p = 0;
            for(let l = 0; l < s.length; l++){
                const f = s[l], m = i.getTile(f), g = m.getBucket(o);
                if (!g) continue;
                const v = ai(f, g, h);
                let y = v;
                0 === r[0] && 0 === r[1] || (y = t1.translatePosMatrix(v, m, r, a));
                const x = n ? g.textCollisionBox : g.iconCollisionBox, b = g.collisionCircleArray;
                if (b.length > 0) {
                    const t1 = e.ab.mat4.create(), i = y;
                    e.ab.mat4.mul(t1, g.placementInvProjMatrix, h.glCoordMatrix), e.ab.mat4.mul(t1, t1, g.placementViewportMatrix), d.push({
                        circleArray: b,
                        circleOffset: p,
                        transform: i,
                        invTransform: t1,
                        projection: g.getProjection()
                    }), _ += b.length / 4, p = _;
                }
                x && (t1.terrain && t1.terrain.setupElevationDraw(m, u), u.draw(t1, c.LINES, Fi.disabled, Bi.disabled, t1.colorModeForRenderPass(), Gi.disabled, ir(y, h, m, g.getProjection()), o.id, x.layoutVertexBuffer, x.indexBuffer, x.segments, null, h.zoom, null, [
                    x.collisionVertexBuffer,
                    x.collisionVertexBufferExt
                ]));
            }
            if (!n || !d.length) return;
            const f = t1.getOrCreateProgram("collisionCircle"), m = new e.cV;
            m.resize(4 * _), m._trim();
            let g = 0;
            for (const e of d)for(let t1 = 0; t1 < e.circleArray.length / 4; t1++){
                const i = 4 * t1, o = e.circleArray[i + 0], s = e.circleArray[i + 1], r = e.circleArray[i + 2], a = e.circleArray[i + 3];
                m.emplace(g++, o, s, r, a, 0), m.emplace(g++, o, s, r, a, 1), m.emplace(g++, o, s, r, a, 2), m.emplace(g++, o, s, r, a, 3);
            }
            (!Ir || Ir.length < 2 * _) && (Ir = function(t1) {
                const i = 2 * t1, o = new e.aU;
                o.resize(i), o._trim();
                for(let e = 0; e < i; e++){
                    const t1 = 6 * e;
                    o.uint16[t1 + 0] = 4 * e + 0, o.uint16[t1 + 1] = 4 * e + 1, o.uint16[t1 + 2] = 4 * e + 2, o.uint16[t1 + 3] = 4 * e + 2, o.uint16[t1 + 4] = 4 * e + 3, o.uint16[t1 + 5] = 4 * e + 0;
                }
                return o;
            }(_));
            const v = l.createIndexBuffer(Ir, !0), y = l.createVertexBuffer(m, e.cW.members, !0);
            for (const i of d){
                const s = {
                    u_matrix: i.transform,
                    u_inv_matrix: i.invTransform,
                    u_camera_to_center_distance: (x = h).getCameraToCenterDistance(i.projection),
                    u_viewport_size: [
                        x.width,
                        x.height
                    ]
                };
                f.draw(t1, c.TRIANGLES, Fi.disabled, Bi.disabled, t1.colorModeForRenderPass(), Gi.disabled, s, o.id, y, v, e.b7.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, h.zoom);
            }
            var x;
            y.destroy(), v.destroy();
        }
        const Dr = e.ab.mat4.create();
        function Lr(t1) {
            const i = t1._camera.getWorldToCamera(t1.worldSize, 1), o = e.ab.mat4.multiply([], i, t1.globeMatrix);
            e.ab.mat4.invert(o, o);
            const s = [
                0,
                0,
                0
            ], r = [
                0,
                1,
                0,
                0
            ];
            return e.ab.vec4.transformMat4(r, r, o), s[0] = r[0], s[1] = r[1], s[2] = r[2], e.ab.vec3.normalize(s, s), s;
        }
        function Ar({ width: t1, height: i, anchor: o, textOffset: s, textScale: r }, a) {
            const { horizontalAlign: n, verticalAlign: l } = e.bD(o), c = -(n - .5) * t1, h = -(l - .5) * i, u = e.bC(o, s);
            return new e.P((c / r + u[0]) * a, (h / r + u[1]) * a);
        }
        function zr(t1, i, o, s, r, a, n, l, c, h, u) {
            const d = t1.text.placedSymbolArray, _ = t1.text.dynamicLayoutVertexArray, p = t1.icon.dynamicLayoutVertexArray, f = {}, m = t1.getProjection(), g = ni(l, m, a), v = a.elevation, y = m.upVectorScale(l.canonical, a.center.lat, a.worldSize).metersToTile;
            _.clear();
            for(let p = 0; p < d.length; p++){
                const x = d.get(p), { tileAnchorX: b, tileAnchorY: w, numGlyphs: T } = x, E = x.hidden || !x.crossTileID || t1.allowVerticalPlacement && !x.placedOrientation ? null : s[x.crossTileID];
                if (E) {
                    let s = 0, d = 0, p = 0;
                    if (v) {
                        const e = v ? v.getAtTileOffset(l, b, w) : 0, [t1, i, o] = m.upVector(l.canonical, b, w);
                        s = e * t1 * y, d = e * i * y, p = e * o * y;
                    }
                    let [S, C, I, R] = Ht(x.projectedAnchorX + s, x.projectedAnchorY + d, x.projectedAnchorZ + p, o ? g : n);
                    const D = Zt(a.getCameraToCenterDistance(m), R);
                    let L = r.evaluateSizeForFeature(t1.textSizeData, h, x) * D / e.bw;
                    o && (L *= t1.tilePixelRatio / c);
                    const A = Ar(E, L);
                    o ? ({ x: S, y: C, z: I } = m.projectTilePoint(b + A.x, w + A.y, l.canonical), [S, C, I] = Ht(S + s, C + d, I + p, n)) : (i && A._rotate(-a.angle), S += A.x, C += A.y, I = 0);
                    const z = t1.allowVerticalPlacement && x.placedOrientation === e.bq.vertical ? Math.PI / 2 : 0;
                    for(let t1 = 0; t1 < T; t1++)e.bt(_, S, C, I, z);
                    u && x.associatedIconIndex >= 0 && (f[x.associatedIconIndex] = {
                        x: S,
                        y: C,
                        z: I,
                        angle: z
                    });
                } else ti(T, _);
            }
            if (u) {
                p.clear();
                const i = t1.icon.placedSymbolArray;
                for(let t1 = 0; t1 < i.length; t1++){
                    const o = i.get(t1), { numGlyphs: s } = o, r = f[t1];
                    if (o.hidden || !r) ti(s, p);
                    else {
                        const { x: t1, y: i, z: o, angle: a } = r;
                        for(let r = 0; r < s; r++)e.bt(p, t1, i, o, a);
                    }
                }
                t1.icon.dynamicLayoutVertexBuffer.updateData(p);
            }
            t1.text.dynamicLayoutVertexBuffer.updateData(_);
        }
        function Pr(t1, i, o, s, r, a, n = {}) {
            const l = o.paint.get("icon-translate"), c = o.paint.get("text-translate"), h = o.paint.get("icon-translate-anchor"), u = o.paint.get("text-translate-anchor"), d = o.layout.get("icon-rotation-alignment"), _ = o.layout.get("text-rotation-alignment"), p = o.layout.get("icon-pitch-alignment"), f = o.layout.get("text-pitch-alignment"), m = o.layout.get("icon-keep-upright"), g = o.layout.get("text-keep-upright"), v = o.paint.get("icon-color-saturation"), y = o.paint.get("icon-color-contrast"), x = o.paint.get("icon-color-brightness-min"), b = o.paint.get("icon-color-brightness-max"), w = "sea" === o.layout.get("symbol-elevation-reference"), T = t1.context, E = T.gl, S = t1.transform, C = "map" === d, I = "map" === _, R = "map" === p, D = "map" === f, L = void 0 !== o.layout.get("symbol-sort-key").constantOr(1);
            let A = !1;
            const z = t1.depthModeForSublayer(0, Fi.ReadOnly), P = [
                e.at(S.center.lng),
                e.aA(S.center.lat)
            ], M = o.layout.get("text-variable-anchor"), O = "globe" === S.projection.name, F = [], k = [
                0,
                -1,
                0
            ];
            for (const r of s){
                const s = i.getTile(r), a = s.getBucket(o);
                if (!a) continue;
                if ("mercator" === a.projection.name && O) continue;
                if (a.fullyClipped) continue;
                const d = "globe" === a.projection.name, _ = d ? e.ae(S.zoom) : 0, p = ni(r, a.getProjection(), S), f = S.calculatePixelsToTileUnitsMatrix(s), T = M && a.hasTextData(), z = a.hasIconTextFit() && T && a.hasIconData(), B = a.getProjection().createInversionMatrix(S, r.canonical), N = (e)=>{
                    S.depthOcclusionForSymbolsAndCircles && (o.hasInitialOcclusionOpacityProperties || t1.terrain) && (e.push("DEPTH_D24"), e.push("DEPTH_OCCLUSION"));
                }, U = ()=>{
                    const i = C && "point" !== o.layout.get("symbol-placement"), n = [];
                    N(n);
                    const c = i || z, u = o.paint.get("icon-image-cross-fade").constantOr(0);
                    t1.terrainRenderModeElevated() && R && n.push("PITCH_WITH_MAP_TERRAIN"), d && (n.push("PROJECTION_GLOBE_VIEW"), c && n.push("PROJECTED_POS_ON_VIEWPORT")), u > 0 && n.push("ICON_TRANSITION"), a.icon.zOffsetVertexBuffer && n.push("Z_OFFSET"), 0 === v && 0 === y && 0 === x && 1 === b || n.push("COLOR_ADJUSTMENT"), a.sdfIcons && n.push("RENDER_SDF");
                    const g = a.icon.programConfigurations.get(o.id), T = t1.getOrCreateProgram("symbol", {
                        config: g,
                        defines: n
                    }), I = s.imageAtlasTexture ? s.imageAtlasTexture.size : [
                        0,
                        0
                    ], D = a.iconSizeData, L = e.bp(D, S.zoom), A = R || 0 !== S.pitch, M = jt(p, s.tileID.canonical, R, C, S, a.getProjection(), f), F = qt(p, s.tileID.canonical, R, C, S, a.getProjection(), f), U = t1.translatePosMatrix(F, s, l, h, !0), G = t1.translatePosMatrix(p, s, l, h), j = c ? Dr : M, V = C && !R && !i;
                    let q = k;
                    !O && !S.mercatorFromTransition || C || (q = Lr(S));
                    const H = d ? q : k, Z = o.getColorAdjustmentMatrix(v, y, x, b), W = fr(D.kind, L, V, R, t1, G, j, U, w, !1, I, [
                        0,
                        0
                    ], !0, r, _, P, B, H, a.getProjection(), Z, u), $ = s.imageAtlasTexture ? s.imageAtlasTexture : null, X = 1 !== o.layout.get("icon-size").constantOr(0) || a.iconsNeedLinear, K = a.sdfIcons || t1.options.rotating || t1.options.zooming || X || A ? E.LINEAR : E.NEAREST, Y = a.sdfIcons && 0 !== o.paint.get("icon-halo-width").constantOr(1), J = t1.terrain && R && i ? e.ab.mat4.invert(e.ab.mat4.create(), M) : Dr;
                    if (i && a.icon) {
                        const e = S.elevation, i = e ? e.getAtTileOffsetFunc(r, S.center.lat, S.worldSize, a.getProjection()) : null, o = Vt(p, s.tileID.canonical, R, C, S, a.getProjection(), f);
                        $t(a, p, t1, !1, o, F, R, m, i, r);
                    }
                    return {
                        program: T,
                        buffers: a.icon,
                        uniformValues: W,
                        atlasTexture: $,
                        atlasTextureIcon: null,
                        atlasInterpolation: K,
                        atlasInterpolationIcon: null,
                        isSDF: a.sdfIcons,
                        hasHalo: Y,
                        tile: s,
                        labelPlaneMatrixInv: J
                    };
                }, G = ()=>{
                    const i = I && "point" !== o.layout.get("symbol-placement"), n = [], l = i || M || z;
                    t1.terrainRenderModeElevated() && D && n.push("PITCH_WITH_MAP_TERRAIN"), d && (n.push("PROJECTION_GLOBE_VIEW"), l && n.push("PROJECTED_POS_ON_VIEWPORT")), a.text.zOffsetVertexBuffer && n.push("Z_OFFSET"), a.iconsInText && n.push("RENDER_TEXT_AND_SYMBOL"), n.push("RENDER_SDF"), N(n);
                    const h = a.text.programConfigurations.get(o.id), m = t1.getOrCreateProgram("symbol", {
                        config: h,
                        defines: n
                    });
                    let v, y = [
                        0,
                        0
                    ], x = null;
                    const b = a.textSizeData;
                    a.iconsInText && (y = s.imageAtlasTexture ? s.imageAtlasTexture.size : [
                        0,
                        0
                    ], x = s.imageAtlasTexture ? s.imageAtlasTexture : null, v = D || 0 !== S.pitch || t1.options.rotating || t1.options.zooming || "composite" === b.kind || "camera" === b.kind ? E.LINEAR : E.NEAREST);
                    const T = s.glyphAtlasTexture ? s.glyphAtlasTexture.size : [
                        0,
                        0
                    ], C = o.layout.get("text-size-scale-range"), R = e.aw(t1.scaleFactor, C[0], C[1]), L = e.bp(b, S.zoom, R), A = jt(p, s.tileID.canonical, D, I, S, a.getProjection(), f), F = qt(p, s.tileID.canonical, D, I, S, a.getProjection(), f), U = t1.translatePosMatrix(F, s, c, u, !0), G = t1.translatePosMatrix(p, s, c, u), j = l ? Dr : A, V = I && !D && !i;
                    let q = k;
                    !O && !S.mercatorFromTransition || I || (q = Lr(S));
                    const H = fr(b.kind, L, V, D, t1, G, j, U, w, !0, T, y, !0, r, _, P, B, d ? q : k, a.getProjection(), null, null, R), Z = s.glyphAtlasTexture ? s.glyphAtlasTexture : null, W = E.LINEAR, $ = 0 !== o.paint.get("text-halo-width").constantOr(1), X = t1.terrain && D && i ? e.ab.mat4.invert(e.ab.mat4.create(), A) : Dr;
                    if (i && a.text) {
                        const e = S.elevation, i = e ? e.getAtTileOffsetFunc(r, S.center.lat, S.worldSize, a.getProjection()) : null, o = Vt(p, s.tileID.canonical, D, I, S, a.getProjection(), f);
                        $t(a, p, t1, !0, o, F, D, g, i, r);
                    }
                    return {
                        program: m,
                        buffers: a.text,
                        uniformValues: H,
                        atlasTexture: Z,
                        atlasTextureIcon: x,
                        atlasInterpolation: W,
                        atlasInterpolationIcon: v,
                        isSDF: !0,
                        hasHalo: $,
                        tile: s,
                        labelPlaneMatrixInv: X
                    };
                }, j = a.icon.segments.get().length, V = a.text.segments.get().length, q = j && !n.onlyText ? U() : null, H = V && !n.onlyIcons ? G() : null, Z = o.paint.get("icon-opacity").constantOr(1), W = o.paint.get("text-opacity").constantOr(1);
                if (L && a.canOverlap) {
                    A = !0;
                    const t1 = Z && !n.onlyText ? a.icon.segments.get() : [], i = W && !n.onlyIcons ? a.text.segments.get() : [];
                    for (const i of t1)F.push({
                        segments: new e.b7([
                            i
                        ]),
                        sortKey: i.sortKey,
                        state: q
                    });
                    for (const t1 of i)F.push({
                        segments: new e.b7([
                            t1
                        ]),
                        sortKey: t1.sortKey,
                        state: H
                    });
                } else n.onlyText || F.push({
                    segments: Z ? a.icon.segments : new e.b7([]),
                    sortKey: 0,
                    state: q
                }), n.onlyIcons || F.push({
                    segments: W ? a.text.segments : new e.b7([]),
                    sortKey: 0,
                    state: H
                });
            }
            A && F.sort((e, t1)=>e.sortKey - t1.sortKey);
            for (const e of F){
                const i = e.state;
                if (i) if (t1.terrain ? t1.terrain.setupElevationDraw(i.tile, i.program, {
                    useDepthForOcclusion: S.depthOcclusionForSymbolsAndCircles,
                    labelPlaneMatrixInv: i.labelPlaneMatrixInv
                }) : t1.setupDepthForOcclusion(S.depthOcclusionForSymbolsAndCircles, i.program), T.activeTexture.set(E.TEXTURE0), i.atlasTexture && i.atlasTexture.bind(i.atlasInterpolation, E.CLAMP_TO_EDGE, !0), i.atlasTextureIcon && (T.activeTexture.set(E.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, E.CLAMP_TO_EDGE, !0)), t1.uploadCommonLightUniforms(t1.context, i.program), i.hasHalo) {
                    const s = i.uniformValues;
                    s.u_is_halo = 1, Mr(i.buffers, e.segments, o, t1, i.program, z, r, a, s, 2), s.u_is_halo = 0;
                } else {
                    if (i.isSDF) {
                        const s = i.uniformValues;
                        i.hasHalo && (s.u_is_halo = 1, Mr(i.buffers, e.segments, o, t1, i.program, z, r, a, s, 1)), s.u_is_halo = 0;
                    }
                    Mr(i.buffers, e.segments, o, t1, i.program, z, r, a, i.uniformValues, 1);
                }
            }
        }
        function Mr(e, t1, i, o, s, r, a, n, l, c) {
            const h = [
                e.dynamicLayoutVertexBuffer,
                e.opacityVertexBuffer,
                e.iconTransitioningVertexBuffer,
                e.globeExtVertexBuffer,
                e.zOffsetVertexBuffer
            ];
            s.draw(o, o.context.gl.TRIANGLES, r, a, n, Gi.disabled, l, i.id, e.layoutVertexBuffer, e.indexBuffer, t1, i.paint, o.transform.zoom, e.programConfigurations.get(i.id), h, c);
        }
        function Or(t1, i, o, s, r, a, n) {
            const l = t1.context.gl, c = o.paint.get("fill-pattern"), h = o.is3D(), u = h ? t1.stencilModeFor3D() : Bi.disabled, d = c && c.constantOr(1);
            let _, p, f, m, g;
            n ? (p = d && !o.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", _ = l.LINES) : (p = d ? "fillPattern" : "fill", _ = l.TRIANGLES);
            for (const v of s){
                const s = i.getTile(v);
                if (d && !s.patternsLoaded()) continue;
                const y = s.getBucket(o);
                if (!y) continue;
                t1.prepareDrawTile();
                const x = y.programConfigurations.get(o.id), b = t1.isTileAffectedByFog(v), w = t1.getOrCreateProgram(p, {
                    config: x,
                    overrideFog: b
                });
                d && (t1.context.activeTexture.set(l.TEXTURE0), s.imageAtlasTexture && s.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE), x.updatePaintBuffers());
                const T = c.constantOr(null);
                if (T && s.imageAtlas) {
                    const t1 = s.imageAtlas, i = e.A.from(T), o = t1.patternPositions[i.getSerializedPrimary()];
                    o && x.setConstantPatternPositions(o);
                }
                const E = t1.translatePosMatrix(v.projMatrix, s, o.paint.get("fill-translate"), o.paint.get("fill-translate-anchor")), S = o.paint.get("fill-emissive-strength");
                if (n) {
                    m = y.indexBuffer2, g = y.segments2;
                    const e = t1.terrain && t1.terrain.renderingToTexture ? t1.terrain.drapeBufferSize : [
                        l.drawingBufferWidth,
                        l.drawingBufferHeight
                    ];
                    f = "fillOutlinePattern" === p && d ? tr(E, S, t1, s, e) : er(E, S, e);
                } else m = y.indexBuffer, g = y.segments, f = d ? Qs(E, S, t1, s) : Js(E, S);
                t1.uploadCommonUniforms(t1.context, w, v.toUnwrapped()), w.draw(t1, _, r, h ? u : t1.stencilModeForClipping(v), a, Gi.disabled, f, o.id, y.layoutVertexBuffer, m, g, o.paint, t1.transform.zoom, x, void 0);
            }
        }
        function Fr(t1, i, o, s, r, a, n, l) {
            o.resetLayerRenderingStats(t1);
            const c = t1.context, h = c.gl, u = t1.transform, d = o.paint.get("fill-extrusion-pattern"), _ = d.constantOr(1), p = o.paint.get("fill-extrusion-opacity"), f = t1.style.enable3dLights(), m = o.paint.get(f && !_ ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), g = [
                o.paint.get("fill-extrusion-ambient-occlusion-intensity"),
                m
            ], v = o.layout.get("fill-extrusion-edge-radius"), y = v > 0 && !o.paint.get("fill-extrusion-rounded-roof"), x = y ? 0 : v, b = "globe" === u.projection.name ? e.d3() : 0, w = "globe" === u.projection.name, T = w ? e.ae(u.zoom) : 0, E = [
                e.at(u.center.lng),
                e.aA(u.center.lat)
            ], S = "none" === o.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default"), C = o.paint.get("fill-extrusion-flood-light-color").toRenderColor(S ? null : o.lut).toArray01().slice(0, 3), I = o.paint.get("fill-extrusion-flood-light-intensity"), R = o.paint.get("fill-extrusion-vertical-scale"), D = 0 !== o.paint.get("fill-extrusion-line-width").constantOr(1), L = o.paint.get("fill-extrusion-height-alignment"), A = o.paint.get("fill-extrusion-base-alignment"), z = Ji(t1, o.paint.get("fill-extrusion-cutoff-fade-range")), P = [];
            let M;
            w && P.push("PROJECTION_GLOBE_VIEW"), g[0] > 0 && P.push("FAUX_AO"), y && P.push("ZERO_ROOF_RADIUS"), l && P.push("HAS_CENTROID"), I > 0 && P.push("FLOOD_LIGHT"), z.shouldRenderCutoff && P.push("RENDER_CUTOFF"), D && P.push("RENDER_WALL_MODE");
            const O = "shadow" === t1.renderPass, F = t1.shadowRenderer, k = O && !!F;
            t1.shadowRenderer && (t1.shadowRenderer.useNormalOffset = !0);
            let B = [
                0,
                0,
                0
            ];
            if (F) {
                const e = t1.style.directionalLight, i = t1.style.ambientLight;
                e && i && (B = ro(t1.style, e, i)), O || (P.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), F.useNormalOffset && P.push("NORMAL_OFFSET")), M = P.concat([
                    "SHADOWS_SINGLE_CASCADE"
                ]);
            }
            const N = k ? "fillExtrusionDepth" : _ ? "fillExtrusionPattern" : "fillExtrusion", U = o.getLayerRenderingStats();
            for (const f of s){
                const s = i.getTile(f), m = s.getBucket(o);
                if (!m || m.projection.name !== u.projection.name) continue;
                let v = !1;
                F && (v = 0 === F.getMaxCascadeForTile(f.toUnwrapped()));
                const y = t1.isTileAffectedByFog(f), S = m.programConfigurations.get(o.id), k = t1.getOrCreateProgram(N, {
                    config: S,
                    defines: v ? M : P,
                    overrideFog: y
                });
                if (t1.terrain && t1.terrain.setupElevationDraw(s, k, {
                    useMeterToDem: !0
                }), !m.centroidVertexBuffer) {
                    const e = k.attributes.a_centroid_pos;
                    void 0 !== e && h.vertexAttrib2f(e, 0, 0);
                }
                !O && F && F.setupShadows(s.tileID.toUnwrapped(), k, "vector-tile", s.tileID.overscaledZ), _ && (t1.context.activeTexture.set(h.TEXTURE0), s.imageAtlasTexture && s.imageAtlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), S.updatePaintBuffers());
                const G = d.constantOr(null);
                if (G && s.imageAtlas) {
                    const t1 = s.imageAtlas, i = e.A.from(G), o = t1.patternPositions[i.getSerializedPrimary()];
                    o && S.setConstantPatternPositions(o);
                }
                const j = o.paint.get("fill-extrusion-vertical-gradient"), V = 1 / m.tileToMeter;
                let q;
                if (O && F) {
                    if (jr(s.tileID, m, t1)) continue;
                    const e = F.calculateShadowPassMatrixFromTile(s.tileID.toUnwrapped());
                    q = Ks(e, x, V, R, L, A);
                } else {
                    const e = t1.translatePosMatrix(f.expandedProjMatrix, s, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")), i = u.projection.createInversionMatrix(u, f.canonical);
                    q = _ ? Ys(e, t1, j, p, g, x, V, f, s, b, L, A, T, E, i, C, R) : Xs(e, t1, j, p, g, x, V, f, b, L, A, T, E, i, C, R, I, B);
                }
                t1.uploadCommonUniforms(c, k, f.toUnwrapped(), null, z);
                let H = m.segments;
                if ("mercator" === u.projection.name && !O && (H = m.getVisibleSegments(s.tileID, t1.terrain, t1.transform.getFrustum(0)), !H.get().length)) continue;
                if (U) if (O) for (const e of H.get())U.numRenderedVerticesInShadowPass += e.primitiveLength;
                else for (const e of H.get())U.numRenderedVerticesInTransparentPass += e.primitiveLength;
                const Z = [];
                (t1.terrain || l) && Z.push(m.centroidVertexBuffer), w && Z.push(m.layoutVertexExtBuffer), D && Z.push(m.wallVertexBuffer), k.draw(t1, c.gl.TRIANGLES, r, a, n, Gi.backCCW, q, o.id, m.layoutVertexBuffer, m.indexBuffer, H, o.paint, t1.transform.zoom, S, Z);
            }
            t1.shadowRenderer && (t1.shadowRenderer.useNormalOffset = !1);
        }
        function kr(t1, i, o, s, r, a, n, l, c, h, u, d, _, p, f, m, g, v, y) {
            const x = t1.context, b = x.gl, w = t1.transform, T = t1.transform.zoom, E = [], S = Ji(t1, o.paint.get("fill-extrusion-cutoff-fade-range"));
            "clear" === h ? (E.push("CLEAR_SUBPASS"), y && (E.push("CLEAR_FROM_TEXTURE"), x.activeTexture.set(b.TEXTURE0), y.bind(b.LINEAR, b.CLAMP_TO_EDGE))) : "sdf" === h && E.push("SDF_SUBPASS"), g && E.push("HAS_CENTROID"), S.shouldRenderCutoff && E.push("RENDER_CUTOFF");
            const C = o.layout.get("fill-extrusion-edge-radius"), I = (e, i, s, h, v)=>{
                const b = i.programConfigurations.get(o.id), w = t1.isTileAffectedByFog(e), I = t1.getOrCreateProgram("fillExtrusionGroundEffect", {
                    config: b,
                    defines: E,
                    overrideFog: w
                }), R = ((e, t1, i, o, s, r, a, n, l, c, h)=>({
                        u_matrix: t1,
                        u_opacity: i,
                        u_ao_pass: o ? 1 : 0,
                        u_meter_to_tile: s,
                        u_ao: r,
                        u_flood_light_intensity: a,
                        u_flood_light_color: n,
                        u_attenuation: l,
                        u_edge_radius: c,
                        u_fb: 0,
                        u_fb_size: h,
                        u_dynamic_offset: 1
                    }))(0, h, u, c, v, [
                    d,
                    _ * v
                ], p, f, m, T >= 17 ? 0 : C * v, y ? y.size[0] : 0), D = [];
                g && D.push(i.hiddenByLandmarkVertexBuffer), t1.uploadCommonUniforms(x, I, e.toUnwrapped(), null, S), I.draw(t1, x.gl.TRIANGLES, r, a, n, l, R, o.id, i.vertexBuffer, i.indexBuffer, s, o.paint, T, b, D);
            };
            for (const r of s){
                const s = i.getTile(r), a = s.getBucket(o);
                if (!a || a.projection.name !== w.projection.name || !a.groundEffect || a.groundEffect && !a.groundEffect.hasData()) continue;
                const n = a.groundEffect, l = 1 / a.tileToMeter;
                {
                    const e = t1.translatePosMatrix(r.projMatrix, s, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")), i = n.getDefaultSegment();
                    I(r, n, i, e, l);
                }
                if (v) for(let a = 0; a < 4; a++){
                    const n = e.d4[a](r), c = i.getTile(n);
                    if (!c) continue;
                    const h = c.getBucket(o);
                    if (!h || h.projection.name !== w.projection.name || !h.groundEffect || h.groundEffect && !h.groundEffect.hasData()) continue;
                    const u = h.groundEffect;
                    let d, _;
                    0 === a ? (d = [
                        -e.ag,
                        0,
                        0
                    ], _ = 1) : 1 === a ? (d = [
                        e.ag,
                        0,
                        0
                    ], _ = 0) : 2 === a ? (d = [
                        0,
                        -e.ag,
                        0
                    ], _ = 3) : (d = [
                        0,
                        e.ag,
                        0
                    ], _ = 2);
                    const p = u.regionSegments[_];
                    if (!p) continue;
                    const f = new Float32Array(16);
                    e.ab.mat4.translate(f, r.projMatrix, d), I(r, u, p, t1.translatePosMatrix(f, s, o.paint.get("fill-extrusion-translate"), o.paint.get("fill-extrusion-translate-anchor")), l);
                }
            }
        }
        function Br(t1, i, o, s, r, a, n) {
            0 === s.centroidVertexArray.length && s.createCentroidsBuffer();
            const l = a ? a.findDEMTileFor(o) : null;
            if (!(l && l.dem || n)) return;
            a && l && l.dem && s.selfDEMTileTimestamp !== l.dem._timestamp && (s.borderDoneWithNeighborZ = [
                -1,
                -1,
                -1,
                -1
            ], s.selfDEMTileTimestamp = l.dem._timestamp);
            const c = (t1)=>new e.P(Math.ceil((t1 + e.d7) * e.d8), 0), h = (e)=>{
                const t1 = i.getSource().minzoom, o = (e)=>{
                    const t1 = i.getTileByID(e);
                    if (t1 && t1.hasData()) return t1.getBucket(r);
                }, s = [
                    0,
                    -1,
                    1
                ];
                for (const i of s){
                    if (e.overscaledZ + i < t1) continue;
                    const s = o(e.calculateScaledKey(e.overscaledZ + i));
                    if (s) return s;
                }
            }, u = [
                0,
                0,
                0
            ], d = (t1, i)=>(u[0] = Math.min(t1.min.y, i.min.y), u[1] = Math.max(t1.max.y, i.max.y), u[2] = e.ag - i.min.x > t1.max.x ? i.min.x - e.ag : t1.max.x, u), _ = (t1, i)=>(u[0] = Math.min(t1.min.x, i.min.x), u[1] = Math.max(t1.max.x, i.max.x), u[2] = e.ag - i.min.y > t1.max.y ? i.min.y - e.ag : t1.max.y, u), p = [
                (e, t1)=>d(e, t1),
                (e, t1)=>d(t1, e),
                (e, t1)=>_(e, t1),
                (e, t1)=>_(t1, e)
            ], f = (t1, i, s, r, n, c, h)=>{
                if (!a) return 0;
                const u = [
                    [
                        c ? s : t1,
                        c ? t1 : s,
                        0
                    ],
                    [
                        c ? s : i,
                        c ? i : s,
                        0
                    ]
                ], d = h < 0 ? e.ag + h : h, _ = [
                    c ? d : (t1 + i) / 2,
                    c ? (t1 + i) / 2 : d,
                    0
                ];
                return 0 === s && h < 0 || 0 !== s && h > 0 ? a.getForTilePoints(n, [
                    _
                ], !0, r) : u.push(_), a.getForTilePoints(o, u, !0, l), Math.max(u[0][2], u[1][2], _[2]) / a.exaggeration();
            };
            for(let t1 = 0; t1 < 4; t1++){
                const i = s.borderFeatureIndices[t1];
                if (0 === i.length) continue;
                const r = e.d4[t1](o), l = h(r);
                if (!(l && l instanceof e.d5)) continue;
                const u = a ? a.findDEMTileFor(r) : null;
                if (!(u && u.dem || n)) continue;
                if (a && u && u.dem && s.borderDEMTileTimestamp[t1] !== u.dem._timestamp && (s.borderDoneWithNeighborZ[t1] = -1, s.borderDEMTileTimestamp[t1] = u.dem._timestamp), s.borderDoneWithNeighborZ[t1] === l.canonical.z) continue;
                0 === l.centroidVertexArray.length && l.createCentroidsBuffer();
                const d = (t1 < 2 ? 1 : 5) - t1, _ = l.borderDoneWithNeighborZ[d] !== s.canonical.z, v = l.borderFeatureIndices[d];
                let y = 0;
                if (s.canonical.z !== l.canonical.z) {
                    for (const e of i)s.showCentroid(s.featuresOnBorder[e]);
                    if (_) for (const e of v)l.showCentroid(l.featuresOnBorder[e]);
                    s.borderDoneWithNeighborZ[t1] = l.canonical.z, l.borderDoneWithNeighborZ[d] = s.canonical.z;
                }
                for (const o of i){
                    const i = s.featuresOnBorder[o], a = s.centroidData[i.centroidDataIndex], h = i.borders[t1];
                    let _;
                    for(; y < v.length;){
                        _ = l.featuresOnBorder[v[y]];
                        const e = _.borders[d];
                        if (e[1] > h[0] + 3 || e[0] > h[0] - 3) break;
                        l.showCentroid(_), y++;
                    }
                    if (_ && y < v.length) {
                        const o = y;
                        let x = 0;
                        for(; !(_.borders[d][0] > h[1] - 3) && (x++, ++y !== v.length);)_ = l.featuresOnBorder[v[y]];
                        _ = l.featuresOnBorder[v[o]];
                        let b = !1;
                        if (x >= 1) {
                            const e = _.borders[d];
                            Math.abs(h[0] - e[0]) < 3 && Math.abs(h[1] - e[1]) < 3 && (x = 1, b = !0, y = o + 1);
                        } else if (0 === x) {
                            s.showCentroid(i);
                            continue;
                        }
                        const w = l.centroidData[_.centroidDataIndex];
                        n && b && (((m = a).flags | (g = w).flags) & e.d6 ? (m.flags |= e.d6, g.flags |= e.d6) : (m.flags &= ~e.d6, g.flags &= ~e.d6));
                        const T = i.intersectsCount() > 1 || _.intersectsCount() > 1;
                        if (x > 1) y = o, a.centroidXY = w.centroidXY = new e.P(0, 0);
                        else if (u && u.dem && !T) {
                            const i = p[t1](a, w), o = t1 % 2 ? e.ag - 1 : 0, s = f(i[0], Math.min(e.ag - 1, i[1]), o, u, r, t1 < 2, i[2]);
                            a.centroidXY = w.centroidXY = c(s);
                        } else T ? a.centroidXY = w.centroidXY = new e.P(0, 0) : (a.centroidXY = s.encodeBorderCentroid(i), w.centroidXY = l.encodeBorderCentroid(_));
                        s.writeCentroidToBuffer(a), l.writeCentroidToBuffer(w);
                    } else s.showCentroid(i);
                }
                s.borderDoneWithNeighborZ[t1] = l.canonical.z, l.borderDoneWithNeighborZ[d] = s.canonical.z;
            }
            var m, g;
            (s.needsCentroidUpdate || !s.centroidVertexBuffer && 0 !== s.centroidVertexArray.length) && s.uploadCentroid(t1);
        }
        const Nr = [
            1,
            0,
            0
        ], Ur = [
            0,
            1,
            0
        ], Gr = [
            0,
            0,
            1
        ];
        function jr(t1, i, o) {
            const s = o.transform, r = o.shadowRenderer;
            if (!r) return !0;
            const a = t1.toUnwrapped(), n = s.tileSize * r._cascades[o.currentShadowCascade].scale;
            let l = i.maxHeight;
            if (s.elevation) {
                const e = s.elevation.getMinMaxForTile(t1);
                e && (l += e.max);
            }
            const c = [
                ...r.shadowDirection
            ];
            c[2] = -c[2];
            const h = r.computeSimplifiedTileShadowVolume(a, l, n, c);
            if (!h) return !1;
            const u = [
                Nr,
                Ur,
                Gr,
                c,
                [
                    c[0],
                    0,
                    c[2]
                ],
                [
                    0,
                    c[1],
                    c[2]
                ]
            ], d = "globe" === s.projection.name, _ = s.scaleZoom(n), p = e.bR.fromInvProjectionMatrix(s.invProjMatrix, s.worldSize, _, !d), f = r.getCurrentCascadeFrustum();
            return 0 === p.intersectsPrecise(h.vertices, h.planes, u) || 0 === f.intersectsPrecise(h.vertices, h.planes, u);
        }
        function Vr(t1) {
            return [
                t1[0] * e.d9,
                t1[1] * e.d9,
                t1[2] * e.d9,
                0
            ];
        }
        function qr(t1, i, o, s, r, a, n, l, c) {
            const h = s.getSource(), u = o.globeSharedBuffers;
            if (!u) return;
            let d, _, p;
            if (i && (d = s.getTile(i)), h instanceof e.aJ ? (_ = h.texture, p = e.cI(0, 0, o.transform)) : d && i && (_ = d.texture, p = e.cI(i.canonical.z, i.canonical.x, o.transform)), !_ || !p) return;
            t1 || (p = e.ab.mat4.scale(e.ab.mat4.create(), p, [
                1,
                -1,
                1
            ]));
            const f = o.context, m = f.gl, g = "nearest" === r.paint.get("raster-resampling") ? m.NEAREST : m.LINEAR, v = o.colorModeForDrapableLayerRenderPass(a), y = n.defines;
            y.push("GLOBE_POLES");
            const x = new Fi(m.LEQUAL, Fi.ReadWrite, o.depthRangeFor3D), b = Float32Array.from(o.transform.expandedFarZProjMatrix), w = Float32Array.from(e.bb(e.cH(new e.bT(0, 0, 0))));
            o.terrain && o.terrain.prepareDrawTile(), f.activeTexture.set(m.TEXTURE0), _.bind(g, m.CLAMP_TO_EDGE), f.activeTexture.set(m.TEXTURE1), _.bind(g, m.CLAMP_TO_EDGE), _.useMipmap && f.extTextureFilterAnisotropic && o.transform.pitch > 20 && m.texParameterf(m.TEXTURE_2D, f.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, f.extTextureFilterAnisotropicMax);
            const [T, E, S, C] = i ? u.getPoleBuffers(i.canonical.z, !1) : u.getPoleBuffers(0, !0), I = r.paint.get("raster-elevation");
            let R;
            t1 ? (R = T, o.renderDefaultNorthPole = 0 !== I) : (R = E, o.renderDefaultSouthPole = 0 !== I);
            const D = Vr(n.mix), L = ((e, t1, i, o, s, r, a, n, l, c, h, u, d)=>lr(e, t1, i, new Float32Array(16), new Float32Array(9), [
                    0,
                    0
                ], o, [
                    0,
                    0
                ], [
                    0,
                    0,
                    0,
                    0
                ], 1, {
                    opacity: 1,
                    mix: 0
                }, r, [
                    0,
                    0
                ] || [
                    0,
                    0
                ], n, 2, c, h, u, 1, 0, d))(b, w, p, e.ae(o.transform.zoom), 0, r, 0, I, 0, D, n.offset, n.range, a), A = o.getOrCreateProgram("raster", {
                defines: y
            });
            o.uploadCommonUniforms(f, A, null), A.draw(o, m.TRIANGLES, x, c, v, l, L, r.id, R, S, C);
        }
        function Hr(e) {
            const t1 = e._nearZ, i = e.projection.farthestPixelDistance(e), o = i - t1, s = .2 * e.height, r = t1 + s;
            return [
                t1,
                i,
                (r - s - t1) / o,
                (r - t1) / o
            ];
        }
        function Zr(e, t1, i, o) {
            if (e) return t1 instanceof ot && e instanceof xt ? t1.getTextureDescriptor(e, i, !0) : {
                texture: e.texture,
                mix: Vr(o.mix),
                offset: o.offset,
                buffer: 0,
                tileSize: 1
            };
        }
        var Wr = e.da([
            {
                name: "a_index",
                type: "Int16",
                components: 1
            }
        ]);
        class $r {
            constructor(t1, i, o, s){
                const r = {
                    width: o[0],
                    height: o[1],
                    data: null
                }, a = t1.gl;
                this.targetColorTexture = new e.T(t1, r, a.RGBA8, {
                    useMipmap: !1
                }), this.backgroundColorTexture = new e.T(t1, r, a.RGBA8, {
                    useMipmap: !1
                }), this.context = t1, this.updateParticleTexture(i, s), this.lastInvalidatedAt = 0;
            }
            updateParticleTexture(t1, i) {
                if (this.particleTextureDimension === i.width) return;
                (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
                const o = this.context.gl, s = i.width * i.height;
                this.particleTexture0 = new e.T(this.context, i, o.RGBA8, {
                    premultiply: !1,
                    useMipmap: !1
                }), this.particleTexture1 = new e.T(this.context, i, o.RGBA8, {
                    premultiply: !1,
                    useMipmap: !1
                });
                const r = new e.db;
                r.reserve(s);
                for(let e = 0; e < s; e++)r.emplaceBack(e);
                this.particleIndexBuffer = this.context.createVertexBuffer(r, Wr.members, !0), this.particleSegment = e.b7.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = i.width;
            }
            update(t1) {
                return !(this.lastInvalidatedAt < t1 && (this.lastInvalidatedAt = e.q.now(), 1));
            }
            destroy() {
                this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
            }
        }
        function Xr(t1, i, o) {
            if (!t1) return null;
            const s = i.getTextureDescriptor(t1, o, !0);
            if (!s) return null;
            let { texture: r, mix: a, offset: n, tileSize: l, buffer: c, format: h } = s;
            if (!r || !h) return null;
            let u = !1;
            return "uint32" === h && (u = !0, a[3] = 0, a = ar(e.dc, a, [
                0,
                o.paint.get("raster-particle-max-speed")
            ]), n = nr(e.dc, n, [
                0,
                o.paint.get("raster-particle-max-speed")
            ])), {
                texture: r,
                textureOffset: [
                    c / (l + 2 * c),
                    l / (l + 2 * c)
                ],
                tileSize: l,
                scalarData: u,
                scale: a,
                offset: n,
                defines: [
                    "RASTER_ARRAY",
                    {
                        uint8: "DATA_FORMAT_UINT8",
                        uint16: "DATA_FORMAT_UINT16",
                        uint32: "DATA_FORMAT_UINT32"
                    }[h]
                ]
            };
        }
        function Kr(e) {
            const t1 = e._nearZ, i = e.projection.farthestPixelDistance(e), o = i - t1, s = .2 * e.height, r = t1 + s;
            return [
                t1,
                i,
                (r - s - t1) / o,
                (r - t1) / o
            ];
        }
        const Yr = new e.aj(1, 0, 0, 1), Jr = new e.aj(0, 1, 0, 1), Qr = new e.aj(0, 0, 1, 1), ea = new e.aj(1, 0, 1, 1), ta = new e.aj(0, 1, 1, 1);
        function ia(t1, i, o, s, r, a, n) {
            const l = t1.context, c = t1.transform, h = l.gl, u = "globe" === c.projection.name, d = u ? [
                "PROJECTION_GLOBE_VIEW"
            ] : [];
            let _ = e.ab.mat4.clone(o.projMatrix);
            if (u && e.ae(c.zoom) > 0) {
                const t1 = e.ba(o.canonical, c), i = e.dd(t1);
                _ = e.ab.mat4.multiply(new Float32Array(16), c.globeMatrix, i), e.ab.mat4.multiply(_, c.projMatrix, _);
            }
            const p = e.ab.mat4.create();
            p[12] += 2 * r / (e.q.devicePixelRatio * c.width), p[13] += 2 * a / (e.q.devicePixelRatio * c.height), e.ab.mat4.multiply(_, p, _);
            const f = t1.getOrCreateProgram("debug", {
                defines: d
            }), m = i.getTileByID(o.key);
            t1.terrain && t1.terrain.setupElevationDraw(m, f);
            const g = Fi.disabled, v = Bi.disabled, y = t1.colorModeForRenderPass(), x = "$debug";
            l.activeTexture.set(h.TEXTURE0), t1.emptyTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), u ? m._makeGlobeTileDebugBuffers(t1.context, c) : m._makeDebugTileBoundsBuffers(t1.context, c.projection);
            const b = m._tileDebugBuffer || t1.debugBuffer, w = m._tileDebugIndexBuffer || t1.debugIndexBuffer, T = m._tileDebugSegments || t1.debugSegments;
            if (f.draw(t1, h.LINE_STRIP, g, v, y, Gi.disabled, or(_, s), x, b, w, T, null, null, null, [
                m._globeTileDebugBorderBuffer
            ]), n) {
                const e = m.latestRawTileData, i = Math.floor((e && e.byteLength || 0) / 1024);
                let s = o.canonical.toString();
                o.overscaledZ !== o.canonical.z && (s += ` => ${o.overscaledZ}`), s += ` ${m.state}`, s += ` ${i}kb`, function(e, t1) {
                    e.initDebugOverlayCanvas();
                    const i = e.debugOverlayCanvas, o = e.context.gl, s = e.debugOverlayCanvas.getContext("2d");
                    s.clearRect(0, 0, i.width, i.height), s.shadowColor = "white", s.shadowBlur = 2, s.lineWidth = 1.5, s.strokeStyle = "white", s.textBaseline = "top", s.font = "bold 36px Open Sans, sans-serif", s.fillText(t1, 5, 5), s.strokeText(t1, 5, 5), e.debugOverlayTexture.update(i), e.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);
                }(t1, s);
            }
            const E = i.getTile(o).tileSize, S = 512 / Math.min(E, 512) * (o.overscaledZ / c.zoom) * .5, C = m._tileDebugTextBuffer || t1.debugBuffer, I = m._tileDebugTextIndexBuffer || t1.quadTriangleIndexBuffer, R = m._tileDebugTextSegments || t1.debugSegments;
            f.draw(t1, h.TRIANGLES, g, v, Oi.alphaBlended, Gi.disabled, or(_, e.aj.transparent, S), x, C, I, R, null, null, null, [
                m._globeTileDebugTextBuffer
            ]);
        }
        function oa(e, t1, i, o) {
            ra(e, 0, t1 + i / 2, e.transform.width, i, o);
        }
        function sa(e, t1, i, o) {
            ra(e, t1 - i / 2, 0, i, e.transform.height, o);
        }
        function ra(t1, i, o, s, r, a) {
            const n = t1.context, l = n.gl;
            l.enable(l.SCISSOR_TEST), l.scissor(i * e.q.devicePixelRatio, o * e.q.devicePixelRatio, s * e.q.devicePixelRatio, r * e.q.devicePixelRatio), n.clear({
                color: a
            }), l.disable(l.SCISSOR_TEST);
        }
        const aa = e.da([
            {
                name: "a_pos_3f",
                components: 3,
                type: "Float32"
            }
        ]), { members: na } = aa;
        function la(e, t1, i, o) {
            e.emplaceBack(t1, i, o);
        }
        class ca {
            constructor(t1){
                this.vertexArray = new e.de, this.indices = new e.aU, la(this.vertexArray, -1, -1, 1), la(this.vertexArray, 1, -1, 1), la(this.vertexArray, -1, 1, 1), la(this.vertexArray, 1, 1, 1), la(this.vertexArray, -1, -1, -1), la(this.vertexArray, 1, -1, -1), la(this.vertexArray, -1, 1, -1), la(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t1.createVertexBuffer(this.vertexArray, na), this.indexBuffer = t1.createIndexBuffer(this.indices), this.segment = e.b7.simpleSegment(0, 0, 36, 12);
            }
        }
        function ha(t1, i, o, s, r, a) {
            const n = t1.context.gl, l = i.paint.get("sky-atmosphere-color"), c = i.paint.get("sky-atmosphere-halo-color"), h = i.paint.get("sky-atmosphere-sun-intensity"), u = ((e, t1, i, o, s)=>({
                    u_matrix_3f: e,
                    u_sun_direction: t1,
                    u_sun_intensity: i,
                    u_color_tint_r: [
                        o.r,
                        o.g,
                        o.b,
                        o.a
                    ],
                    u_color_tint_m: [
                        s.r,
                        s.g,
                        s.b,
                        s.a
                    ],
                    u_luminance: 5e-5
                }))(e.ab.mat3.fromMat4(e.ab.mat3.create(), s), r, h, l, c);
            n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + a, i.skyboxTexture, 0), o.draw(t1, n.TRIANGLES, Fi.disabled, Bi.disabled, Oi.unblended, Gi.frontCW, u, "skyboxCapture", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
        }
        const ua = e.da([
            {
                type: "Float32",
                name: "a_pos",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            }
        ]);
        class da {
            constructor(t1){
                const i = new e.df;
                i.emplaceBack(-1, 1, 1, 0, 0), i.emplaceBack(1, 1, 1, 1, 0), i.emplaceBack(1, -1, 1, 1, 1), i.emplaceBack(-1, -1, 1, 0, 1);
                const o = new e.aU;
                o.emplaceBack(0, 1, 2), o.emplaceBack(2, 3, 0), this.vertexBuffer = t1.createVertexBuffer(i, ua.members), this.indexBuffer = t1.createIndexBuffer(o), this.segments = e.b7.simpleSegment(0, 0, 4, 2);
            }
            destroy() {
                this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
            }
        }
        const _a = e.da([
            {
                type: "Float32",
                name: "a_pos_3f",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            },
            {
                type: "Float32",
                name: "a_size_scale",
                components: 1
            },
            {
                type: "Float32",
                name: "a_fade_opacity",
                components: 1
            }
        ]);
        class pa {
            constructor(){
                this.starsCount = 16e3, this.sizeMultiplier = .15, this.sizeRange = 100, this.intensityRange = 200;
            }
        }
        class fa {
            constructor(t1){
                this.colorModeAlphaBlendedWriteRGB = new Oi([
                    1,
                    Mi,
                    1,
                    Mi
                ], e.aj.transparent, [
                    !0,
                    !0,
                    !0,
                    !1
                ]), this.colorModeWriteAlpha = new Oi([
                    1,
                    0,
                    1,
                    0
                ], e.aj.transparent, [
                    !1,
                    !1,
                    !1,
                    !0
                ]), this.params = new pa, this.updateNeeded = !0, t1.tp.registerParameter(this.params, [
                    "Stars"
                ], "starsCount", {
                    min: 100,
                    max: 16e3,
                    step: 1
                }, ()=>{
                    this.updateNeeded = !0;
                }), t1.tp.registerParameter(this.params, [
                    "Stars"
                ], "sizeMultiplier", {
                    min: .01,
                    max: 2,
                    step: .01
                }), t1.tp.registerParameter(this.params, [
                    "Stars"
                ], "sizeRange", {
                    min: 0,
                    max: 200,
                    step: 1
                }, ()=>{
                    this.updateNeeded = !0;
                }), t1.tp.registerParameter(this.params, [
                    "Stars"
                ], "intensityRange", {
                    min: 0,
                    max: 200,
                    step: 1
                }, ()=>{
                    this.updateNeeded = !0;
                });
            }
            update(t1) {
                const i = t1.context;
                if (!this.atmosphereBuffer || this.updateNeeded) {
                    this.updateNeeded = !1, this.atmosphereBuffer = new da(i);
                    const t1 = this.params.sizeRange, o = this.params.intensityRange, s = function(t1) {
                        const i = e.di(30), o = [];
                        for(let s = 0; s < t1; ++s){
                            const t1 = 2 * Math.PI * i(), s = Math.acos(1 - 2 * i()) - .5 * Math.PI;
                            o.push(e.ab.vec3.fromValues(Math.cos(s) * Math.cos(t1), Math.cos(s) * Math.sin(t1), Math.sin(s)));
                        }
                        return o;
                    }(this.params.starsCount), r = e.di(300), a = new e.dg, n = new e.aU;
                    let l = 0;
                    for(let i = 0; i < s.length; ++i){
                        const c = e.ab.vec3.scale([], s[i], 200), h = Math.max(0, 1 + .01 * t1 * (1 * r() - .5)), u = Math.max(0, 1 + .01 * o * (1 * r() - .5));
                        a.emplaceBack(c[0], c[1], c[2], -1, -1, h, u), a.emplaceBack(c[0], c[1], c[2], 1, -1, h, u), a.emplaceBack(c[0], c[1], c[2], 1, 1, h, u), a.emplaceBack(c[0], c[1], c[2], -1, 1, h, u), n.emplaceBack(l + 0, l + 1, l + 2), n.emplaceBack(l + 0, l + 2, l + 3), l += 4;
                    }
                    this.starsVx = i.createVertexBuffer(a, _a.members), this.starsIdx = i.createIndexBuffer(n), this.starsSegments = e.b7.simpleSegment(0, 0, a.length, n.length);
                }
            }
            destroy() {
                this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
            }
            drawAtmosphereGlow(t1, i) {
                const o = t1.context, s = o.gl, r = t1.transform, a = new Fi(s.LEQUAL, Fi.ReadOnly, [
                    0,
                    1
                ]), n = e.ae(r.zoom), l = t1.style.getLut(i.scope), c = "none" === i.properties.get("color-use-theme"), h = i.properties.get("color").toRenderColor(c ? null : l).toArray01(), u = "none" === i.properties.get("high-color-use-theme"), d = i.properties.get("high-color").toRenderColor(u ? null : l).toArray01(), _ = "none" === i.properties.get("space-color-use-theme"), p = i.properties.get("space-color").toRenderColor(_ ? null : l).toArray01PremultipliedAlpha(), f = 5e-4, m = e.dh(i.properties.get("horizon-blend"), 0, 1, f, .25), g = e.cC(t1, o, r) && m === f ? r.worldSize / (2 * Math.PI * 1.025) - 1 : r.globeRadius, v = t1.frameCounter / 1e3 % 1, y = e.ab.vec3.length(r.globeCenterInViewSpace), x = Math.sqrt(Math.pow(y, 2) - Math.pow(g, 2)), b = Math.acos(x / y), w = (e)=>{
                    const i = "globe" === r.projection.name ? [
                        "PROJECTION_GLOBE_VIEW",
                        "FOG"
                    ] : [
                        "FOG"
                    ];
                    e && i.push("ALPHA_PASS");
                    const l = t1.getOrCreateProgram("globeAtmosphere", {
                        defines: i
                    }), c = ((e, t1, i, o, s, r, a, n, l, c, h, u)=>({
                            u_frustum_tl: e,
                            u_frustum_tr: t1,
                            u_frustum_br: i,
                            u_frustum_bl: o,
                            u_horizon: s,
                            u_transition: r,
                            u_fadeout_range: a,
                            u_color: n,
                            u_high_color: l,
                            u_space_color: c,
                            u_temporal_offset: h,
                            u_horizon_angle: u
                        }))(r.frustumCorners.TL, r.frustumCorners.TR, r.frustumCorners.BR, r.frustumCorners.BL, r.frustumCorners.horizon, n, m, h, d, p, v, b);
                    t1.uploadCommonUniforms(o, l);
                    const u = this.atmosphereBuffer;
                    u && l.draw(t1, s.TRIANGLES, a, Bi.disabled, e ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, Gi.backCW, c, e ? "atmosphere_glow_alpha" : "atmosphere_glow", u.vertexBuffer, u.indexBuffer, u.segments);
                };
                w(!1), w(!0);
            }
            drawStars(t1, i) {
                const o = e.aw(i.properties.get("star-intensity"), 0, 1);
                if (0 === o) return;
                const s = t1.context, r = s.gl, a = t1.transform, n = t1.getOrCreateProgram("stars"), l = e.ab.quat.identity([]);
                e.ab.quat.rotateX(l, l, -a._pitch), e.ab.quat.rotateZ(l, l, -a.angle), e.ab.quat.rotateX(l, l, e.ai(a._center.lat)), e.ab.quat.rotateY(l, l, -e.ai(a._center.lng));
                const c = e.ab.mat4.fromQuat(new Float32Array(16), l), h = e.ab.mat4.multiply([], a.starsProjMatrix, c), u = e.ab.mat3.fromMat4([], c), d = e.ab.mat3.invert([], u), _ = [
                    0,
                    1,
                    0
                ];
                e.ab.vec3.transformMat3(_, _, d), e.ab.vec3.scale(_, _, this.params.sizeMultiplier);
                const p = [
                    1,
                    0,
                    0
                ];
                e.ab.vec3.transformMat3(p, p, d), e.ab.vec3.scale(p, p, this.params.sizeMultiplier);
                const f = (m = _, g = p, v = o, {
                    u_matrix: Float32Array.from(h),
                    u_up: m,
                    u_right: g,
                    u_intensity_multiplier: v
                });
                var m, g, v;
                t1.uploadCommonUniforms(s, n), this.starsVx && this.starsIdx && n.draw(t1, r.TRIANGLES, Fi.disabled, Bi.disabled, this.colorModeAlphaBlendedWriteRGB, Gi.disabled, f, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
            }
        }
        function ma(t1, i) {
            const o = [
                ...t1
            ], s = i.cameraWorldSizeForFog / i.worldSize, r = e.ab.mat4.identity([]);
            return e.ab.mat4.scale(r, r, [
                s,
                s,
                1
            ]), e.ab.mat4.multiply(o, r, o), e.ab.mat4.multiply(o, i.worldToFogMatrix, o), o;
        }
        function ga(t1, i, o, s, r) {
            const a = o.material, n = s.context, { baseColorTexture: l, metallicRoughnessTexture: c } = a.pbrMetallicRoughness, { normalTexture: h, occlusionTexture: u, emissionTexture: d } = a;
            function _(e, i, o) {
                if (e && (t1.push(i), n.activeTexture.set(n.gl.TEXTURE0 + o), e.gfxTexture)) {
                    const { minFilter: t1, magFilter: i, wrapS: o, wrapT: s } = e.sampler;
                    e.gfxTexture.bindExtraParam(t1, i, o, s);
                }
            }
            _(l, "HAS_TEXTURE_u_baseColorTexture", Wi.BaseColor), _(c, "HAS_TEXTURE_u_metallicRoughnessTexture", Wi.MetallicRoughness), _(h, "HAS_TEXTURE_u_normalTexture", Wi.Normal), _(u, "HAS_TEXTURE_u_occlusionTexture", Wi.Occlusion), _(d, "HAS_TEXTURE_u_emissionTexture", Wi.Emission), r && (r.texture || (r.texture = new e.dk(s.context, r.image, [
                r.image.height,
                r.image.height,
                r.image.height
            ], n.gl.RGBA8)), n.activeTexture.set(n.gl.TEXTURE0 + Wi.LUT), r.texture && r.texture.bind(n.gl.LINEAR, n.gl.CLAMP_TO_EDGE), t1.push("APPLY_LUT_ON_GPU")), o.texcoordBuffer && (t1.push("HAS_ATTRIBUTE_a_uv_2f"), i.push(o.texcoordBuffer)), o.colorBuffer && (t1.push(12 === o.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), i.push(o.colorBuffer)), o.normalBuffer && (t1.push("HAS_ATTRIBUTE_a_normal_3f"), i.push(o.normalBuffer)), o.pbrBuffer && (t1.push("HAS_ATTRIBUTE_a_pbr"), t1.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), i.push(o.pbrBuffer)), "OPAQUE" !== a.alphaMode && "MASK" !== a.alphaMode || t1.push("UNPREMULT_TEXTURE_IN_SHADER"), a.defined || t1.push("DIFFUSE_SHADED"), t1.push("USE_STANDARD_DERIVATIVES");
            const p = s.shadowRenderer;
            p && (t1.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), p.useNormalOffset && t1.push("NORMAL_OFFSET"));
        }
        function va(t1, i, o, s, r, a) {
            const n = o.paint.get("model-opacity").constantOr(1), l = i.context, c = new Fi(i.context.gl.LEQUAL, Fi.ReadWrite, i.depthRangeFor3D), h = i.transform, u = t1.mesh, d = u.material, _ = d.pbrMetallicRoughness, p = i.style.fog;
            let f;
            f = "pixels" === i.transform.projection.zAxisUnit ? [
                ...t1.nodeModelMatrix
            ] : e.ab.mat4.multiply([], s.zScaleMatrix, t1.nodeModelMatrix), e.ab.mat4.multiply(f, s.negCameraPosMatrix, f);
            const m = e.ab.mat4.invert([], f);
            e.ab.mat4.transpose(m, m);
            const g = "none" === o.paint.get("model-color-use-theme").constantOr("default"), v = o.paint.get("model-emissive-strength").constantOr(0), y = yr(new Float32Array(t1.worldViewProjection), new Float32Array(f), new Float32Array(m), null, i, n, _.baseColorFactor.toRenderColor(null), d.emissiveFactor, _.metallicFactor, _.roughnessFactor, d, v, o), x = {
                defines: []
            }, b = [], w = i.shadowRenderer;
            w && (w.useNormalOffset = !1), ga(x.defines, b, u, i, g ? null : o.lut);
            let T = null;
            if (p) {
                const e = ma(t1.nodeModelMatrix, i.transform);
                if (T = new Float32Array(e), "globe" !== h.projection.name) {
                    const t1 = u.aabb.min, i = u.aabb.max, [o, s] = p.getOpacityForBounds(e, t1[0], t1[1], i[0], i[1]);
                    x.overrideFog = o >= Fe || s >= Fe;
                }
            }
            const E = Ji(i, o.paint.get("model-cutoff-fade-range"));
            E.shouldRenderCutoff && x.defines.push("RENDER_CUTOFF");
            const S = i.getOrCreateProgram("model", x);
            i.uploadCommonUniforms(l, S, null, T, E), "shadow" !== i.renderPass && w && w.setupShadowsFromMatrix(t1.nodeModelMatrix, S), S.draw(i, l.gl.TRIANGLES, c, r, a, u.material.doubleSided ? Gi.disabled : Gi.backCCW, y, o.id, u.vertexBuffer, u.indexBuffer, u.segments, o.paint, i.transform.zoom, void 0, b);
        }
        function ya(t1, i, o, s, r, a, n) {
            let l;
            l = "globe" === t1.projection.name ? e.dl(o, t1) : [
                ...o
            ], e.ab.mat4.multiply(l, l, i.matrix);
            const c = e.ab.mat4.multiply([], s, l);
            if (i.meshes) for (const t1 of i.meshes){
                if ("BLEND" !== t1.material.alphaMode) {
                    n.push({
                        mesh: t1,
                        depth: 0,
                        modelIndex: r,
                        worldViewProjection: c,
                        nodeModelMatrix: l
                    });
                    continue;
                }
                const i = e.ab.vec3.transformMat4([], t1.centroid, c);
                i[2] > 0 && a.push({
                    mesh: t1,
                    depth: i[2],
                    modelIndex: r,
                    worldViewProjection: c,
                    nodeModelMatrix: l
                });
            }
            if (i.children) for (const e of i.children)ya(t1, e, o, s, r, a, n);
        }
        function xa(e, t1, i, o) {
            const s = i.shadowRenderer;
            if (!s) return;
            const r = s.getShadowPassDepthMode(), a = s.getShadowPassColorMode(), n = s.calculateShadowPassMatrixFromMatrix(t1), l = xr(n);
            i.getOrCreateProgram("modelDepth", {
                defines: i._shadowMapDebug ? [] : [
                    "DEPTH_TEXTURE"
                ]
            }).draw(i, i.context.gl.TRIANGLES, r, Bi.disabled, a, Gi.backCCW, l, o.id, e.vertexBuffer, e.indexBuffer, e.segments, o.paint, i.transform.zoom, void 0, void 0);
        }
        function ba(t1, i, o) {
            const s = i.updateZoomBasedPaintProperties(), r = function(t1, i, o) {
                let s, r, a, n = t1.terrain ? t1.terrain.exaggeration() : 0;
                if (t1.terrain && n > 0) {
                    const i = t1.terrain, r = i.findDEMTileFor(o);
                    r && r.dem ? s = e.dn.create(i, o, r) : n = 0;
                }
                if (0 === n && (i.terrainElevationMin = 0, i.terrainElevationMax = 0), n === i.validForExaggeration && (0 === n || s && s._demTile && s._demTile.tileID === i.validForDEMTile.id && s._dem._timestamp === i.validForDEMTile.timestamp)) return !1;
                for(const e in i.instancesPerModel){
                    const t1 = i.instancesPerModel[e];
                    for(let e = 0; e < t1.instancedDataArray.length; ++e){
                        const o = (s ? n * s.getElevationAt(0 | t1.instancedDataArray.float32[16 * e], 0 | t1.instancedDataArray.float32[16 * e + 1], !0, !0) : 0) + t1.instancesEvaluatedElevation[e];
                        t1.instancedDataArray.float32[16 * e + 6] = o, r = r ? Math.min(i.terrainElevationMin, o) : o, a = a ? Math.max(i.terrainElevationMax, o) : o;
                    }
                }
                return i.terrainElevationMin = r || 0, i.terrainElevationMax = a || 0, i.validForExaggeration = n, i.validForDEMTile = s && s._demTile ? {
                    id: s._demTile.tileID,
                    timestamp: s._dem._timestamp
                } : {
                    id: void 0,
                    timestamp: 0
                }, !0;
            }(t1, i, o);
            (s || r) && (i.uploaded = !1, i.upload(t1.context));
        }
        const wa = {
            shadowUniformsInitialized: !1,
            useSingleShadowCascade: !1,
            tileMatrix: new Float64Array(16),
            shadowTileMatrix: new Float32Array(16),
            aabb: new e.cd([
                0,
                0,
                0
            ], [
                e.ag,
                e.ag,
                0
            ])
        };
        function Ta(t1, i) {
            const o = 1 << t1.canonical.z, s = i.getFreeCameraOptions().position, r = i.elevation, a = t1.canonical.x / o, n = (t1.canonical.x + 1) / o, l = t1.canonical.y / o, c = (t1.canonical.y + 1) / o;
            let h = i._centerAltitude;
            if (r) {
                const e = r.getMinMaxForTile(t1);
                e && e.max > h && (h = e.max);
            }
            const u = e.aw(s.x, a, n) - s.x, d = e.aw(s.y, l, c) - s.y, _ = e.bH(h, i.center.lat) - s.z;
            return i._zoomFromMercatorZ(Math.sqrt(u * u + d * d + _ * _));
        }
        function Ea(e, t1, i, o, s, r, a) {
            const n = e.context, l = "shadow" === e.renderPass, c = e.shadowRenderer, h = l && c ? c.getShadowPassDepthMode() : new Fi(n.gl.LEQUAL, Fi.ReadWrite, e.depthRangeFor3D), u = e.isTileAffectedByFog(r);
            if (i.meshes) for (const d of i.meshes){
                const _ = [
                    "MODEL_POSITION_ON_GPU"
                ], p = [];
                let f, m, g;
                o.instancedDataArray.length > 20 && _.push("INSTANCED_ARRAYS");
                const v = Ji(e, t1.paint.get("model-cutoff-fade-range"));
                if (v.shouldRenderCutoff && _.push("RENDER_CUTOFF"), l && c) f = e.getOrCreateProgram("modelDepth", {
                    defines: _
                }), m = xr(a.shadowTileMatrix, a.shadowTileMatrix, Float32Array.from(i.matrix)), g = c.getShadowPassColorMode();
                else {
                    ga(_, p, d, e, "none" === t1.paint.get("model-color-use-theme").constantOr("default") ? null : t1.lut), f = e.getOrCreateProgram("model", {
                        defines: _,
                        overrideFog: u
                    });
                    const o = d.material, l = o.pbrMetallicRoughness, h = t1.paint.get("model-opacity").constantOr(1), y = t1.paint.get("model-emissive-strength").constantOr(0);
                    m = yr(r.expandedProjMatrix, Float32Array.from(i.matrix), new Float32Array(16), null, e, h, l.baseColorFactor.toRenderColor(null), o.emissiveFactor, l.metallicFactor, l.roughnessFactor, o, y, t1, s), c && (a.shadowUniformsInitialized ? f.setShadowUniformValues(n, c.getShadowUniformValues()) : (c.setupShadows(r.toUnwrapped(), f, "model-tile", r.overscaledZ), a.shadowUniformsInitialized = !0)), g = v.shouldRenderCutoff || h < 1 || "OPAQUE" !== o.alphaMode ? Oi.alphaBlended : Oi.unblended;
                }
                e.uploadCommonUniforms(n, f, r.toUnwrapped(), null, v);
                const y = d.material.doubleSided ? Gi.disabled : Gi.backCCW;
                if (o.instancedDataArray.length > 20) p.push(o.instancedDataBuffer), f.draw(e, n.gl.TRIANGLES, h, Bi.disabled, g, y, m, t1.id, d.vertexBuffer, d.indexBuffer, d.segments, t1.paint, e.transform.zoom, void 0, p, o.instancedDataArray.length);
                else {
                    const i = l ? "u_instance" : "u_normal_matrix";
                    for(let s = 0; s < o.instancedDataArray.length; ++s)m[i] = new Float32Array(o.instancedDataArray.arrayBuffer, 64 * s, 16), f.draw(e, n.gl.TRIANGLES, h, Bi.disabled, g, y, m, t1.id, d.vertexBuffer, d.indexBuffer, d.segments, t1.paint, e.transform.zoom, void 0, p);
                }
            }
            if (i.children) for (const n of i.children)Ea(e, t1, n, o, s, r, a);
        }
        const Sa = [
            1,
            -1,
            1
        ];
        function Ca(t1, i, o, s) {
            if (!o.modelManager) return !0;
            const r = o.modelManager;
            if (!o.shadowRenderer) return !0;
            const a = o.shadowRenderer, n = i.aabb;
            let l = !0, c = t1.maxHeight;
            if (0 === c) {
                let e = 0;
                for(const i in t1.instancesPerModel){
                    const t1 = r.getModel(i, s);
                    t1 ? e = Math.max(e, Math.max(Math.max(t1.aabb.max[0], t1.aabb.max[1]), t1.aabb.max[2])) : l = !1;
                }
                c = t1.maxScale * e * 1.41 + t1.maxVerticalOffset, l && (t1.maxHeight = c);
            }
            n.max[2] = c, n.min[2] += t1.terrainElevationMin, n.max[2] += t1.terrainElevationMax, e.ab.vec3.transformMat4(n.min, n.min, i.tileMatrix), e.ab.vec3.transformMat4(n.max, n.max, i.tileMatrix);
            const h = n.intersects(a.getCurrentCascadeFrustum());
            return 0 === o.currentShadowCascade && (t1.isInsideFirstShadowMapFrustum = 2 === h), 0 === h;
        }
        function Ia(t1, i) {
            const o = t1.uniformValues.u_cutoff_params[0], s = t1.uniformValues.u_cutoff_params[1], r = t1.uniformValues.u_cutoff_params[2], a = t1.uniformValues.u_cutoff_params[3];
            return s === o || a === r ? 1 : e.aw(((i - o) / (s - o) - r) / (a - r), 0, 1);
        }
        function Ra(t1, i, o, s) {
            if (i.pitch < 20) return 1;
            const r = i.getWorldToCameraMatrix();
            e.ab.mat4.multiply(r, r, t1);
            const a = e.ab.vec4.fromValues(o.min[0], o.min[1], o.min[2], 1);
            let n = e.ab.vec4.transformMat4(e.ab.vec4.create(), a, r), l = n, c = n;
            a[1] = o.max[1], n = e.ab.vec4.transformMat4(e.ab.vec4.create(), a, r), l = n[1] < l[1] ? n : l, c = n[1] > c[1] ? n : c, a[0] = o.max[0], n = e.ab.vec4.transformMat4(e.ab.vec4.create(), a, r), l = n[1] < l[1] ? n : l, c = n[1] > c[1] ? n : c, a[1] = o.min[1], n = e.ab.vec4.transformMat4(e.ab.vec4.create(), a, r), l = n[1] < l[1] ? n : l, c = n[1] > c[1] ? n : c;
            const h = e.aw(s[0], 0, 1), u = 100 * i.pixelsPerMeter * e.aw(s[1], 0, 1), d = e.aw(s[2], 0, 1), _ = e.ab.vec4.lerp(e.ab.vec4.create(), l, c, h), p = Math.tan(.5 * i.fovX), f = -_[2] * p;
            if (0 === u) return _[1] < -Math.abs(f) ? d : 1;
            const m = (-Math.abs(f) - _[1]) / u, g = (e, t1, i)=>(1 - i) * e + i * t1, v = e.aw(g(1, d, m), d, 1);
            return g(1, v, e.aw((i.pitch - 20) / 20, 0, 1));
        }
        class Da {
        }
        class La {
            constructor(){
                this._storage = new Map;
            }
            getLinesFromTrianglesBuffer(t1, i, o) {
                {
                    const e = this._storage.get(i.id);
                    if (e) return e.lastUsedFrameIdx = t1, e.buf;
                }
                const s = o.gl, r = s.getBufferParameter(s.ELEMENT_ARRAY_BUFFER, s.BUFFER_SIZE), a = new ArrayBuffer(r), n = new Int16Array(a);
                s.getBufferSubData(s.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(a));
                const l = new e.dq;
                for(let e = 0; e < r / 2; e += 3){
                    const t1 = n[e], i = n[e + 1], o = n[e + 2];
                    l.emplaceBack(t1, i), l.emplaceBack(i, o), l.emplaceBack(o, t1);
                }
                const c = o.bindVertexArrayOES.current, h = new Da;
                return h.buf = new wr(o, l), h.lastUsedFrameIdx = t1, this._storage.set(i.id, h), o.bindVertexArrayOES.set(c), h.buf;
            }
            update(e) {
                for (const [t1, i] of this._storage)e - i.lastUsedFrameIdx > 30 && (i.buf.destroy(), this._storage.delete(t1));
            }
            destroy() {
                for (const [e, t1] of this._storage)t1.buf.destroy(), this._storage.delete(e);
            }
        }
        class Aa {
            constructor(e){
                this.occluderSize = 30, this.depthOffset = -1e-4, e.registerParameter(this, [
                    "Occlusion"
                ], "occluderSize", {
                    min: 1,
                    max: 100,
                    step: 1
                }), e.registerParameter(this, [
                    "Occlusion"
                ], "depthOffset", {
                    min: -.05,
                    max: 0,
                    step: 1e-5
                });
            }
        }
        const za = e.da([
            {
                type: "Float32",
                name: "a_pos_3f",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            },
            {
                type: "Float32",
                name: "a_rainParticleData",
                components: 4
            }
        ]);
        class Pa {
            registerParameter() {}
            registerButton() {}
            registerBinding() {}
            refreshUI() {}
        }
        class Ma {
            constructor(e, t1){
                this.revealStart = 11, this.revealRange = 2, e.registerParameter(this, [
                    ...t1,
                    "Reveal"
                ], "revealStart", {
                    min: 0,
                    max: 17,
                    step: .05
                }), e.registerParameter(this, [
                    ...t1,
                    "Reveal"
                ], "revealRange", {
                    min: .1,
                    max: 5.1,
                    step: .05
                });
            }
        }
        const Oa = e.da([
            {
                type: "Float32",
                name: "a_pos_2f",
                components: 2
            }
        ]);
        class Fa {
            destroy() {
                this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy();
            }
            draw(t1, i) {
                const o = t1.getOrCreateProgram("vignette");
                if (!this.vignetteVx || !this.vignetteIdx) {
                    const i = new e.dr, o = new e.aU;
                    i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(1, 1), i.emplaceBack(-1, 1), o.emplaceBack(0, 1, 2), o.emplaceBack(0, 2, 3), this.vignetteVx = t1.context.createVertexBuffer(i, Oa.members), this.vignetteIdx = t1.context.createIndexBuffer(o);
                }
                const s = e.b7.simpleSegment(0, 0, 4, 6);
                if (this.vignetteVx && this.vignetteIdx) {
                    t1.uploadCommonUniforms(t1.context, o);
                    const e = {
                        u_vignetteShape: (r = {
                            vignetteShape: [
                                i.start,
                                i.range,
                                Math.pow(10, i.fadePower)
                            ],
                            vignetteColor: [
                                i.color.r,
                                i.color.g,
                                i.color.b,
                                i.color.a * i.strength
                            ]
                        }).vignetteShape,
                        u_vignetteColor: r.vignetteColor
                    };
                    o.draw(t1, t1.context.gl.TRIANGLES, Fi.disabled, Bi.disabled, Oi.alphaBlended, Gi.disabled, e, "vignette", this.vignetteVx, this.vignetteIdx, s, {});
                }
                var r;
            }
        }
        class ka {
            constructor(){
                this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
            }
            update(t1, i) {
                const o = t1.getFreeCameraOptions().position, s = o.toAltitude(), r = o.toLngLat(), a = e.ai(r.lng), n = e.ai(r.lat), l = t1.pixelsPerMeter / i, c = a * e.ds, h = e.ds * Math.log(Math.tan(Math.PI / 4 + n / 2));
                if (void 0 === this._offsetXPrev) this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
                else {
                    const e = -this._offsetYPrev + h, t1 = -this._elevationPrev + s;
                    this._accumulatedOffsetX += (-this._offsetXPrev + c) * l, this._accumulatedOffsetY += e * l, this._accumulatedElevation += t1 * l, this._offsetXPrev = c, this._offsetYPrev = h, this._elevationPrev = s;
                }
            }
            getPosition() {
                return [
                    this._accumulatedOffsetX,
                    this._accumulatedOffsetY,
                    this._accumulatedElevation
                ];
            }
        }
        function Ba(e, t1) {
            return [
                -(e[0] - Math.floor(e[0] / t1) * t1),
                -(e[1] - Math.floor(e[1] / t1) * t1),
                -(e[2] - Math.floor(e[2] / t1) * t1)
            ];
        }
        function Na(t1) {
            const i = e.di(1323123451230), o = [];
            for(let s = 0; s < t1; ++s){
                const t1 = 2 * i() - 1, s = 2 * i() - 1, r = 2 * i() - 1;
                o.push(e.ab.vec3.fromValues(t1, s, r));
            }
            return o;
        }
        function Ua(t1, i, o, s, r) {
            const a = e.aw((r - o) / (s - o), 0, 1);
            return (1 - a) * t1 + a * i;
        }
        class Ga {
            constructor(e){
                this._movement = new ka, this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new Fa, this._ppmScaleFactor = e;
            }
            destroy() {
                this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy();
            }
            updateOnRender(t1, i) {
                const o = t1.transform;
                this._movement.update(o, this._ppmScaleFactor);
                const s = o.starsProjMatrix, r = e.ab.quat.identity([]);
                e.ab.quat.rotateX(r, r, e.ai(90) - o._pitch), e.ab.quat.rotateZ(r, r, -o.angle);
                const a = e.ab.mat4.fromQuat(new Float32Array(16), r), n = e.ab.mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1), l = e.ab.mat4.transpose([], n), c = e.ab.mat4.multiply([], l, a), h = Date.now() / 1e3;
                return this._accumulatedTimeFromStart += (h - this._prevTime) * i, this._prevTime = h, {
                    projectionMatrix: s,
                    modelviewMatrix: c
                };
            }
        }
        class ja extends Ga {
            constructor(e){
                super(4.25), this._params = {
                    overrideStyleParameters: !1,
                    intensity: .5,
                    timeFactor: 1,
                    velocityConeAperture: 0,
                    velocity: 300,
                    boxSize: 2500,
                    dropletSizeX: 1,
                    dropletSizeYScale: 10,
                    distortionStrength: 70,
                    screenThinning: {
                        intensity: .57,
                        start: .46,
                        range: 1.17,
                        fadePower: .17,
                        affectedRatio: 1,
                        particleOffset: -.2
                    },
                    color: {
                        r: .66,
                        g: .68,
                        b: .74,
                        a: .7
                    },
                    direction: {
                        x: -50,
                        y: -35
                    },
                    shapeDirPower: 2,
                    shapeNormalPower: 1
                }, this._revealParams = new Ma(e.tp, [
                    "Precipitation",
                    "Rain"
                ]), this._vignetteParams = {
                    strength: 1,
                    start: .7,
                    range: 1,
                    fadePower: .4,
                    color: {
                        r: .27,
                        g: .27,
                        b: .27,
                        a: 1
                    }
                }, this.particlesCount = 16e3;
            }
            update(t1) {
                const i = t1.context;
                if (!this.particlesVx) {
                    const t1 = Na(this.particlesCount), o = new e.dt, s = new e.aU;
                    let r = 0;
                    const a = e.di(1323123451230);
                    for(let e = 0; e < t1.length; ++e){
                        const i = t1[e], n = [
                            2 * a() - 1,
                            a(),
                            a(),
                            a()
                        ];
                        o.emplaceBack(i[0], i[1], i[2], -1, -1, ...n), o.emplaceBack(i[0], i[1], i[2], 1, -1, ...n), o.emplaceBack(i[0], i[1], i[2], 1, 1, ...n), o.emplaceBack(i[0], i[1], i[2], -1, 1, ...n), s.emplaceBack(r + 0, r + 1, r + 2), s.emplaceBack(r + 0, r + 2, r + 3), r += 4;
                    }
                    this.particlesVx = i.createVertexBuffer(o, za.members), this.particlesIdx = i.createIndexBuffer(s);
                }
            }
            draw(t1) {
                if (!this._params.overrideStyleParameters && !t1.style.rain) return;
                const i = this._params.overrideStyleParameters ? this._revealParams : {
                    revealStart: 0,
                    revealRange: .01
                }, o = t1.transform.zoom;
                if (i.revealStart > o) return;
                const s = Ua(0, 1, i.revealStart, i.revealStart + i.revealRange, o);
                if (!this.particlesVx || !this.particlesIdx) return;
                const r = structuredClone(this._params);
                let a = [
                    -r.direction.x,
                    r.direction.y,
                    -100
                ];
                e.ab.vec3.normalize(a, a);
                const n = structuredClone(this._vignetteParams);
                n.strength *= s, r.overrideStyleParameters || (r.intensity = t1.style.rain.state.density, r.timeFactor = t1.style.rain.state.intensity, r.color = structuredClone(t1.style.rain.state.color), a = structuredClone(t1.style.rain.state.direction), r.screenThinning.intensity = t1.style.rain.state.centerThinning, r.dropletSizeX = t1.style.rain.state.dropletSize[0], r.dropletSizeYScale = t1.style.rain.state.dropletSize[1] / t1.style.rain.state.dropletSize[0], r.distortionStrength = 100 * t1.style.rain.state.distortionStrength, n.strength = 1, n.color = structuredClone(t1.style.rain.state.vignetteColor));
                const l = this.updateOnRender(t1, r.timeFactor), c = t1.context, h = c.gl, u = t1.transform;
                this.screenTexture && this.screenTexture.size[0] === t1.width && this.screenTexture.size[1] === t1.height || (this.screenTexture = new e.T(c, {
                    width: t1.width,
                    height: t1.height,
                    data: null
                }, h.RGBA8)), r.distortionStrength > 0 && (c.activeTexture.set(h.TEXTURE0), this.screenTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), h.copyTexSubImage2D(h.TEXTURE_2D, 0, 0, 0, 0, 0, t1.width, t1.height));
                const d = t1.getOrCreateProgram("rainParticle");
                t1.uploadCommonUniforms(c, d), c.activeTexture.set(h.TEXTURE0), this.screenTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE);
                const _ = [
                    r.color.r,
                    r.color.g,
                    r.color.b,
                    r.color.a
                ], p = (i, o)=>{
                    const n = Ba(this._movement.getPosition(), i), c = r.dropletSizeX, p = r.dropletSizeX * r.dropletSizeYScale, f = t1.width / 2, m = t1.height / 2, g = Ua(0, r.screenThinning.start, 0, 1, r.screenThinning.intensity), v = Ua(.001, r.screenThinning.range, 0, 1, r.screenThinning.intensity), y = Ua(0, r.screenThinning.particleOffset, 0, 1, r.screenThinning.intensity), x = (b = {
                        modelview: l.modelviewMatrix,
                        projection: l.projectionMatrix,
                        time: this._accumulatedTimeFromStart,
                        camPos: n,
                        velocityConeAperture: r.velocityConeAperture,
                        velocity: r.velocity,
                        boxSize: i,
                        rainDropletSize: [
                            c,
                            p
                        ],
                        distortionStrength: r.distortionStrength,
                        rainDirection: a,
                        color: _,
                        screenSize: [
                            u.width,
                            u.height
                        ],
                        thinningCenterPos: [
                            f,
                            m
                        ],
                        thinningShape: [
                            g,
                            v,
                            Math.pow(10, r.screenThinning.fadePower)
                        ],
                        thinningAffectedRatio: r.screenThinning.affectedRatio,
                        thinningParticleOffset: y,
                        shapeDirectionalPower: r.shapeDirPower,
                        shapeNormalPower: r.shapeNormalPower,
                        mode: o ? 0 : 1
                    }, {
                        u_modelview: Float32Array.from(b.modelview),
                        u_projection: Float32Array.from(b.projection),
                        u_time: b.time,
                        u_cam_pos: b.camPos,
                        u_texScreen: 0,
                        u_velocityConeAperture: b.velocityConeAperture,
                        u_velocity: b.velocity,
                        u_boxSize: b.boxSize,
                        u_rainDropletSize: b.rainDropletSize,
                        u_distortionStrength: b.distortionStrength,
                        u_rainDirection: b.rainDirection,
                        u_color: b.color,
                        u_screenSize: b.screenSize,
                        u_thinningCenterPos: b.thinningCenterPos,
                        u_thinningShape: b.thinningShape,
                        u_thinningAffectedRatio: b.thinningAffectedRatio,
                        u_thinningParticleOffset: b.thinningParticleOffset,
                        u_shapeDirectionalPower: b.shapeDirectionalPower,
                        u_shapeNormalPower: b.shapeNormalPower,
                        u_mode: b.mode
                    });
                    var b;
                    const w = Math.round(s * r.intensity * this.particlesCount), T = e.b7.simpleSegment(0, 0, 4 * w, 2 * w);
                    d.draw(t1, h.TRIANGLES, Fi.disabled, Bi.disabled, Oi.alphaBlended, Gi.disabled, x, "rain_particles", this.particlesVx, this.particlesIdx, T, {});
                };
                r.distortionStrength > 0 && p(r.boxSize, !0), p(r.boxSize, !1), this._vignette.draw(t1, n);
            }
        }
        const Va = e.da([
            {
                type: "Float32",
                name: "a_pos_3f",
                components: 3
            },
            {
                type: "Float32",
                name: "a_uv",
                components: 2
            },
            {
                type: "Float32",
                name: "a_snowParticleData",
                components: 4
            },
            {
                type: "Float32",
                name: "a_snowParticleDataHorizontalOscillation",
                components: 2
            }
        ]);
        class qa extends Ga {
            constructor(e){
                super(2.25), this._params = {
                    overrideStyleParameters: !1,
                    intensity: .85,
                    timeFactor: .75,
                    velocityConeAperture: 70,
                    velocity: 40,
                    horizontalOscillationRadius: 4,
                    horizontalOscillationRate: 1.5,
                    boxSize: 2e3,
                    billboardSize: 2,
                    shapeFadeStart: .27,
                    shapeFadePower: .21,
                    screenThinning: {
                        intensity: .4,
                        start: .15,
                        range: 1.4,
                        fadePower: .24,
                        affectedRatio: 1,
                        particleOffset: -.2
                    },
                    color: {
                        r: 1,
                        g: 1,
                        b: 1,
                        a: 1
                    },
                    direction: {
                        x: -50,
                        y: -35
                    }
                }, this._revealParams = new Ma(e.tp, [
                    "Precipitation",
                    "Snow"
                ]), this._vignetteParams = {
                    strength: .3,
                    start: .78,
                    range: .46,
                    fadePower: .2,
                    color: {
                        r: 1,
                        g: 1,
                        b: 1,
                        a: 1
                    }
                }, this.particlesCount = 16e3;
            }
            update(t1) {
                const i = t1.context;
                if (!this.particlesVx) {
                    const t1 = Na(this.particlesCount), o = new e.du, s = new e.aU;
                    let r = 0;
                    const a = e.di(1323123451230);
                    for(let e = 0; e < t1.length; ++e){
                        const i = t1[e], n = a(), l = a(), c = a(), h = [
                            e / t1.length,
                            n,
                            l,
                            c
                        ], u = [
                            a(),
                            a()
                        ];
                        o.emplaceBack(i[0], i[1], i[2], -1, -1, ...h, ...u), o.emplaceBack(i[0], i[1], i[2], 1, -1, ...h, ...u), o.emplaceBack(i[0], i[1], i[2], 1, 1, ...h, ...u), o.emplaceBack(i[0], i[1], i[2], -1, 1, ...h, ...u), s.emplaceBack(r + 0, r + 1, r + 2), s.emplaceBack(r + 0, r + 2, r + 3), r += 4;
                    }
                    this.particlesVx = i.createVertexBuffer(o, Va.members), this.particlesIdx = i.createIndexBuffer(s);
                }
            }
            draw(t1) {
                if (!this._params.overrideStyleParameters && !t1.style.snow) return;
                const i = structuredClone(this._params);
                let o = [
                    -i.direction.x,
                    i.direction.y,
                    -100
                ];
                e.ab.vec3.normalize(o, o);
                const s = structuredClone(this._vignetteParams), r = i.overrideStyleParameters ? this._revealParams : {
                    revealStart: 0,
                    revealRange: .01
                }, a = t1.transform.zoom;
                if (r.revealStart > a) return;
                const n = Ua(0, 1, r.revealStart, r.revealStart + r.revealRange, a);
                s.strength *= n, i.overrideStyleParameters || (i.intensity = t1.style.snow.state.density, i.timeFactor = t1.style.snow.state.intensity, i.color = structuredClone(t1.style.snow.state.color), o = structuredClone(t1.style.snow.state.direction), i.screenThinning.intensity = t1.style.snow.state.centerThinning, i.billboardSize = 2.79 * t1.style.snow.state.flakeSize, s.strength = 1, s.color = structuredClone(t1.style.snow.state.vignetteColor));
                const l = this.updateOnRender(t1, i.timeFactor);
                if (!this.particlesVx || !this.particlesIdx) return;
                const c = t1.context, h = c.gl, u = t1.transform, d = t1.getOrCreateProgram("snowParticle");
                t1.uploadCommonUniforms(c, d), ((i, s, r)=>{
                    const a = Ba(this._movement.getPosition(), i), c = u.width / 2, _ = u.height / 2, p = Ua(0, r.screenThinning.start, 0, 1, r.screenThinning.intensity), f = Ua(.001, r.screenThinning.range, 0, 1, r.screenThinning.intensity), m = Ua(0, r.screenThinning.particleOffset, 0, 1, r.screenThinning.intensity), g = (v = {
                        modelview: l.modelviewMatrix,
                        projection: l.projectionMatrix,
                        time: this._accumulatedTimeFromStart,
                        camPos: a,
                        velocityConeAperture: r.velocityConeAperture,
                        velocity: r.velocity,
                        horizontalOscillationRadius: r.horizontalOscillationRadius,
                        horizontalOscillationRate: r.horizontalOscillationRate,
                        boxSize: i,
                        billboardSize: 1 * r.billboardSize,
                        simpleShapeParameters: [
                            r.shapeFadeStart,
                            r.shapeFadePower
                        ],
                        screenSize: [
                            u.width,
                            u.height
                        ],
                        thinningCenterPos: [
                            c,
                            _
                        ],
                        thinningShape: [
                            p,
                            f,
                            Math.pow(10, r.screenThinning.fadePower)
                        ],
                        thinningAffectedRatio: r.screenThinning.affectedRatio,
                        thinningParticleOffset: m,
                        color: [
                            r.color.r,
                            r.color.g,
                            r.color.b,
                            r.color.a
                        ],
                        direction: o
                    }, {
                        u_modelview: Float32Array.from(v.modelview),
                        u_projection: Float32Array.from(v.projection),
                        u_time: v.time,
                        u_cam_pos: v.camPos,
                        u_velocityConeAperture: v.velocityConeAperture,
                        u_velocity: v.velocity,
                        u_horizontalOscillationRadius: v.horizontalOscillationRadius,
                        u_horizontalOscillationRate: v.horizontalOscillationRate,
                        u_boxSize: v.boxSize,
                        u_billboardSize: v.billboardSize,
                        u_simpleShapeParameters: v.simpleShapeParameters,
                        u_screenSize: v.screenSize,
                        u_thinningCenterPos: v.thinningCenterPos,
                        u_thinningShape: v.thinningShape,
                        u_thinningAffectedRatio: v.thinningAffectedRatio,
                        u_thinningParticleOffset: v.thinningParticleOffset,
                        u_particleColor: v.color,
                        u_direction: v.direction
                    });
                    var v;
                    const y = Math.round(n * r.intensity * this.particlesCount), x = e.b7.simpleSegment(0, 0, 4 * y, 2 * y);
                    this.particlesVx && this.particlesIdx && d.draw(t1, h.TRIANGLES, Fi.disabled, Bi.disabled, Oi.alphaBlended, Gi.disabled, g, "snow_particles", this.particlesVx, this.particlesIdx, x, {});
                })(i.boxSize, 0, i), this._vignette.draw(t1, s);
            }
        }
        const Ha = {
            symbol: function(t1, i, o, s, r) {
                if ("translucent" !== t1.renderPass) return;
                const a = Bi.disabled, n = t1.colorModeForRenderPass(), l = o.layout.get("text-variable-anchor"), c = o.layout.get("text-size-scale-range"), h = e.aw(t1.scaleFactor, c[0], c[1]);
                l && function(t1, i, o, s, r, a, n, l) {
                    const c = i.transform, h = "map" === r, u = "map" === a;
                    for (const i of t1){
                        const t1 = s.getTile(i), r = t1.getBucket(o);
                        if (!r || !r.text || !r.text.segments.get().length) continue;
                        const a = e.bp(r.textSizeData, c.zoom, l), d = ni(i, r.getProjection(), c), _ = c.calculatePixelsToTileUnitsMatrix(t1), p = jt(d, t1.tileID.canonical, u, h, c, r.getProjection(), _), f = r.hasIconTextFit() && r.hasIconData();
                        if (a) {
                            const o = Math.pow(2, c.zoom - t1.tileID.overscaledZ);
                            zr(r, h, u, n, e.cX, c, p, i, o, a, f);
                        }
                    }
                }(s, t1, o, i, o.layout.get("text-rotation-alignment"), o.layout.get("text-pitch-alignment"), r, h);
                const u = 0 !== o.paint.get("icon-opacity").constantOr(1), d = 0 !== o.paint.get("text-opacity").constantOr(1);
                void 0 !== o.layout.get("symbol-sort-key").constantOr(1) && (u || d) ? Pr(t1, i, o, s, a, n) : (u && Pr(t1, i, o, s, a, n, {
                    onlyIcons: !0
                }), d && Pr(t1, i, o, s, a, n, {
                    onlyText: !0
                })), i.map.showCollisionBoxes && (Rr(t1, i, o, s, o.paint.get("text-translate"), o.paint.get("text-translate-anchor"), !0), Rr(t1, i, o, s, o.paint.get("icon-translate"), o.paint.get("icon-translate-anchor"), !1));
            },
            circle: function(t1, i, o, s) {
                if ("translucent" !== t1.renderPass) return;
                const r = o.paint.get("circle-opacity"), a = o.paint.get("circle-stroke-width"), n = o.paint.get("circle-stroke-opacity"), l = void 0 !== o.layout.get("circle-sort-key").constantOr(1), c = o.paint.get("circle-emissive-strength");
                if (0 === r.constantOr(1) && (0 === a.constantOr(1) || 0 === n.constantOr(1))) return;
                const h = t1.context, u = h.gl, d = t1.transform, _ = t1.depthModeForSublayer(0, Fi.ReadOnly), p = Bi.disabled, f = t1.colorModeForDrapableLayerRenderPass(c), m = "globe" === d.projection.name, g = [
                    e.at(d.center.lng),
                    e.aA(d.center.lat)
                ], v = [];
                for(let r = 0; r < s.length; r++){
                    const a = s[r], n = i.getTile(a), c = n.getBucket(o);
                    if (!c || c.projection.name !== d.projection.name) continue;
                    const h = c.programConfigurations.get(o.id), u = e.cY(o), _ = t1.isTileAffectedByFog(a);
                    m && u.push("PROJECTION_GLOBE_VIEW"), u.push("DEPTH_D24"), t1.terrain && d.depthOcclusionForSymbolsAndCircles && u.push("DEPTH_OCCLUSION");
                    const p = t1.getOrCreateProgram("circle", {
                        config: h,
                        defines: u,
                        overrideFog: _
                    }), f = c.layoutVertexBuffer, y = c.globeExtVertexBuffer, x = c.indexBuffer, b = d.projection.createInversionMatrix(d, a.canonical), w = {
                        programConfiguration: h,
                        program: p,
                        layoutVertexBuffer: f,
                        globeExtVertexBuffer: y,
                        indexBuffer: x,
                        uniformValues: e.cZ(t1, a, n, b, g, o),
                        tile: n
                    };
                    if (l) {
                        const t1 = c.segments.get();
                        for (const i of t1)v.push({
                            segments: new e.b7([
                                i
                            ]),
                            sortKey: i.sortKey,
                            state: w
                        });
                    } else v.push({
                        segments: c.segments,
                        sortKey: 0,
                        state: w
                    });
                }
                l && v.sort((e, t1)=>e.sortKey - t1.sortKey);
                const y = {
                    useDepthForOcclusion: d.depthOcclusionForSymbolsAndCircles
                };
                for (const e of v){
                    const { programConfiguration: i, program: s, layoutVertexBuffer: r, globeExtVertexBuffer: a, indexBuffer: n, uniformValues: l, tile: c } = e.state, m = e.segments;
                    t1.terrain && t1.terrain.setupElevationDraw(c, s, y), t1.uploadCommonUniforms(h, s, c.tileID.toUnwrapped()), s.draw(t1, u.TRIANGLES, _, p, f, Gi.disabled, l, o.id, r, n, m, o.paint, d.zoom, i, [
                        a
                    ]);
                }
            },
            heatmap: function(t1, i, o, s) {
                if (0 !== o.paint.get("heatmap-opacity")) if ("offscreen" === t1.renderPass) {
                    const r = t1.context, a = r.gl, n = Bi.disabled, l = new Oi([
                        a.ONE,
                        a.ONE,
                        a.ONE,
                        a.ONE
                    ], e.aj.transparent, [
                        !0,
                        !0,
                        !0,
                        !0
                    ]);
                    !function(e, t1, i, o) {
                        const s = e.gl, r = t1.width * o, a = t1.height * o;
                        e.activeTexture.set(s.TEXTURE1), e.viewport.set([
                            0,
                            0,
                            r,
                            a
                        ]);
                        let n = i.heatmapFbo;
                        if (!n || n && (n.width !== r || n.height !== a)) {
                            n && n.destroy();
                            const t1 = s.createTexture();
                            s.bindTexture(s.TEXTURE_2D, t1), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR), n = i.heatmapFbo = e.createFramebuffer(r, a, !0, null), function(e, t1, i, o, s, r) {
                                const a = e.gl;
                                a.texImage2D(a.TEXTURE_2D, 0, e.extRenderToTextureHalfFloat ? a.RGBA16F : a.RGBA, s, r, 0, a.RGBA, e.extRenderToTextureHalfFloat ? a.HALF_FLOAT : a.UNSIGNED_BYTE, null), o.colorAttachment.set(i);
                            }(e, 0, t1, n, r, a);
                        } else s.bindTexture(s.TEXTURE_2D, n.colorAttachment.get()), e.bindFramebuffer.set(n.framebuffer);
                    }(r, t1, o, "globe" === t1.transform.projection.name ? .5 : .25), r.clear({
                        color: e.aj.transparent
                    });
                    const c = t1.transform, h = "globe" === c.projection.name, u = h ? [
                        "PROJECTION_GLOBE_VIEW"
                    ] : [], d = h ? Gi.frontCCW : Gi.disabled, _ = [
                        e.at(c.center.lng),
                        e.aA(c.center.lat)
                    ];
                    for(let e = 0; e < s.length; e++){
                        const p = s[e];
                        if (i.hasRenderableParent(p)) continue;
                        const f = i.getTile(p), m = f.getBucket(o);
                        if (!m || m.projection.name !== c.projection.name) continue;
                        const g = t1.isTileAffectedByFog(p), v = m.programConfigurations.get(o.id), y = t1.getOrCreateProgram("heatmap", {
                            config: v,
                            defines: u,
                            overrideFog: g
                        }), { zoom: x } = t1.transform;
                        t1.terrain && t1.terrain.setupElevationDraw(f, y), t1.uploadCommonUniforms(r, y, p.toUnwrapped());
                        const b = c.projection.createInversionMatrix(c, p.canonical);
                        y.draw(t1, a.TRIANGLES, Fi.disabled, n, l, d, rr(t1, p, f, b, _, x, o.paint.get("heatmap-intensity")), o.id, m.layoutVertexBuffer, m.indexBuffer, m.segments, o.paint, t1.transform.zoom, v, h ? [
                            m.globeExtVertexBuffer
                        ] : null);
                    }
                    r.viewport.set([
                        0,
                        0,
                        t1.width,
                        t1.height
                    ]);
                } else "translucent" === t1.renderPass && (t1.context.setColorMode(t1.colorModeForRenderPass()), function(t1, i) {
                    const o = t1.context, s = o.gl, r = i.heatmapFbo;
                    if (!r) return;
                    o.activeTexture.set(s.TEXTURE0), s.bindTexture(s.TEXTURE_2D, r.colorAttachment.get()), o.activeTexture.set(s.TEXTURE1);
                    let a = i.colorRampTexture;
                    a || (a = i.colorRampTexture = new e.T(o, i.colorRamp, s.RGBA8)), a.bind(s.LINEAR, s.CLAMP_TO_EDGE), t1.getOrCreateProgram("heatmapTexture").draw(t1, s.TRIANGLES, Fi.disabled, Bi.disabled, t1.colorModeForRenderPass(), Gi.disabled, ((e, t1, i, o)=>({
                            u_image: 0,
                            u_color_ramp: 1,
                            u_opacity: t1.paint.get("heatmap-opacity")
                        }))(0, i), i.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments, i.paint, t1.transform.zoom);
                }(t1, o));
            },
            line: function(t1, i, o, s) {
                if ("translucent" !== t1.renderPass) return;
                const r = o.paint.get("line-opacity"), a = o.paint.get("line-width");
                if (0 === r.constantOr(1) || 0 === a.constantOr(1)) return;
                const n = o.paint.get("line-emissive-strength"), l = o.paint.get("line-occlusion-opacity"), c = o.layout.get("line-elevation-reference"), h = "meters" === o.layout.get("line-width-unit"), u = "sea" === c, d = t1.context, _ = d.gl, p = !o.isDraped();
                if (p && "globe" === t1.transform.projection.name) return;
                const f = o.layout.get("line-cross-slope"), m = void 0 !== f, g = f < 1, v = p ? new Fi(t1.depthOcclusion ? _.GREATER : _.LEQUAL, Fi.ReadOnly, t1.depthRangeFor3D) : t1.depthModeForSublayer(0, Fi.ReadOnly), y = t1.colorModeForDrapableLayerRenderPass(n), x = t1.terrain && t1.terrain.renderingToTexture, b = x ? 1 : e.q.devicePixelRatio, w = o.paint.get("line-dasharray"), T = w.constantOr(1), E = o.layout.get("line-cap"), S = w.constantOr(null), C = E.constantOr(null), I = o.paint.get("line-pattern"), R = I.constantOr(1), D = I.constantOr(null), L = o.paint.get("line-opacity").constantOr(1);
                let A = !R && 1 !== L || t1.depthOcclusion && l > 0 && l < 1;
                const z = o.paint.get("line-gradient"), P = R ? "linePattern" : "line", M = e.c_(o);
                let O;
                if (x && t1.terrain && t1.terrain.clipOrMaskOverlapStencilType() && (A = !1), 0 !== l && t1.depthOcclusion) {
                    const t1 = o.paint._values["line-opacity"];
                    t1 && t1.value && "constant" === t1.value.kind ? O = t1.value : e.w(`Occlusion opacity for layer ${o.id} is supported only when line-opacity isn't data-driven.`);
                }
                if (p && (t1.forceTerrainMode = !0), !p && 0 !== l && t1.terrain && !x) return void e.w(`Occlusion opacity for layer ${o.id} is supported on terrain only if the layer has line-z-offset enabled.`);
                const F = A && p ? t1.stencilModeFor3D() : Bi.disabled;
                p && (M.push("ELEVATED"), m && M.push(g ? "CROSS_SLOPE_HORIZONTAL" : "CROSS_SLOPE_VERTICAL"), u && M.push("ELEVATION_REFERENCE_SEA")), "constant" !== a.value.kind && !1 === a.value.isLineProgressConstant && M.push("VARIABLE_LINE_WIDTH");
                for (const r of s){
                    const s = i.getTile(r);
                    if (R && !s.patternsLoaded()) continue;
                    const a = s.getBucket(o);
                    if (!a) continue;
                    t1.prepareDrawTile();
                    const n = a.programConfigurations.get(o.id), c = t1.isTileAffectedByFog(r), f = t1.getOrCreateProgram(P, {
                        config: n,
                        defines: M,
                        overrideFog: c,
                        overrideRtt: !p && void 0
                    });
                    if (D && s.imageAtlas) {
                        const t1 = e.A.from(D), i = s.imageAtlas.patternPositions[t1.getSerializedPrimary()];
                        i && n.setConstantPatternPositions(i);
                    }
                    if (!R && S && C && s.lineAtlas) {
                        const e = s.lineAtlas.getDash(S, C);
                        e && n.setConstantPatternPositions(e);
                    }
                    let [m, g] = o.paint.get("line-trim-offset");
                    if ("round" === C || "square" === C) {
                        const e = 1;
                        m !== g && (0 === m && (m -= e), 1 === g && (g += e));
                    }
                    const w = x ? r.projMatrix : null, E = h ? 1 / a.tileToMeter / e.ar(s, 1, t1.transform.zoom) : 1, I = h ? 1 / a.tileToMeter / e.ar(s, 1, Math.floor(t1.transform.zoom)) : 1, k = R ? e.c$(t1, s, o, w, b, E, I, [
                        m,
                        g
                    ]) : e.d0(t1, s, o, w, a.lineClipsArray.length, b, E, I, [
                        m,
                        g
                    ]);
                    if (z) {
                        const s = a.gradients[o.id];
                        let n = s.texture;
                        if (o.gradientVersion !== s.version) {
                            let l = 256;
                            if (o.stepInterpolant) {
                                const o = i.getSource().maxzoom, s = r.canonical.z === o ? Math.ceil(1 << t1.transform.maxZoom - r.canonical.z) : 1;
                                l = e.aw(e.d1(a.maxLineLength / e.ag * 1024 * s), 256, d.maxTextureSize);
                            }
                            s.gradient = e.d2({
                                expression: o.gradientExpression(),
                                evaluationKey: "lineProgress",
                                resolution: l,
                                image: s.gradient || void 0,
                                clips: a.lineClipsArray
                            }), s.texture ? s.texture.update(s.gradient) : s.texture = new e.T(d, s.gradient, _.RGBA8), s.version = o.gradientVersion, n = s.texture;
                        }
                        d.activeTexture.set(_.TEXTURE1), n.bind(o.stepInterpolant ? _.NEAREST : _.LINEAR, _.CLAMP_TO_EDGE);
                    }
                    T && (d.activeTexture.set(_.TEXTURE0), s.lineAtlasTexture && s.lineAtlasTexture.bind(_.LINEAR, _.REPEAT), n.updatePaintBuffers()), R && (d.activeTexture.set(_.TEXTURE0), s.imageAtlasTexture && s.imageAtlasTexture.bind(_.LINEAR, _.CLAMP_TO_EDGE), n.updatePaintBuffers()), p && !u && t1.terrain.setupElevationDraw(s, f), t1.uploadCommonUniforms(d, f, r.toUnwrapped());
                    const B = (e)=>{
                        null != O && (O.value = L * l), f.draw(t1, _.TRIANGLES, v, e, y, Gi.disabled, k, o.id, a.layoutVertexBuffer, a.indexBuffer, a.segments, o.paint, t1.transform.zoom, n, [
                            a.layoutVertexBuffer2,
                            a.patternVertexBuffer,
                            a.zOffsetVertexBuffer
                        ]), null != O && (O.value = L);
                    };
                    if (A && !p) {
                        const e = t1.stencilModeForClipping(r).ref;
                        0 === e && x && d.clear({
                            stencil: 0
                        });
                        const i = {
                            func: _.EQUAL,
                            mask: 255
                        };
                        k.u_alpha_discard_threshold = .8, B(new Bi(i, e, 255, _.KEEP, _.KEEP, _.INVERT)), k.u_alpha_discard_threshold = 0, B(new Bi(i, e, 255, _.KEEP, _.KEEP, _.KEEP));
                    } else A && p && (k.u_alpha_discard_threshold = .001), B(p ? F : t1.stencilModeForClipping(r));
                }
                p && (t1.forceTerrainMode = !1), A && (t1.resetStencilClippingMasks(), x && d.clear({
                    stencil: 0
                })), 0 === l || t1.depthOcclusion || x || t1.layersWithOcclusionOpacity.push(t1.currentLayer);
            },
            fill: function(t1, i, o, s) {
                const r = o.paint.get("fill-color"), a = o.paint.get("fill-opacity"), n = o.is3D(), l = new Fi(t1.context.gl.LEQUAL, Fi.ReadWrite, t1.depthRangeFor3D);
                if (0 === a.constantOr(1)) return;
                const c = o.paint.get("fill-emissive-strength"), h = t1.colorModeForDrapableLayerRenderPass(c), u = o.paint.get("fill-pattern"), d = t1.opaquePassEnabledForLayer() && !u.constantOr(1) && 1 === r.constantOr(e.aj.transparent).a && 1 === a.constantOr(0) ? "opaque" : "translucent";
                if (t1.renderPass === d) {
                    const e = n ? l : t1.depthModeForSublayer(1, "opaque" === t1.renderPass ? Fi.ReadWrite : Fi.ReadOnly);
                    Or(t1, i, o, s, e, h, !1);
                }
                if (!n && "translucent" === t1.renderPass && o.paint.get("fill-antialias")) {
                    const e = n ? l : t1.depthModeForSublayer(o.getPaintProperty("fill-outline-color") ? 2 : 0, Fi.ReadOnly);
                    Or(t1, i, o, s, e, h, !0);
                }
            },
            "fill-extrusion": function(t1, i, o, s) {
                const r = o.paint.get("fill-extrusion-opacity"), a = t1.context, n = a.gl, l = t1.terrain, c = l && l.renderingToTexture;
                if (0 === r) return;
                const h = t1.conflationActive && t1.style.isLayerClipped(o, i.getSource()), u = t1.style.order.indexOf(o.fqid);
                if (h && function(e, t1, i, o, s) {
                    for (const r of o){
                        const o = t1.getTile(r).getBucket(i);
                        o && (o.updateReplacement(r, e.replacementSource, s), o.uploadCentroid(e.context));
                    }
                }(t1, i, o, s, u), l || h) for (const e of s){
                    const s = i.getTile(e).getBucket(o);
                    s && Br(t1.context, i, e, s, o, l, h);
                }
                if ("shadow" === t1.renderPass && t1.shadowRenderer) {
                    const a = t1.shadowRenderer;
                    if (l && r < .65 && o._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof e.a9) return;
                    const n = a.getShadowPassDepthMode(), c = a.getShadowPassColorMode();
                    Fr(t1, i, o, s, n, Bi.disabled, c, h);
                } else if ("translucent" === t1.renderPass) {
                    const u = !o.paint.get("fill-extrusion-pattern").constantOr(1), d = o.paint.get("fill-extrusion-color").constantOr(e.aj.white);
                    if (!c && 0 !== d.a) {
                        const e = new Fi(t1.context.gl.LEQUAL, Fi.ReadWrite, t1.depthRangeFor3D);
                        1 === r && u ? Fr(t1, i, o, s, e, Bi.disabled, Oi.unblended, h) : (Fr(t1, i, o, s, e, Bi.disabled, Oi.disabled, h), Fr(t1, i, o, s, e, t1.stencilModeFor3D(), t1.colorModeForRenderPass(), h), t1.resetStencilClippingMasks());
                    }
                    if (t1.style.enable3dLights() && u && (!l && "globe" !== t1.transform.projection.name || c)) {
                        const r = o.paint.get("fill-extrusion-opacity"), u = o.paint.get("fill-extrusion-ambient-occlusion-intensity"), d = o.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), _ = o.paint.get("fill-extrusion-flood-light-intensity"), p = "none" === o.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default"), f = o.paint.get("fill-extrusion-flood-light-color").toRenderColor(p ? null : o.lut).toArray01().slice(0, 3), m = u > 0 && d > 0, g = _ > 0, v = (e, t1, i)=>(1 - i) * e + i * t1, y = (a)=>{
                            const l = t1.depthModeForSublayer(1, Fi.ReadOnly, n.LEQUAL, !0), c = o.paint.get(a ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), p = v(.1, 3, c), m = t1._showOverdrawInspector;
                            if (!m) {
                                const c = new Bi({
                                    func: n.ALWAYS,
                                    mask: 255
                                }, 255, 255, n.KEEP, n.KEEP, n.REPLACE), m = new Oi([
                                    n.ONE,
                                    n.ONE,
                                    n.ONE,
                                    n.ONE
                                ], e.aj.transparent, [
                                    !1,
                                    !1,
                                    !1,
                                    !0
                                ], n.MIN);
                                kr(t1, i, o, s, l, c, m, Gi.disabled, a, "sdf", r, u, d, _, f, p, h, !1);
                            }
                            {
                                const c = m ? Bi.disabled : new Bi({
                                    func: n.EQUAL,
                                    mask: 255
                                }, 255, 255, n.KEEP, n.DECR, n.DECR), g = m ? t1.colorModeForRenderPass() : new Oi([
                                    n.ONE_MINUS_DST_ALPHA,
                                    n.DST_ALPHA,
                                    n.ONE,
                                    n.ONE
                                ], e.aj.transparent, [
                                    !0,
                                    !0,
                                    !0,
                                    !0
                                ]);
                                kr(t1, i, o, s, l, c, g, Gi.disabled, a, "color", r, u, d, _, f, p, h, !1);
                            }
                        };
                        if (c) {
                            const c = (a, l, c)=>{
                                const p = t1.depthModeForSublayer(1, Fi.ReadOnly, n.LEQUAL, !1), m = o.paint.get(a ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), g = v(.1, 3, m);
                                {
                                    const c = new Oi([
                                        n.ONE,
                                        n.ONE,
                                        n.ONE,
                                        n.ONE
                                    ], e.aj.transparent, [
                                        !1,
                                        !1,
                                        !1,
                                        !0
                                    ]);
                                    kr(t1, i, o, s, p, Bi.disabled, c, Gi.disabled, a, "clear", r, u, d, _, f, g, h, l);
                                }
                                {
                                    const c = new Bi({
                                        func: n.ALWAYS,
                                        mask: 255
                                    }, 255, 255, n.KEEP, n.KEEP, n.REPLACE), m = new Oi([
                                        n.ONE,
                                        n.ONE,
                                        n.ONE,
                                        n.ONE
                                    ], e.aj.transparent, [
                                        !1,
                                        !1,
                                        !1,
                                        !0
                                    ], n.MIN);
                                    kr(t1, i, o, s, p, c, m, Gi.disabled, a, "sdf", r, u, d, _, f, g, h, l);
                                }
                                {
                                    const c = a ? n.ZERO : n.ONE_MINUS_DST_ALPHA, m = new Bi({
                                        func: n.EQUAL,
                                        mask: 255
                                    }, 255, 255, n.KEEP, n.DECR, n.DECR), v = new Oi([
                                        c,
                                        n.DST_ALPHA,
                                        n.ONE_MINUS_DST_ALPHA,
                                        n.ZERO
                                    ], e.aj.transparent, [
                                        !0,
                                        !0,
                                        !0,
                                        !0
                                    ]);
                                    kr(t1, i, o, s, p, m, v, Gi.disabled, a, "color", r, u, d, _, f, g, h, l);
                                }
                                {
                                    const m = new Oi([
                                        n.ONE,
                                        n.ONE,
                                        n.ONE,
                                        a ? n.ZERO : n.ONE
                                    ], e.aj.transparent, [
                                        !1,
                                        !1,
                                        !1,
                                        !0
                                    ], a ? n.FUNC_ADD : n.MAX);
                                    kr(t1, i, o, s, p, Bi.disabled, m, Gi.disabled, a, "clear", r, u, d, _, f, g, h, l, c);
                                }
                            };
                            if (m || g) {
                                let i;
                                if (t1.prepareDrawTile(), l) {
                                    const t1 = l.drapeBufferSize[0], o = l.drapeBufferSize[1];
                                    i = l.framebufferCopyTexture, i && (!i || i.size[0] === t1 && i.size[1] === o) || (i && i.destroy(), i = l.framebufferCopyTexture = new e.T(a, new e.r({
                                        width: t1,
                                        height: o
                                    }), n.RGBA8)), i.bind(n.LINEAR, n.CLAMP_TO_EDGE), n.copyTexSubImage2D(n.TEXTURE_2D, 0, 0, 0, 0, 0, t1, o);
                                }
                                m && c(!0, !1, i), g && c(!1, !0, i);
                            }
                        } else m && y(!0), g && y(!1), (m || g) && t1.resetStencilClippingMasks();
                    }
                }
            },
            hillshade: function(e, t1, i, o) {
                if ("offscreen" !== e.renderPass && "translucent" !== e.renderPass) return;
                if (e.style.disableElevatedTerrain) return;
                const s = e.context, r = e.terrain && e.terrain.renderingToTexture, [a, n] = "translucent" !== e.renderPass || r ? [
                    {},
                    o
                ] : e.stencilConfigForOverlap(o);
                for (const o of n){
                    const s = t1.getTile(o);
                    if (s.needsHillshadePrepare && "offscreen" === e.renderPass) Ho(e, s, i);
                    else if ("translucent" === e.renderPass) {
                        const t1 = e.depthModeForSublayer(0, Fi.ReadOnly), n = i.paint.get("hillshade-emissive-strength"), l = e.colorModeForDrapableLayerRenderPass(n), c = r && e.terrain ? e.terrain.stencilModeForRTTOverlap(o) : a[o.overscaledZ];
                        Vo(e, o, s, i, t1, c, l);
                    }
                }
                s.viewport.set([
                    0,
                    0,
                    e.width,
                    e.height
                ]), e.resetStencilClippingMasks();
            },
            raster: function(t1, i, o, s, r, a) {
                if ("translucent" !== t1.renderPass) return;
                if (0 === o.paint.get("raster-opacity")) return;
                const n = "globe" === t1.transform.projection.name, l = 0 !== o.paint.get("raster-elevation"), c = l && n;
                if (t1.renderElevatedRasterBackface && !c) return;
                const h = t1.context, u = h.gl, d = i.getSource(), _ = function(t1, i, o, s) {
                    const r = i.paint.get("raster-color"), a = "raster-array" === t1.type, n = [], l = i.paint.get("raster-resampling"), c = i.paint.get("raster-color-mix");
                    let h = i.paint.get("raster-color-range");
                    const u = [
                        c[0],
                        c[1],
                        c[2],
                        0
                    ], d = c[3];
                    let _ = "nearest" === l ? s.NEAREST : s.LINEAR;
                    if (a && (n.push("RASTER_ARRAY"), r || n.push("RASTER_COLOR"), "linear" === l && n.push("RASTER_ARRAY_LINEAR"), _ = s.NEAREST, !h && t1.rasterLayers)) {
                        const e = t1.rasterLayers.find(({ id: e })=>e === i.sourceLayer);
                        e && e.fields && e.fields.range && (h = e.fields.range);
                    }
                    if (h = h || [
                        0,
                        1
                    ], r) {
                        n.push("RASTER_COLOR"), o.activeTexture.set(s.TEXTURE2), i.updateColorRamp(h);
                        let t1 = i.colorRampTexture;
                        t1 || (t1 = i.colorRampTexture = new e.T(o, i.colorRamp, s.RGBA8)), t1.bind(s.LINEAR, s.CLAMP_TO_EDGE);
                    }
                    return {
                        mix: u,
                        range: h,
                        offset: d,
                        defines: n,
                        resampling: _
                    };
                }(d, o, h, u);
                if (d instanceof e.aJ && !s.length && !n) return;
                const p = o.paint.get("raster-emissive-strength"), f = t1.colorModeForDrapableLayerRenderPass(p), m = t1.terrain && t1.terrain.renderingToTexture, g = !t1.options.moving, v = "nearest" === o.paint.get("raster-resampling") ? u.NEAREST : u.LINEAR;
                if (d instanceof e.aJ && !s.length && (d.onNorthPole || d.onSouthPole)) {
                    const e = l ? t1.stencilModeFor3D() : Bi.disabled;
                    return void qr(!!d.onNorthPole, null, t1, i, o, p, _, Gi.disabled, e);
                }
                if (!s.length) return;
                const [y, x] = d instanceof e.aJ || m ? [
                    {},
                    s
                ] : t1.stencilConfigForOverlap(s), b = x[x.length - 1].overscaledZ;
                c && _.defines.push("PROJECTION_GLOBE_VIEW"), l && _.defines.push("RENDER_CUTOFF");
                const w = (s, r, x)=>{
                    for (const w of s){
                        const s = w.toUnwrapped(), T = i.getTile(w);
                        if (m && (!T || !T.hasData())) continue;
                        h.activeTexture.set(u.TEXTURE0);
                        const E = Zr(T, d, o, _);
                        if (!E || !E.texture) continue;
                        const { texture: S, mix: C, offset: I, tileSize: R, buffer: D } = E;
                        let L, A;
                        m ? (L = Fi.disabled, A = w.projMatrix) : l ? (L = new Fi(u.LEQUAL, Fi.ReadWrite, t1.depthRangeFor3D), A = n ? Float32Array.from(t1.transform.expandedFarZProjMatrix) : t1.transform.calculateProjMatrix(s, g)) : (L = t1.depthModeForSublayer(w.overscaledZ - b, 1 === o.paint.get("raster-opacity") ? Fi.ReadWrite : Fi.ReadOnly, u.LESS), A = t1.transform.calculateProjMatrix(s, g));
                        const z = t1.terrain && m ? t1.terrain.stencilModeForRTTOverlap(w) : y[w.overscaledZ], P = a ? 0 : o.paint.get("raster-fade-duration");
                        T.registerFadeDuration(P);
                        const M = i.findLoadedParent(w, 0), O = ks(T, M, i, t1.transform, P);
                        let F, k;
                        t1.terrain && t1.terrain.prepareDrawTile(), h.activeTexture.set(u.TEXTURE0), S.bind(v, u.CLAMP_TO_EDGE), h.activeTexture.set(u.TEXTURE1), M ? (M.texture && M.texture.bind(v, u.CLAMP_TO_EDGE), F = Math.pow(2, M.tileID.overscaledZ - T.tileID.overscaledZ), k = [
                            T.tileID.canonical.x * F % 1,
                            T.tileID.canonical.y * F % 1
                        ]) : S.bind(v, u.CLAMP_TO_EDGE), S.useMipmap && h.extTextureFilterAnisotropic && t1.transform.pitch > 20 && u.texParameterf(u.TEXTURE_2D, h.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h.extTextureFilterAnisotropicMax);
                        const B = t1.transform;
                        let N;
                        const U = l ? Hr(B) : [
                            0,
                            0,
                            0,
                            0
                        ];
                        let G, j, V, q, H, Z = 0;
                        if (c && d instanceof e.aJ && d.coordinates.length > 3) G = Float32Array.from(e.bb(e.cH(new e.bT(0, 0, 0)))), j = Float32Array.from(B.globeMatrix), V = Float32Array.from(e.cD(B)), q = [
                            e.at(B.center.lng),
                            e.aA(B.center.lat)
                        ], N = d.elevatedGlobePerspectiveTransform, H = d.elevatedGlobeGridMatrix || new Float32Array(9);
                        else if (c) {
                            const t1 = e.cE(w.canonical);
                            Z = e.cF(t1.getCenter().lat), G = Float32Array.from(e.bb(e.cH(w.canonical))), j = Float32Array.from(B.globeMatrix), V = Float32Array.from(e.cD(B)), q = [
                                e.at(B.center.lng),
                                e.aA(B.center.lat)
                            ], N = [
                                0,
                                0
                            ], H = Float32Array.from(e.cG(w.canonical, t1, Z, B.worldSize / B._pixelsPerMercatorPixel));
                        } else N = d instanceof e.aJ ? d.perspectiveTransform : [
                            0,
                            0
                        ], G = new Float32Array(16), j = new Float32Array(9), V = new Float32Array(16), q = [
                            0,
                            0
                        ], H = new Float32Array(9);
                        const W = lr(A, G, j, V, H, k || [
                            0,
                            0
                        ], e.ae(t1.transform.zoom), q, U, F || 1, O, o, N, l ? o.paint.get("raster-elevation") : 0, 2, C, I, _.range, R, D, p), $ = t1.isTileAffectedByFog(w), X = t1.getOrCreateProgram("raster", {
                            defines: _.defines,
                            overrideFog: $
                        });
                        if (t1.uploadCommonUniforms(h, X, s), d instanceof e.aJ) {
                            const i = d.elevatedGlobeVertexBuffer, s = d.elevatedGlobeIndexBuffer;
                            if (m || !n) d.boundsBuffer && d.boundsSegments && X.draw(t1, u.TRIANGLES, L, Bi.disabled, f, Gi.disabled, W, o.id, d.boundsBuffer, t1.quadTriangleIndexBuffer, d.boundsSegments);
                            else if (i && s) {
                                const a = B.zoom <= e.c6 ? d.elevatedGlobeSegments : d.getSegmentsForLongitude(B.center.lng);
                                a && X.draw(t1, u.TRIANGLES, L, Bi.disabled, f, r, W, o.id, i, s, a);
                            }
                        } else if (c) {
                            L = new Fi(u.LEQUAL, Fi.ReadOnly, t1.depthRangeFor3D);
                            const e = t1.globeSharedBuffers;
                            if (e) {
                                const [i, s, a] = e.getGridBuffers(Z, !1);
                                X.draw(t1, u.TRIANGLES, L, x || z, t1.colorModeForRenderPass(), r, W, o.id, i, s, a);
                            }
                        } else {
                            const { tileBoundsBuffer: e, tileBoundsIndexBuffer: i, tileBoundsSegments: s } = t1.getTileBoundsBuffers(T);
                            X.draw(t1, u.TRIANGLES, L, z, f, Gi.disabled, W, o.id, e, i, s);
                        }
                    }
                    if (!(d instanceof e.aJ) && c) for (const e of s){
                        const s = e.canonical.y === (1 << e.canonical.z) - 1;
                        0 === e.canonical.y && qr(!0, e, t1, i, o, p, _, r, x || Bi.disabled), s && qr(!1, e, t1, i, o, p, _, r === Gi.frontCW ? Gi.backCW : Gi.frontCW, x || Bi.disabled);
                    }
                };
                c ? w(x, t1.renderElevatedRasterBackface ? Gi.backCW : Gi.frontCW, t1.stencilModeFor3D()) : w(x, Gi.disabled, void 0), t1.resetStencilClippingMasks();
            },
            "raster-particle": function(t1, i, o, s, r, a) {
                "offscreen" === t1.renderPass && function(t1, i, o, s) {
                    if (!s.length) return;
                    const r = t1.context, a = r.gl, n = i.getSource();
                    if (!(n instanceof ot)) return;
                    const l = Math.ceil(Math.sqrt(o.paint.get("raster-particle-count")));
                    let c = o.particlePositionRGBAImage;
                    if (!c || c.width !== l) {
                        const t1 = function(e) {
                            const t1 = e * e, i = new Uint8Array(4 * t1), o = function(e) {
                                return e |= 0, e = Math.imul(2747636419 ^ e, 2654435769), e = Math.imul(e ^ e >>> 16, 2654435769), ((e = Math.imul(e ^ e >>> 16, 2654435769)) >>> 0) / 4294967296;
                            }, s = 1 / 1.1;
                            for(let e = 0; e < t1; e++){
                                const t1 = s * (o(2 * e + 0) + hr), r = s * (o(2 * e + 1) + hr), a = 255 * t1 % 1, n = 255 * r % 1, l = a, c = r - n / 255, h = n;
                                i[4 * e + 0] = 255 * (t1 - a / 255), i[4 * e + 1] = 255 * l, i[4 * e + 2] = 255 * c, i[4 * e + 3] = 255 * h;
                            }
                            return i;
                        }(l);
                        c = o.particlePositionRGBAImage = new e.r({
                            width: l,
                            height: l
                        }, t1);
                    }
                    let h = o.particleFramebuffer;
                    h ? h.width !== l && (h.destroy(), h = o.particleFramebuffer = r.createFramebuffer(l, l, !0, null)) : h = o.particleFramebuffer = r.createFramebuffer(l, l, !0, null);
                    const u = [];
                    for (const e of s){
                        const t1 = i.getTile(e);
                        if (!(t1 instanceof xt)) continue;
                        const s = Xr(t1, n, o);
                        if (!s) continue;
                        const a = [
                            t1.tileSize,
                            t1.tileSize
                        ];
                        let h = o.tileFramebuffer;
                        h || (h = o.tileFramebuffer = r.createFramebuffer(a[0], a[1], !0, null));
                        let d = t1.rasterParticleState;
                        d || (d = t1.rasterParticleState = new $r(r, e, a, c));
                        const _ = d.update(o.lastInvalidatedAt);
                        d.particleTextureDimension !== l && d.updateParticleTexture(e, c);
                        const p = d.targetColorTexture;
                        d.targetColorTexture = d.backgroundColorTexture, d.backgroundColorTexture = p;
                        const f = d.particleTexture0;
                        d.particleTexture0 = d.particleTexture1, d.particleTexture1 = f, u.push([
                            e,
                            s,
                            d,
                            _
                        ]);
                    }
                    if (0 === u.length) return;
                    const d = e.q.now(), _ = o.previousDrawTimestamp ? .001 * (d - o.previousDrawTimestamp) : .0167;
                    if (o.previousDrawTimestamp = d, o.hasColorMap()) {
                        r.activeTexture.set(a.TEXTURE0 + 2);
                        let t1 = o.colorRampTexture;
                        t1 || (t1 = o.colorRampTexture = new e.T(r, o.colorRamp, a.RGBA8)), t1.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                    }
                    r.bindFramebuffer.set(o.tileFramebuffer.framebuffer), function(t1, i, o) {
                        const s = t1.context, r = s.gl, a = i.tileFramebuffer;
                        s.activeTexture.set(r.TEXTURE0);
                        const n = {
                            u_texture: 0,
                            u_opacity: 1.05 * (c = i.paint.get("raster-particle-fade-opacity-factor")) / (c + .05)
                        }, l = t1.getOrCreateProgram("rasterParticleTexture", {
                            defines: [],
                            overrideFog: !1
                        });
                        var c;
                        for (const c of o){
                            const [, , o, h] = c;
                            a.colorAttachment.set(o.targetColorTexture.texture), s.viewport.set([
                                0,
                                0,
                                a.width,
                                a.height
                            ]), s.clear({
                                color: e.aj.transparent
                            }), h && (o.backgroundColorTexture.bind(r.NEAREST, r.CLAMP_TO_EDGE), l.draw(t1, r.TRIANGLES, Fi.disabled, Bi.disabled, Oi.alphaBlended, Gi.disabled, n, i.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments));
                        }
                    }(t1, o, u), function(t1, i, o, s) {
                        const r = t1.context, a = r.gl, n = o.tileFramebuffer, l = "globe" === t1.transform.projection.name, c = o.paint.get("raster-particle-max-speed");
                        for (const h of s){
                            const [s, u, d] = h;
                            r.activeTexture.set(a.TEXTURE0 + 0), u.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE), n.colorAttachment.set(d.targetColorTexture.texture);
                            const _ = t1.getOrCreateProgram("rasterParticleDraw", {
                                defines: u.defines,
                                overrideFog: !1
                            });
                            r.activeTexture.set(a.TEXTURE0 + 1);
                            const p = u.scalarData ? [] : [
                                0,
                                1,
                                2,
                                3
                            ].map((t1)=>e.d4[t1](s));
                            p.push(s);
                            const f = s.canonical.x, m = s.canonical.y;
                            for (const e of p){
                                const r = i.getTile(l ? e.wrapped() : e);
                                if (!r) continue;
                                const n = r.rasterParticleState;
                                if (!n) continue;
                                const h = e.canonical.x + (1 << e.canonical.z) * (e.wrap - s.wrap), d = e.canonical.y;
                                n.particleTexture0.bind(a.NEAREST, a.CLAMP_TO_EDGE);
                                const p = dr(1, n.particleTexture0.size[0], [
                                    h - f,
                                    d - m
                                ], 0, u.texture.size, 2, c, u.textureOffset, u.scale, u.offset);
                                _.draw(t1, a.POINTS, Fi.disabled, Bi.disabled, Oi.alphaBlended, Gi.disabled, p, o.id, n.particleIndexBuffer, void 0, n.particleSegment);
                            }
                        }
                    }(t1, i, o, u), r.bindFramebuffer.set(o.particleFramebuffer.framebuffer), function(t1, i, o, s) {
                        const r = t1.context, a = r.gl, n = i.paint.get("raster-particle-max-speed"), l = s * i.paint.get("raster-particle-speed-factor") * .15, c = function(e) {
                            return Math.pow(e, 6);
                        }(.01 + 1 * i.paint.get("raster-particle-reset-rate-factor")), h = i.particleFramebuffer;
                        r.viewport.set([
                            0,
                            0,
                            h.width,
                            h.height
                        ]);
                        for (const s of o){
                            const [, o, u] = s;
                            r.activeTexture.set(a.TEXTURE0 + 0), o.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE), r.activeTexture.set(a.TEXTURE0 + 1);
                            const d = u.particleTexture0;
                            d.bind(a.NEAREST, a.CLAMP_TO_EDGE);
                            const _ = _r(1, d.size[0], 0, o.texture.size, n, l, c, o.textureOffset, o.scale, o.offset);
                            h.colorAttachment.set(u.particleTexture1.texture), r.clear({
                                color: e.aj.transparent
                            }), t1.getOrCreateProgram("rasterParticleUpdate", {
                                defines: o.defines
                            }).draw(t1, a.TRIANGLES, Fi.disabled, Bi.disabled, Oi.unblended, Gi.disabled, _, i.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments);
                        }
                    }(t1, o, u, _);
                }(t1, i, o, s), "translucent" === t1.renderPass && (function(t1, i, o, s, r) {
                    const a = t1.context, n = a.gl, l = i.getSource().tileSize, c = 5 * (1 - e.ac(e.bY, e.bY + 1, t1.transform.zoom)) * l + o.paint.get("raster-particle-elevation"), h = !t1.options.moving, u = "globe" === t1.transform.projection.name;
                    if (!s.length) return;
                    const [d, _] = t1.stencilConfigForOverlap(s), p = [];
                    u && p.push("PROJECTION_GLOBE_VIEW");
                    const f = t1.stencilModeFor3D();
                    for (const s of _){
                        const r = s.toUnwrapped(), l = i.getTile(s);
                        if (!l.rasterParticleState) continue;
                        const _ = l.rasterParticleState, m = 100;
                        l.registerFadeDuration(m);
                        const g = i.findLoadedParent(s, 0), v = ks(l, g, i, t1.transform, m);
                        let y, x;
                        t1.terrain && t1.terrain.prepareDrawTile(), a.activeTexture.set(n.TEXTURE0), _.targetColorTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE), a.activeTexture.set(n.TEXTURE1), g && g.rasterParticleState ? (g.rasterParticleState.targetColorTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE), y = Math.pow(2, g.tileID.overscaledZ - l.tileID.overscaledZ), x = [
                            l.tileID.canonical.x * y % 1,
                            l.tileID.canonical.y * y % 1
                        ]) : _.targetColorTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE);
                        const b = u ? Float32Array.from(t1.transform.expandedFarZProjMatrix) : t1.transform.calculateProjMatrix(r, h), w = t1.transform, T = Kr(w), E = e.cE(s.canonical), S = e.cF(E.getCenter().lat);
                        let C, I, R, D, L;
                        u ? (C = Float32Array.from(e.bb(e.cH(s.canonical))), I = Float32Array.from(w.globeMatrix), R = Float32Array.from(e.cD(w)), D = [
                            e.at(w.center.lng),
                            e.aA(w.center.lat)
                        ], L = Float32Array.from(e.cG(s.canonical, E, S, w.worldSize / w._pixelsPerMercatorPixel))) : (C = new Float32Array(16), I = new Float32Array(9), R = new Float32Array(16), D = [
                            0,
                            0
                        ], L = new Float32Array(9));
                        const A = ur(b, C, I, R, L, x || [
                            0,
                            0
                        ], e.ae(t1.transform.zoom), D, T, y || 1, v, c), z = t1.isTileAffectedByFog(s), P = t1.getOrCreateProgram("rasterParticle", {
                            defines: p,
                            overrideFog: z
                        });
                        if (t1.uploadCommonUniforms(a, P, r), u) {
                            const e = new Fi(n.LEQUAL, Fi.ReadOnly, t1.depthRangeFor3D), i = 0, s = t1.globeSharedBuffers;
                            if (s) {
                                const [r, a, l] = s.getGridBuffers(S, 0 !== i);
                                P.draw(t1, n.TRIANGLES, e, f, Oi.alphaBlended, t1.renderElevatedRasterBackface ? Gi.frontCCW : Gi.backCCW, A, o.id, r, a, l);
                            }
                        } else {
                            const e = t1.depthModeForSublayer(0, Fi.ReadOnly), i = d[s.overscaledZ], { tileBoundsBuffer: r, tileBoundsIndexBuffer: a, tileBoundsSegments: c } = t1.getTileBoundsBuffers(l);
                            P.draw(t1, n.TRIANGLES, e, i, Oi.alphaBlended, Gi.disabled, A, o.id, r, a, c);
                        }
                    }
                    t1.resetStencilClippingMasks();
                }(t1, i, o, s), t1.style.map.triggerRepaint());
            },
            background: function(t1, i, o, s) {
                const r = o.paint.get("background-color"), a = "none" === o.paint.get("background-color-use-theme").constantOr("default"), n = o.paint.get("background-opacity"), l = o.paint.get("background-emissive-strength"), c = "viewport" === o.paint.get("background-pitch-alignment");
                if (0 === n) return;
                const h = t1.context, u = h.gl, d = t1.transform, _ = d.tileSize, p = o.paint.get("background-pattern");
                let f;
                if (void 0 !== p) {
                    if (null === p) return;
                    if (f = t1.imageManager.getPattern(p.toString(), o.scope, t1.style.getLut(o.scope)), !f) return;
                }
                const m = !p && 1 === r.a && 1 === n && t1.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (t1.renderPass !== m) return;
                const g = Bi.disabled, v = t1.depthModeForSublayer(0, "opaque" === m ? Fi.ReadWrite : Fi.ReadOnly), y = t1.colorModeForDrapableLayerRenderPass(l), x = p ? "backgroundPattern" : "background";
                let b, w = s;
                if (w || (b = t1.getBackgroundTiles(), w = Object.values(b).map((e)=>e.tileID)), p && (h.activeTexture.set(u.TEXTURE0), t1.imageManager.bind(t1.context, o.scope)), c) {
                    const i = t1.getOrCreateProgram(x, {
                        overrideFog: !1,
                        overrideRtt: !0
                    }), s = new Float32Array(e.ab.mat4.identity([])), h = new e.aG(0, 0, 0, 0, 0), d = p ? gr(s, l, n, t1, 0, o.scope, f, c, {
                        tileID: h,
                        tileSize: _
                    }) : mr(s, l, n, r.toRenderColor(a ? null : o.lut));
                    i.draw(t1, u.TRIANGLES, v, g, y, Gi.disabled, d, o.id, t1.viewportBuffer, t1.quadTriangleIndexBuffer, t1.viewportSegments);
                } else for (const e of w){
                    const m = t1.isTileAffectedByFog(e), w = t1.getOrCreateProgram(x, {
                        overrideFog: m
                    }), T = e.toUnwrapped(), E = s ? e.projMatrix : t1.transform.calculateProjMatrix(T);
                    t1.prepareDrawTile();
                    const S = i ? i.getTile(e) : b ? b[e.key] : new yt(e, _, d.zoom, t1), C = p ? gr(E, l, n, t1, 0, o.scope, f, c, {
                        tileID: e,
                        tileSize: _
                    }) : mr(E, l, n, r.toRenderColor(a ? null : o.lut));
                    t1.uploadCommonUniforms(h, w, T);
                    const { tileBoundsBuffer: I, tileBoundsIndexBuffer: R, tileBoundsSegments: D } = t1.getTileBoundsBuffers(S);
                    w.draw(t1, u.TRIANGLES, v, g, y, Gi.disabled, C, o.id, I, R, D);
                }
            },
            sky: function(t1, i, o) {
                const s = t1._atmosphere ? e.ae(t1.transform.zoom) : 1, r = o.paint.get("sky-opacity") * s;
                if (0 === r) return;
                const a = t1.context, n = o.paint.get("sky-type"), l = new Fi(a.gl.LEQUAL, Fi.ReadOnly, [
                    0,
                    1
                ]), c = t1.frameCounter / 1e3 % 1;
                "atmosphere" === n ? "offscreen" === t1.renderPass ? o.needsSkyboxCapture(t1) && (function(t1, i, o, s) {
                    const r = t1.context, a = r.gl;
                    let n = i.skyboxFbo;
                    if (!n) {
                        n = i.skyboxFbo = r.createFramebuffer(32, 32, !0, null), i.skyboxGeometry = new ca(r), i.skyboxTexture = r.gl.createTexture(), a.bindTexture(a.TEXTURE_CUBE_MAP, i.skyboxTexture), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_MIN_FILTER, a.LINEAR), a.texParameteri(a.TEXTURE_CUBE_MAP, a.TEXTURE_MAG_FILTER, a.LINEAR);
                        for(let e = 0; e < 6; ++e)a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, a.RGBA, 32, 32, 0, a.RGBA, a.UNSIGNED_BYTE, null);
                    }
                    r.bindFramebuffer.set(n.framebuffer), r.viewport.set([
                        0,
                        0,
                        32,
                        32
                    ]);
                    const l = i.getCenter(t1, !0), c = t1.getOrCreateProgram("skyboxCapture"), h = new Float64Array(16);
                    e.ab.mat4.identity(h), e.ab.mat4.rotateY(h, h, .5 * -Math.PI), ha(t1, i, c, h, l, 0), e.ab.mat4.identity(h), e.ab.mat4.rotateY(h, h, .5 * Math.PI), ha(t1, i, c, h, l, 1), e.ab.mat4.identity(h), e.ab.mat4.rotateX(h, h, .5 * -Math.PI), ha(t1, i, c, h, l, 2), e.ab.mat4.identity(h), e.ab.mat4.rotateX(h, h, .5 * Math.PI), ha(t1, i, c, h, l, 3), e.ab.mat4.identity(h), ha(t1, i, c, h, l, 4), e.ab.mat4.identity(h), e.ab.mat4.rotateY(h, h, Math.PI), ha(t1, i, c, h, l, 5), r.viewport.set([
                        0,
                        0,
                        t1.width,
                        t1.height
                    ]);
                }(t1, o), o.markSkyboxValid(t1)) : "sky" === t1.renderPass && function(e, t1, i, o, s) {
                    const r = e.context, a = r.gl, n = e.transform, l = e.getOrCreateProgram("skybox");
                    r.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_CUBE_MAP, t1.skyboxTexture);
                    const c = ((e, t1, i, o, s)=>({
                            u_matrix: e,
                            u_sun_direction: t1,
                            u_cubemap: 0,
                            u_opacity: o,
                            u_temporal_offset: s
                        }))(n.skyboxMatrix, t1.getCenter(e, !1), 0, o, s);
                    e.uploadCommonUniforms(r, l), l.draw(e, a.TRIANGLES, i, Bi.disabled, e.colorModeForRenderPass(), Gi.backCW, c, "skybox", t1.skyboxGeometry.vertexBuffer, t1.skyboxGeometry.indexBuffer, t1.skyboxGeometry.segment);
                }(t1, o, l, r, c) : "gradient" === n && "sky" === t1.renderPass && function(t1, i, o, s, r) {
                    const a = t1.context, n = a.gl, l = t1.transform, c = t1.getOrCreateProgram("skyboxGradient");
                    i.skyboxGeometry || (i.skyboxGeometry = new ca(a)), a.activeTexture.set(n.TEXTURE0);
                    let h = i.colorRampTexture;
                    h || (h = i.colorRampTexture = new e.T(a, i.colorRamp, n.RGBA8)), h.bind(n.LINEAR, n.CLAMP_TO_EDGE);
                    const u = ((t1, i, o, s, r)=>({
                            u_matrix: t1,
                            u_color_ramp: 0,
                            u_center_direction: i,
                            u_radius: e.ai(o),
                            u_opacity: s,
                            u_temporal_offset: r
                        }))(l.skyboxMatrix, i.getCenter(t1, !1), i.paint.get("sky-gradient-radius"), s, r);
                    t1.uploadCommonUniforms(a, c), c.draw(t1, n.TRIANGLES, o, Bi.disabled, t1.colorModeForRenderPass(), Gi.backCW, u, "skyboxGradient", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);
                }(t1, o, l, r, c);
            },
            debug: function(t1, i, o, s, r, a) {
                for(let n = 0; n < o.length; n++)if (r) {
                    const r = 1, l = .8, c = new e.aj(s.r * l, s.g * l, s.b * l, 1);
                    ia(t1, i, o[n], s, -r, -r, a), ia(t1, i, o[n], s, -r, r, a), ia(t1, i, o[n], s, r, r, a), ia(t1, i, o[n], s, r, -r, a), ia(t1, i, o[n], c, 0, 0, a);
                } else ia(t1, i, o[n], s, 0, 0, a);
            },
            custom: function(t1, i, o, s) {
                const r = t1.context, a = o.implementation;
                if (!t1.transform.projection.unsupportedLayers || !t1.transform.projection.unsupportedLayers.includes("custom") || t1.terrain && (t1.terrain.renderingToTexture || "offscreen" === t1.renderPass) && o.isDraped(i)) {
                    if ("offscreen" === t1.renderPass) {
                        const i = a.prerender;
                        if (i) {
                            if (t1.setCustomLayerDefaults(), r.setColorMode(t1.colorModeForRenderPass()), "globe" === t1.transform.projection.name) {
                                const o = t1.transform.pointMerc;
                                i.call(a, r.gl, t1.transform.customLayerMatrix(), t1.transform.getProjection(), t1.transform.globeToMercatorMatrix(), e.ae(t1.transform.zoom), [
                                    o.x,
                                    o.y
                                ], t1.transform.pixelsPerMeterRatio);
                            } else i.call(a, r.gl, t1.transform.customLayerMatrix());
                            r.setDirty(), t1.setBaseState();
                        }
                    } else if ("translucent" === t1.renderPass) {
                        if (t1.terrain && t1.terrain.renderingToTexture) {
                            const i = a.renderToTile;
                            if (i) {
                                const o = s[0].canonical, n = new e.aa(o.x + s[0].wrap * (1 << o.z), o.y, o.z);
                                r.setDepthMode(Fi.disabled), r.setStencilMode(Bi.disabled), r.setColorMode(t1.colorModeForRenderPass()), t1.setCustomLayerDefaults(), i.call(a, r.gl, n), r.setDirty(), t1.setBaseState();
                            }
                            return;
                        }
                        t1.setCustomLayerDefaults(), r.setColorMode(t1.colorModeForRenderPass()), r.setStencilMode(Bi.disabled);
                        const i = "3d" === a.renderingMode ? new Fi(t1.context.gl.LEQUAL, Fi.ReadWrite, t1.depthRangeFor3D) : t1.depthModeForSublayer(0, Fi.ReadOnly);
                        if (r.setDepthMode(i), "globe" === t1.transform.projection.name) {
                            const i = t1.transform.pointMerc;
                            a.render(r.gl, t1.transform.customLayerMatrix(), t1.transform.getProjection(), t1.transform.globeToMercatorMatrix(), e.ae(t1.transform.zoom), [
                                i.x,
                                i.y
                            ], t1.transform.pixelsPerMeterRatio);
                        } else a.render(r.gl, t1.transform.customLayerMatrix());
                        r.setDirty(), t1.setBaseState(), r.bindFramebuffer.set(null);
                    }
                } else e.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
            },
            model: function(t1, i, o, s) {
                if ("opaque" === t1.renderPass) return;
                const r = o.paint.get("model-opacity").constantOr(1);
                if (0 === r) return;
                const a = o.paint.get("model-cast-shadows");
                if ("shadow" === t1.renderPass) {
                    if (!a) return;
                    if (t1.terrain && r < .65 && o._transitionablePaint._values["model-opacity"].value.expression instanceof e.a9) return;
                }
                const n = t1.shadowRenderer, l = o.paint.get("model-receive-shadows");
                n && (n.useNormalOffset = !0, l || (n.enabled = !1));
                const c = ()=>{
                    n && (n.useNormalOffset = !0, l || (n.enabled = !0));
                }, h = i.getSource();
                if ("light-beam" === t1.renderPass && "batched-model" !== h.type) return;
                if ("vector" === h.type || "geojson" === h.type) return function(t1, i, o, s, r) {
                    const a = t1.transform;
                    if ("mercator" !== a.projection.name) return void e.w(`Drawing 3D models for ${a.projection.name} projection is not yet implemented`);
                    const n = a.getFreeCameraOptions().position;
                    if (!t1.modelManager) return;
                    const l = t1.modelManager;
                    o.modelManager = l;
                    const c = t1.shadowRenderer;
                    if (!o._unevaluatedLayout._values.hasOwnProperty("model-id")) return;
                    const h = o._unevaluatedLayout._values["model-id"], u = {
                        ...o.layout.get("model-id").parameters
                    }, d = t1.style.order.indexOf(o.fqid);
                    for (const _ of s){
                        const s = i.getTile(_).getBucket(o);
                        if (!s || s.projection.name !== a.projection.name) continue;
                        const p = s.getModelUris();
                        p && !s.modelsRequested && (l.addModelsFromBucket(p, r), s.modelsRequested = !0);
                        const f = Ta(_, a);
                        u.zoom = f;
                        const m = h.possiblyEvaluate(u);
                        if (ba(t1, s, _), wa.shadowUniformsInitialized = !1, wa.useSingleShadowCascade = !!c && 0 === c.getMaxCascadeForTile(_.toUnwrapped()), "shadow" === t1.renderPass && c) {
                            if (1 === t1.currentShadowCascade && s.isInsideFirstShadowMapFrustum) continue;
                            const i = a.calculatePosMatrix(_.toUnwrapped(), a.worldSize);
                            if (wa.tileMatrix.set(i), wa.shadowTileMatrix = Float32Array.from(c.calculateShadowPassMatrixFromMatrix(i)), wa.aabb.min.fill(0), wa.aabb.max[0] = wa.aabb.max[1] = e.ag, wa.aabb.max[2] = 0, Ca(s, wa, t1, o.scope)) continue;
                        }
                        const g = 1 << _.canonical.z, v = [
                            ((n.x - _.wrap) * g - _.canonical.x) * e.ag,
                            (n.y * g - _.canonical.y) * e.ag,
                            n.z * g * e.ag
                        ];
                        t1.conflationActive && Object.keys(s.instancesPerModel).length > 0 && t1.style.isLayerClipped(o, i.getSource()) && s.updateReplacement(_, t1.replacementSource, d, r) && (s.uploaded = !1, s.upload(t1.context));
                        for(let e in s.instancesPerModel){
                            const i = s.instancesPerModel[e];
                            i.features.length > 0 && (e = m.evaluate(i.features[0].feature, {}));
                            const a = l.getModel(e, r);
                            if (a && a.uploaded) for (const e of a.nodes)Ea(t1, o, e, i, v, _, wa);
                        }
                    }
                }(t1, i, o, s, "vector" === h.type ? o.scope : ""), void c();
                if (!h.loaded()) return;
                if ("batched-model" === h.type) return function(t1, i, o, s) {
                    o.resetLayerRenderingStats(t1);
                    const r = t1.context, a = t1.transform, n = t1.style.fog, l = t1.shadowRenderer;
                    if ("mercator" !== a.projection.name) return void e.w(`Drawing 3D landmark models for ${a.projection.name} projection is not yet implemented`);
                    const c = t1.transform.getFreeCameraOptions().position, h = e.ab.vec3.scale([], [
                        c.x,
                        c.y,
                        c.z
                    ], t1.transform.worldSize), u = e.ab.vec3.negate([], h), d = e.ab.mat4.identity([]), _ = e.dj(a.center.lat, a.zoom), p = e.ab.mat4.fromScaling([], [
                        1,
                        1,
                        1 / _
                    ]);
                    e.ab.mat4.translate(d, d, u);
                    const f = o.paint.get("model-opacity").constantOr(1), m = new Fi(r.gl.LEQUAL, Fi.ReadWrite, t1.depthRangeFor3D), g = new Fi(r.gl.LEQUAL, Fi.ReadOnly, t1.depthRangeFor3D), v = new e.cd([
                        1 / 0,
                        1 / 0,
                        1 / 0
                    ], [
                        -1 / 0,
                        -1 / 0,
                        -1 / 0
                    ]), y = "shadow" === t1.renderPass, x = y && l ? l.getCurrentCascadeFrustum() : a.getFrustum(a.scaleZoom(a.worldSize)), b = o.paint.get("model-front-cutoff"), w = b[2] < 1, T = Ji(t1, o.paint.get("model-cutoff-fade-range")), E = o.getLayerRenderingStats();
                    (function(e, t1, i, o) {
                        const s = e.terrain ? e.terrain.exaggeration() : 0, r = e.transform.zoom;
                        for (const a of o){
                            const o = t1.getTile(a).getBucket(i);
                            o && (e.conflationActive && o.updateReplacement(a, e.replacementSource), o.evaluateScale(e, i), e.terrain && s > 0 && o.elevationUpdate(e.terrain, s, a, i.source), o.needsReEvaluation(e, r, i) && o.evaluate(i));
                        }
                    })(t1, i, o, s), function() {
                        let c, u, S;
                        w ? (c = s.length - 1, u = -1, S = -1) : (c = 0, u = s.length, S = 1);
                        const C = new Float64Array(16), I = e.ab.vec3.create(), R = new e.P(0, 0);
                        for(let D = c; D !== u; D += S){
                            const c = s[D], u = i.getTile(c).getBucket(o);
                            if (!u || !u.uploaded) continue;
                            let S = !1;
                            l && (S = 0 === l.getMaxCascadeForTile(c.toUnwrapped()));
                            const L = a.calculatePosMatrix(c.toUnwrapped(), a.worldSize), A = u.modelTraits;
                            !y && w && (e.ab.mat4.invert(C, L), e.ab.vec3.transformMat4(I, h, C), R.x = I[0], R.y = I[1]);
                            const z = [];
                            for (const i of u.getNodesInfo()){
                                if (i.hiddenByReplacement) continue;
                                if (!i.node.meshes) continue;
                                const o = i.node;
                                let s = 0;
                                t1.terrain && o.elevation && (s = o.elevation * t1.terrain.exaggeration());
                                const r = (()=>{
                                    const t1 = i.aabb;
                                    return v.min = [
                                        ...t1.min
                                    ], v.max = [
                                        ...t1.max
                                    ], v.min[2] += s, v.max[2] += s, e.ab.vec3.transformMat4(v.min, v.min, L), e.ab.vec3.transformMat4(v.max, v.max, L), v;
                                })(), n = i.evaluatedScale;
                                if (n[0] <= 1 && n[1] <= 1 && n[2] <= 1 && 0 === r.intersects(x)) continue;
                                if (!y && w) {
                                    const t1 = 1 / 6;
                                    i.cameraCollisionOpacity = h[0] > r.min[0] && h[0] < r.max[0] && h[1] > r.min[1] && h[1] < r.max[1] && h[2] * _ < r.max[2] && o.footprint && e.bA(R, o.footprint) ? Math.max(i.cameraCollisionOpacity - t1, 0) : Math.min(1, i.cameraCollisionOpacity + t1);
                                }
                                const l = [
                                    ...L
                                ], c = o.anchor ? o.anchor[0] : 0, u = o.anchor ? o.anchor[1] : 0;
                                e.ab.mat4.translate(l, l, [
                                    c * (n[0] - 1),
                                    u * (n[1] - 1),
                                    s
                                ]), e.ab.vec3.exactEquals(n, e.dm) || e.ab.mat4.scale(l, l, n);
                                const d = e.ab.mat4.multiply([], l, o.matrix), p = e.ab.mat4.multiply([], a.expandedFarZProjMatrix, d), m = e.ab.mat4.multiply([], a.expandedFarZProjMatrix, l), g = e.ab.vec4.transformMat4([], [
                                    c,
                                    u,
                                    s,
                                    1
                                ], p)[2];
                                o.hidden = !1;
                                let E = f;
                                y || (w && (E *= i.cameraCollisionOpacity, E *= Ra(l, a, i.aabb, b)), E *= Ia(T, g)), 0 !== E ? z.push({
                                    nodeInfo: i,
                                    depth: g,
                                    opacity: E,
                                    wvpForNode: p,
                                    wvpForTile: m,
                                    nodeModelMatrix: d,
                                    tileModelMatrix: l
                                }) : o.hidden = !0;
                            }
                            y || z.sort((e, t1)=>!w || 1 === e.opacity && 1 === t1.opacity ? e.depth < t1.depth ? -1 : 1 : 1 === e.opacity ? -1 : 1 === t1.opacity ? 1 : e.depth > t1.depth ? -1 : 1);
                            for (const i of z){
                                const s = i.nodeInfo, c = s.node;
                                let h = e.ab.mat4.multiply([], p, i.tileModelMatrix);
                                e.ab.mat4.multiply(h, d, h);
                                const u = e.ab.mat4.invert([], h);
                                e.ab.mat4.transpose(u, u), e.ab.mat4.scale(u, u, Sa), h = e.ab.mat4.multiply(h, h, c.matrix);
                                const _ = "light-beam" === t1.renderPass, f = "none" === o.paint.get("model-color-use-theme").constantOr("default"), v = A & e.dp.HasMapboxMeshFeatures, x = v ? 0 : s.evaluatedRMEA[0][2];
                                for(let e = 0; e < c.meshes.length; ++e){
                                    const d = c.meshes[e], p = e === c.lightMeshIndex;
                                    let b = i.wvpForNode;
                                    if (p) {
                                        if (!_ && !t1.terrain && t1.shadowRenderer) {
                                            t1.currentLayer < t1.firstLightBeamLayer && (t1.firstLightBeamLayer = t1.currentLayer);
                                            continue;
                                        }
                                        b = i.wvpForTile;
                                    } else if (_) continue;
                                    const w = {
                                        defines: []
                                    }, T = [];
                                    if (!y && l && (l.useNormalOffset = !!d.normalBuffer), ga(w.defines, T, d, t1, f ? null : o.lut), v || w.defines.push("DIFFUSE_SHADED"), S && w.defines.push("SHADOWS_SINGLE_CASCADE"), E && (y ? E.numRenderedVerticesInShadowPass += d.vertexArray.length : E.numRenderedVerticesInTransparentPass += d.vertexArray.length), y) {
                                        xa(d, i.nodeModelMatrix, t1, o);
                                        continue;
                                    }
                                    let C = null;
                                    if (n) {
                                        const e = ma(i.nodeModelMatrix, t1.transform);
                                        if (C = new Float32Array(e), "globe" !== a.projection.name) {
                                            const t1 = d.aabb.min, i = d.aabb.max, [o, s] = n.getOpacityForBounds(e, t1[0], t1[1], i[0], i[1]);
                                            w.overrideFog = o >= Fe || s >= Fe;
                                        }
                                    }
                                    const I = d.material;
                                    let R;
                                    I.occlusionTexture && I.occlusionTexture.offsetScale && (R = I.occlusionTexture.offsetScale, w.defines.push("OCCLUSION_TEXTURE_TRANSFORM"));
                                    const D = t1.getOrCreateProgram("model", w);
                                    !y && l && l.setupShadowsFromMatrix(i.tileModelMatrix, D, l.useNormalOffset), t1.uploadCommonUniforms(r, D, null, C);
                                    const L = I.pbrMetallicRoughness;
                                    L.metallicFactor = .9, L.roughnessFactor = .5;
                                    const A = yr(new Float32Array(b), new Float32Array(h), new Float32Array(u), new Float32Array(c.matrix), t1, i.opacity, L.baseColorFactor.toRenderColor(null), I.emissiveFactor, L.metallicFactor, L.roughnessFactor, I, x, o, [
                                        0,
                                        0,
                                        0
                                    ], R);
                                    !p && (s.hasTranslucentParts || i.opacity < 1) && D.draw(t1, r.gl.TRIANGLES, m, Bi.disabled, Oi.disabled, Gi.backCCW, A, o.id, d.vertexBuffer, d.indexBuffer, d.segments, o.paint, t1.transform.zoom, void 0, T), D.draw(t1, r.gl.TRIANGLES, p ? g : m, Bi.disabled, p || i.opacity < 1 || s.hasTranslucentParts ? Oi.alphaBlended : Oi.unblended, Gi.backCCW, A, o.id, d.vertexBuffer, d.indexBuffer, d.segments, o.paint, t1.transform.zoom, void 0, T);
                                }
                            }
                        }
                    }();
                }(t1, i, o, s), void c();
                if ("model" !== h.type) return;
                const u = h.getModels(), d = [], _ = t1.transform.getFreeCameraOptions().position, p = e.ab.vec3.scale([], [
                    _.x,
                    _.y,
                    _.z
                ], t1.transform.worldSize);
                e.ab.vec3.negate(p, p);
                const f = [], m = [];
                let g = 0;
                for (const i of u){
                    const s = o.paint.get("model-rotation").constantOr(null), r = o.paint.get("model-scale").constantOr(null), a = o.paint.get("model-translation").constantOr(null);
                    i.computeModelMatrix(t1, s, r, a, !0, !0, !1);
                    const n = e.ab.mat4.identity([]), l = e.dj(i.position.lat, t1.transform.zoom), c = e.ab.mat4.fromScaling([], [
                        1,
                        1,
                        1 / l
                    ]);
                    e.ab.mat4.translate(n, n, p), d.push({
                        zScaleMatrix: c,
                        negCameraPosMatrix: n
                    });
                    for (const e of i.nodes)ya(t1.transform, e, i.matrix, t1.transform.expandedFarZProjMatrix, g, f, m);
                    g++;
                }
                if (f.sort((e, t1)=>t1.depth - e.depth), "shadow" !== t1.renderPass) {
                    if (1 === r) for (const e of m)va(e, t1, o, d[e.modelIndex], Bi.disabled, t1.colorModeForRenderPass());
                    else {
                        for (const e of m)va(e, t1, o, d[e.modelIndex], Bi.disabled, Oi.disabled);
                        for (const e of m)va(e, t1, o, d[e.modelIndex], t1.stencilModeFor3D(), t1.colorModeForRenderPass());
                        t1.resetStencilClippingMasks();
                    }
                    for (const e of f)va(e, t1, o, d[e.modelIndex], Bi.disabled, t1.colorModeForRenderPass());
                    c();
                } else {
                    for (const e of m)xa(e.mesh, e.nodeModelMatrix, t1, o);
                    for (const e of f)xa(e.mesh, e.nodeModelMatrix, t1, o);
                    c();
                }
            }
        }, Za = {
            model: function(e, t1, i) {
                const o = t1.getSource();
                if (!o.loaded()) return;
                if ("vector" === o.type || "geojson" === o.type) return void (i.modelManager && i.modelManager.upload(i, "vector" === o.type ? e.scope : ""));
                if ("batched-model" === o.type) return;
                if ("model" !== o.type) return;
                const s = o.getModels();
                for (const e of s)e.upload(i.context);
            },
            raster: function(e, t1, i) {
                const o = t1.getSource();
                if (!(o instanceof ot && o.loaded())) return;
                const s = e.sourceLayer || o.rasterLayerIds && o.rasterLayerIds[0];
                if (!s) return;
                const r = e.paint.get("raster-array-band") || o.getInitialBand(s);
                if (null == r) return;
                const a = t1.getIds().map((e)=>t1.getTileByID(e));
                for (const e of a)e.updateNeeded(s, r) && o.prepareTile(e, s, r);
            },
            "raster-particle": function(e, t1, i) {
                const o = t1.getSource();
                if (!(o instanceof ot && o.loaded())) return;
                const s = e.sourceLayer || o.rasterLayerIds && o.rasterLayerIds[0];
                if (!s) return;
                const r = e.paint.get("raster-particle-array-band") || o.getInitialBand(s);
                if (null == r) return;
                const a = t1.getIds().map((e)=>t1.getTileByID(e));
                for (const e of a)e.updateNeeded(s, r) && o.prepareTile(e, s, r);
            }
        };
        class Wa {
            constructor(t1, i, o, s, r){
                this.context = new Cr(t1, i), this.transform = o, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = r, this._timeStamp = e.q.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = {
                    forceEnablePrecipitation: !1,
                    showTerrainProxyTiles: !1,
                    fpsWindow: 30,
                    continousRedraw: !1,
                    enabledLayers: {}
                };
                const a = [
                    "fill",
                    "line",
                    "symbol",
                    "circle",
                    "heatmap",
                    "fill-extrusion",
                    "raster",
                    "raster-particle",
                    "hillshade",
                    "model",
                    "background",
                    "sky"
                ];
                for (const e of a)this._debugParams.enabledLayers[e] = !0;
                r.registerParameter(this._debugParams, [
                    "Terrain"
                ], "showTerrainProxyTiles", {}, ()=>{
                    this.style.map.triggerRepaint();
                }), r.registerParameter(this._debugParams, [
                    "Precipitation"
                ], "forceEnablePrecipitation"), r.registerParameter(this._debugParams, [
                    "FPS"
                ], "fpsWindow", {
                    min: 1,
                    max: 100,
                    step: 1
                }), r.registerBinding(this._debugParams, [
                    "FPS"
                ], "continousRedraw", {
                    readonly: !0,
                    label: "continuous redraw"
                }), r.registerBinding(this, [
                    "FPS"
                ], "_averageFPS", {
                    readonly: !0,
                    label: "value"
                }), r.registerBinding(this, [
                    "FPS"
                ], "_averageFPS", {
                    readonly: !0,
                    label: "graph",
                    view: "graph",
                    min: 0,
                    max: 200
                });
                for (const e of a)r.registerParameter(this._debugParams.enabledLayers, [
                    "Debug",
                    "Layers"
                ], e);
                this.occlusionParams = new Aa(r), this.setup(), this.numSublayers = Tt.maxUnderzooming + Tt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = !1, this.replacementSource = new e.dv, this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = !1, this._cachedTileFogOpacities = {}, this._shadowRenderer = new io(this), this._wireframeDebugCache = new La, this.renderDefaultNorthPole = !0, this.renderDefaultSouthPole = !0, this.layersWithOcclusionOpacity = [];
                const n = new e.r({
                    width: 1,
                    height: 1
                }, Uint8Array.of(0, 0, 0, 0));
                this.emptyDepthTexture = new e.T(this.context, n, t1.RGBA8), this._clippingActiveLastFrame = !1, this.scaleFactor = s;
            }
            updateTerrain(e, t1) {
                const i = !!e && !!e.terrain && this.transform.projection.supportsTerrain;
                if (!(i || this._terrain && this._terrain.enabled)) return;
                this._terrain || (this._terrain = new Gs(this, e));
                const o = this._terrain;
                this.transform.elevation = i ? o : null, o.update(e, this.transform, t1), this.transform.elevation && !o.enabled && (this.transform.elevation = null);
            }
            _updateFog(e) {
                const t1 = e.fog;
                if (!t1 || "globe" === this.transform.projection.name || t1.getOpacity(this.transform.pitch) < 1 || t1.properties.get("horizon-blend") < .03) return void (this.transform.fogCullDistSq = null);
                const [i, o] = t1.getFovAdjustedRange(this.transform._fov);
                if (i > o) return void (this.transform.fogCullDistSq = null);
                const s = i + .78 * (o - i);
                this.transform.fogCullDistSq = s * s;
            }
            get terrain() {
                return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;
            }
            get forceTerrainMode() {
                return this._forceTerrainMode;
            }
            set forceTerrainMode(e) {
                e && !this._terrain && (this._terrain = new Gs(this, this.style)), this._forceTerrainMode = e;
            }
            get shadowRenderer() {
                return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
            }
            get wireframeDebugCache() {
                return this._wireframeDebugCache;
            }
            resize(t1, i) {
                if (this.width = t1 * e.q.devicePixelRatio, this.height = i * e.q.devicePixelRatio, this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.style) for (const e of this.style.order)this.style._mergedLayers[e].resize();
            }
            setup() {
                const t1 = this.context, i = new e.b4;
                i.emplaceBack(0, 0), i.emplaceBack(e.ag, 0), i.emplaceBack(0, e.ag), i.emplaceBack(e.ag, e.ag), this.tileExtentBuffer = t1.createVertexBuffer(i, e.b6.members), this.tileExtentSegments = e.b7.simpleSegment(0, 0, 4, 2);
                const o = new e.b4;
                o.emplaceBack(0, 0), o.emplaceBack(e.ag, 0), o.emplaceBack(0, e.ag), o.emplaceBack(e.ag, e.ag), this.debugBuffer = t1.createVertexBuffer(o, e.b6.members), this.debugSegments = e.b7.simpleSegment(0, 0, 4, 5);
                const s = new e.b4;
                s.emplaceBack(-1, -1), s.emplaceBack(1, -1), s.emplaceBack(-1, 1), s.emplaceBack(1, 1), this.viewportBuffer = t1.createVertexBuffer(s, e.b6.members), this.viewportSegments = e.b7.simpleSegment(0, 0, 4, 2);
                const r = new e.aT;
                r.emplaceBack(0, 0, 0, 0), r.emplaceBack(e.ag, 0, e.ag, 0), r.emplaceBack(0, e.ag, 0, e.ag), r.emplaceBack(e.ag, e.ag, e.ag, e.ag), this.mercatorBoundsBuffer = t1.createVertexBuffer(r, e.b9.members), this.mercatorBoundsSegments = e.b7.simpleSegment(0, 0, 4, 2);
                const a = new e.aU;
                a.emplaceBack(0, 1, 2), a.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t1.createIndexBuffer(a);
                const n = new e.b5;
                for (const e of [
                    0,
                    1,
                    3,
                    2,
                    0
                ])n.emplaceBack(e);
                this.debugIndexBuffer = t1.createIndexBuffer(n), this.emptyTexture = new e.T(t1, new e.r({
                    width: 1,
                    height: 1
                }, Uint8Array.of(0, 0, 0, 0)), t1.gl.RGBA8), this.identityMat = e.ab.mat4.create();
                const l = this.context.gl;
                this.stencilClearMode = new Bi({
                    func: l.ALWAYS,
                    mask: 0
                }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(performance.now());
            }
            getMercatorTileBoundsBuffers() {
                return {
                    tileBoundsBuffer: this.mercatorBoundsBuffer,
                    tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                    tileBoundsSegments: this.mercatorBoundsSegments
                };
            }
            getTileBoundsBuffers(e) {
                return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? {
                    tileBoundsBuffer: e._tileBoundsBuffer,
                    tileBoundsIndexBuffer: e._tileBoundsIndexBuffer,
                    tileBoundsSegments: e._tileBoundsSegments
                } : this.getMercatorTileBoundsBuffers();
            }
            clearStencil() {
                const e = this.context.gl;
                this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, e.TRIANGLES, Fi.disabled, this.stencilClearMode, Oi.disabled, Gi.disabled, Fs(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            resetStencilClippingMasks() {
                this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
            }
            _renderTileClippingMasks(e, t1, i) {
                if (!t1 || this.currentStencilSource === t1.id || !e.isTileClipped() || !i || 0 === i.length) return;
                if (this._tileClippingMaskIDs && !this.terrain) {
                    let e = !1;
                    for (const t1 of i)if (void 0 === this._tileClippingMaskIDs[t1.key]) {
                        e = !0;
                        break;
                    }
                    if (!e) return;
                }
                this.currentStencilSource = t1.id;
                const o = this.context, s = o.gl;
                this.nextStencilID + i.length > 256 && this.clearStencil(), o.setColorMode(Oi.disabled), o.setDepthMode(Fi.disabled);
                const r = this.getOrCreateProgram("clippingMask");
                this._tileClippingMaskIDs = {};
                for (const e of i){
                    const i = t1.getTile(e), o = this._tileClippingMaskIDs[e.key] = this.nextStencilID++, { tileBoundsBuffer: a, tileBoundsIndexBuffer: n, tileBoundsSegments: l } = this.getTileBoundsBuffers(i);
                    r.draw(this, s.TRIANGLES, Fi.disabled, new Bi({
                        func: s.ALWAYS,
                        mask: 0
                    }, o, 255, s.KEEP, s.KEEP, s.REPLACE), Oi.disabled, Gi.disabled, Fs(e.projMatrix), "$clipping", a, n, l);
                }
            }
            stencilModeFor3D() {
                this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
                const e = this.nextStencilID++, t1 = this.context.gl;
                return new Bi({
                    func: t1.NOTEQUAL,
                    mask: 255
                }, e, 255, t1.KEEP, t1.KEEP, t1.REPLACE);
            }
            stencilModeForClipping(e) {
                if (this.terrain) return this.terrain.stencilModeForRTTOverlap(e);
                const t1 = this.context.gl;
                return new Bi({
                    func: t1.EQUAL,
                    mask: 255
                }, this._tileClippingMaskIDs[e.key], 0, t1.KEEP, t1.KEEP, t1.REPLACE);
            }
            stencilConfigForOverlap(e) {
                const t1 = this.context.gl, i = e.sort((e, t1)=>t1.overscaledZ - e.overscaledZ), o = i[i.length - 1].overscaledZ, s = i[0].overscaledZ - o + 1;
                if (s > 1) {
                    this.currentStencilSource = void 0, this.nextStencilID + s > 256 && this.clearStencil();
                    const e = {};
                    for(let i = 0; i < s; i++)e[i + o] = new Bi({
                        func: t1.GEQUAL,
                        mask: 255
                    }, i + this.nextStencilID, 255, t1.KEEP, t1.KEEP, t1.REPLACE);
                    return this.nextStencilID += s, [
                        e,
                        i
                    ];
                }
                return [
                    {
                        [o]: Bi.disabled
                    },
                    i
                ];
            }
            colorModeForRenderPass() {
                const t1 = this.context.gl;
                if (this._showOverdrawInspector) {
                    const i = 1 / 8;
                    return new Oi([
                        t1.CONSTANT_COLOR,
                        t1.ONE,
                        t1.CONSTANT_COLOR,
                        t1.ONE
                    ], new e.aj(i, i, i, 0), [
                        !0,
                        !0,
                        !0,
                        !0
                    ]);
                }
                return "opaque" === this.renderPass ? Oi.unblended : Oi.alphaBlended;
            }
            colorModeForDrapableLayerRenderPass(t1) {
                const i = this.context.gl;
                return (()=>this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && "translucent" === this.renderPass ? new Oi([
                    i.ONE,
                    i.ONE_MINUS_SRC_ALPHA,
                    i.CONSTANT_ALPHA,
                    i.ONE_MINUS_SRC_ALPHA
                ], new e.aj(0, 0, 0, void 0 === t1 ? 0 : t1), [
                    !0,
                    !0,
                    !0,
                    !0
                ]) : this.colorModeForRenderPass();
            }
            depthModeForSublayer(e, t1, i, o = !1) {
                if (this.depthOcclusion) return new Fi(this.context.gl.GREATER, Fi.ReadOnly, this.depthRangeFor3D);
                if (!this.opaquePassEnabledForLayer() && !o) return Fi.disabled;
                const s = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
                return new Fi(i || this.context.gl.LEQUAL, t1, [
                    s,
                    s
                ]);
            }
            opaquePassEnabledForLayer() {
                return this.currentLayer < this.opaquePassCutoff;
            }
            blitDepth() {
                const t1 = this.context.gl, i = Math.ceil(this.width), o = Math.ceil(this.height), s = this.context.bindFramebuffer.get(), r = t1.getParameter(t1.TEXTURE_BINDING_2D);
                this.depthFBO && this.depthFBO.width === i && this.depthFBO.height === o || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), 0 !== i && 0 !== o && (this.depthFBO = new Sr(this.context, i, o, !1, "texture"), this.depthTexture = new e.T(this.context, {
                    width: i,
                    height: o,
                    data: null
                }, t1.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(s), t1.bindTexture(t1.TEXTURE_2D, r), this.depthFBO && (t1.bindFramebuffer(t1.READ_FRAMEBUFFER, null), t1.bindFramebuffer(t1.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t1.blitFramebuffer(0, 0, i, o, 0, 0, i, o, t1.DEPTH_BUFFER_BIT, t1.NEAREST), t1.bindFramebuffer(t1.FRAMEBUFFER, this.context.bindFramebuffer.current));
            }
            updateAverageFPS() {
                this._fpsHistory.push(0 === this._dt ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((e, t1)=>e + t1 / this._fpsHistory.length, 0));
            }
            render(t1, i) {
                const o = e.q.now();
                this._dt = o - this._timeStamp, this._timeStamp = o, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t1.map.repaint, this.style = t1, this.options = i;
                const s = this.style._mergedLayers, r = this.style._getOrder(!(!this.terrain || !this.terrain.enabled)).filter((e)=>{
                    const t1 = s[e];
                    return !(t1.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[t1.type];
                });
                let a = !1, n = !1;
                for (const e of r){
                    const t1 = s[e];
                    "circle" === t1.type && (a = !0), "symbol" === t1.type && (t1.hasInitialOcclusionOpacityProperties ? n = !0 : a = !0);
                }
                const l = r.map((e)=>s[e]), c = this.style._mergedSourceCaches;
                this.imageManager = t1.imageManager, this.modelManager = t1.modelManager, this.symbolFadeChange = t1.placement.symbolFadeChange(e.q.now()), this.imageManager.beginFrame();
                let h = 0, u = !1;
                for(const e in c){
                    const t1 = c[e];
                    t1.used && (t1.prepare(this.context), t1.getSource().usedInConflation && ++h);
                }
                let d = !1;
                for (const e of l)e.isHidden(this.transform.zoom) || ("clip" === e.type && (d = !0), this.prepareLayer(e));
                const _ = {}, p = {}, f = {}, m = {}, g = {};
                for(const e in c){
                    const t1 = c[e];
                    _[e] = t1.getVisibleCoordinates(), p[e] = _[e].slice().reverse(), f[e] = t1.getVisibleCoordinates(!0).reverse(), m[e] = t1.getShadowCasterCoordinates(), g[e] = t1.sortCoordinatesByDistance(_[e]);
                }
                const v = (e)=>{
                    const t1 = this.style.getLayerSourceCache(e);
                    return t1 && t1.used ? t1.getSource() : null;
                };
                if (h || d || this._clippingActiveLastFrame) {
                    const t1 = [], i = [];
                    let o = 0;
                    for (const e of l)this.isSourceForClippingOrConflation(e, v(e)) && (t1.push(e), i.push(o)), o++;
                    if (t1 && (d || t1.length > 1) || this._clippingActiveLastFrame) {
                        d = !1;
                        const o = [];
                        for(let s = 0; s < t1.length; s++){
                            const r = t1[s], a = i[s], n = this.style.getLayerSourceCache(r);
                            if (!n || !n.used || !n.getSource().usedInConflation && "clip" !== r.type) continue;
                            let l = e.dx, c = e.by.None;
                            const h = [];
                            let u = !0;
                            if ("clip" === r.type) {
                                l = a;
                                for (const t1 of r.layout.get("clip-layer-types"))c |= "model" === t1 ? e.by.Model : "symbol" === t1 ? e.by.Symbol : e.by.FillExtrusion;
                                for (const e of r.layout.get("clip-layer-scope"))h.push(e);
                                r.isHidden(this.transform.zoom) ? u = !1 : d = !0;
                            }
                            u && o.push({
                                layer: r.fqid,
                                cache: n,
                                order: l,
                                clipMask: c,
                                clipScope: h
                            });
                        }
                        this.replacementSource.setSources(o), u = !0;
                    }
                }
                this._clippingActiveLastFrame = d, u || this.replacementSource.clear(), this.conflationActive = u, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
                for(let e = 0; e < l.length; e++){
                    const t1 = l[e], i = t1.cutoffRange();
                    if (this.longestCutoffRange = Math.max(i, this.longestCutoffRange), i > 0) {
                        const e = v(t1);
                        e && (this.minCutoffZoom = Math.max(e.minzoom, this.minCutoffZoom)), t1.minzoom && (this.minCutoffZoom = Math.max(t1.minzoom, this.minCutoffZoom));
                    }
                    t1.is3D() && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = e), this._lastOcclusionLayer = e);
                }
                const y = this.style && this.style.fog;
                y ? (this._fogVisible = 0 !== y.getOpacity(this.transform.pitch), this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = y.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(f), this.opaquePassCutoff = 0);
                const x = this._shadowRenderer;
                if (x) {
                    x.updateShadowParameters(this.transform, this.style.directionalLight);
                    for(const e in c)for (const t1 of _[e]){
                        let e = {
                            min: 0,
                            max: 0
                        };
                        this.terrain && (e = this.terrain.getMinMaxForTile(t1) || e), x.addShadowReceiver(t1.toUnwrapped(), e.min, e.max);
                    }
                }
                "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.dw(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new fa(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0);
                const b = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow), w = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);
                if (b && !this._snow && (this._snow = new qa(this)), !b && this._snow && (this._snow.destroy(), delete this._snow), w && !this._rain && (this._rain = new ja(this)), !w && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), !U.has(this.context.gl)) return;
                this.renderPass = "offscreen";
                for (const e of l){
                    const i = t1.getLayerSourceCache(e);
                    if (!e.hasOffscreenPass() || e.isHidden(this.transform.zoom)) continue;
                    const o = i ? p[i.id] : void 0;
                    ("custom" === e.type || "raster" === e.type || "raster-particle" === e.type || e.isSky() || o && o.length) && this.renderLayer(this, i, e, o);
                }
                this.depthRangeFor3D = [
                    0,
                    1 - (l.length + 2) * this.numSublayers * this.depthEpsilon
                ], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, m)), this.context.bindFramebuffer.set(null), this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]);
                const T = "globe" === this.transform.projection.name || this.transform.isHorizonVisible(), E = (()=>{
                    if (i.showOverdrawInspector) return e.aj.black;
                    const t1 = this.style.fog;
                    if (t1 && this.transform.projection.supportsFog) {
                        const i = this.style.getLut(t1.scope);
                        if (!T) {
                            const o = "none" === t1.properties.get("color-use-theme"), s = t1.properties.get("color").toRenderColor(o ? null : i).toArray01();
                            return new e.aj(...s);
                        }
                        if (T) {
                            const o = "none" === t1.properties.get("space-color-use-theme"), s = t1.properties.get("space-color").toRenderColor(o ? null : i).toArray01();
                            return new e.aj(...s);
                        }
                    }
                    return e.aj.transparent;
                })();
                if (this.context.clear({
                    color: E,
                    depth: 1
                }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && T && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for(this.currentLayer = r.length - 1; this.currentLayer >= 0; this.currentLayer--){
                    const e = l[this.currentLayer], i = t1.getLayerSourceCache(e);
                    if (e.isSky()) continue;
                    const o = i ? (e.is3D() ? g : p)[i.id] : void 0;
                    this._renderTileClippingMasks(e, i, o), this.renderLayer(this, i, e, o);
                }
                if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && T && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || e.ae(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible())) for(this.currentLayer = 0; this.currentLayer < r.length; this.currentLayer++){
                    const e = l[this.currentLayer], i = t1.getLayerSourceCache(e);
                    e.isSky() && this.renderLayer(this, i, e, i ? p[i.id] : void 0);
                }
                function S(e, t1) {
                    let i;
                    return t1 && (i = ("symbol" === e.type ? f : e.is3D() ? g : p)[t1.id]), i;
                }
                if (this.renderPass = "translucent", "globe" === this.transform.projection.name) {
                    for(this.renderElevatedRasterBackface = !0, this.currentLayer = 0; this.currentLayer < r.length;){
                        const e = l[this.currentLayer];
                        if ("raster" === e.type || "raster-particle" === e.type) {
                            const i = t1.getLayerSourceCache(e);
                            this.renderLayer(this, i, e, S(e, i));
                        }
                        ++this.currentLayer;
                    }
                    this.renderElevatedRasterBackface = !1;
                }
                this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
                let C = 0;
                x && (C = x.getShadowCastingLayerCount());
                let I = !1, R = -1;
                for(let e = 0; e < r.length; ++e){
                    const t1 = l[e];
                    t1.isHidden(this.transform.zoom) || t1.is3D() && (R = e);
                }
                for(n && -1 === R && (a = !0); this.currentLayer < r.length;){
                    const e = l[this.currentLayer], i = t1.getLayerSourceCache(e);
                    if (e.isSky()) ++this.currentLayer;
                    else if (this.terrain && this.style.isLayerDraped(e)) {
                        if (e.isHidden(this.transform.zoom)) {
                            ++this.currentLayer;
                            continue;
                        }
                        this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
                    } else {
                        if (a && !I && this.terrain && !this.transform.isOrthographic && (I = !0, this.blitDepth()), n && -1 !== R && this.currentLayer === R + 1 && !this.transform.isOrthographic && this.blitDepth(), e.is3D() || this.terrain || this._renderTileClippingMasks(e, i, i ? _[i.id] : void 0), this.renderLayer(this, i, e, S(e, i)), !this.terrain && x && C > 0 && e.hasShadowPass() && 0 == --C && (x.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
                            const e = this.currentLayer;
                            for(this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e; this.currentLayer++){
                                const e = l[this.currentLayer];
                                if (!e.hasLightBeamPass()) continue;
                                const i = t1.getLayerSourceCache(e);
                                this.renderLayer(this, i, e, i ? p[i.id] : void 0);
                            }
                            this.currentLayer = e, this.renderPass = "translucent";
                        }
                        if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                            const e = this.currentLayer;
                            this.depthOcclusion = !0;
                            for (const e of this.layersWithOcclusionOpacity){
                                this.currentLayer = e;
                                const i = l[this.currentLayer], o = t1.getLayerSourceCache(i), s = o ? p[o.id] : void 0;
                                i.is3D() || this.terrain || this._renderTileClippingMasks(i, o, o ? _[o.id] : void 0), this.renderLayer(this, o, i, s);
                            }
                            this.depthOcclusion = !1, this.currentLayer = e, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
                        }
                        ++this.currentLayer;
                    }
                }
                if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                    let i = null;
                    l.forEach((e)=>{
                        const o = t1.getLayerSourceCache(e);
                        o && !e.isHidden(this.transform.zoom) && o.getVisibleCoordinates().length && (!i || i.getSource().maxzoom < o.getSource().maxzoom) && (i = o);
                    }), i && this.options.showTileBoundaries && Ha.debug(this, i, i.getVisibleCoordinates(), e.aj.red, !1, this.options.showParseStatus);
                }
                this.terrain && this._debugParams.showTerrainProxyTiles && Ha.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e.aj(1, .8, .1, 1), !0, this.options.showParseStatus), this.options.showPadding && function(e) {
                    const t1 = e.transform.padding;
                    oa(e, e.transform.height - (t1.top || 0), 3, Yr), oa(e, t1.bottom || 0, 3, Jr), sa(e, t1.left || 0, 3, Qr), sa(e, e.transform.width - (t1.right || 0), 3, ea);
                    const i = e.transform.centerPoint;
                    !function(e, t1, i, o) {
                        ra(e, t1 - 1, i - 10, 2, 20, o), ra(e, t1 - 10, i - 1, 20, 2, o);
                    }(e, i.x, e.transform.height - i.y, ta);
                }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), u || (this.conflationActive = !1);
            }
            prepareLayer(e) {
                this.gpuTimingStart(e);
                const { unsupportedLayers: t1 } = this.transform.projection, i = !t1 || !t1.includes(e.type);
                if (Za[e.type] && (i || this.terrain && "custom" === e.type)) {
                    const t1 = this.style.getLayerSourceCache(e);
                    Za[e.type](e, t1, this);
                }
                this.gpuTimingEnd();
            }
            renderLayer(e, t1, i, o) {
                i.isHidden(this.transform.zoom) || ("background" === i.type || "sky" === i.type || "custom" === i.type || "model" === i.type || "raster" === i.type || "raster-particle" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), e.transform.projection.unsupportedLayers && e.transform.projection.unsupportedLayers.includes(i.type) && (!e.terrain || "custom" !== i.type) || "clip" === i.type || Ha[i.type](e, t1, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
            }
            gpuTimingStart(e) {
                if (!this.options.gpuTiming) return;
                const t1 = this.context.extTimerQuery, i = this.context.gl;
                let o = this.gpuTimers[e.id];
                o || (o = this.gpuTimers[e.id] = {
                    calls: 0,
                    cpuTime: 0,
                    query: i.createQuery()
                }), o.calls++, i.beginQuery(t1.TIME_ELAPSED_EXT, o.query);
            }
            gpuTimingDeferredRenderStart() {
                if (this.options.gpuTimingDeferredRender) {
                    const e = this.context.extTimerQuery, t1 = this.context.gl, i = t1.createQuery();
                    this.deferredRenderGpuTimeQueries.push(i), t1.beginQuery(e.TIME_ELAPSED_EXT, i);
                }
            }
            gpuTimingDeferredRenderEnd() {
                this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
            }
            gpuTimingEnd() {
                this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
                const e = this.gpuTimers;
                return this.gpuTimers = {}, e;
            }
            collectDeferredRenderGpuQueries() {
                const e = this.deferredRenderGpuTimeQueries;
                return this.deferredRenderGpuTimeQueries = [], e;
            }
            queryGpuTimers(e) {
                const t1 = {};
                for(const i in e){
                    const o = e[i], s = this.context.extTimerQuery, r = s.getQueryParameter(o.query, this.context.gl.QUERY_RESULT) / 1e6;
                    s.deleteQueryEXT(o.query), t1[i] = r;
                }
                return t1;
            }
            queryGpuTimeDeferredRender(e) {
                if (!this.options.gpuTimingDeferredRender) return 0;
                const t1 = this.context.gl;
                let i = 0;
                for (const o of e)i += t1.getQueryParameter(o, t1.QUERY_RESULT) / 1e6, t1.deleteQuery(o);
                return i;
            }
            translatePosMatrix(t1, i, o, s, r) {
                if (!o[0] && !o[1]) return t1;
                const a = r ? "map" === s ? this.transform.angle : 0 : "viewport" === s ? -this.transform.angle : 0;
                if (a) {
                    const e = Math.sin(a), t1 = Math.cos(a);
                    o = [
                        o[0] * t1 - o[1] * e,
                        o[0] * e + o[1] * t1
                    ];
                }
                const n = [
                    r ? o[0] : e.ar(i, o[0], this.transform.zoom),
                    r ? o[1] : e.ar(i, o[1], this.transform.zoom),
                    0
                ], l = new Float32Array(16);
                return e.ab.mat4.translate(l, t1, n), l;
            }
            saveTileTexture(e) {
                const t1 = e.size[0], i = this._tileTextures[t1];
                i ? i.push(e) : this._tileTextures[t1] = [
                    e
                ];
            }
            getTileTexture(e) {
                const t1 = this._tileTextures[e];
                return t1 && t1.length > 0 ? t1.pop() : null;
            }
            terrainRenderModeElevated() {
                return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;
            }
            linearFloatFilteringSupported() {
                return null != this.context.extTextureFloatLinear;
            }
            currentGlobalDefines(e, t1, i) {
                const o = void 0 === i ? this.terrain && this.terrain.renderingToTexture : i, s = [];
                return this.style && this.style.enable3dLights() && ("globeRaster" === e || "terrainRaster" === e ? (s.push("LIGHTING_3D_MODE"), s.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : o || s.push("LIGHTING_3D_MODE")), "shadow" === this.renderPass && (this._shadowMapDebug || s.push("DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (s.push("TERRAIN"), this.linearFloatFilteringSupported() && s.push("TERRAIN_DEM_FLOAT_FORMAT")), "globe" === this.transform.projection.name && s.push("GLOBE"), !this._fogVisible || o || void 0 !== t1 && !t1 || s.push("FOG", "FOG_DITHERING"), o && s.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && s.push("OVERDRAW_INSPECTOR"), s;
            }
            getOrCreateProgram(e, t1) {
                this.cache = this.cache || {};
                const i = t1 && t1.defines || [], o = t1 && t1.config, s = this.currentGlobalDefines(e, t1 && t1.overrideFog, t1 && t1.overrideRtt).concat(i), r = Hs.cacheKey(Bo[e], e, s, o);
                return this.cache[r] || (this.cache[r] = new Hs(this.context, e, Bo[e], o, br[e], s)), this.cache[r];
            }
            setCustomLayerDefaults() {
                this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
                const e = this.context.gl;
                this.context.cullFace.set(!1), this.context.viewport.set([
                    0,
                    0,
                    this.width,
                    this.height
                ]), this.context.blendEquation.set(e.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
                null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));
            }
            destroy() {
                this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();
            }
            prepareDrawTile() {
                this.terrain && this.terrain.prepareDrawTile();
            }
            uploadCommonLightUniforms(t1, i) {
                if (this.style.enable3dLights()) {
                    const o = this.style.directionalLight, s = this.style.ambientLight;
                    if (o && s) {
                        const r = ((t1, i, o)=>{
                            const s = t1.properties.get("direction"), r = "none" === t1.properties.get("color-use-theme"), a = t1.properties.get("color").toRenderColor(r ? null : o.getLut(t1.scope)).toArray01(), n = t1.properties.get("intensity"), l = "none" === i.properties.get("color-use-theme"), c = i.properties.get("color").toRenderColor(l ? null : o.getLut(i.scope)).toArray01(), h = i.properties.get("intensity"), u = [
                                s.x,
                                s.y,
                                s.z
                            ], d = e.cM(c, h), _ = e.cM(a, n);
                            return {
                                u_lighting_ambient_color: d,
                                u_lighting_directional_dir: u,
                                u_lighting_directional_color: _,
                                u_ground_radiance: js(u, _, d)
                            };
                        })(o, s, this.style);
                        i.setLightsUniformValues(t1, r);
                    }
                }
            }
            uploadCommonUniforms(t1, i, o, s, r) {
                if (this.uploadCommonLightUniforms(t1, i), this.terrain && this.terrain.renderingToTexture) return;
                const a = this.style.fog;
                if (a) {
                    const r = a.getOpacity(this.transform.pitch), n = ((t1, i, o, s, r, a, n, l, c, h, u, d)=>{
                        const _ = t1.transform, p = "none" === i.properties.get("color-use-theme"), f = i.properties.get("color").toRenderColor(p ? null : t1.style.getLut(i.scope)).toArray01();
                        f[3] = s;
                        const m = t1.frameCounter / 1e3 % 1, [g, v] = i.properties.get("vertical-range");
                        return {
                            u_fog_matrix: o ? _.calculateFogTileMatrix(o) : d || t1.identityMat,
                            u_fog_range: i.getFovAdjustedRange(_._fov),
                            u_fog_color: f,
                            u_fog_horizon_blend: i.properties.get("horizon-blend"),
                            u_fog_vertical_limit: [
                                Math.min(g, v),
                                v
                            ],
                            u_fog_temporal_offset: m,
                            u_frustum_tl: r,
                            u_frustum_tr: a,
                            u_frustum_br: n,
                            u_frustum_bl: l,
                            u_globe_pos: c,
                            u_globe_radius: h,
                            u_viewport: u,
                            u_globe_transition: e.ae(_.zoom),
                            u_is_globe: +("globe" === _.projection.name)
                        };
                    })(this, a, o, r, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [
                        this.transform.width * e.q.devicePixelRatio,
                        this.transform.height * e.q.devicePixelRatio
                    ], s);
                    i.setFogUniformValues(t1, n);
                }
                r && i.setCutoffUniformValues(t1, r.uniformValues);
            }
            setTileLoadedFlag(e) {
                this.tileLoaded = e;
            }
            saveCanvasCopy() {
                const e = this.canvasCopy();
                e && (this.frameCopies.push(e), this.tileLoaded = !1);
            }
            canvasCopy() {
                const e = this.context.gl, t1 = e.createTexture();
                return e.bindTexture(e.TEXTURE_2D, t1), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, e.drawingBufferWidth, e.drawingBufferHeight, 0), t1;
            }
            getCanvasCopiesAndTimestamps() {
                return {
                    canvasCopies: this.frameCopies,
                    timeStamps: this.loadTimeStamps
                };
            }
            averageElevationNeedsEasing() {
                if (!this.transform._elevation) return !1;
                const e = this.style && this.style.fog;
                return !!e && 0 !== e.getOpacity(this.transform.pitch);
            }
            getBackgroundTiles() {
                const e = this._backgroundTiles, t1 = this._backgroundTiles = {}, i = this.transform.coveringTiles({
                    tileSize: 512
                });
                for (const o of i)t1[o.key] = e[o.key] || new yt(o, 512, this.transform.tileZoom, this);
                return t1;
            }
            clearBackgroundTiles() {
                this._backgroundTiles = {};
            }
            isSourceForClippingOrConflation(e, t1) {
                return !(!e.is3D() || "clip" !== e.type && (e.minzoom && e.minzoom > this.transform.zoom || (this.style._clipLayerPresent || "building" !== e.sourceLayer) && (!t1 || "batched-model" !== t1.type)));
            }
            isTileAffectedByFog(e) {
                if (!this.style || !this.style.fog) return !1;
                if ("globe" === this.transform.projection.name) return !0;
                let t1 = this._cachedTileFogOpacities[e.key];
                return t1 || (this._cachedTileFogOpacities[e.key] = t1 = this.style.fog.getOpacityForTile(e)), t1[0] >= Fe || t1[1] >= Fe;
            }
            setupDepthForOcclusion(e, t1, i) {
                const o = this.context, s = o.gl, r = !!i;
                var a;
                i || (i = {
                    u_dem: 2,
                    u_dem_prev: 4,
                    u_dem_tl: [
                        0,
                        0
                    ],
                    u_dem_tl_prev: [
                        0,
                        0
                    ],
                    u_dem_scale: 0,
                    u_dem_scale_prev: 0,
                    u_dem_size: 0,
                    u_dem_lerp: 1,
                    u_depth: 3,
                    u_depth_size_inv: [
                        0,
                        0
                    ],
                    u_depth_range_unpack: [
                        0,
                        1
                    ],
                    u_occluder_half_size: 16,
                    u_occlusion_depth_offset: -1e-4,
                    u_exaggeration: 0
                }), o.activeTexture.set(s.TEXTURE3), e && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE), i.u_depth_size_inv = [
                    1 / this.depthFBO.width,
                    1 / this.depthFBO.height
                ], i.u_depth_range_unpack = [
                    2 / ((a = this.depthRangeFor3D)[1] - a[0]),
                    -1 - 2 * a[0] / (a[1] - a[0])
                ], i.u_occluder_half_size = .5 * this.occlusionParams.occluderSize, i.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE), o.activeTexture.set(s.TEXTURE0), r || t1.setTerrainUniformValues(o, i);
            }
        }
        function $a(e, t1) {
            let i = !1, o = null;
            const s = ()=>{
                o = null, i && (e(), o = setTimeout(s, t1), i = !1);
            };
            return ()=>(i = !0, o || s(), o);
        }
        class Xa {
            constructor(t1){
                this._hashName = t1 && encodeURIComponent(t1), e.aP([
                    "_getCurrentHash",
                    "_onHashChange",
                    "_updateHash"
                ], this), this._updateHash = $a(this._updateHashUnthrottled.bind(this), 300);
            }
            addTo(e) {
                return this._map = e, window.addEventListener("hashchange", this._onHashChange, !1), e.on("moveend", this._updateHash), this;
            }
            remove() {
                return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
            }
            getHashString() {
                const e = this._map;
                if (!e) return "";
                const t1 = Ka(e);
                if (this._hashName) {
                    const e = this._hashName;
                    let i = !1;
                    const o = location.hash.slice(1).split("&").map((o)=>{
                        const s = o.split("=")[0];
                        return s === e ? (i = !0, `${s}=${t1}`) : o;
                    }).filter((e)=>e);
                    return i || o.push(`${e}=${t1}`), `#${o.join("&")}`;
                }
                return `#${t1}`;
            }
            _getCurrentHash() {
                const e = location.hash.replace("#", "");
                if (this._hashName) {
                    let t1;
                    return e.split("&").map((e)=>e.split("=")).forEach((e)=>{
                        e[0] === this._hashName && (t1 = e);
                    }), (t1 && t1[1] || "").split("/");
                }
                return e.split("/");
            }
            _onHashChange() {
                const e = this._map;
                if (!e) return !1;
                const t1 = this._getCurrentHash();
                if (t1.length >= 3 && !t1.some((e)=>isNaN(e))) {
                    const i = e.dragRotate.isEnabled() && e.touchZoomRotate.isEnabled() ? +(t1[3] || 0) : e.getBearing();
                    return e.jumpTo({
                        center: [
                            +t1[2],
                            +t1[1]
                        ],
                        zoom: +t1[0],
                        bearing: i,
                        pitch: +(t1[4] || 0)
                    }), !0;
                }
                return !1;
            }
            _updateHashUnthrottled() {
                history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
            }
        }
        function Ka(e, t1) {
            const i = e.getCenter(), o = Math.round(100 * e.getZoom()) / 100, s = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), r = Math.pow(10, s), a = Math.round(i.lng * r) / r, n = Math.round(i.lat * r) / r, l = e.getBearing(), c = e.getPitch();
            let h = t1 ? `/${a}/${n}/${o}` : `${o}/${n}/${a}`;
            return (l || c) && (h += "/" + Math.round(10 * l) / 10), c && (h += `/${Math.round(c)}`), h;
        }
        const Ya = {
            linearity: .3,
            easing: e.dy(0, 0, .3, 1)
        }, Ja = e.l({
            deceleration: 2500,
            maxSpeed: 1400
        }, Ya), Qa = e.l({
            deceleration: 20,
            maxSpeed: 1400
        }, Ya), en = e.l({
            deceleration: 1e3,
            maxSpeed: 360
        }, Ya), tn = e.l({
            deceleration: 1e3,
            maxSpeed: 90
        }, Ya);
        class on {
            constructor(e){
                this._map = e, this.clear();
            }
            clear() {
                this._inertiaBuffer = [];
            }
            record(t1) {
                this._drainInertiaBuffer(), this._inertiaBuffer.push({
                    time: e.q.now(),
                    settings: t1
                });
            }
            _drainInertiaBuffer() {
                const t1 = this._inertiaBuffer, i = e.q.now();
                for(; t1.length > 0 && i - t1[0].time > 160;)t1.shift();
            }
            _onMoveEnd(t1) {
                if (this._map._prefersReducedMotion()) return;
                if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
                const i = {
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    pan: new e.P(0, 0),
                    pinchAround: void 0,
                    around: void 0
                };
                for (const { settings: e } of this._inertiaBuffer)i.zoom += e.zoomDelta || 0, i.bearing += e.bearingDelta || 0, i.pitch += e.pitchDelta || 0, e.panDelta && i.pan._add(e.panDelta), e.around && (i.around = e.around), e.pinchAround && (i.pinchAround = e.pinchAround);
                const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, s = {};
                if (i.pan.mag()) {
                    const r = rn(i.pan.mag(), o, e.l({}, Ja, t1 || {}));
                    s.offset = i.pan.mult(r.amount / i.pan.mag()), s.center = this._map.transform.center, sn(s, r);
                }
                if (i.zoom) {
                    const e = rn(i.zoom, o, Qa);
                    s.zoom = this._map.transform.zoom + e.amount, sn(s, e);
                }
                if (i.bearing) {
                    const t1 = rn(i.bearing, o, en);
                    s.bearing = this._map.transform.bearing + e.aw(t1.amount, -179, 179), sn(s, t1);
                }
                if (i.pitch) {
                    const e = rn(i.pitch, o, tn);
                    s.pitch = this._map.transform.pitch + e.amount, sn(s, e);
                }
                if (s.zoom || s.bearing) {
                    const e = void 0 === i.pinchAround ? i.around : i.pinchAround;
                    s.around = e ? this._map.unproject(e) : this._map.getCenter();
                }
                return this.clear(), s.noMoveStart = !0, s;
            }
        }
        function sn(e, t1) {
            (!e.duration || e.duration < t1.duration) && (e.duration = t1.duration, e.easing = t1.easing);
        }
        function rn(t1, i, o) {
            const { maxSpeed: s, linearity: r, deceleration: a } = o, n = e.aw(t1 * r / (i / 1e3), -s, s), l = Math.abs(n) / (a * r);
            return {
                easing: o.easing,
                duration: 1e3 * l,
                amount: n * (l / 2)
            };
        }
        class an extends e.z {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(t1, i, o, s = {}){
                const r = g(i.getCanvasContainer(), o), a = i.unproject(r);
                super(t1, e.l({
                    point: r,
                    lngLat: a,
                    originalEvent: o
                }, s)), this._defaultPrevented = !1, this.target = i;
            }
        }
        class nn extends e.z {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(t1, i, o){
                const s = "touchend" === t1 ? o.changedTouches : o.touches, r = v(i.getCanvasContainer(), s), a = r.map((e)=>i.unproject(e)), n = r.reduce((e, t1, i, o)=>e.add(t1.div(o.length)), new e.P(0, 0));
                super(t1, {
                    points: r,
                    point: n,
                    lngLats: a,
                    lngLat: i.unproject(n),
                    originalEvent: o
                }), this._defaultPrevented = !1;
            }
        }
        class ln extends e.z {
            preventDefault() {
                this._defaultPrevented = !0;
            }
            get defaultPrevented() {
                return this._defaultPrevented;
            }
            constructor(e, t1){
                super("wheel", {
                    originalEvent: t1
                }), this._defaultPrevented = !1;
            }
        }
        class cn {
            constructor(e, t1){
                this._map = e, this._clickTolerance = t1.clickTolerance;
            }
            reset() {
                this._mousedownPos = void 0;
            }
            wheel(e) {
                return this._firePreventable(new ln(this._map, e));
            }
            mousedown(e, t1) {
                return this._mousedownPos = t1, this._firePreventable(new an(e.type, this._map, e));
            }
            mouseup(e) {
                this._map.fire(new an(e.type, this._map, e));
            }
            preclick(t1) {
                const i = e.l({}, t1);
                i.type = "preclick", this._map.fire(new an(i.type, this._map, i));
            }
            click(e, t1) {
                this._mousedownPos && this._mousedownPos.dist(t1) >= this._clickTolerance || (this.preclick(e), this._map.fire(new an(e.type, this._map, e)));
            }
            dblclick(e) {
                return this._firePreventable(new an(e.type, this._map, e));
            }
            mouseover(e) {
                this._map.fire(new an(e.type, this._map, e));
            }
            mouseout(e) {
                this._map.fire(new an(e.type, this._map, e));
            }
            touchstart(e) {
                return this._firePreventable(new nn(e.type, this._map, e));
            }
            touchmove(e) {
                this._map.fire(new nn(e.type, this._map, e));
            }
            touchend(e) {
                this._map.fire(new nn(e.type, this._map, e));
            }
            touchcancel(e) {
                this._map.fire(new nn(e.type, this._map, e));
            }
            _firePreventable(e) {
                if (this._map.fire(e), e.defaultPrevented) return {};
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {}
            disable() {}
        }
        class hn {
            constructor(e){
                this._map = e;
            }
            reset() {
                this._delayContextMenu = !1, this._contextMenuEvent = void 0;
            }
            mousemove(e) {
                this._map.fire(new an(e.type, this._map, e));
            }
            mousedown() {
                this._delayContextMenu = !0;
            }
            mouseup() {
                this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new an("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(e) {
                this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new an(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault();
            }
            isEnabled() {
                return !0;
            }
            isActive() {
                return !1;
            }
            enable() {}
            disable() {}
        }
        class un {
            constructor(e, t1){
                this._map = e, this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t1.clickTolerance || 1;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            enable() {
                this.isEnabled() || (this._enabled = !0);
            }
            disable() {
                this.isEnabled() && (this._enabled = !1);
            }
            mousedown(e, t1) {
                this.isEnabled() && e.shiftKey && 0 === e.button && (_(), this._startPos = this._lastPos = t1, this._active = !0);
            }
            mousemoveWindow(e, t1) {
                if (!this._active) return;
                const i = t1, o = this._startPos, s = this._lastPos;
                if (!o || !s || s.equals(i) || !this._box && i.dist(o) < this._clickTolerance) return;
                this._lastPos = i, this._box || (this._box = l("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e));
                const r = Math.min(o.x, i.x), a = Math.max(o.x, i.x), n = Math.min(o.y, i.y), c = Math.max(o.y, i.y);
                this._map._requestDomTask(()=>{
                    this._box && (this._box.style.transform = `translate(${r}px,${n}px)`, this._box.style.width = a - r + "px", this._box.style.height = c - n + "px");
                });
            }
            mouseupWindow(t1, i) {
                if (!this._active) return;
                const o = this._startPos, s = i;
                if (o && 0 === t1.button) {
                    if (this.reset(), m(), o.x !== s.x || o.y !== s.y) return this._map.fire(new e.z("boxzoomend", {
                        originalEvent: t1
                    })), {
                        cameraAnimation: (e)=>e.fitScreenCoordinates(o, s, this._map.getBearing(), {
                                linear: !1
                            })
                    };
                    this._fireEvent("boxzoomcancel", t1);
                }
            }
            keydown(e) {
                this._active && 27 === e.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e));
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), p(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(t1, i) {
                return this._map.fire(new e.z(t1, {
                    originalEvent: i
                }));
            }
        }
        function dn(e, t1) {
            const i = {};
            for(let o = 0; o < e.length; o++)i[e[o].identifier] = t1[o];
            return i;
        }
        class _n {
            constructor(e){
                this.reset(), this.numTouches = e.numTouches;
            }
            reset() {
                this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;
            }
            touchstart(t1, i, o) {
                (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t1.timeStamp), o.length === this.numTouches && (this.centroid = function(t1) {
                    const i = new e.P(0, 0);
                    for (const e of t1)i._add(e);
                    return i.div(t1.length);
                }(i), this.touches = dn(o, i)));
            }
            touchmove(e, t1, i) {
                if (this.aborted || !this.centroid) return;
                const o = dn(i, t1);
                for(const e in this.touches){
                    const t1 = o[e];
                    (!t1 || t1.dist(this.touches[e]) > 30) && (this.aborted = !0);
                }
            }
            touchend(e, t1, i) {
                if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {
                    const e = !this.aborted && this.centroid;
                    if (this.reset(), e) return e;
                }
            }
        }
        class pn {
            constructor(e){
                this.singleTap = new _n(e), this.numTaps = e.numTaps, this.reset();
            }
            reset() {
                this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
            }
            touchstart(e, t1, i) {
                this.singleTap.touchstart(e, t1, i);
            }
            touchmove(e, t1, i) {
                this.singleTap.touchmove(e, t1, i);
            }
            touchend(e, t1, i) {
                const o = this.singleTap.touchend(e, t1, i);
                if (o) {
                    const t1 = e.timeStamp - this.lastTime < 500, i = !this.lastTap || this.lastTap.dist(o) < 30;
                    if (t1 && i || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;
                }
            }
        }
        class fn {
            constructor(){
                this._zoomIn = new pn({
                    numTouches: 1,
                    numTaps: 2
                }), this._zoomOut = new pn({
                    numTouches: 2,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(e, t1, i) {
                this._zoomIn.touchstart(e, t1, i), this._zoomOut.touchstart(e, t1, i);
            }
            touchmove(e, t1, i) {
                this._zoomIn.touchmove(e, t1, i), this._zoomOut.touchmove(e, t1, i);
            }
            touchend(e, t1, i) {
                const o = this._zoomIn.touchend(e, t1, i), s = this._zoomOut.touchend(e, t1, i);
                return o ? (this._active = !0, e.preventDefault(), setTimeout(()=>this.reset(), 0), {
                    cameraAnimation: (t1)=>t1.easeTo({
                            duration: 300,
                            zoom: t1.getZoom() + 1,
                            around: t1.unproject(o)
                        }, {
                            originalEvent: e
                        })
                }) : s ? (this._active = !0, e.preventDefault(), setTimeout(()=>this.reset(), 0), {
                    cameraAnimation: (t1)=>t1.easeTo({
                            duration: 300,
                            zoom: t1.getZoom() - 1,
                            around: t1.unproject(s)
                        }, {
                            originalEvent: e
                        })
                }) : void 0;
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        const mn = {
            0: 1,
            2: 2
        };
        class gn {
            constructor(e){
                this.reset(), this._clickTolerance = e.clickTolerance || 1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;
            }
            _correctButton(e, t1) {
                return !1;
            }
            _move(e, t1) {
                return {};
            }
            mousedown(e, t1) {
                if (this._lastPoint) return;
                const i = y(e);
                this._correctButton(e, i) && (this._lastPoint = t1, this._eventButton = i);
            }
            mousemoveWindow(e, t1) {
                const i = this._lastPoint;
                if (i) {
                    if (e.preventDefault(), null != this._eventButton && function(e, t1) {
                        const i = mn[t1];
                        return void 0 === e.buttons || (e.buttons & i) !== i;
                    }(e, this._eventButton)) this.reset();
                    else if (this._moved || !(t1.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t1, this._move(i, t1);
                }
            }
            mouseupWindow(e) {
                this._lastPoint && y(e) === this._eventButton && (this._moved && m(), this.reset());
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class vn extends gn {
            mousedown(e, t1) {
                super.mousedown(e, t1), this._lastPoint && (this._active = !0);
            }
            _correctButton(e, t1) {
                return 0 === t1 && !e.ctrlKey;
            }
            _move(e, t1) {
                return {
                    around: t1,
                    panDelta: t1.sub(e)
                };
            }
        }
        class yn extends gn {
            _correctButton(e, t1) {
                return 0 === t1 && e.ctrlKey || 2 === t1;
            }
            _move(e, t1) {
                const i = .8 * (t1.x - e.x);
                if (i) return this._active = !0, {
                    bearingDelta: i
                };
            }
            contextmenu(e) {
                e.preventDefault();
            }
        }
        class xn extends gn {
            _correctButton(e, t1) {
                return 0 === t1 && e.ctrlKey || 2 === t1;
            }
            _move(e, t1) {
                const i = -.5 * (t1.y - e.y);
                if (i) return this._active = !0, {
                    pitchDelta: i
                };
            }
            contextmenu(e) {
                e.preventDefault();
            }
        }
        class bn {
            constructor(t1, i){
                this._map = t1, this._el = t1.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i.clickTolerance || 1, this.reset(), e.aP([
                    "_addTouchPanBlocker",
                    "_showTouchPanBlockerAlert"
                ], this);
            }
            reset() {
                this._active = !1, this._touches = {}, this._sum = new e.P(0, 0);
            }
            touchstart(e, t1, i) {
                return this._calculateTransform(e, t1, i);
            }
            touchmove(t1, i, o) {
                if (this._active && !(o.length < this._minTouches)) {
                    if (this._map._cooperativeGestures && !this._map.isMoving()) {
                        if (1 === o.length && !e.dz()) return void this._showTouchPanBlockerAlert();
                        "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                    }
                    return t1.cancelable && t1.preventDefault(), this._calculateTransform(t1, i, o);
                }
            }
            touchend(e, t1, i) {
                this._calculateTransform(e, t1, i), this._active && i.length < this._minTouches && this.reset();
            }
            touchcancel() {
                this.reset();
            }
            _calculateTransform(t1, i, o) {
                o.length > 0 && (this._active = !0);
                const s = dn(o, i), r = new e.P(0, 0), a = new e.P(0, 0);
                let n = 0;
                for(const e in s){
                    const t1 = s[e], i = this._touches[e];
                    i && (r._add(t1), a._add(t1.sub(i)), n++, s[e] = t1);
                }
                if (this._touches = s, n < this._minTouches || !a.mag()) return;
                const l = a.div(n);
                return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {
                    around: r.div(n),
                    panDelta: l
                };
            }
            enable() {
                this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
            }
            disable() {
                this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return !!this._active;
            }
            _addTouchPanBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = l("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }
            _showTouchPanBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(()=>{
                    this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
                }, 500);
            }
        }
        class wn {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1, this._firstTwoTouches = void 0;
            }
            _start(e) {}
            _move(e, t1, i) {
                return {};
            }
            touchstart(e, t1, i) {
                this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [
                    i[0].identifier,
                    i[1].identifier
                ], this._start([
                    t1[0],
                    t1[1]
                ]));
            }
            touchmove(e, t1, i) {
                const o = this._firstTwoTouches;
                if (!o) return;
                e.preventDefault();
                const [s, r] = o, a = Tn(i, t1, s), n = Tn(i, t1, r);
                if (!a || !n) return;
                const l = this._aroundCenter ? null : a.add(n).div(2);
                return this._move([
                    a,
                    n
                ], l, e);
            }
            touchend(e, t1, i) {
                if (!this._firstTwoTouches) return;
                const [o, s] = this._firstTwoTouches, r = Tn(i, t1, o), a = Tn(i, t1, s);
                r && a || (this._active && m(), this.reset());
            }
            touchcancel() {
                this.reset();
            }
            enable(e) {
                this._enabled = !0, this._aroundCenter = !!e && "center" === e.around;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        function Tn(e, t1, i) {
            for(let o = 0; o < e.length; o++)if (e[o].identifier === i) return t1[o];
        }
        function En(e, t1) {
            return Math.log(e / t1) / Math.LN2;
        }
        class Sn extends wn {
            reset() {
                super.reset(), this._distance = 0, this._startDistance = 0;
            }
            _start(e) {
                this._startDistance = this._distance = e[0].dist(e[1]);
            }
            _move(e, t1) {
                const i = this._distance;
                if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(En(this._distance, this._startDistance)) < .1)) return this._active = !0, {
                    zoomDelta: En(this._distance, i),
                    pinchAround: t1
                };
            }
        }
        function Cn(e, t1) {
            return 180 * e.angleWith(t1) / Math.PI;
        }
        class In extends wn {
            reset() {
                super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
            }
            _start(e) {
                this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);
            }
            _move(e, t1) {
                const i = this._vector;
                if (this._vector = e[0].sub(e[1]), i && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, {
                    bearingDelta: Cn(this._vector, i),
                    pinchAround: t1
                };
            }
            _isBelowThreshold(e) {
                this._minDiameter = Math.min(this._minDiameter, e.mag());
                const t1 = 25 / (Math.PI * this._minDiameter) * 360, i = this._startVector;
                if (!i) return !1;
                const o = Cn(e, i);
                return Math.abs(o) < t1;
            }
        }
        function Rn(e) {
            return Math.abs(e.y) > Math.abs(e.x);
        }
        class Dn extends wn {
            constructor(e){
                super(), this._map = e;
            }
            reset() {
                super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
            }
            _start(e) {
                this._lastPoints = e, Rn(e[0].sub(e[1])) && (this._valid = !1);
            }
            _move(t1, i, o) {
                const s = this._lastPoints;
                if (!s) return;
                const r = t1[0].sub(s[0]), a = t1[1].sub(s[1]);
                return this._map._cooperativeGestures && !e.dz() && o.touches.length < 3 || (this._valid = this.gestureBeginsVertically(r, a, o.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t1, this._active = !0, {
                    pitchDelta: (r.y + a.y) / 2 * -.5
                });
            }
            gestureBeginsVertically(e, t1, i) {
                if (void 0 !== this._valid) return this._valid;
                const o = e.mag() >= 2, s = t1.mag() >= 2;
                if (!o && !s) return;
                if (!o || !s) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;
                const r = e.y > 0 == t1.y > 0;
                return Rn(e) && Rn(t1) && r;
            }
        }
        const Ln = {
            panStep: 100,
            bearingStep: 15,
            pitchStep: 10
        };
        class An {
            constructor(){
                const e = Ln;
                this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            keydown(e) {
                if (e.altKey || e.ctrlKey || e.metaKey) return;
                let t1 = 0, i = 0, o = 0, s = 0, r = 0;
                switch(e.keyCode){
                    case 61:
                    case 107:
                    case 171:
                    case 187:
                        t1 = 1;
                        break;
                    case 189:
                    case 109:
                    case 173:
                        t1 = -1;
                        break;
                    case 37:
                        e.shiftKey ? i = -1 : (e.preventDefault(), s = -1);
                        break;
                    case 39:
                        e.shiftKey ? i = 1 : (e.preventDefault(), s = 1);
                        break;
                    case 38:
                        e.shiftKey ? o = 1 : (e.preventDefault(), r = -1);
                        break;
                    case 40:
                        e.shiftKey ? o = -1 : (e.preventDefault(), r = 1);
                        break;
                    default:
                        return;
                }
                return this._rotationDisabled && (i = 0, o = 0), {
                    cameraAnimation: (a)=>{
                        const n = a.getZoom();
                        a.easeTo({
                            duration: 300,
                            easeId: "keyboardHandler",
                            easing: zn,
                            zoom: t1 ? Math.round(n) + t1 * (e.shiftKey ? 2 : 1) : n,
                            bearing: a.getBearing() + i * this._bearingStep,
                            pitch: a.getPitch() + o * this._pitchStep,
                            offset: [
                                -s * this._panStep,
                                -r * this._panStep
                            ],
                            center: a.getCenter()
                        }, {
                            originalEvent: e
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
            disableRotation() {
                this._rotationDisabled = !0;
            }
            enableRotation() {
                this._rotationDisabled = !1;
            }
        }
        function zn(e) {
            return e * (2 - e);
        }
        const Pn = 4.000244140625, Mn = 1 / 450;
        class On {
            constructor(t1, i){
                this._map = t1, this._el = t1.getCanvasContainer(), this._handler = i, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = Mn, e.aP([
                    "_onTimeout",
                    "_addScrollZoomBlocker",
                    "_showBlockerAlert"
                ], this);
            }
            setZoomRate(e) {
                this._defaultZoomRate = e;
            }
            setWheelZoomRate(e) {
                this._wheelZoomRate = e;
            }
            isEnabled() {
                return !!this._enabled;
            }
            isActive() {
                return this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
                return !!this._zooming;
            }
            enable(e) {
                this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && "center" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
            }
            disable() {
                this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
            }
            wheel(t1) {
                if (!this.isEnabled()) return;
                if (this._map._cooperativeGestures) {
                    if (!(t1.ctrlKey || t1.metaKey || this.isZooming() || e.dz())) return void this._showBlockerAlert();
                    "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                }
                let i = t1.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t1.deltaY : t1.deltaY;
                const o = e.q.now(), s = o - (this._lastWheelEventTime || 0);
                this._lastWheelEventTime = o, 0 !== i && i % Pn == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : s > 400 ? (this._type = null, this._lastValue = i, this._timeout = window.setTimeout(this._onTimeout, 40, t1)) : this._type || (this._type = Math.abs(s * i) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), t1.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = t1, this._delta -= i, this._active || this._start(t1)), t1.preventDefault();
            }
            _onTimeout(e) {
                this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e);
            }
            _start(e) {
                if (!this._delta) return;
                this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
                const t1 = g(this._el, e);
                this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t1, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());
            }
            renderFrame() {
                if (!this._frameId) return;
                if (this._frameId = null, !this.isActive()) return;
                const t1 = this._map.transform;
                "wheel" === this._type && t1.projection.wrap && (t1._center.lng >= 180 || t1._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
                const i = ()=>t1._terrainEnabled() && this._aroundCoord ? t1.computeZoomRelativeTo(this._aroundCoord) : t1.zoom;
                if (0 !== this._delta) {
                    const e = "wheel" === this._type && Math.abs(this._delta) > Pn ? this._wheelZoomRate : this._defaultZoomRate;
                    let o = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));
                    this._delta < 0 && 0 !== o && (o = 1 / o);
                    const s = i(), r = Math.pow(2, s), a = "number" == typeof this._targetZoom ? t1.zoomScale(this._targetZoom) : r;
                    this._targetZoom = Math.min(t1.maxZoom, Math.max(t1.minZoom, t1.scaleZoom(a * o))), "wheel" === this._type && (this._startZoom = s, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
                }
                const o = "number" == typeof this._targetZoom ? this._targetZoom : i(), s = this._startZoom, r = this._easing;
                let a, n = !1;
                if ("wheel" === this._type && s && r) {
                    const t1 = Math.min((e.q.now() - this._lastWheelEventTime) / 200, 1), i = r(t1);
                    a = e.af(s, o, i), t1 < 1 ? this._frameId || (this._frameId = !0) : n = !0;
                } else a = o, n = !0;
                this._active = !0, n && (this._active = !1, this._finishTimeout = window.setTimeout(()=>{
                    this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
                }, 200));
                let l = a - i();
                return l * this._lastDelta < 0 && (l = 0), {
                    noInertia: !0,
                    needsRenderFrame: !n,
                    zoomDelta: l,
                    around: this._aroundPoint,
                    aroundCoord: this._aroundCoord,
                    originalEvent: this._lastWheelEvent
                };
            }
            _smoothOutEasing(t1) {
                let i = e.dA;
                if (this._prevEase) {
                    const t1 = this._prevEase, o = (e.q.now() - t1.start) / t1.duration, s = t1.easing(o + .01) - t1.easing(o), r = .27 / Math.sqrt(s * s + 1e-4) * .01, a = Math.sqrt(.0729 - r * r);
                    i = e.dy(r, a, .25, 1);
                }
                return this._prevEase = {
                    start: e.q.now(),
                    duration: t1,
                    easing: i
                }, i;
            }
            blur() {
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            _addScrollZoomBlocker() {
                this._map && !this._alertContainer && (this._alertContainer = l("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);
            }
            _showBlockerAlert() {
                this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(()=>{
                    this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
                }, 200);
            }
        }
        class Fn {
            constructor(e, t1){
                this._clickZoom = e, this._tapZoom = t1;
            }
            enable() {
                this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
                this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
                return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
                return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
        }
        class kn {
            constructor(){
                this.reset();
            }
            reset() {
                this._active = !1;
            }
            blur() {
                this.reset();
            }
            dblclick(e, t1) {
                return e.preventDefault(), {
                    cameraAnimation: (i)=>{
                        i.easeTo({
                            duration: 300,
                            zoom: i.getZoom() + (e.shiftKey ? -1 : 1),
                            around: i.unproject(t1)
                        }, {
                            originalEvent: e
                        });
                    }
                };
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class Bn {
            constructor(){
                this._tap = new pn({
                    numTouches: 1,
                    numTaps: 1
                }), this.reset();
            }
            reset() {
                this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
            }
            touchstart(e, t1, i) {
                this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t1[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e, t1, i));
            }
            touchmove(e, t1, i) {
                if (this._tapTime) {
                    if (this._swipePoint) {
                        if (i[0].identifier !== this._swipeTouch) return;
                        const o = t1[0], s = o.y - this._swipePoint.y;
                        return this._swipePoint = o, e.preventDefault(), this._active = !0, {
                            zoomDelta: s / 128
                        };
                    }
                } else this._tap.touchmove(e, t1, i);
            }
            touchend(e, t1, i) {
                this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e, t1, i) && (this._tapTime = e.timeStamp);
            }
            touchcancel() {
                this.reset();
            }
            enable() {
                this._enabled = !0;
            }
            disable() {
                this._enabled = !1, this.reset();
            }
            isEnabled() {
                return this._enabled;
            }
            isActive() {
                return this._active;
            }
        }
        class Nn {
            constructor(e, t1, i){
                this._el = e, this._mousePan = t1, this._touchPan = i;
            }
            enable(e) {
                this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
            }
            disable() {
                this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
            }
            isEnabled() {
                return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
                return this._mousePan.isActive() || this._touchPan.isActive();
            }
        }
        class Un {
            constructor(e, t1, i){
                this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t1, this._mousePitch = i;
            }
            enable() {
                this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
                this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
                return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
                return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
        }
        class Gn {
            constructor(e, t1, i, o){
                this._el = e, this._touchZoom = t1, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;
            }
            enable(e) {
                this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
            }
            disable() {
                this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
            }
            isEnabled() {
                return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
                return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
                this._rotationDisabled = !0, this._touchRotate.disable();
            }
            enableRotation() {
                this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
        }
        const jn = (e)=>e.zoom || e.drag || e.pitch || e.rotate;
        class Vn extends e.z {
        }
        class qn {
            constructor(){
                this.constants = [
                    1,
                    1,
                    .01
                ], this.radius = 0;
            }
            setup(t1, i) {
                const o = e.ab.vec3.sub([], i, t1);
                this.radius = e.ab.vec3.length(o[2] < 0 ? e.ab.vec3.div([], o, this.constants) : [
                    o[0],
                    o[1],
                    0
                ]);
            }
            projectRay(t1) {
                e.ab.vec3.div(t1, t1, this.constants), e.ab.vec3.normalize(t1, t1), e.ab.vec3.mul(t1, t1, this.constants);
                const i = e.ab.vec3.scale([], t1, this.radius);
                if (i[2] > 0) {
                    const t1 = e.ab.vec3.scale([], [
                        0,
                        0,
                        1
                    ], e.ab.vec3.dot(i, [
                        0,
                        0,
                        1
                    ])), o = e.ab.vec3.scale([], e.ab.vec3.normalize([], [
                        i[0],
                        i[1],
                        0
                    ]), this.radius), s = e.ab.vec3.add([], i, e.ab.vec3.scale([], e.ab.vec3.sub([], e.ab.vec3.add([], o, t1), i), 2));
                    i[0] = s[0], i[1] = s[1];
                }
                return i;
            }
        }
        function Hn(e) {
            return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta;
        }
        class Zn {
            constructor(t1, i){
                this._map = t1, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new on(t1), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new qn, this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i), e.aP([
                    "handleEvent",
                    "handleWindowEvent"
                ], this);
                const o = this._el;
                this._listeners = [
                    [
                        o,
                        "touchstart",
                        {
                            passive: !0
                        }
                    ],
                    [
                        o,
                        "touchmove",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o,
                        "touchend",
                        void 0
                    ],
                    [
                        o,
                        "touchcancel",
                        void 0
                    ],
                    [
                        o,
                        "mousedown",
                        void 0
                    ],
                    [
                        o,
                        "mousemove",
                        void 0
                    ],
                    [
                        o,
                        "mouseup",
                        void 0
                    ],
                    [
                        document,
                        "mousemove",
                        {
                            capture: !0
                        }
                    ],
                    [
                        document,
                        "mouseup",
                        void 0
                    ],
                    [
                        o,
                        "mouseover",
                        void 0
                    ],
                    [
                        o,
                        "mouseout",
                        void 0
                    ],
                    [
                        o,
                        "dblclick",
                        void 0
                    ],
                    [
                        o,
                        "click",
                        void 0
                    ],
                    [
                        o,
                        "keydown",
                        {
                            capture: !1
                        }
                    ],
                    [
                        o,
                        "keyup",
                        void 0
                    ],
                    [
                        o,
                        "wheel",
                        {
                            passive: !1
                        }
                    ],
                    [
                        o,
                        "contextmenu",
                        void 0
                    ],
                    [
                        window,
                        "blur",
                        void 0
                    ]
                ];
                for (const [e, t1, i] of this._listeners){
                    const o = e === document ? this.handleWindowEvent : this.handleEvent;
                    e.addEventListener(t1, o, i);
                }
            }
            destroy() {
                for (const [e, t1, i] of this._listeners){
                    const o = e === document ? this.handleWindowEvent : this.handleEvent;
                    e.removeEventListener(t1, o, i);
                }
            }
            _addDefaultHandlers(e) {
                const t1 = this._map, i = t1.getCanvasContainer();
                this._add("mapEvent", new cn(t1, e));
                const o = t1.boxZoom = new un(t1, e);
                this._add("boxZoom", o);
                const s = new fn, r = new kn;
                t1.doubleClickZoom = new Fn(r, s), this._add("tapZoom", s), this._add("clickZoom", r);
                const a = new Bn;
                this._add("tapDragZoom", a);
                const n = t1.touchPitch = new Dn(t1);
                this._add("touchPitch", n);
                const l = new yn(e), c = new xn(e);
                t1.dragRotate = new Un(e, l, c), this._add("mouseRotate", l, [
                    "mousePitch"
                ]), this._add("mousePitch", c, [
                    "mouseRotate"
                ]);
                const h = new vn(e), u = new bn(t1, e);
                t1.dragPan = new Nn(i, h, u), this._add("mousePan", h), this._add("touchPan", u, [
                    "touchZoom",
                    "touchRotate"
                ]);
                const d = new In, _ = new Sn;
                t1.touchZoomRotate = new Gn(i, _, d, a), this._add("touchRotate", d, [
                    "touchPan",
                    "touchZoom"
                ]), this._add("touchZoom", _, [
                    "touchPan",
                    "touchRotate"
                ]), this._add("blockableMapEvent", new hn(t1));
                const p = t1.scrollZoom = new On(t1, this);
                this._add("scrollZoom", p, [
                    "mousePan"
                ]);
                const f = t1.keyboard = new An;
                this._add("keyboard", f);
                for (const i of [
                    "boxZoom",
                    "doubleClickZoom",
                    "tapDragZoom",
                    "touchPitch",
                    "dragRotate",
                    "dragPan",
                    "touchZoomRotate",
                    "scrollZoom",
                    "keyboard"
                ])e.interactive && e[i] && t1[i].enable(e[i]);
            }
            _add(e, t1, i) {
                this._handlers.push({
                    handlerName: e,
                    handler: t1,
                    allowed: i
                }), this._handlersById[e] = t1;
            }
            stop(e) {
                if (!this._updatingCamera) {
                    for (const { handler: e } of this._handlers)e.reset();
                    this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [], this._originalZoom = void 0;
                }
            }
            isActive() {
                for (const { handler: e } of this._handlers)if (e.isActive()) return !0;
                return !1;
            }
            isZooming() {
                return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
                return !!this._eventsInProgress.rotate;
            }
            isMoving() {
                return !!jn(this._eventsInProgress) || this.isZooming();
            }
            _isDragging() {
                return !!this._eventsInProgress.drag;
            }
            _blockedByActive(e, t1, i) {
                for(const o in e)if (o !== i && (!t1 || t1.indexOf(o) < 0)) return !0;
                return !1;
            }
            handleWindowEvent(e) {
                this.handleEvent(e, `${e.type}Window`);
            }
            _getMapTouches(e) {
                const t1 = [];
                for (const i of e)this._el.contains(i.target) && t1.push(i);
                return t1;
            }
            handleEvent(e, t1) {
                this._updatingCamera = !0;
                const i = "renderFrame" === e.type, o = i ? void 0 : e, s = {
                    needsRenderFrame: !1
                }, r = {}, a = {}, n = e.touches ? this._getMapTouches(e.touches) : void 0, l = n ? v(this._el, n) : i ? void 0 : g(this._el, e);
                for (const { handlerName: i, handler: c, allowed: h } of this._handlers){
                    if (!c.isEnabled()) continue;
                    let u;
                    this._blockedByActive(a, h, i) ? c.reset() : c[t1 || e.type] && (u = c[t1 || e.type](e, l, n), this.mergeHandlerResult(s, r, u, i, o), u && u.needsRenderFrame && this._triggerRenderFrame()), (u || c.isActive()) && (a[i] = c);
                }
                const c = {};
                for(const e in this._previousActiveHandlers)a[e] || (c[e] = o);
                this._previousActiveHandlers = a, (Object.keys(c).length || Hn(s)) && (this._changes.push([
                    s,
                    r,
                    c
                ]), this._triggerRenderFrame()), (Object.keys(a).length || Hn(s)) && this._map._stop(!0), this._updatingCamera = !1;
                const { cameraAnimation: h } = s;
                h && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h(this._map));
            }
            mergeHandlerResult(t1, i, o, s, r) {
                if (!o) return;
                e.l(t1, o);
                const a = {
                    handlerName: s,
                    originalEvent: o.originalEvent || r
                };
                void 0 !== o.zoomDelta && (i.zoom = a), void 0 !== o.panDelta && (i.drag = a), void 0 !== o.pitchDelta && (i.pitch = a), void 0 !== o.bearingDelta && (i.rotate = a);
            }
            _applyChanges() {
                const t1 = {}, i = {}, o = {};
                for (const [s, r, a] of this._changes)s.panDelta && (t1.panDelta = (t1.panDelta || new e.P(0, 0))._add(s.panDelta)), s.zoomDelta && (t1.zoomDelta = (t1.zoomDelta || 0) + s.zoomDelta), s.bearingDelta && (t1.bearingDelta = (t1.bearingDelta || 0) + s.bearingDelta), s.pitchDelta && (t1.pitchDelta = (t1.pitchDelta || 0) + s.pitchDelta), void 0 !== s.around && (t1.around = s.around), void 0 !== s.aroundCoord && (t1.aroundCoord = s.aroundCoord), void 0 !== s.pinchAround && (t1.pinchAround = s.pinchAround), s.noInertia && (t1.noInertia = s.noInertia), e.l(i, r), e.l(o, a);
                this._updateMapTransform(t1, i, o), this._changes = [];
            }
            _updateMapTransform(t1, i, o) {
                const s = this._map, r = s.transform, a = (e)=>[
                        e.x,
                        e.y,
                        e.z
                    ];
                if (((e)=>{
                    const t1 = this._eventsInProgress.drag;
                    return t1 && !this._handlersById[t1.handlerName].isActive();
                })() && !Hn(t1)) {
                    const e = r.zoom;
                    r.cameraElevationReference = "sea", null != this._originalZoom && r._orthographicProjectionAtLowPitch && "globe" !== r.projection.name && 0 === r.pitch ? (r.cameraElevationReference = "ground", r.zoom = this._originalZoom) : (r.recenterOnTerrain(), r.cameraElevationReference = "ground"), e !== r.zoom && this._map._update(!0);
                }
                if (r._isCameraConstrained && s._stop(!0), !Hn(t1)) return void this._fireEvents(i, o, !0);
                let { panDelta: n, zoomDelta: l, bearingDelta: c, pitchDelta: h, around: u, aroundCoord: d, pinchAround: _ } = t1;
                r._isCameraConstrained && (l > 0 && (l = 0), r._isCameraConstrained = !1), void 0 !== _ && (u = _), (l || ((e)=>i[e] && !this._eventsInProgress[e])("drag")) && u && (this._dragOrigin = a(r.pointCoordinate3D(u)), this._originalZoom = r.zoom, this._trackingEllipsoid.setup(r._camera.position, this._dragOrigin)), r.cameraElevationReference = "sea", s._stop(!0), u = u || s.transform.centerPoint, c && (r.bearing += c), h && (r.pitch += h), r._updateCameraState();
                const p = [
                    0,
                    0,
                    0
                ];
                if (n) if ("mercator" === r.projection.name) {
                    const e = this._trackingEllipsoid.projectRay(r.screenPointToMercatorRay(u).dir), t1 = this._trackingEllipsoid.projectRay(r.screenPointToMercatorRay(u.sub(n)).dir);
                    p[0] = t1[0] - e[0], p[1] = t1[1] - e[1];
                } else {
                    const t1 = r.pointCoordinate(u);
                    if ("globe" === r.projection.name) {
                        n = n.rotate(-r.angle);
                        const i = r._pixelsPerMercatorPixel / r.worldSize;
                        p[0] = -n.x * e.dB(e.aS(t1.y)) * i, p[1] = -n.y * e.dB(r.center.lat) * i;
                    } else {
                        const e = r.pointCoordinate(u.sub(n));
                        t1 && e && (p[0] = e.x - t1.x, p[1] = e.y - t1.y);
                    }
                }
                const f = r.zoom, m = [
                    0,
                    0,
                    0
                ];
                if (l) {
                    const t1 = a(d || r.pointCoordinate3D(u)), i = {
                        dir: e.ab.vec3.normalize([], e.ab.vec3.sub([], t1, r._camera.position))
                    };
                    if (i.dir[2] < 0) {
                        const o = r.zoomDeltaToMovement(t1, l);
                        e.ab.vec3.scale(m, i.dir, o);
                    }
                }
                const g = e.ab.vec3.add(p, p, m);
                r._translateCameraConstrained(g), l && Math.abs(r.zoom - f) > 1e-4 && r.recenterOnTerrain(), r.cameraElevationReference = "ground", this._map._update(), t1.noInertia || this._inertia.record(t1), this._fireEvents(i, o, !0);
            }
            _fireEvents(t1, i, o) {
                const s = jn(this._eventsInProgress), r = jn(t1), a = {};
                for(const e in t1){
                    const { originalEvent: i } = t1[e];
                    this._eventsInProgress[e] || (a[`${e}start`] = i), this._eventsInProgress[e] = t1[e];
                }
                !s && r && this._fireEvent("movestart", r.originalEvent);
                for(const e in a)this._fireEvent(e, a[e]);
                r && this._fireEvent("move", r.originalEvent);
                for(const e in t1){
                    const { originalEvent: i } = t1[e];
                    this._fireEvent(e, i);
                }
                const n = {};
                let l;
                for(const e in this._eventsInProgress){
                    const { handlerName: t1, originalEvent: o } = this._eventsInProgress[e];
                    this._handlersById[t1].isActive() || (delete this._eventsInProgress[e], l = i[t1] || o, n[`${e}end`] = l);
                }
                for(const e in n)this._fireEvent(e, n[e]);
                const c = jn(this._eventsInProgress);
                if (o && (s || r) && !c) {
                    this._updatingCamera = !0;
                    const t1 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i = (e)=>0 !== e && -this._bearingSnap < e && e < this._bearingSnap;
                    t1 ? (i(t1.bearing || this._map.getBearing()) && (t1.bearing = 0), this._map.easeTo(t1, {
                        originalEvent: l
                    })) : (this._map.fire(new e.z("moveend", {
                        originalEvent: l
                    })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;
                }
            }
            _fireEvent(t1, i) {
                this._map.fire(new e.z(t1, i ? {
                    originalEvent: i
                } : {}));
            }
            _requestFrame() {
                return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e)=>{
                    this._frameId = void 0, this.handleEvent(new Vn("renderFrame", {
                        timeStamp: e
                    })), this._applyChanges();
                });
            }
            _triggerRenderFrame() {
                void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
        }
        const Wn = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
        class $n extends e.E {
            constructor(t1, i){
                super(), this._moving = !1, this._zooming = !1, this.transform = t1, this._bearingSnap = i.bearingSnap, this._respectPrefersReducedMotion = !1 !== i.respectPrefersReducedMotion, e.aP([
                    "_renderFrameCallback"
                ], this);
            }
            getCenter() {
                return new e.bO(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(e, t1) {
                return this.jumpTo({
                    center: e
                }, t1);
            }
            panBy(t1, i, o) {
                return t1 = e.P.convert(t1).mult(-1), this.panTo(this.transform.center, e.l({
                    offset: t1
                }, i), o);
            }
            panTo(t1, i, o) {
                return this.easeTo(e.l({
                    center: t1
                }, i), o);
            }
            getZoom() {
                return this.transform.zoom;
            }
            setZoom(e, t1) {
                return this.jumpTo({
                    zoom: e
                }, t1), this;
            }
            zoomTo(t1, i, o) {
                return this.easeTo(e.l({
                    zoom: t1
                }, i), o);
            }
            zoomIn(e, t1) {
                return this.zoomTo(this.getZoom() + 1, e, t1), this;
            }
            zoomOut(e, t1) {
                return this.zoomTo(this.getZoom() - 1, e, t1), this;
            }
            getBearing() {
                return this.transform.bearing;
            }
            setBearing(e, t1) {
                return this.jumpTo({
                    bearing: e
                }, t1), this;
            }
            getPadding() {
                return this.transform.padding;
            }
            setPadding(e, t1) {
                return this.jumpTo({
                    padding: e
                }, t1), this;
            }
            rotateTo(t1, i, o) {
                return this.easeTo(e.l({
                    bearing: t1
                }, i), o);
            }
            resetNorth(t1, i) {
                return this.rotateTo(0, e.l({
                    duration: 1e3
                }, t1), i), this;
            }
            resetNorthPitch(t1, i) {
                return this.easeTo(e.l({
                    bearing: 0,
                    pitch: 0,
                    duration: 1e3
                }, t1), i), this;
            }
            snapToNorth(e, t1) {
                return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t1) : this;
            }
            getPitch() {
                return this.transform.pitch;
            }
            setPitch(e, t1) {
                return this.jumpTo({
                    pitch: e
                }, t1), this;
            }
            cameraForBounds(t1, i) {
                t1 = e.az.convert(t1);
                const o = i && i.bearing || 0, s = i && i.pitch || 0, r = t1.getNorthWest(), a = t1.getSouthEast();
                return this._cameraForBounds(this.transform, r, a, o, s, i);
            }
            _extendPadding(t1) {
                const i = {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                };
                return null == t1 ? e.l({}, i, this.transform.padding) : "number" == typeof t1 ? {
                    top: t1,
                    bottom: t1,
                    right: t1,
                    left: t1
                } : e.l({}, i, t1);
            }
            _extendCameraOptions(t1) {
                return (t1 = e.l({
                    offset: [
                        0,
                        0
                    ],
                    maxZoom: this.transform.maxZoom
                }, t1)).padding = this._extendPadding(t1.padding), t1;
            }
            _minimumAABBFrustumDistance(e, t1) {
                const i = t1.max[0] - t1.min[0], o = t1.max[1] - t1.min[1];
                return i / o > e.aspect ? i / (2 * Math.tan(.5 * e.fovX) * e.aspect) : o / (2 * Math.tan(.5 * e.fovY) * e.aspect);
            }
            _cameraForBoundsOnGlobe(t1, i, o, s, r, a) {
                const n = t1.clone(), l = this._extendCameraOptions(a);
                n.bearing = s, n.pitch = r;
                const c = e.bO.convert(i), h = e.bO.convert(o), u = .5 * (c.lat + h.lat), d = .5 * (c.lng + h.lng), _ = e.dC(u, d), p = e.ab.vec3.normalize([], _), f = e.ab.vec3.normalize([], e.ab.vec3.cross([], p, [
                    0,
                    1,
                    0
                ])), m = e.ab.vec3.cross([], f, p), g = [
                    f[0],
                    f[1],
                    f[2],
                    0,
                    m[0],
                    m[1],
                    m[2],
                    0,
                    p[0],
                    p[1],
                    p[2],
                    0,
                    0,
                    0,
                    0,
                    1
                ], v = [
                    _,
                    e.dC(c.lat, c.lng),
                    e.dC(h.lat, c.lng),
                    e.dC(h.lat, h.lng),
                    e.dC(c.lat, h.lng),
                    e.dC(u, c.lng),
                    e.dC(u, h.lng),
                    e.dC(c.lat, d),
                    e.dC(h.lat, d)
                ];
                let y = e.cd.fromPoints(v.map((t1)=>[
                        e.ab.vec3.dot(f, t1),
                        e.ab.vec3.dot(m, t1),
                        e.ab.vec3.dot(p, t1)
                    ]));
                const x = e.ab.vec3.transformMat4([], y.center, g);
                0 === e.ab.vec3.squaredLength(x) && e.ab.vec3.set(x, 0, 0, 1), e.ab.vec3.normalize(x, x), e.ab.vec3.scale(x, x, e.ax), n.center = e.dD(x);
                const b = n.getWorldToCameraMatrix(), w = e.ab.mat4.invert(new Float64Array(16), b);
                y = e.cd.applyTransform(y, e.ab.mat4.multiply([], b, g));
                const T = this._extendAABB(y, n, l, s);
                if (!T) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                y = T, e.ab.vec3.transformMat4(x, x, b);
                const E = .5 * (y.max[2] - y.min[2]), S = this._minimumAABBFrustumDistance(n, y), C = e.ab.vec3.scale([], [
                    0,
                    0,
                    1
                ], E), I = e.ab.vec3.add(C, x, C), R = S + (0 === n.pitch ? 0 : e.ab.vec3.distance(x, I)), D = n.globeCenterInViewSpace, L = e.ab.vec3.sub([], x, [
                    D[0],
                    D[1],
                    D[2]
                ]);
                e.ab.vec3.normalize(L, L), e.ab.vec3.scale(L, L, R);
                const A = e.ab.vec3.add([], x, L);
                e.ab.vec3.transformMat4(A, A, w);
                const z = e.ds / e.ax, P = e.ab.vec3.length(A), M = e.bH(Math.max(P * z - e.ds, Number.EPSILON), 0), O = Math.min(n.zoomFromMercatorZAdjusted(M), l.maxZoom);
                return O > .5 * (e.c6 + e.bY) ? (n.setProjection({
                    name: "mercator"
                }), n.zoom = O, this._cameraForBounds(n, i, o, s, r, a)) : {
                    center: n.center,
                    zoom: O,
                    bearing: s,
                    pitch: r
                };
            }
            _extendAABB(t1, i, o, s) {
                const r = .5 * ((o.padding.left || 0) + (o.padding.right || 0)), a = .5 * ((o.padding.top || 0) + (o.padding.bottom || 0)), n = a, l = r, c = r, h = a, u = i.width - (l + c), d = i.height - (n + h), _ = e.ab.vec3.sub([], t1.max, t1.min), p = Math.min(u / _[0], d / _[1]), f = Math.min(i.scaleZoom(i.scale * p), o.maxZoom);
                if (isNaN(f)) return null;
                const m = i.scale / i.zoomScale(f), g = new e.cd([
                    t1.min[0] - l * m,
                    t1.min[1] - h * m,
                    t1.min[2]
                ], [
                    t1.max[0] + c * m,
                    t1.max[1] + n * m,
                    t1.max[2]
                ]), v = ("number" == typeof o.offset.x && "number" == typeof o.offset.y ? new e.P(o.offset.x, o.offset.y) : e.P.convert(o.offset)).rotate(-e.ai(s));
                return g.center[0] -= v.x * m, g.center[1] += v.y * m, g;
            }
            queryTerrainElevation(t1, i) {
                const o = this.transform.elevation;
                return o ? (i = e.l({}, {
                    exaggerated: !0
                }, i), o.getAtPoint(e.aa.fromLngLat(t1), null, i.exaggerated)) : null;
            }
            _cameraForBounds(t1, i, o, s, r, a) {
                if ("globe" === t1.projection.name) return this._cameraForBoundsOnGlobe(t1, i, o, s, r, a);
                const n = t1.clone(), l = this._extendCameraOptions(a);
                n.bearing = s, n.pitch = r;
                const c = e.bO.convert(i), h = e.bO.convert(o), u = new e.bO(c.lng, h.lat), d = new e.bO(h.lng, c.lat), _ = n.project(c), p = n.project(h), f = this.queryTerrainElevation(c), m = this.queryTerrainElevation(h), g = this.queryTerrainElevation(u), v = this.queryTerrainElevation(d), y = [
                    [
                        _.x,
                        _.y,
                        Math.min(f || 0, m || 0, g || 0, v || 0)
                    ],
                    [
                        p.x,
                        p.y,
                        Math.max(f || 0, m || 0, g || 0, v || 0)
                    ]
                ];
                let x = e.cd.fromPoints(y);
                const b = n.getWorldToCameraMatrix(), w = e.ab.mat4.invert(new Float64Array(16), b);
                x = e.cd.applyTransform(x, b);
                const T = this._extendAABB(x, n, l, s);
                if (!T) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
                x = T;
                const E = .5 * e.ab.vec3.sub([], x.max, x.min)[2], S = this._minimumAABBFrustumDistance(n, x), C = [
                    0,
                    0,
                    1,
                    0
                ];
                e.ab.vec4.transformMat4(C, C, b), e.ab.vec4.normalize(C, C);
                const I = e.ab.vec3.scale([], C, S + E), R = e.ab.vec3.add([], x.center, I);
                e.ab.vec3.transformMat4(x.center, x.center, w), e.ab.vec3.transformMat4(R, R, w);
                const D = n.unproject(new e.P(x.center[0], x.center[1])), L = e.dE(n.projection, D), A = Math.pow(2, L), z = Math.min(n._zoomFromMercatorZ(R[2] * n.pixelsPerMeter * A / n.worldSize), l.maxZoom);
                return n.mercatorFromTransition && z < .5 * (e.c6 + e.bY) ? (n.setProjection({
                    name: "globe"
                }), n.zoom = z, this._cameraForBounds(n, i, o, s, r, a)) : {
                    center: D,
                    zoom: z,
                    bearing: s,
                    pitch: r
                };
            }
            fitBounds(e, t1, i) {
                const o = this.cameraForBounds(e, t1);
                return this._fitInternal(o, t1, i);
            }
            fitScreenCoordinates(t1, i, o, s, r) {
                const a = e.P.convert(t1), n = e.P.convert(i), l = new e.P(Math.min(a.x, n.x), Math.min(a.y, n.y)), c = new e.P(Math.max(a.x, n.x), Math.max(a.y, n.y));
                if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(a, n)) return this;
                const h = this.transform.pointLocation3D(l), u = this.transform.pointLocation3D(c), d = this.transform.pointLocation3D(new e.P(l.x, c.y)), _ = this.transform.pointLocation3D(new e.P(c.x, l.y)), p = [
                    Math.min(h.lng, u.lng, d.lng, _.lng),
                    Math.min(h.lat, u.lat, d.lat, _.lat)
                ], f = [
                    Math.max(h.lng, u.lng, d.lng, _.lng),
                    Math.max(h.lat, u.lat, d.lat, _.lat)
                ], m = s && s.pitch ? s.pitch : this.getPitch(), g = this._cameraForBounds(this.transform, p, f, o, m, s);
                return this._fitInternal(g, s, r);
            }
            _fitInternal(t1, i, o) {
                return t1 ? (i = e.l(t1, i)).linear ? this.easeTo(i, o) : this.flyTo(i, o) : this;
            }
            jumpTo(t1, i) {
                this.stop();
                const o = t1.preloadOnly ? this.transform.clone() : this.transform;
                let s = !1, r = !1, a = !1;
                "zoom" in t1 && o.zoom !== +t1.zoom && (s = !0, o.zoom = +t1.zoom), void 0 !== t1.center && (o.center = e.bO.convert(t1.center)), "bearing" in t1 && o.bearing !== +t1.bearing && (r = !0, o.bearing = +t1.bearing), "pitch" in t1 && o.pitch !== +t1.pitch && (a = !0, o.pitch = +t1.pitch);
                const n = "number" == typeof t1.padding ? this._extendPadding(t1.padding) : t1.padding;
                if (null != t1.padding && !o.isPaddingEqual(n)) if (!1 === t1.retainPadding) {
                    const e = o.clone();
                    e.padding = n, o.setLocationAtPoint(o.center, e.centerPoint);
                } else o.padding = n;
                return t1.preloadOnly ? (this._preloadTiles(o), this) : (this.fire(new e.z("movestart", i)).fire(new e.z("move", i)), s && this.fire(new e.z("zoomstart", i)).fire(new e.z("zoom", i)).fire(new e.z("zoomend", i)), r && this.fire(new e.z("rotatestart", i)).fire(new e.z("rotate", i)).fire(new e.z("rotateend", i)), a && this.fire(new e.z("pitchstart", i)).fire(new e.z("pitch", i)).fire(new e.z("pitchend", i)), this.fire(new e.z("moveend", i)));
            }
            getFreeCameraOptions() {
                return this.transform.projection.supportsFreeCamera || e.w(Wn), this.transform.getFreeCameraOptions();
            }
            setFreeCameraOptions(t1, i) {
                const o = this.transform;
                if (!o.projection.supportsFreeCamera) return e.w(Wn), this;
                this.stop();
                const s = o.zoom, r = o.pitch, a = o.bearing;
                o.setFreeCameraOptions(t1);
                const n = s !== o.zoom, l = r !== o.pitch, c = a !== o.bearing;
                return this.fire(new e.z("movestart", i)).fire(new e.z("move", i)), n && this.fire(new e.z("zoomstart", i)).fire(new e.z("zoom", i)).fire(new e.z("zoomend", i)), c && this.fire(new e.z("rotatestart", i)).fire(new e.z("rotate", i)).fire(new e.z("rotateend", i)), l && this.fire(new e.z("pitchstart", i)).fire(new e.z("pitch", i)).fire(new e.z("pitchend", i)), this.fire(new e.z("moveend", i)), this;
            }
            easeTo(t1, i) {
                this._stop(!1, t1.easeId), (!1 === (t1 = e.l({
                    offset: [
                        0,
                        0
                    ],
                    duration: 500,
                    easing: e.dA
                }, t1)).animate || this._prefersReducedMotion(t1)) && (t1.duration = 0);
                const o = this.transform, s = this.getZoom(), r = this.getBearing(), a = this.getPitch(), n = this.getPadding(), l = "zoom" in t1 ? +t1.zoom : s, c = "bearing" in t1 ? this._normalizeBearing(t1.bearing, r) : r, h = "pitch" in t1 ? +t1.pitch : a, u = this._extendPadding(t1.padding), d = e.P.convert(t1.offset);
                let _, p, f;
                if ("globe" === o.projection.name) {
                    const i = e.aa.fromLngLat(o.center), s = d.rotate(-o.angle);
                    i.x += s.x / o.worldSize, i.y += s.y / o.worldSize;
                    const r = i.toLngLat(), a = e.bO.convert(t1.center || r);
                    this._normalizeCenter(a), _ = o.centerPoint.add(s), p = new e.P(i.x, i.y).mult(o.worldSize), f = new e.P(e.at(a.lng), e.aA(a.lat)).mult(o.worldSize).sub(p);
                } else {
                    _ = o.centerPoint.add(d);
                    const i = o.pointLocation(_), s = e.bO.convert(t1.center || i);
                    this._normalizeCenter(s), p = o.project(i), f = o.project(s).sub(p);
                }
                const m = o.zoomScale(l - s);
                let g, v;
                t1.around && (g = e.bO.convert(t1.around), v = o.locationPoint(g));
                const y = this._zooming || l !== s, x = this._rotating || r !== c, b = this._pitching || h !== a, w = !o.isPaddingEqual(u), T = !1 === t1.retainPadding ? o.clone() : o, E = (o)=>(E)=>{
                        if (y && (o.zoom = e.af(s, l, E)), x && (o.bearing = e.af(r, c, E)), b && (o.pitch = e.af(a, h, E)), w && (T.interpolatePadding(n, u, E), _ = T.centerPoint.add(d)), g) o.setLocationAtPoint(g, v);
                        else {
                            const e = o.zoomScale(o.zoom - s), t1 = l > s ? Math.min(2, m) : Math.max(.5, m), i = Math.pow(t1, 1 - E), r = o.unproject(p.add(f.mult(E * i)).mult(e));
                            o.setLocationAtPoint(o.renderWorldCopies ? r.wrap() : r, _);
                        }
                        return t1.preloadOnly || this._fireMoveEvents(i), o;
                    };
                if (t1.preloadOnly) {
                    const e = this._emulate(E, t1.duration, o);
                    return this._preloadTiles(e), this;
                }
                const S = {
                    moving: this._moving,
                    zooming: this._zooming,
                    rotating: this._rotating,
                    pitching: this._pitching
                };
                return this._zooming = y, this._rotating = x, this._pitching = b, this._padding = w, this._easeId = t1.easeId, this._prepareEase(i, t1.noMoveStart, S), this._ease(E(o), (e)=>{
                    "sea" === o.cameraElevationReference && o.recenterOnTerrain(), this._afterEase(i, e);
                }, t1), this;
            }
            _prepareEase(t1, i, o = {}) {
                this._moving = !0, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"), i || o.moving || this.fire(new e.z("movestart", t1)), this._zooming && !o.zooming && this.fire(new e.z("zoomstart", t1)), this._rotating && !o.rotating && this.fire(new e.z("rotatestart", t1)), this._pitching && !o.pitching && this.fire(new e.z("pitchstart", t1));
            }
            _fireMoveEvents(t1) {
                this.fire(new e.z("move", t1)), this._zooming && this.fire(new e.z("zoom", t1)), this._rotating && this.fire(new e.z("rotate", t1)), this._pitching && this.fire(new e.z("pitch", t1));
            }
            _afterEase(t1, i) {
                if (this._easeId && i && this._easeId === i) return;
                this._easeId = void 0, this.transform.cameraElevationReference = "ground";
                const o = this._zooming, s = this._rotating, r = this._pitching;
                this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new e.z("zoomend", t1)), s && this.fire(new e.z("rotateend", t1)), r && this.fire(new e.z("pitchend", t1)), this.fire(new e.z("moveend", t1));
            }
            flyTo(t1, i) {
                if (this._prefersReducedMotion(t1)) {
                    const o = e.ay(t1, [
                        "center",
                        "zoom",
                        "bearing",
                        "pitch",
                        "around",
                        "padding",
                        "retainPadding"
                    ]);
                    return this.jumpTo(o, i);
                }
                this.stop(), t1 = e.l({
                    offset: [
                        0,
                        0
                    ],
                    speed: 1.2,
                    curve: 1.42,
                    easing: e.dA
                }, t1);
                const o = this.transform, s = this.getZoom(), r = this.getBearing(), a = this.getPitch(), n = this.getPadding(), l = "zoom" in t1 ? e.aw(+t1.zoom, o.minZoom, o.maxZoom) : s, c = "bearing" in t1 ? this._normalizeBearing(t1.bearing, r) : r, h = "pitch" in t1 ? +t1.pitch : a, u = this._extendPadding(t1.padding), d = o.zoomScale(l - s), _ = e.P.convert(t1.offset);
                let p = o.centerPoint.add(_);
                const f = o.pointLocation(p), m = e.bO.convert(t1.center || f);
                this._normalizeCenter(m);
                const g = o.project(f), v = o.project(m).sub(g);
                let y = t1.curve;
                const x = Math.max(o.width, o.height), b = x / d, w = v.mag();
                if ("minZoom" in t1) {
                    const i = e.aw(Math.min(t1.minZoom, s, l), o.minZoom, o.maxZoom), r = x / o.zoomScale(i - s);
                    y = Math.sqrt(r / w * 2);
                }
                const T = y * y;
                function E(e) {
                    const t1 = (b * b - x * x + (e ? -1 : 1) * T * T * w * w) / (2 * (e ? b : x) * T * w);
                    return Math.log(Math.sqrt(t1 * t1 + 1) - t1);
                }
                function S(e) {
                    return (Math.exp(e) - Math.exp(-e)) / 2;
                }
                function C(e) {
                    return (Math.exp(e) + Math.exp(-e)) / 2;
                }
                const I = E(0);
                let R = function(e) {
                    return C(I) / C(I + y * e);
                }, D = function(e) {
                    return x * ((C(I) * (S(t1 = I + y * e) / C(t1)) - S(I)) / T) / w;
                    "TURBOPACK unreachable";
                    var t1;
                }, L = (E(1) - I) / y;
                if (Math.abs(w) < 1e-6 || !isFinite(L)) {
                    if (Math.abs(x - b) < 1e-6) return this.easeTo(t1, i);
                    const e = b < x ? -1 : 1;
                    L = Math.abs(Math.log(b / x)) / y, D = function() {
                        return 0;
                    }, R = function(t1) {
                        return Math.exp(e * y * t1);
                    };
                }
                t1.duration = "duration" in t1 ? +t1.duration : 1e3 * L / ("screenSpeed" in t1 ? +t1.screenSpeed / y : +t1.speed), t1.maxDuration && t1.duration > t1.maxDuration && (t1.duration = 0);
                const A = r !== c, z = h !== a, P = !o.isPaddingEqual(u), M = !1 === t1.retainPadding ? o.clone() : o, O = (o)=>(d)=>{
                        const f = d * L, y = 1 / R(f);
                        o.zoom = 1 === d ? l : s + o.scaleZoom(y), A && (o.bearing = e.af(r, c, d)), z && (o.pitch = e.af(a, h, d)), P && (M.interpolatePadding(n, u, d), p = M.centerPoint.add(_));
                        const x = 1 === d ? m : o.unproject(g.add(v.mult(D(f))).mult(y));
                        return o.setLocationAtPoint(o.renderWorldCopies ? x.wrap() : x, p), o._updateCameraOnTerrain(), t1.preloadOnly || this._fireMoveEvents(i), o;
                    };
                if (t1.preloadOnly) {
                    const e = this._emulate(O, t1.duration, o);
                    return this._preloadTiles(e), this;
                }
                return this._zooming = !0, this._rotating = A, this._pitching = z, this._padding = P, this._prepareEase(i, !1), this._ease(O(o), ()=>this._afterEase(i), t1), this;
            }
            isEasing() {
                return !!this._easeFrameId;
            }
            stop() {
                return this._stop();
            }
            _requestRenderFrame(e) {}
            _cancelRenderFrame(e) {}
            _stop(e, t1) {
                if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
                    const e = this._onEaseEnd;
                    this._onEaseEnd = void 0, e.call(this, t1);
                }
                if (!e) {
                    const e = this.handlers;
                    e && e.stop(!1);
                }
                return this;
            }
            _ease(t1, i, o) {
                !1 === o.animate || 0 === o.duration ? (t1(1), i()) : (this._easeStart = e.q.now(), this._easeOptions = o, this._onEaseFrame = t1, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
                const t1 = Math.min((e.q.now() - this._easeStart) / this._easeOptions.duration, 1), i = this._onEaseFrame;
                i && i(this._easeOptions.easing(t1)), t1 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(t1, i) {
                t1 = e.bF(t1, -180, 180);
                const o = Math.abs(t1 - i);
                return Math.abs(t1 - 360 - i) < o && (t1 -= 360), Math.abs(t1 + 360 - i) < o && (t1 += 360), t1;
            }
            _normalizeCenter(e) {
                const t1 = this.transform;
                if (t1.maxBounds) return;
                if ("globe" !== t1.projection.name && !t1.renderWorldCopies) return;
                const i = e.lng - t1.center.lng;
                e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;
            }
            _prefersReducedMotion(t1) {
                return this._respectPrefersReducedMotion && e.q.prefersReducedMotion && !(t1 && t1.essential);
            }
            _emulate(e, t1, i) {
                const o = Math.ceil(15 * t1 / 1e3), s = [], r = e(i.clone());
                for(let e = 0; e <= o; e++){
                    const t1 = r(e / o);
                    s.push(t1.clone());
                }
                return s;
            }
            _preloadTiles(e, t1) {}
        }
        class Xn {
            constructor(t1 = {}){
                this.options = t1, e.aP([
                    "_toggleAttribution",
                    "_updateEditLink",
                    "_updateData",
                    "_updateCompact"
                ], this);
            }
            getDefaultPosition() {
                return "bottom-right";
            }
            onAdd(e) {
                const t1 = this.options && this.options.compact, i = e._getUIString("AttributionControl.ToggleAttribution");
                this._map = e, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = l("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", i);
                const o = l("span", "mapboxgl-ctrl-icon", this._compactButton);
                return o.setAttribute("aria-hidden", "true"), o.setAttribute("title", i), this._innerContainer = l("div", "mapboxgl-ctrl-attrib-inner", this._container), t1 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t1 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
            }
            onRemove() {
                this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
            }
            _toggleAttribution() {
                this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
            }
            _updateEditLink() {
                let t1 = this._editLink;
                t1 || (t1 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
                const i = [
                    {
                        key: "owner",
                        value: this.styleOwner
                    },
                    {
                        key: "id",
                        value: this.styleId
                    },
                    {
                        key: "access_token",
                        value: this._map._requestManager._customAccessToken || e.e.ACCESS_TOKEN
                    }
                ];
                if (t1) {
                    const o = i.reduce((e, t1, o)=>(t1.value && (e += `${t1.key}=${t1.value}${o < i.length - 1 ? "&" : ""}`), e), "?");
                    t1.href = `${e.e.FEEDBACK_URL}/${o}#${Ka(this._map, !0)}`, t1.rel = "noopener nofollow";
                }
            }
            _updateData(e) {
                !e || "metadata" !== e.sourceDataType && "visibility" !== e.sourceDataType && "style" !== e.dataType || (this._updateAttributions(), this._updateEditLink());
            }
            _updateAttributions() {
                if (!this._map.style) return;
                let e = [];
                if (this._map.style.stylesheet) {
                    const e = this._map.style.stylesheet;
                    this.styleOwner = e.owner, this.styleId = e.id;
                }
                const t1 = this._map.style._mergedSourceCaches;
                for(const i in t1){
                    const o = t1[i];
                    if (o.used) {
                        const t1 = o.getSource();
                        t1.attribution && e.indexOf(t1.attribution) < 0 && e.push(t1.attribution);
                    }
                }
                e.sort((e, t1)=>e.length - t1.length), e = e.filter((t1, i)=>{
                    for(let o = i + 1; o < e.length; o++)if (e[o].indexOf(t1) >= 0) return !1;
                    return !0;
                }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = [
                    ...this.options.customAttribution,
                    ...e
                ] : e.unshift(this.options.customAttribution));
                const i = e.join(" | ");
                i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
            }
            _updateCompact() {
                this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
            }
        }
        class Kn {
            constructor(){
                e.aP([
                    "_updateLogo",
                    "_updateCompact"
                ], this);
            }
            onAdd(e) {
                this._map = e, this._container = l("div", "mapboxgl-ctrl");
                const t1 = l("a", "mapboxgl-ctrl-logo");
                return t1.target = "_blank", t1.rel = "noopener nofollow", t1.href = "https://www.mapbox.com/", t1.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t1.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t1), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
                this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
            }
            getDefaultPosition() {
                return "bottom-left";
            }
            _updateLogo(e) {
                e && "metadata" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
            }
            _logoRequired() {
                if (!this._map.style) return !0;
                const e = this._map.style._sourceCaches;
                if (0 === Object.entries(e).length) return !0;
                for(const t1 in e){
                    const i = e[t1].getSource();
                    if (i.hasOwnProperty("mapbox_logo") && !i.mapbox_logo) return !1;
                }
                return !0;
            }
            _updateCompact() {
                const e = this._container.children;
                if (e.length) {
                    const t1 = e[0];
                    this._map.getCanvasContainer().offsetWidth < 250 ? t1.classList.add("mapboxgl-compact") : t1.classList.remove("mapboxgl-compact");
                }
            }
        }
        class Yn {
            constructor(){
                this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
            }
            add(e) {
                const t1 = ++this._id;
                return this._queue.push({
                    callback: e,
                    id: t1,
                    cancelled: !1
                }), t1;
            }
            remove(e) {
                const t1 = this._currentlyRunning, i = t1 ? this._queue.concat(t1) : this._queue;
                for (const t1 of i)if (t1.id === e) return void (t1.cancelled = !0);
            }
            run(e = 0) {
                const t1 = this._currentlyRunning = this._queue;
                this._queue = [];
                for (const i of t1)if (!i.cancelled && (i.callback(e), this._cleared)) break;
                this._cleared = !1, this._currentlyRunning = !1;
            }
            clear() {
                this._currentlyRunning && (this._cleared = !0), this._queue = [];
            }
        }
        class Jn {
            constructor(e){
                this.jumpTo(e);
            }
            getValue(t1) {
                if (t1 <= this._startTime) return this._start;
                if (t1 >= this._endTime) return this._end;
                const i = e.cB((t1 - this._startTime) / (this._endTime - this._startTime));
                return this._start * (1 - i) + this._end * i;
            }
            isEasing(e) {
                return e >= this._startTime && e <= this._endTime;
            }
            jumpTo(e) {
                this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e;
            }
            easeTo(e, t1, i) {
                this._start = this.getValue(t1), this._end = e, this._startTime = t1, this._endTime = t1 + i;
            }
        }
        const Qn = {
            "AttributionControl.ToggleAttribution": "Toggle attribution",
            "FullscreenControl.Enter": "Enter fullscreen",
            "FullscreenControl.Exit": "Exit fullscreen",
            "GeolocateControl.FindMyLocation": "Find my location",
            "GeolocateControl.LocationNotAvailable": "Location not available",
            "LogoControl.Title": "Mapbox homepage",
            "Map.Title": "Map",
            "NavigationControl.ResetBearing": "Reset bearing to north",
            "NavigationControl.ZoomIn": "Zoom in",
            "NavigationControl.ZoomOut": "Zoom out",
            "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
            "ScrollZoomBlocker.CmdMessage": "Use â + scroll to zoom the map",
            "TouchPanBlocker.Message": "Use two fingers to move the map"
        }, el = [
            "mouseenter",
            "mouseover",
            "mouseleave",
            "mouseout"
        ];
        class tl extends e.z {
            constructor(e, t1, i, o){
                const { point: s, lngLat: r, originalEvent: a, target: n } = e;
                super(e.type, {
                    point: s,
                    lngLat: r,
                    originalEvent: a,
                    target: n
                }), this.preventDefault = ()=>{
                    e.preventDefault();
                }, this.id = t1, this.interaction = i, this.feature = o;
            }
        }
        class il {
            constructor(e){
                this.map = e, this.interactionsByType = new Map, this.typeById = new Map, this.filters = new Map, this.delegatedHandlers = new Map, this.handleType = this.handleType.bind(this);
            }
            add(t1, i) {
                if (this.typeById.has(t1)) throw new Error(`Interaction id "${t1}" already exists.`);
                const { type: o, filter: s } = i;
                s && this.filters.set(t1, e.aZ(s));
                const r = this.interactionsByType.get(o) || new Map;
                if (0 === r.size) {
                    if (el.includes(o)) {
                        const { mousemove: e, mouseout: o } = this._createDelegatedHandlers(t1, i);
                        this.map.on("mousemove", e), this.map.on("mouseout", o), this.delegatedHandlers.set(t1, {
                            mousemove: e,
                            mouseout: o
                        });
                    } else this.map.on(o, this.handleType);
                    this.interactionsByType.set(o, r);
                }
                r.set(t1, i), this.typeById.set(t1, o);
            }
            get(e) {
                const t1 = this.typeById.get(e);
                if (!t1) return;
                const i = this.interactionsByType.get(t1);
                return i ? i.get(e) : void 0;
            }
            remove(e) {
                const t1 = this.typeById.get(e);
                if (!t1) return;
                this.typeById.delete(e), this.filters.delete(e);
                const i = this.interactionsByType.get(t1);
                if (i) {
                    if (i.delete(e), this.delegatedHandlers.has(e)) {
                        const { mousemove: t1, mouseout: i } = this.delegatedHandlers.get(e);
                        this.map.off("mousemove", t1), this.map.off("mouseout", i), this.delegatedHandlers.delete(e);
                    }
                    0 === i.size && this.map.off(t1, this.handleType);
                }
            }
            queryTargets(e, t1) {
                const i = [];
                for (const [e, o] of t1)o.target && i.push({
                    targetId: e,
                    target: o.target,
                    filter: this.filters.get(e)
                });
                return this.map.style.queryRenderedTargets(e, i, this.map.transform);
            }
            handleType(t1, i) {
                const o = this.interactionsByType.get(t1.type), s = Array.from(o).reverse();
                i = i || this.queryTargets(t1.point, s);
                let r = !1;
                for (const o of i){
                    for (const [i, a] of s){
                        if (!a.target) continue;
                        const s = o.variants ? o.variants[i] : null;
                        if (s) {
                            for (const n of s){
                                const s = new e.cw(o, n);
                                if (!1 !== a.handler(new tl(t1, i, a, s))) {
                                    r = !0;
                                    break;
                                }
                            }
                            if (r) break;
                        }
                    }
                    if (r) break;
                }
                if (!r) for (const [e, i] of s){
                    const { handler: o, target: s } = i;
                    if (!s && !1 !== o(new tl(t1, e, i, null))) break;
                }
            }
            _createDelegatedHandlers(e, t1) {
                switch(t1.type){
                    case "mouseenter":
                    case "mouseover":
                        {
                            let i = !1, o = new Set;
                            return {
                                mousemove: (s)=>{
                                    const r = this.queryTargets(s.point, [
                                        [
                                            e,
                                            t1
                                        ]
                                    ]), a = new Set;
                                    if (!r.length) return i = !1, void o.clear();
                                    const n = [];
                                    for (const e of r)o.has(e.id) || (a.add(e.id), n.push(e));
                                    i && !n.length || (i = !0, o = a, s.type = t1.type, this.handleType(s, n));
                                },
                                mouseout: ()=>{
                                    i = !1, o.clear();
                                }
                            };
                        }
                    case "mouseleave":
                    case "mouseout":
                        {
                            let i = [];
                            return {
                                mousemove: (o)=>{
                                    const s = this.queryTargets(o.point, [
                                        [
                                            e,
                                            t1
                                        ]
                                    ]);
                                    if (!s.length) return o.type = t1.type, this.handleType(o, i), void (i = s);
                                    const r = [], a = new Set(s.map((e)=>e.id));
                                    for (const e of i)a.has(e.id) || r.push(e);
                                    r.length && (o.type = t1.type, this.handleType(o, r)), i = s;
                                },
                                mouseout: (e)=>{
                                    i.length && (e.type = t1.type, this.handleType(e, i), i = []);
                                }
                            };
                        }
                }
            }
        }
        function ol(t1, i) {
            if (Array.isArray(t1) && Array.isArray(i)) {
                const e = new Set(t1), o = new Set(i);
                return e.size === o.size && t1.every((e)=>o.has(e));
            }
            return e.bn(t1, i);
        }
        const sl = {
            center: [
                0,
                0
            ],
            zoom: 0,
            bearing: 0,
            pitch: 0,
            minZoom: -2,
            maxZoom: 22,
            minPitch: 0,
            maxPitch: 85,
            interactive: !0,
            scrollZoom: !0,
            boxZoom: !0,
            dragRotate: !0,
            dragPan: !0,
            keyboard: !0,
            doubleClickZoom: !0,
            touchZoomRotate: !0,
            touchPitch: !0,
            cooperativeGestures: !1,
            performanceMetricsCollection: !0,
            bearingSnap: 7,
            clickTolerance: 3,
            pitchWithRotate: !0,
            hash: !1,
            attributionControl: !0,
            antialias: !1,
            failIfMajorPerformanceCaveat: !1,
            preserveDrawingBuffer: !1,
            trackResize: !0,
            renderWorldCopies: !0,
            refreshExpiredTiles: !0,
            minTileCacheSize: null,
            maxTileCacheSize: null,
            localIdeographFontFamily: "sans-serif",
            localFontFamily: null,
            transformRequest: null,
            accessToken: null,
            fadeDuration: 300,
            respectPrefersReducedMotion: !0,
            crossSourceCollisions: !0,
            collectResourceTiming: !1,
            testMode: !1,
            precompilePrograms: !0,
            scaleFactor: 1,
            spriteFormat: "auto"
        }, rl = {
            showCompass: !0,
            showZoom: !0,
            visualizePitch: !1
        };
        class al {
            constructor(t1, i, o = !1){
                this._clickTolerance = 10, this.element = i, this.mouseRotate = new yn({
                    clickTolerance: t1.dragRotate._mouseRotate._clickTolerance
                }), this.map = t1, o && (this.mousePitch = new xn({
                    clickTolerance: t1.dragRotate._mousePitch._clickTolerance
                })), e.aP([
                    "mousedown",
                    "mousemove",
                    "mouseup",
                    "touchstart",
                    "touchmove",
                    "touchend",
                    "reset"
                ], this), i.addEventListener("mousedown", this.mousedown), i.addEventListener("touchstart", this.touchstart, {
                    passive: !1
                }), i.addEventListener("touchmove", this.touchmove), i.addEventListener("touchend", this.touchend), i.addEventListener("touchcancel", this.reset);
            }
            down(e, t1) {
                this.mouseRotate.mousedown(e, t1), this.mousePitch && this.mousePitch.mousedown(e, t1), _();
            }
            move(e, t1) {
                const i = this.map, o = this.mouseRotate.mousemoveWindow(e, t1), s = o && o.bearingDelta;
                if (s && i.setBearing(i.getBearing() + s), this.mousePitch) {
                    const o = this.mousePitch.mousemoveWindow(e, t1), s = o && o.pitchDelta;
                    s && i.setPitch(i.getPitch() + s);
                }
            }
            off() {
                const e = this.element;
                e.removeEventListener("mousedown", this.mousedown), e.removeEventListener("touchstart", this.touchstart, {
                    passive: !1
                }), e.removeEventListener("touchmove", this.touchmove), e.removeEventListener("touchend", this.touchend), e.removeEventListener("touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
                p(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
            }
            mousedown(t1) {
                this.down(e.l({}, t1, {
                    ctrlKey: !0,
                    preventDefault: ()=>t1.preventDefault()
                }), g(this.element, t1)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
            }
            mousemove(e) {
                this.move(e, g(this.element, e));
            }
            mouseup(e) {
                this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp();
            }
            touchstart(e) {
                1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = v(this.element, e.targetTouches)[0], this.down({
                    type: "mousedown",
                    button: 0,
                    ctrlKey: !0,
                    preventDefault: ()=>e.preventDefault()
                }, this._startPos));
            }
            touchmove(e) {
                1 !== e.targetTouches.length ? this.reset() : (this._lastPos = v(this.element, e.targetTouches)[0], this.move({
                    preventDefault: ()=>e.preventDefault()
                }, this._lastPos));
            }
            touchend(e) {
                0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }
            reset() {
                this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
        }
        function nl(t1, i, o) {
            if (t1 = new e.bO(t1.lng, t1.lat), i) {
                const s = new e.bO(t1.lng - 360, t1.lat), r = new e.bO(t1.lng + 360, t1.lat), a = 360 * Math.ceil(Math.abs(t1.lng - o.center.lng) / 360), n = o.locationPoint(t1).distSqr(i), l = i.x < 0 || i.y < 0 || i.x > o.width || i.y > o.height;
                o.locationPoint(s).distSqr(i) < n && (l || Math.abs(s.lng - o.center.lng) < a) ? t1 = s : o.locationPoint(r).distSqr(i) < n && (l || Math.abs(r.lng - o.center.lng) < a) && (t1 = r);
            }
            for(; Math.abs(t1.lng - o.center.lng) > 180;){
                const e = o.locationPoint(t1);
                if (e.x >= 0 && e.y >= 0 && e.x <= o.width && e.y <= o.height) break;
                t1.lng > o.center.lng ? t1.lng -= 360 : t1.lng += 360;
            }
            return t1;
        }
        const ll = {
            center: "translate(-50%,-50%)",
            top: "translate(-50%,0)",
            "top-left": "translate(0,0)",
            "top-right": "translate(-100%,0)",
            bottom: "translate(-50%,-100%)",
            "bottom-left": "translate(0,-100%)",
            "bottom-right": "translate(-100%,-100%)",
            left: "translate(0,-50%)",
            right: "translate(-100%,-50%)"
        };
        class cl extends e.E {
            constructor(t1, i){
                if (super(), (t1 instanceof HTMLElement || i) && (t1 = e.l({
                    element: t1
                }, i)), e.aP([
                    "_update",
                    "_onMove",
                    "_onUp",
                    "_addDragHandler",
                    "_onMapClick",
                    "_onKeyPress",
                    "_clearFadeTimer"
                ], this), this._anchor = t1 && t1.anchor || "center", this._color = t1 && t1.color || "#3FB1CE", this._scale = t1 && t1.scale || 1, this._draggable = t1 && t1.draggable || !1, this._clickTolerance = t1 && t1.clickTolerance || 0, this._isDragging = !1, this._state = "inactive", this._rotation = t1 && t1.rotation || 0, this._rotationAlignment = t1 && t1.rotationAlignment || "auto", this._pitchAlignment = t1 && t1.pitchAlignment && t1.pitchAlignment || "auto", this._updateMoving = ()=>this._update(!0), this._occludedOpacity = t1 && t1.occludedOpacity || .2, t1 && t1.element) this._element = t1.element, this._offset = e.P.convert(t1 && t1.offset || [
                    0,
                    0
                ]);
                else {
                    this._defaultMarker = !0, this._element = l("div");
                    const i = 41, o = 27, s = c("svg", {
                        display: "block",
                        height: i * this._scale + "px",
                        width: o * this._scale + "px",
                        viewBox: `0 0 ${o} ${i}`
                    }, this._element), r = c("radialGradient", {
                        id: "shadowGradient"
                    }, c("defs", {}, s));
                    c("stop", {
                        offset: "10%",
                        "stop-opacity": .4
                    }, r), c("stop", {
                        offset: "100%",
                        "stop-opacity": .05
                    }, r), c("ellipse", {
                        cx: 13.5,
                        cy: 34.8,
                        rx: 10.5,
                        ry: 5.25,
                        fill: "url(#shadowGradient)"
                    }, s), c("path", {
                        fill: this._color,
                        d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
                    }, s), c("path", {
                        opacity: .25,
                        d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
                    }, s), c("circle", {
                        fill: "white",
                        cx: 13.5,
                        cy: 13.5,
                        r: 5.5
                    }, s), this._offset = e.P.convert(t1 && t1.offset || [
                        0,
                        -14
                    ]);
                }
                this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e)=>{
                    e.preventDefault();
                }), this._element.addEventListener("mousedown", (e)=>{
                    e.preventDefault();
                });
                const o = this._element.classList;
                for(const e in ll)o.remove(`mapboxgl-marker-anchor-${e}`);
                o.add(`mapboxgl-marker-anchor-${this._anchor}`);
                const s = t1 && t1.className ? t1.className.trim().split(/\s+/) : [];
                o.add(...s), this._popup = null;
            }
            addTo(e) {
                return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on("move", this._updateMoving), e.on("moveend", this._update), e.on("remove", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), e.on("click", this._onMapClick)), this;
            }
            remove() {
                const e = this._map;
                return e && (e.off("click", this._onMapClick), e.off("move", this._updateMoving), e.off("moveend", this._update), e.off("mousedown", this._addDragHandler), e.off("touchstart", this._addDragHandler), e.off("mouseup", this._onUp), e.off("touchend", this._onUp), e.off("mousemove", this._onMove), e.off("touchmove", this._onMove), e.off("remove", this._clearFadeTimer), e._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
                return this._lngLat;
            }
            setLngLat(t1) {
                return this._lngLat = e.bO.convert(t1), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
            }
            getElement() {
                return this._element;
            }
            setPopup(e) {
                if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) {
                    if (!("offset" in e.options)) {
                        const t1 = 38.1, i = 13.5, o = Math.sqrt(Math.pow(i, 2) / 2);
                        e.options.offset = this._defaultMarker ? {
                            top: [
                                0,
                                0
                            ],
                            "top-left": [
                                0,
                                0
                            ],
                            "top-right": [
                                0,
                                0
                            ],
                            bottom: [
                                0,
                                -t1
                            ],
                            "bottom-left": [
                                o,
                                -1 * (t1 - i + o)
                            ],
                            "bottom-right": [
                                -o,
                                -1 * (t1 - i + o)
                            ],
                            left: [
                                i,
                                -1 * (t1 - i)
                            ],
                            right: [
                                -i,
                                -1 * (t1 - i)
                            ]
                        } : this._offset;
                    }
                    this._popup = e, e._marker = this, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
                }
                return this;
            }
            _onKeyPress(e) {
                const t1 = e.code, i = e.charCode || e.keyCode;
                "Space" !== t1 && "Enter" !== t1 && 32 !== i && 13 !== i || this.togglePopup();
            }
            _onMapClick(e) {
                const t1 = e.originalEvent.target, i = this._element;
                this._popup && (t1 === i || i.contains(t1)) && this.togglePopup();
            }
            getPopup() {
                return this._popup;
            }
            togglePopup() {
                const e = this._popup;
                return e ? (e.isOpen() ? (e.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
            }
            _behindTerrain() {
                const e = this._map, t1 = this._pos;
                if (!e || !t1) return !1;
                const i = e.unproject(t1), o = e.getFreeCameraOptions();
                if (!o.position) return !1;
                const s = o.position.toLngLat();
                return s.distanceTo(i) < .9 * s.distanceTo(this._lngLat);
            }
            _evaluateOpacity() {
                const t1 = this._map;
                if (!t1) return;
                const i = this._pos;
                if (!i || i.x < 0 || i.x > t1.transform.width || i.y < 0 || i.y > t1.transform.height) return void this._clearFadeTimer();
                const o = t1.unproject(i);
                let s;
                t1._showingGlobe() && e.dH(t1.transform, this._lngLat) ? s = 0 : (s = 1 - t1._queryFogOpacity(o), t1.transform._terrainEnabled() && t1.getTerrain() && this._behindTerrain() && (s *= this._occludedOpacity)), this._element.style.opacity = `${s}`, this._element.style.pointerEvents = s > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(s), this._fadeTimer = null;
            }
            _clearFadeTimer() {
                this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
            }
            _updateDOM() {
                const e = this._pos;
                if (!e || !this._map) return;
                const t1 = this._offset.mult(this._scale);
                this._element.style.transform = `\n            translate(${e.x}px,${e.y}px)\n            ${ll[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${t1.x}px,${t1.y}px)\n        `;
            }
            _calculateXYTransform() {
                const t1 = this._pos, i = this._map, o = this.getPitchAlignment();
                if (!i || !t1 || "map" !== o) return "";
                if (!i._showingGlobe()) {
                    const e = i.getPitch();
                    return e ? `rotateX(${e}deg)` : "";
                }
                const s = e.c4(e.dI(i.transform, this._lngLat)), r = t1.sub(e.dJ(i.transform)), a = Math.abs(r.x) + Math.abs(r.y);
                if (0 === a) return "";
                const n = s / a;
                return `rotateX(${-r.y * n}deg) rotateY(${r.x * n}deg)`;
            }
            _calculateZTransform() {
                const t1 = this._pos, i = this._map;
                if (!i || !t1) return "";
                let o = 0;
                const s = this.getRotationAlignment();
                if ("map" === s) if (i._showingGlobe()) {
                    const t1 = i.project(new e.bO(this._lngLat.lng, this._lngLat.lat + .001)), s = i.project(new e.bO(this._lngLat.lng, this._lngLat.lat - .001)).sub(t1);
                    o = e.c4(Math.atan2(s.y, s.x)) - 90;
                } else o = -i.getBearing();
                else if ("horizon" === s) {
                    const s = e.ac(4, 6, i.getZoom()), r = e.dJ(i.transform);
                    r.y += s * i.transform.height;
                    const a = t1.sub(r), n = e.c4(Math.atan2(a.y, a.x));
                    o = (n > 90 ? n - 270 : n + 90) * (1 - s);
                }
                return o += this._rotation, o ? `rotateZ(${o}deg)` : "";
            }
            _update(e) {
                cancelAnimationFrame(this._updateFrameId);
                const t1 = this._map;
                t1 && (t1.transform.renderWorldCopies && (this._lngLat = nl(this._lngLat, this._pos, t1.transform)), this._pos = t1.project(this._lngLat), !0 === e ? this._updateFrameId = requestAnimationFrame(()=>{
                    this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
                }) : this._pos = this._pos.round(), t1._requestDomTask(()=>{
                    this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t1._showingGlobe() || t1.getTerrain() || t1.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));
                }));
            }
            getOffset() {
                return this._offset;
            }
            setOffset(t1) {
                return this._offset = e.P.convert(t1), this._update(), this;
            }
            addClassName(e) {
                return this._element.classList.add(e), this;
            }
            removeClassName(e) {
                return this._element.classList.remove(e), this;
            }
            toggleClassName(e) {
                return this._element.classList.toggle(e);
            }
            _onMove(t1) {
                const i = this._map;
                if (!i) return;
                const o = this._pointerdownPos, s = this._positionDelta;
                if (o && s) {
                    if (!this._isDragging) {
                        const e = this._clickTolerance || i._clickTolerance;
                        if (t1.point.dist(o) < e) return;
                        this._isDragging = !0;
                    }
                    this._pos = t1.point.sub(s), this._lngLat = i.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.z("dragstart"))), this.fire(new e.z("drag"));
                }
            }
            _onUp() {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;
                const t1 = this._map;
                t1 && (t1.off("mousemove", this._onMove), t1.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.z("dragend")), this._state = "inactive";
            }
            _addDragHandler(e) {
                const t1 = this._map, i = this._pos;
                t1 && i && this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(i), this._pointerdownPos = e.point, this._state = "pending", t1.on("mousemove", this._onMove), t1.on("touchmove", this._onMove), t1.once("mouseup", this._onUp), t1.once("touchend", this._onUp));
            }
            setDraggable(e) {
                this._draggable = !!e;
                const t1 = this._map;
                return t1 && (e ? (t1.on("mousedown", this._addDragHandler), t1.on("touchstart", this._addDragHandler)) : (t1.off("mousedown", this._addDragHandler), t1.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
                return this._draggable;
            }
            setRotation(e) {
                return this._rotation = e || 0, this._update(), this;
            }
            getRotation() {
                return this._rotation;
            }
            setRotationAlignment(e) {
                return this._rotationAlignment = e || "auto", this._update(), this;
            }
            getRotationAlignment() {
                return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
            }
            setPitchAlignment(e) {
                return this._pitchAlignment = e || "auto", this._update(), this;
            }
            getPitchAlignment() {
                return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
            }
            setOccludedOpacity(e) {
                return this._occludedOpacity = e || .2, this._update(), this;
            }
            getOccludedOpacity() {
                return this._occludedOpacity;
            }
        }
        const hl = {
            positionOptions: {
                enableHighAccuracy: !1,
                maximumAge: 0,
                timeout: 6e3
            },
            fitBoundsOptions: {
                maxZoom: 15
            },
            trackUserLocation: !1,
            showAccuracyCircle: !0,
            showUserLocation: !0,
            showUserHeading: !1
        }, ul = {
            maxWidth: 100,
            unit: "metric"
        }, dl = {
            kilometer: "km",
            meter: "m",
            mile: "mi",
            foot: "ft",
            "nautical-mile": "nm"
        }, _l = {
            closeButton: !0,
            closeOnClick: !0,
            focusAfterOpen: !0,
            className: "",
            maxWidth: "240px"
        }, pl = [
            "a[href]",
            "[tabindex]:not([tabindex='-1'])",
            "[contenteditable]:not([contenteditable='false'])",
            "button:not([disabled])",
            "input:not([disabled])",
            "select:not([disabled])",
            "textarea:not([disabled])"
        ].join(", ");
        function fl(t1 = new e.P(0, 0), i = "bottom") {
            if ("number" == typeof t1) {
                const o = Math.round(Math.sqrt(.5 * Math.pow(t1, 2)));
                switch(i){
                    case "top":
                        return new e.P(0, t1);
                    case "top-left":
                        return new e.P(o, o);
                    case "top-right":
                        return new e.P(-o, o);
                    case "bottom":
                        return new e.P(0, -t1);
                    case "bottom-left":
                        return new e.P(o, -o);
                    case "bottom-right":
                        return new e.P(-o, -o);
                    case "left":
                        return new e.P(t1, 0);
                    case "right":
                        return new e.P(-t1, 0);
                }
                return new e.P(0, 0);
            }
            return t1 instanceof e.P || Array.isArray(t1) ? e.P.convert(t1) : e.P.convert(t1[i] || [
                0,
                0
            ]);
        }
        const ml = {
            version: t1,
            supported: n.supported,
            setRTLTextPlugin: e.dK,
            getRTLTextPluginStatus: e.dL,
            Map: class extends $n {
                constructor(t1){
                    o.mark(i.create);
                    const s = t1;
                    if (null != (t1 = e.l({}, sl, t1)).minZoom && null != t1.maxZoom && t1.minZoom > t1.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
                    if (null != t1.minPitch && null != t1.maxPitch && t1.minPitch > t1.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
                    if (null != t1.minPitch && t1.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (null != t1.maxPitch && t1.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t1.antialias && e.dF(window) && (t1.antialias = !1, e.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Yi(t1.minZoom, t1.maxZoom, t1.minPitch, t1.maxPitch, t1.renderWorldCopies), t1), this._repaint = !!t1.repaint, this._interactive = t1.interactive, this._minTileCacheSize = t1.minTileCacheSize, this._maxTileCacheSize = t1.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t1.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t1.preserveDrawingBuffer, this._antialias = t1.antialias, this._trackResize = t1.trackResize, this._bearingSnap = t1.bearingSnap, this._refreshExpiredTiles = t1.refreshExpiredTiles, this._fadeDuration = t1.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t1.crossSourceCollisions, this._collectResourceTiming = t1.collectResourceTiming, this._language = this._parseLanguage(t1.language), this._worldview = t1.worldview, this._renderTaskQueue = new Yn, this._domRenderTaskQueue = new Yn, this._controls = [], this._markers = [], this._popups = [], this._mapId = e.aV(), this._locale = e.l({}, Qn, t1.locale), this._clickTolerance = t1.clickTolerance, this._cooperativeGestures = t1.cooperativeGestures, this._performanceMetricsCollection = t1.performanceMetricsCollection, this._tessellationStep = t1.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = !0, this._precompilePrograms = t1.precompilePrograms, this._scaleFactorChanged = !1, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new Jn(0), this._interactionRange = [
                        1 / 0,
                        -1 / 0
                    ], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._frameId = 0, this._scaleFactor = t1.scaleFactor, this._requestManager = new T(t1.transformRequest, t1.accessToken, t1.testMode), this._silenceAuthErrors = !!t1.testMode, this._contextCreateOptions = t1.contextCreateOptions ? {
                        ...t1.contextCreateOptions
                    } : {}, "string" == typeof t1.container) {
                        const e = document.getElementById(t1.container);
                        if (!e) throw new Error(`Container '${t1.container.toString()}' not found.`);
                        this._container = e;
                    } else {
                        if (!(t1.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                        this._container = t1.container;
                    }
                    if (this._container.childNodes.length > 0 && e.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t1.maxBounds && this.setMaxBounds(t1.maxBounds), this._spriteFormat = t1.spriteFormat, e.aP([
                        "_onWindowOnline",
                        "_onWindowResize",
                        "_onVisibilityChange",
                        "_onMapScroll",
                        "_contextLost",
                        "_contextRestored"
                    ], this), this._setupContainer(), this._tp || (this._tp = new Pa), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showOverdrawInspector"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showTileBoundaries"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showParseStatus"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "repaint"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showTileAABBs"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showPadding"), this._tp.registerParameter(this, [
                        "Debug"
                    ], "showCollisionBoxes", {
                        noSave: !0
                    }), this._tp.registerParameter(this.transform, [
                        "Debug"
                    ], "freezeTileCoverage", {
                        noSave: !0
                    }, ()=>{
                        this._update();
                    }), this._tp.registerParameter(this, [
                        "Debug",
                        "Wireframe"
                    ], "showTerrainWireframe"), this._tp.registerParameter(this, [
                        "Debug",
                        "Wireframe"
                    ], "showLayers2DWireframe"), this._tp.registerParameter(this, [
                        "Debug",
                        "Wireframe"
                    ], "showLayers3DWireframe"), this._tp.registerParameter(this, [
                        "Scaling"
                    ], "_scaleFactor", {
                        min: .1,
                        max: 10,
                        step: .1
                    }, ()=>{
                        this.setScaleFactor(this._scaleFactor);
                    }), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
                    if (this.on("move", ()=>this._update(!1)), this.on("moveend", ()=>this._update(!1)), this.on("zoom", ()=>this._update(!0)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, !1), window.addEventListener("resize", this._onWindowResize, !1), window.addEventListener("orientationchange", this._onWindowResize, !1), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.addEventListener("visibilitychange", this._onVisibilityChange, !1), this.handlers = new Zn(this, t1), this._localFontFamily = t1.localFontFamily, this._localIdeographFontFamily = t1.localIdeographFontFamily, (t1.style || !t1.testMode) && this.setStyle(t1.style || e.e.DEFAULT_STYLE, {
                        config: t1.config,
                        localFontFamily: this._localFontFamily,
                        localIdeographFontFamily: this._localIdeographFontFamily
                    }), t1.projection && this.setProjection(t1.projection), this.indoor = new uo(this), t1.hash && (this._hash = new Xa("string" == typeof t1.hash && t1.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
                        null == s.center && null == s.zoom || (this.transform._unmodified = !1), this.jumpTo({
                            center: t1.center,
                            zoom: t1.zoom,
                            bearing: t1.bearing,
                            pitch: t1.pitch
                        });
                        const i = t1.bounds;
                        i && (this.resize(), this.fitBounds(i, e.l({}, t1.fitBoundsOptions, {
                            duration: 0
                        })));
                    }
                    this.resize(), t1.attributionControl && this.addControl(new Xn({
                        customAttribution: t1.customAttribution
                    })), this._logoControl = new Kn, this.addControl(this._logoControl, t1.logoPosition), this.on("style.load", ()=>{
                        this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();
                    }), this.on("data", (t1)=>{
                        this._update("style" === t1.dataType), this.fire(new e.z(`${t1.dataType}data`, t1));
                    }), this.on("dataloading", (t1)=>{
                        this.fire(new e.z(`${t1.dataType}dataloading`, t1));
                    }), this._interactions = new il(this);
                }
                _getMapId() {
                    return this._mapId;
                }
                addControl(t1, i) {
                    if (void 0 === i && (i = t1.getDefaultPosition ? t1.getDefaultPosition() : "top-right"), !t1 || !t1.onAdd) return this.fire(new e.y(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const o = t1.onAdd(this);
                    this._controls.push(t1);
                    const s = this._controlPositions[i];
                    return -1 !== i.indexOf("bottom") ? s.insertBefore(o, s.firstChild) : s.appendChild(o), this;
                }
                removeControl(t1) {
                    if (!t1 || !t1.onRemove) return this.fire(new e.y(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                    const i = this._controls.indexOf(t1);
                    return i > -1 && this._controls.splice(i, 1), t1.onRemove(this), this;
                }
                hasControl(e) {
                    return this._controls.indexOf(e) > -1;
                }
                getContainer() {
                    return this._container;
                }
                getCanvasContainer() {
                    return this._canvasContainer;
                }
                getCanvas() {
                    return this._canvas;
                }
                resize(t1) {
                    if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
                    this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
                    const i = !this._moving;
                    return i && this.fire(new e.z("movestart", t1)).fire(new e.z("move", t1)), this.fire(new e.z("resize", t1)), i && this.fire(new e.z("moveend", t1)), this;
                }
                getBounds() {
                    return this.transform.getBounds();
                }
                getMaxBounds() {
                    return this.transform.getMaxBounds() || null;
                }
                setMaxBounds(t1) {
                    return this.transform.setMaxBounds(e.az.convert(t1)), this._update();
                }
                setMinZoom(t1) {
                    if ((t1 = t1 ?? -2) >= -2 && t1 <= this.transform.maxZoom) return this.transform.minZoom = t1, this._update(), this.getZoom() < t1 ? this.setZoom(t1) : this.fire(new e.z("zoomstart")).fire(new e.z("zoom")).fire(new e.z("zoomend")), this;
                    throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
                }
                getMinZoom() {
                    return this.transform.minZoom;
                }
                setMaxZoom(t1) {
                    if ((t1 = t1 ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = t1, this._update(), this.getZoom() > t1 ? this.setZoom(t1) : this.fire(new e.z("zoomstart")).fire(new e.z("zoom")).fire(new e.z("zoomend")), this;
                    throw new Error("maxZoom must be greater than the current minZoom");
                }
                getMaxZoom() {
                    return this.transform.maxZoom;
                }
                setMinPitch(t1) {
                    if ((t1 = t1 ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
                    if (t1 >= 0 && t1 <= this.transform.maxPitch) return this.transform.minPitch = t1, this._update(), this.getPitch() < t1 ? this.setPitch(t1) : this.fire(new e.z("pitchstart")).fire(new e.z("pitch")).fire(new e.z("pitchend")), this;
                    throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
                }
                getMinPitch() {
                    return this.transform.minPitch;
                }
                setMaxPitch(t1) {
                    if ((t1 = t1 ?? 85) > 85) throw new Error("maxPitch must be less than or equal to 85");
                    if (t1 >= this.transform.minPitch) return this.transform.maxPitch = t1, this._update(), this.getPitch() > t1 ? this.setPitch(t1) : this.fire(new e.z("pitchstart")).fire(new e.z("pitch")).fire(new e.z("pitchend")), this;
                    throw new Error("maxPitch must be greater than or equal to minPitch");
                }
                getMaxPitch() {
                    return this.transform.maxPitch;
                }
                getScaleFactor() {
                    return this._scaleFactor;
                }
                setScaleFactor(e) {
                    return this._scaleFactor = e, this.painter.scaleFactor = e, this._tp.refreshUI(), this._scaleFactorChanged = !0, this.style._updateFilteredLayers((e)=>"symbol" === e.type), this._update(!0), this;
                }
                getRenderWorldCopies() {
                    return this.transform.renderWorldCopies;
                }
                setRenderWorldCopies(e) {
                    return this.transform.renderWorldCopies = e, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
                }
                getLanguage() {
                    return this._language;
                }
                _parseLanguage(e) {
                    return "auto" === e ? navigator.language : Array.isArray(e) ? 0 === e.length ? void 0 : e.map((e)=>"auto" === e ? navigator.language : e) : e;
                }
                setLanguage(e) {
                    const t1 = this._parseLanguage(e);
                    if (!this.style || t1 === this._language) return this;
                    this._language = t1, this.style.reloadSources();
                    for (const e of this._controls)e._setLanguage && e._setLanguage(this._language);
                    return this;
                }
                getWorldview() {
                    return this._worldview;
                }
                setWorldview(e) {
                    return this.style && e !== this._worldview ? (this._worldview = e, this.style.reloadSources(), this) : this;
                }
                getProjection() {
                    return this.transform.mercatorFromTransition ? {
                        name: "globe",
                        center: [
                            0,
                            0
                        ]
                    } : this.transform.getProjection();
                }
                _showingGlobe() {
                    return "globe" === this.transform.projection.name;
                }
                setProjection(e) {
                    return this._lazyInitEmptyStyle(), e ? "string" == typeof e && (e = {
                        name: e
                    }) : e = null, this._useExplicitProjection = !!e, this._prioritizeAndUpdateProjection(e, this.style.projection);
                }
                _updateProjectionTransition() {
                    if ("globe" !== this.getProjection().name) return;
                    const t1 = this.transform, i = t1.projection.name;
                    let o;
                    "globe" === i && t1.zoom >= e.bY ? (t1.setMercatorFromTransition(), o = !0) : "mercator" === i && t1.zoom < e.bY && (t1.setProjection({
                        name: "globe"
                    }), o = !0), o && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
                }
                _prioritizeAndUpdateProjection(e, t1) {
                    return this._updateProjection(e || t1 || {
                        name: "mercator"
                    });
                }
                _updateProjection(t1) {
                    let i;
                    return i = "globe" === t1.name && this.transform.zoom >= e.bY ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t1), this.style.applyProjectionUpdate(), i && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this;
                }
                project(t1) {
                    return this.transform.locationPoint3D(e.bO.convert(t1));
                }
                unproject(t1) {
                    return this.transform.pointLocation3D(e.P.convert(t1));
                }
                isMoving() {
                    return this._moving || this.handlers && this.handlers.isMoving() || !1;
                }
                isZooming() {
                    return this._zooming || this.handlers && this.handlers.isZooming() || !1;
                }
                isRotating() {
                    return this._rotating || this.handlers && this.handlers.isRotating() || !1;
                }
                _isDragging() {
                    return this.handlers && this.handlers._isDragging() || !1;
                }
                _createDelegatedListener(e, t1, i) {
                    const o = (e)=>{
                        let i = [];
                        if (Array.isArray(t1)) {
                            const o = t1.filter((e)=>this.getLayer(e));
                            i = o.length ? this.queryRenderedFeatures(e, {
                                layers: o
                            }) : [];
                        } else i = this.queryRenderedFeatures(e, {
                            target: t1
                        });
                        return i;
                    };
                    if ("mouseenter" === e || "mouseover" === e) {
                        let s = !1;
                        const r = (t1)=>{
                            const r = o(t1.point);
                            r.length ? s || (s = !0, i.call(this, new an(e, this, t1.originalEvent, {
                                features: r
                            }))) : s = !1;
                        };
                        return {
                            listener: i,
                            targets: t1,
                            delegates: {
                                mousemove: r,
                                mouseout: ()=>{
                                    s = !1;
                                }
                            }
                        };
                    }
                    if ("mouseleave" === e || "mouseout" === e) {
                        let s = !1;
                        const r = (t1)=>{
                            o(t1.point).length ? s = !0 : s && (s = !1, i.call(this, new an(e, this, t1.originalEvent)));
                        }, a = (t1)=>{
                            s && (s = !1, i.call(this, new an(e, this, t1.originalEvent)));
                        };
                        return {
                            listener: i,
                            targets: t1,
                            delegates: {
                                mousemove: r,
                                mouseout: a
                            }
                        };
                    }
                    {
                        const s = (e)=>{
                            const t1 = o(e.point);
                            t1.length && (e.features = t1, i.call(this, e), delete e.features);
                        };
                        return {
                            listener: i,
                            targets: t1,
                            delegates: {
                                [e]: s
                            }
                        };
                    }
                }
                on(e, t1, i) {
                    if ("function" == typeof t1 || void 0 === i) return super.on(e, t1);
                    if ("string" == typeof t1 && (t1 = [
                        t1
                    ]), !this._areTargetsValid(t1)) return this;
                    const o = this._createDelegatedListener(e, t1, i);
                    this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(o);
                    for(const e in o.delegates)this.on(e, o.delegates[e]);
                    return this;
                }
                once(e, t1, i) {
                    if ("function" == typeof t1 || void 0 === i) return super.once(e, t1);
                    if ("string" == typeof t1 && (t1 = [
                        t1
                    ]), !this._areTargetsValid(t1)) return this;
                    const o = this._createDelegatedListener(e, t1, i);
                    for(const e in o.delegates)this.once(e, o.delegates[e]);
                    return this;
                }
                off(e, t1, i) {
                    if ("function" == typeof t1 || void 0 === i) return super.off(e, t1);
                    if ("string" == typeof t1 && (t1 = [
                        t1
                    ]), !this._areTargetsValid(t1)) return this;
                    const o = this._delegatedListeners ? this._delegatedListeners[e] : void 0;
                    return o && ((e)=>{
                        for(let o = 0; o < e.length; o++){
                            const s = e[o];
                            if (s.listener === i && ol(s.targets, t1)) {
                                for(const e in s.delegates)this.off(e, s.delegates[e]);
                                return e.splice(o, 1), this;
                            }
                        }
                    })(o), this;
                }
                queryRenderedFeatures(t1, i) {
                    if (!this.style) return [];
                    if (void 0 === t1 || t1 instanceof e.P || Array.isArray(t1) || void 0 !== i || (i = t1, t1 = void 0), t1 = t1 || [
                        [
                            0,
                            0
                        ],
                        [
                            this.transform.width,
                            this.transform.height
                        ]
                    ], !i) {
                        const e = this.style.queryRenderedFeatures(t1, void 0, this.transform), i = this.style.queryRenderedFeatureset(t1, void 0, this.transform);
                        return e.concat(i);
                    }
                    let o = !0;
                    if (i.target && (o = this._isTargetValid(i.target), o && !i.layers)) return this.style.queryRenderedFeatureset(t1, i, this.transform);
                    let s = !0;
                    if (i.layers && Array.isArray(i.layers)) {
                        for (const e of i.layers)if (!this._isValidId(e)) {
                            s = !1;
                            break;
                        }
                        if (s && !i.target) return this.style.queryRenderedFeatures(t1, i, this.transform);
                    }
                    let r = [];
                    return s && (r = r.concat(this.style.queryRenderedFeatures(t1, i, this.transform))), o && (r = r.concat(this.style.queryRenderedFeatureset(t1, i, this.transform))), r;
                }
                querySourceFeatures(e, t1) {
                    return !e || "string" == typeof e && !this._isValidId(e) ? [] : this.style.querySourceFeatures(e, t1);
                }
                isPointOnSurface(t1) {
                    const { name: i } = this.transform.projection;
                    return "globe" !== i && "mercator" !== i && e.w(`${i} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e.P.convert(t1));
                }
                addInteraction(e, t1) {
                    return this._interactions.add(e, t1), this;
                }
                removeInteraction(e) {
                    return this._interactions.remove(e), this;
                }
                setStyle(t1, i) {
                    return i = e.l({}, {
                        localIdeographFontFamily: this._localIdeographFontFamily,
                        localFontFamily: this._localFontFamily
                    }, i), this.style && t1 && !1 !== i.diff && i.localFontFamily === this._localFontFamily && i.localIdeographFontFamily === this._localIdeographFontFamily && !i.config ? (this.style._diffStyle(t1, (o, s)=>{
                        o ? (e.w(`Unable to perform style diff: ${String(o.message || o.error || o)}. Rebuilding the style from scratch.`), this._updateStyle(t1, i)) : s && this._update(!0);
                    }, ()=>{
                        this._postStyleLoadEvent();
                    }), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t1, i));
                }
                _getUIString(e) {
                    const t1 = this._locale[e];
                    if (null == t1) throw new Error(`Missing UI string '${e}'`);
                    return t1;
                }
                _updateStyle(t1, i) {
                    if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), t1) {
                        const o = e.l({}, i);
                        i && i.config && (o.initialConfig = i.config, delete o.config), this.style = new bo(this, o).load(t1), this.style.setEventedParent(this, {
                            style: this.style
                        });
                    }
                    return this._updateTerrain(), this;
                }
                _lazyInitEmptyStyle() {
                    this.style || (this.style = new bo(this, {}), this.style.setEventedParent(this, {
                        style: this.style
                    }), this.style.loadEmpty());
                }
                getStyle() {
                    if (this.style) return this.style.serialize();
                }
                isStyleLoaded() {
                    return this.style ? this.style.loaded() : (e.w("There is no style added to the map."), !1);
                }
                _isValidId(t1) {
                    return null == t1 ? (this.fire(new e.y(new Error("IDs can't be empty."))), !1) : !e.cr(t1) || (this.fire(new e.y(new Error(`IDs can't contain special symbols: "${t1}".`))), !1);
                }
                _isTargetValid(e) {
                    return "featuresetId" in e ? this._isValidId("importId" in e ? e.importId : e.featuresetId) : "layerId" in e && this._isValidId(e.layerId);
                }
                _areTargetsValid(e) {
                    if (Array.isArray(e)) {
                        for (const t1 of e)if (!this._isValidId(t1)) return !1;
                        return !0;
                    }
                    return this._isTargetValid(e);
                }
                addSource(e, t1) {
                    return this._isValidId(e) ? (this._lazyInitEmptyStyle(), this.style.addSource(e, t1), this._update(!0)) : this;
                }
                isSourceLoaded(e) {
                    return !!this._isValidId(e) && !!this.style && this.style._isSourceCacheLoaded(e);
                }
                areTilesLoaded() {
                    return this.style.areTilesLoaded();
                }
                addSourceType(e, t1, i) {
                    this._lazyInitEmptyStyle(), this.style.addSourceType(e, t1, i);
                }
                removeSource(e) {
                    return this._isValidId(e) ? (this.style.removeSource(e), this._updateTerrain(), this._update(!0)) : this;
                }
                getSource(e) {
                    return this._isValidId(e) ? this.style.getOwnSource(e) : null;
                }
                addImage(t1, i, { pixelRatio: o = 1, sdf: s = !1, stretchX: r, stretchY: a, content: n } = {}) {
                    if (this._lazyInitEmptyStyle(), i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap) {
                        const { width: l, height: c, data: h } = e.q.getImageData(i);
                        this.style.addImage(t1, {
                            data: new e.r({
                                width: l,
                                height: c
                            }, h),
                            pixelRatio: o,
                            stretchX: r,
                            stretchY: a,
                            content: n,
                            sdf: s,
                            version: 0,
                            usvg: !1
                        });
                    } else if (void 0 === i.width || void 0 === i.height) this.fire(new e.y(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    else {
                        const { width: l, height: c } = i, h = i;
                        this.style.addImage(t1, {
                            data: new e.r({
                                width: l,
                                height: c
                            }, new Uint8Array(h.data)),
                            pixelRatio: o,
                            stretchX: r,
                            stretchY: a,
                            content: n,
                            sdf: s,
                            usvg: !1,
                            version: 0,
                            userImage: h
                        }), h.onAdd && h.onAdd(this, t1);
                    }
                }
                updateImage(t1, i) {
                    this._lazyInitEmptyStyle();
                    const o = this.style.getImage(t1);
                    if (!o) return void this.fire(new e.y(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                    const s = i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap ? e.q.getImageData(i) : i, { width: r, height: a, data: n } = s;
                    if (void 0 === r || void 0 === a) return void this.fire(new e.y(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                    if (r !== (o.usvg ? o.icon.usvg_tree.width : o.data.width) || a !== (o.usvg ? o.icon.usvg_tree.height : o.data.height)) return void this.fire(new e.y(new Error(`The width and height of the updated image (${r}, ${a})\n                must be that same as the previous version of the image\n                (${o.data.width}, ${o.data.height})`)));
                    const l = !(i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap);
                    let c = !1;
                    o.usvg ? (o.data = new e.r({
                        width: r,
                        height: a
                    }, new Uint8Array(n)), o.usvg = !1, o.icon = void 0, c = !0) : o.data.replace(n, l), this.style.updateImage(t1, o, c);
                }
                hasImage(t1) {
                    return t1 ? !!this.style && !!this.style.getImage(t1) : (this.fire(new e.y(new Error("Missing required image id"))), !1);
                }
                removeImage(e) {
                    this.style.removeImage(e);
                }
                loadImage(t1, i) {
                    e.o(this._requestManager.transformRequest(t1, e.R.Image), (t1, o)=>{
                        i(t1, o instanceof HTMLImageElement ? e.q.getImageData(o) : o);
                    });
                }
                listImages() {
                    return this.style.listImages();
                }
                addModel(e, t1) {
                    this._lazyInitEmptyStyle(), this.style.addModel(e, t1);
                }
                hasModel(t1) {
                    return t1 ? this.style.hasModel(t1) : (this.fire(new e.y(new Error("Missing required model id"))), !1);
                }
                removeModel(e) {
                    this.style.removeModel(e);
                }
                listModels() {
                    return this.style.listModels();
                }
                addLayer(e, t1) {
                    return this._isValidId(e.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e, t1), this._update(!0)) : this;
                }
                getSlot(e) {
                    const t1 = this.getLayer(e);
                    return t1 && t1.slot || null;
                }
                setSlot(e, t1) {
                    return this.style.setSlot(e, t1), this.style.mergeLayers(), this._update(!0);
                }
                addImport(e, t1) {
                    return this.style.addImport(e, t1), this;
                }
                updateImport(e, t1) {
                    return "string" != typeof t1 && t1.id !== e ? (this.removeImport(e), this.addImport(t1)) : (this.style.updateImport(e, t1), this._update(!0));
                }
                removeImport(e) {
                    return this.style.removeImport(e), this;
                }
                moveImport(e, t1) {
                    return this.style.moveImport(e, t1), this._update(!0);
                }
                moveLayer(e, t1) {
                    return this._isValidId(e) ? (this.style.moveLayer(e, t1), this._update(!0)) : this;
                }
                removeLayer(e) {
                    return this._isValidId(e) ? (this.style.removeLayer(e), this._update(!0)) : this;
                }
                getLayer(e) {
                    if (!this._isValidId(e)) return null;
                    const t1 = this.style.getOwnLayer(e);
                    return t1 ? "custom" === t1.type ? t1.implementation : t1.serialize() : void 0;
                }
                getSlots() {
                    return this.style.getSlots();
                }
                setLayerZoomRange(e, t1, i) {
                    return this._isValidId(e) ? (this.style.setLayerZoomRange(e, t1, i), this._update(!0)) : this;
                }
                setFilter(e, t1, i = {}) {
                    return this._isValidId(e) ? (this.style.setFilter(e, t1, i), this._update(!0)) : this;
                }
                getFilter(e) {
                    return this._isValidId(e) ? this.style.getFilter(e) : null;
                }
                setPaintProperty(e, t1, i, o = {}) {
                    return this._isValidId(e) ? (this.style.setPaintProperty(e, t1, i, o), this._update(!0)) : this;
                }
                getPaintProperty(e, t1) {
                    return this._isValidId(e) ? this.style.getPaintProperty(e, t1) : null;
                }
                setLayoutProperty(e, t1, i, o = {}) {
                    return this._isValidId(e) ? (this.style.setLayoutProperty(e, t1, i, o), this._update(!0)) : this;
                }
                getLayoutProperty(e, t1) {
                    return this._isValidId(e) ? this.style.getLayoutProperty(e, t1) : null;
                }
                getSchema(e) {
                    return this.style.getSchema(e);
                }
                setSchema(e, t1) {
                    return this.style.setSchema(e, t1), this._update(!0);
                }
                getConfig(e) {
                    return this.style.getConfig(e);
                }
                setConfig(e, t1) {
                    return this.style.setConfig(e, t1), this._update(!0);
                }
                getConfigProperty(e, t1) {
                    return this.style.getConfigProperty(e, t1);
                }
                setConfigProperty(e, t1, i) {
                    return this.style.setConfigProperty(e, t1, i), this._update(!0);
                }
                getFeaturesetDescriptors(e) {
                    return this.style.getFeaturesetDescriptors(e);
                }
                setLights(e) {
                    if (this._lazyInitEmptyStyle(), e && 1 === e.length && "flat" === e[0].type) {
                        const t1 = e[0];
                        t1.properties ? this.style.setFlatLight(t1.properties, t1.id, {}) : this.style.setFlatLight({}, "flat");
                    } else this.style.setLights(e), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);
                    return this._update(!0);
                }
                getLights() {
                    const e = this.style.getLights() || [];
                    return 0 === e.length && e.push({
                        id: this.style.light.id,
                        type: "flat",
                        properties: this.style.getFlatLight()
                    }), e;
                }
                setLight(e, t1 = {}) {
                    return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([
                        {
                            id: "flat",
                            type: "flat",
                            properties: e
                        }
                    ]);
                }
                getLight() {
                    return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
                }
                setTerrain(e) {
                    return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);
                }
                getTerrain() {
                    return this.style ? this.style.getTerrain() : null;
                }
                setFog(e) {
                    return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0);
                }
                getFog() {
                    return this.style ? this.style.getFog() : null;
                }
                setSnow(e) {
                    return this._lazyInitEmptyStyle(), this.style.setSnow(e), this._update(!0);
                }
                getSnow() {
                    return this.style ? this.style.getSnow() : null;
                }
                setRain(e) {
                    return this._lazyInitEmptyStyle(), this.style.setRain(e), this._update(!0);
                }
                getRain() {
                    return this.style ? this.style.getRain() : null;
                }
                setColorTheme(e) {
                    return this._lazyInitEmptyStyle(), this.style.setColorTheme(e), this._update(!0);
                }
                setImportColorTheme(e, t1) {
                    return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(e, t1), this._update(!0);
                }
                setCamera(e) {
                    return this.style.setCamera(e), this._triggerCameraUpdate(e);
                }
                _triggerCameraUpdate(e) {
                    return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === e["camera-projection"]));
                }
                getCamera() {
                    return this.style.camera;
                }
                _queryFogOpacity(t1) {
                    return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.bO.convert(t1), this.transform) : 0;
                }
                setFeatureState(e, t1) {
                    return e.source && !this._isValidId(e.source) ? this : (this.style.setFeatureState(e, t1), this._update());
                }
                removeFeatureState(e, t1) {
                    return e.source && !this._isValidId(e.source) ? this : (this.style.removeFeatureState(e, t1), this._update());
                }
                getFeatureState(e) {
                    return e.source && !this._isValidId(e.source) ? null : this.style.getFeatureState(e);
                }
                _updateContainerDimensions() {
                    if (!this._container) return;
                    const e = this._container.getBoundingClientRect().width || 400, t1 = this._container.getBoundingClientRect().height || 300;
                    let i, o, s, r = this._container;
                    for(; r && (!o || !s);){
                        const e = window.getComputedStyle(r).transform;
                        e && "none" !== e && (i = e.match(/matrix.*\((.+)\)/)[1].split(", "), i[0] && "0" !== i[0] && "1" !== i[0] && (o = i[0]), i[3] && "0" !== i[3] && "1" !== i[3] && (s = i[3])), r = r.parentElement;
                    }
                    this._containerWidth = o ? Math.abs(e / o) : e, this._containerHeight = s ? Math.abs(t1 / s) : t1;
                }
                _detectMissingCSS() {
                    "rgb(250, 128, 114)" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
                }
                _setupContainer() {
                    const e = this._container;
                    e.classList.add("mapboxgl-map"), (this._missingCSSCanary = l("div", "mapboxgl-canary", e)).style.visibility = "hidden", this._detectMissingCSS();
                    const t1 = this._canvasContainer = l("div", "mapboxgl-canvas-container", e);
                    this._canvas = l("canvas", "mapboxgl-canvas", t1), this._interactive && (t1.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
                    const i = this._controlContainer = l("div", "mapboxgl-control-container", e), o = this._controlPositions = {};
                    [
                        "top-left",
                        "top",
                        "top-right",
                        "right",
                        "bottom-right",
                        "bottom",
                        "bottom-left",
                        "left"
                    ].forEach((e)=>{
                        o[e] = l("div", `mapboxgl-ctrl-${e}`, i);
                    }), this._container.addEventListener("scroll", this._onMapScroll, !1);
                }
                _resizeCanvas(t1, i) {
                    const o = e.q.devicePixelRatio || 1;
                    this._canvas.width = o * Math.ceil(t1), this._canvas.height = o * Math.ceil(i), this._canvas.style.width = `${t1}px`, this._canvas.style.height = `${i}px`;
                }
                _addMarker(e) {
                    this._markers.push(e);
                }
                _removeMarker(e) {
                    const t1 = this._markers.indexOf(e);
                    -1 !== t1 && this._markers.splice(t1, 1);
                }
                _addPopup(e) {
                    this._popups.push(e);
                }
                _removePopup(e) {
                    const t1 = this._popups.indexOf(e);
                    -1 !== t1 && this._popups.splice(t1, 1);
                }
                _setupPainter() {
                    const t1 = e.l({}, n.supported.webGLContextAttributes, {
                        failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                        preserveDrawingBuffer: this._preserveDrawingBuffer,
                        antialias: this._antialias || !1
                    }), i = this._canvas.getContext("webgl2", t1);
                    i ? (G(i, !0), this.painter = new Wa(i, this._contextCreateOptions, this.transform, this._scaleFactor, this._tp), this.on("data", (e)=>{
                        "source" === e.dataType && this.painter.setTileLoadedFlag(!0);
                    }), e.m.testSupport(i)) : this.fire(new e.y(new Error("Failed to initialize WebGL")));
                }
                _contextLost(t1) {
                    t1.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.z("webglcontextlost", {
                        originalEvent: t1
                    }));
                }
                _contextRestored(t1) {
                    this._setupPainter(), this.resize(), this._update(), this.fire(new e.z("webglcontextrestored", {
                        originalEvent: t1
                    }));
                }
                _onMapScroll(e) {
                    if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
                }
                idle() {
                    return !this.isMoving() && this.loaded();
                }
                loaded() {
                    return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
                }
                frameReady() {
                    return this.loaded() && !this._placementDirty;
                }
                _update(e) {
                    return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
                }
                _requestRenderFrame(e) {
                    return this._update(), this._renderTaskQueue.add(e);
                }
                _cancelRenderFrame(e) {
                    this._renderTaskQueue.remove(e);
                }
                _requestDomTask(e) {
                    !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e);
                }
                _render(t1) {
                    let s;
                    this.fire(new e.z("renderstart")), ++this._frameId;
                    const r = this.painter.context.extTimerQuery, a = e.q.now(), n = this.painter.context.gl;
                    if (this.listens("gpu-timing-frame") && (s = n.createQuery(), n.beginQuery(r.TIME_ELAPSED_EXT, s)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t1), this._domRenderTaskQueue.run(t1), this._removed) return;
                    this._updateProjectionTransition();
                    const l = this._isInitialLoad ? 0 : this._fadeDuration;
                    if (this.style && this._styleDirty) {
                        this._styleDirty = !1;
                        const t1 = this.transform.zoom, i = this.transform.pitch, o = e.q.now(), s = new e.a8(t1, {
                            now: o,
                            fadeDuration: l,
                            pitch: i,
                            transition: this.style.transition
                        });
                        this.style.update(s);
                    }
                    this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);
                    let c = !1;
                    this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), c = this._updateAverageElevation(a), this.style.updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : c = this._updateAverageElevation(a);
                    const h = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, l, this._crossSourceCollisions, this.painter.replacementSource, this._scaleFactorChanged);
                    if (this._scaleFactorChanged && (this._scaleFactorChanged = !1), h && (this._placementDirty = h.needsRerender), this.style && this.painter.render(this.style, {
                        showTileBoundaries: this.showTileBoundaries,
                        showParseStatus: this.showParseStatus,
                        wireframe: {
                            terrain: this.showTerrainWireframe,
                            layers2D: this.showLayers2DWireframe,
                            layers3D: this.showLayers3DWireframe
                        },
                        showOverdrawInspector: this._showOverdrawInspector,
                        showQueryGeometry: !!this._showQueryGeometry,
                        showTileAABBs: this.showTileAABBs,
                        rotating: this.isRotating(),
                        zooming: this.isZooming(),
                        moving: this.isMoving(),
                        fadeDuration: l,
                        isInitialLoad: this._isInitialLoad,
                        showPadding: this.showPadding,
                        gpuTiming: !!this.listens("gpu-timing-layer"),
                        gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
                        speedIndexTiming: this.speedIndexTiming
                    }), this.fire(new e.z("render")), this.loaded() && !this._loaded && (this._loaded = !0, o.mark(i.load), this.fire(new e.z("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), s) {
                        const t1 = e.q.now() - a;
                        n.endQuery(r.TIME_ELAPSED_EXT), setTimeout(()=>{
                            const i = n.getQueryParameter(s, n.QUERY_RESULT) / 1e6;
                            n.deleteQuery(s), this.fire(new e.z("gpu-timing-frame", {
                                cpuTime: t1,
                                gpuTime: i
                            }));
                        }, 50);
                    }
                    if (this.listens("gpu-timing-layer")) {
                        const t1 = this.painter.collectGpuTimers();
                        setTimeout(()=>{
                            const i = this.painter.queryGpuTimers(t1);
                            this.fire(new e.z("gpu-timing-layer", {
                                layerTimes: i
                            }));
                        }, 50);
                    }
                    if (this.listens("gpu-timing-deferred-render")) {
                        const t1 = this.painter.collectDeferredRenderGpuQueries();
                        setTimeout(()=>{
                            const i = this.painter.queryGpuTimeDeferredRender(t1);
                            this.fire(new e.z("gpu-timing-deferred-render", {
                                gpuTime: i
                            }));
                        }, 50);
                    }
                    const u = this._sourcesDirty || this._styleDirty || this._placementDirty || c;
                    if (u || this._repaint) this.triggerRepaint();
                    else {
                        const t1 = this.idle();
                        if (t1 && (c = this._updateAverageElevation(a, !0)), c) this.triggerRepaint();
                        else if (this._triggerFrame(!1), t1 && (this.fire(new e.z("idle")), this._isInitialLoad = !1, this.speedIndexTiming)) {
                            const t1 = this._calculateSpeedIndex();
                            this.fire(new e.z("speedindexcompleted", {
                                speedIndex: t1
                            })), this.speedIndexTiming = !1;
                        }
                    }
                    !this._loaded || this._fullyLoaded || u || (this._fullyLoaded = !0, o.mark(i.fullLoad), this._performanceMetricsCollection && k(this._requestManager._customAccessToken, {
                        width: this.painter.width,
                        height: this.painter.height,
                        interactionRange: this._interactionRange,
                        visibilityHidden: this._visibilityHidden,
                        terrainEnabled: !!this.painter.style.getTerrain(),
                        fogEnabled: !!this.painter.style.getFog(),
                        projection: this.getProjection().name,
                        zoom: this.transform.zoom,
                        renderer: this.painter.context.renderer,
                        vendor: this.painter.context.vendor
                    }), this._authenticate());
                }
                _forceMarkerAndPopupUpdate(e) {
                    for (const t1 of this._markers)e && !this.getRenderWorldCopies() && (t1._lngLat = t1._lngLat.wrap()), t1._update();
                    for (const t1 of this._popups)!e || this.getRenderWorldCopies() || t1._trackPointer || (t1._lngLat = t1._lngLat.wrap()), t1._update();
                }
                _updateAverageElevation(e, t1 = !1) {
                    const i = (e)=>(this.transform.averageElevation = e, this._update(!1), !0);
                    if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i(0);
                    const o = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
                    if (o || (t1 || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) {
                        const t1 = this.transform.averageElevation;
                        let s = this.transform.sampleAverageElevation();
                        null != this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(s) ? s = 0 : this._averageElevationLastSampledAt = e;
                        const r = Math.abs(t1 - s);
                        if (r > 1) {
                            if (this._isInitialLoad || o) return this._averageElevation.jumpTo(s), i(s);
                            this._averageElevation.easeTo(s, e, 300);
                        } else if (r > 1e-4) return this._averageElevation.jumpTo(s), i(s);
                    }
                    return !!this._averageElevation.isEasing(e) && i(this._averageElevation.getValue(e));
                }
                _authenticate() {
                    N(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t1)=>{
                        if (t1 && (t1.message === w || 401 === t1.status)) {
                            const t1 = this.painter.context.gl;
                            G(t1, !1), this._logoControl instanceof Kn && this._logoControl._updateLogo(), t1 && t1.clear(t1.DEPTH_BUFFER_BIT | t1.COLOR_BUFFER_BIT | t1.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.y(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
                        }
                    }), P(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, ()=>{});
                }
                _postStyleLoadEvent() {
                    this.style.globalId && O(this._requestManager._customAccessToken, {
                        map: this,
                        skuToken: this._requestManager._skuToken,
                        style: this.style.globalId,
                        importedStyles: this.style.getImportGlobalIds()
                    });
                }
                _updateTerrain() {
                    const e = this._isDragging();
                    this.painter.updateTerrain(this.style, e);
                }
                _calculateSpeedIndex() {
                    const e = this.painter.canvasCopy(), t1 = this.painter.getCanvasCopiesAndTimestamps();
                    t1.timeStamps.push(performance.now());
                    const i = this.painter.context.gl, o = i.createFramebuffer();
                    function s(e) {
                        i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);
                        const t1 = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);
                        return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, t1), t1;
                    }
                    return i.bindFramebuffer(i.FRAMEBUFFER, o), this._canvasPixelComparison(s(e), t1.canvasCopies.map(s), t1.timeStamps);
                }
                _canvasPixelComparison(e, t1, i) {
                    let o = i[1] - i[0];
                    const s = e.length / 4;
                    for(let r = 0; r < t1.length; r++){
                        const a = t1[r];
                        let n = 0;
                        for(let t1 = 0; t1 < a.length; t1 += 4)a[t1] === e[t1] && a[t1 + 1] === e[t1 + 1] && a[t1 + 2] === e[t1 + 2] && a[t1 + 3] === e[t1 + 3] && (n += 1);
                        o += (i[r + 2] - i[r + 1]) * (1 - n / s);
                    }
                    return o;
                }
                remove() {
                    this._hash && this._hash.remove();
                    for (const e of this._controls)e.onRemove(this);
                    this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.indoor.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, !1), window.removeEventListener("orientationchange", this._onWindowResize, !1), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.removeEventListener("online", this._onWindowOnline, !1), window.removeEventListener("visibilitychange", this._onVisibilityChange, !1);
                    const t1 = this.painter.context.gl.getExtension("WEBGL_lose_context");
                    t1 && t1.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, !1), U.delete(this.painter.context.gl), B.remove(), z.remove(), this._removed = !0, this.fire(new e.z("remove"));
                }
                triggerRepaint() {
                    this._triggerFrame(!0);
                }
                _triggerFrame(t1) {
                    this._renderNextFrame = this._renderNextFrame || t1, this.style && !this._frame && (this._frame = e.q.frame((e)=>{
                        const t1 = !!this._renderNextFrame;
                        this._frame = null, this._renderNextFrame = null, t1 && this._render(e);
                    }));
                }
                _preloadTiles(t1) {
                    const i = this.style ? this.style.getSourceCaches() : [];
                    return e.bl(i, (e, i)=>e._preloadTiles(t1, i), ()=>{
                        this.triggerRepaint();
                    }), this;
                }
                _onWindowOnline() {
                    this._update();
                }
                _onWindowResize(e) {
                    this._trackResize && this.resize({
                        originalEvent: e
                    })._update();
                }
                _onVisibilityChange() {
                    "hidden" === document.visibilityState && this._visibilityHidden++;
                }
                get showTileBoundaries() {
                    return !!this._showTileBoundaries;
                }
                set showTileBoundaries(e) {
                    this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._tp.refreshUI(), this._update());
                }
                get showParseStatus() {
                    return !!this._showParseStatus;
                }
                set showParseStatus(e) {
                    this._showParseStatus !== e && (this._showParseStatus = e, this._tp.refreshUI(), this._update());
                }
                get showTerrainWireframe() {
                    return !!this._showTerrainWireframe;
                }
                set showTerrainWireframe(e) {
                    this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._tp.refreshUI(), this._update());
                }
                get showLayers2DWireframe() {
                    return !!this._showLayers2DWireframe;
                }
                set showLayers2DWireframe(e) {
                    this._showLayers2DWireframe !== e && (this._showLayers2DWireframe = e, this._tp.refreshUI(), this._update());
                }
                get showLayers3DWireframe() {
                    return !!this._showLayers3DWireframe;
                }
                set showLayers3DWireframe(e) {
                    this._showLayers3DWireframe !== e && (this._showLayers3DWireframe = e, this._tp.refreshUI(), this._update());
                }
                get speedIndexTiming() {
                    return !!this._speedIndexTiming;
                }
                set speedIndexTiming(e) {
                    this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update());
                }
                get showPadding() {
                    return !!this._showPadding;
                }
                set showPadding(e) {
                    this._showPadding !== e && (this._showPadding = e, this._tp.refreshUI(), this._update());
                }
                get showCollisionBoxes() {
                    return !!this._showCollisionBoxes;
                }
                set showCollisionBoxes(e) {
                    this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, this._tp.refreshUI(), e ? this.style._generateCollisionBoxes() : this._update());
                }
                get showOverdrawInspector() {
                    return !!this._showOverdrawInspector;
                }
                set showOverdrawInspector(e) {
                    this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._tp.refreshUI(), this._update());
                }
                get repaint() {
                    return !!this._repaint;
                }
                set repaint(e) {
                    this._repaint !== e && (this._repaint = e, this._tp.refreshUI(), this.triggerRepaint());
                }
                get vertices() {
                    return !!this._vertices;
                }
                set vertices(e) {
                    this._vertices = e, this._update();
                }
                get showTileAABBs() {
                    return !!this._showTileAABBs;
                }
                set showTileAABBs(e) {
                    this._showTileAABBs !== e && (this._showTileAABBs = e, this._tp.refreshUI(), e && this._update());
                }
                _setCacheLimits(t1, i) {
                    e.dG(t1, i);
                }
                get version() {
                    return t1;
                }
            },
            NavigationControl: class {
                constructor(t1 = {}){
                    this.options = e.l({}, rl, t1), this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e)=>e.preventDefault()), this.options.showZoom && (e.aP([
                        "_setButtonTitle",
                        "_updateZoomButtons"
                    ], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e)=>{
                        this._map && this._map.zoomIn({}, {
                            originalEvent: e
                        });
                    }), l("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e)=>{
                        this._map && this._map.zoomOut({}, {
                            originalEvent: e
                        });
                    }), l("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.aP([
                        "_rotateCompassArrow"
                    ], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e)=>{
                        const t1 = this._map;
                        t1 && (this.options.visualizePitch ? t1.resetNorthPitch({}, {
                            originalEvent: e
                        }) : t1.resetNorth({}, {
                            originalEvent: e
                        }));
                    }), this._compassIcon = l("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
                }
                _updateZoomButtons() {
                    const e = this._map;
                    if (!e) return;
                    const t1 = e.getZoom(), i = t1 === e.getMaxZoom(), o = t1 === e.getMinZoom();
                    this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute("aria-disabled", i.toString()), this._zoomOutButton.setAttribute("aria-disabled", o.toString());
                }
                _rotateCompassArrow() {
                    const e = this._map;
                    if (!e) return;
                    const t1 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e.transform.angle * (180 / Math.PI)}deg)`;
                    e._requestDomTask(()=>{
                        this._compassIcon && (this._compassIcon.style.transform = t1);
                    });
                }
                onAdd(e) {
                    return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e.on("pitch", this._rotateCompassArrow), e.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new al(e, this._compass, this.options.visualizePitch)), this._container;
                }
                onRemove() {
                    const e = this._map;
                    e && (this._container.remove(), this.options.showZoom && e.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e.off("pitch", this._rotateCompassArrow), e.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
                }
                _createButton(e, t1) {
                    const i = l("button", e, this._container);
                    return i.type = "button", i.addEventListener("click", t1), i;
                }
                _setButtonTitle(e, t1) {
                    if (!this._map) return;
                    const i = this._map._getUIString(`NavigationControl.${t1}`);
                    e.setAttribute("aria-label", i), e.firstElementChild && e.firstElementChild.setAttribute("title", i);
                }
            },
            GeolocateControl: class extends e.E {
                constructor(t1 = {}){
                    super();
                    const i = navigator.geolocation;
                    this.options = e.l({
                        geolocation: i
                    }, hl, t1), e.aP([
                        "_onSuccess",
                        "_onError",
                        "_onZoom",
                        "_finish",
                        "_setupUI",
                        "_updateCamera",
                        "_updateMarker",
                        "_updateMarkerRotation",
                        "_onDeviceOrientation"
                    ], this), this._updateMarkerRotationThrottled = $a(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
                }
                onAdd(e) {
                    return this._map = e, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
                }
                onRemove() {
                    void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;
                }
                _checkGeolocationSupport(e) {
                    const t1 = (t1 = !!this.options.geolocation)=>{
                        this._supportsGeolocation = t1, e(t1);
                    };
                    void 0 !== this._supportsGeolocation ? e(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({
                        name: "geolocation"
                    }).then((e)=>t1("denied" !== e.state)).catch(()=>t1()) : t1();
                }
                _isOutOfMapMaxBounds(e) {
                    const t1 = this._map.getMaxBounds(), i = e.coords;
                    return !!t1 && (i.longitude < t1.getWest() || i.longitude > t1.getEast() || i.latitude < t1.getSouth() || i.latitude > t1.getNorth());
                }
                _setErrorState() {
                    switch(this._watchState){
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                    }
                }
                _onSuccess(t1) {
                    if (this._map) {
                        if (this._isOutOfMapMaxBounds(t1)) return this._setErrorState(), this.fire(new e.z("outofmaxbounds", t1)), this._updateMarker(), void this._finish();
                        if (this.options.trackUserLocation) switch(this._lastKnownPosition = t1, this._watchState){
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "BACKGROUND":
                            case "BACKGROUND_ERROR":
                                this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                        }
                        this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t1), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t1), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.z("geolocate", t1)), this._finish();
                    }
                }
                _updateCamera(t1) {
                    const i = new e.bO(t1.coords.longitude, t1.coords.latitude), o = t1.coords.accuracy, s = this._map.getBearing(), r = e.l({
                        bearing: s
                    }, this.options.fitBoundsOptions);
                    this._map.fitBounds(i.toBounds(o), r, {
                        geolocateSource: !0
                    });
                }
                _updateMarker(t1) {
                    if (t1) {
                        const i = new e.bO(t1.coords.longitude, t1.coords.latitude);
                        this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t1.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                    } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
                }
                _updateCircleRadius() {
                    const t1 = this._map.transform, i = e.bH(1, t1._center.lat) * t1.worldSize, o = Math.ceil(2 * this._accuracy * i);
                    this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`;
                }
                _onZoom() {
                    this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                }
                _updateMarkerRotation() {
                    this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
                }
                _onError(t1) {
                    if (this._map) {
                        if (this.options.trackUserLocation) if (1 === t1.code) {
                            this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                            const e = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                            this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e), void 0 !== this._geolocationWatchID && this._clearWatch();
                        } else {
                            if (3 === t1.code && this._noTimeout) return;
                            this._setErrorState();
                        }
                        "OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.z("error", t1)), this._finish();
                    }
                }
                _finish() {
                    this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
                }
                _setupUI(t1) {
                    if (void 0 !== this._map) {
                        if (this._container.addEventListener("contextmenu", (e)=>e.preventDefault()), this._geolocateButton = l("button", "mapboxgl-ctrl-geolocate", this._container), l("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", !1 === t1) {
                            e.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                            const t1 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                            this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute("aria-label", t1), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t1);
                        } else {
                            const e = this._map._getUIString("GeolocateControl.FindMyLocation");
                            this._geolocateButton.setAttribute("aria-label", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e);
                        }
                        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = l("div", "mapboxgl-user-location"), this._dotElement.appendChild(l("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(l("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new cl({
                            element: this._dotElement,
                            rotationAlignment: "map",
                            pitchAlignment: "map"
                        }), this._circleElement = l("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new cl({
                            element: this._circleElement,
                            pitchAlignment: "map"
                        }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (t1)=>{
                            t1.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t1.originalEvent && "resize" === t1.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.z("trackuserlocationend")));
                        });
                    }
                }
                _onDeviceOrientation(e) {
                    this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled());
                }
                trigger() {
                    if (!this._setup) return e.w("Geolocate control triggered before added to a map"), !1;
                    if (this.options.trackUserLocation) {
                        switch(this._watchState){
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE", this.fire(new e.z("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                this._numberOfWatches--, this._noTimeout = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.z("trackuserlocationend"));
                                break;
                            case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.z("trackuserlocationstart"));
                        }
                        switch(this._watchState){
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                break;
                            case "BACKGROUND":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                                break;
                            case "BACKGROUND_ERROR":
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
                        }
                        if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
                        else if (void 0 === this._geolocationWatchID) {
                            let e;
                            this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e = {
                                maximumAge: 6e5,
                                timeout: 0
                            }, this._noTimeout = !0) : (e = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e), this.options.showUserHeading && this._addDeviceOrientationListener();
                        }
                    } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4);
                    return !0;
                }
                _addDeviceOrientationListener() {
                    const e = ()=>{
                        "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
                    };
                    "undefined" != typeof DeviceMotionEvent && "function" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t1)=>{
                        "granted" === t1 && e();
                    }).catch(console.error) : e();
                }
                _clearWatch() {
                    this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
                }
            },
            AttributionControl: Xn,
            ScaleControl: class {
                constructor(t1 = {}){
                    this.options = e.l({}, ul, t1), this._isNumberFormatSupported = function() {
                        try {
                            return new Intl.NumberFormat("en", {
                                style: "unit",
                                unitDisplay: "short",
                                unit: "meter"
                            }), !0;
                        } catch (e) {
                            return !1;
                        }
                    }(), e.aP([
                        "_update",
                        "_setScale",
                        "setUnit"
                    ], this);
                }
                getDefaultPosition() {
                    return "bottom-left";
                }
                _update() {
                    const e = this.options.maxWidth || 100, t1 = this._map, i = t1._containerHeight / 2, o = t1._containerWidth / 2 - e / 2, s = t1.unproject([
                        o,
                        i
                    ]), r = t1.unproject([
                        o + e,
                        i
                    ]), a = s.distanceTo(r);
                    if ("imperial" === this.options.unit) {
                        const t1 = 3.2808 * a;
                        t1 > 5280 ? this._setScale(e, t1 / 5280, "mile") : this._setScale(e, t1, "foot");
                    } else "nautical" === this.options.unit ? this._setScale(e, a / 1852, "nautical-mile") : a >= 1e3 ? this._setScale(e, a / 1e3, "kilometer") : this._setScale(e, a, "meter");
                }
                _setScale(e, t1, i) {
                    this._map._requestDomTask(()=>{
                        const o = function(e) {
                            const t1 = Math.pow(10, `${Math.floor(e)}`.length - 1);
                            let i = e / t1;
                            return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function(e) {
                                const t1 = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10));
                                return Math.round(e * t1) / t1;
                            }(i), t1 * i;
                        }(t1), s = o / t1;
                        this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i ? new Intl.NumberFormat(this._language, {
                            style: "unit",
                            unitDisplay: "short",
                            unit: i
                        }).format(o) : `${o}&nbsp;${dl[i]}`, this._container.style.width = e * s + "px";
                    });
                }
                onAdd(e) {
                    return this._map = e, this._language = e.getLanguage(), this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
                }
                onRemove() {
                    this._container.remove(), this._map.off("move", this._update), this._map = void 0;
                }
                _setLanguage(e) {
                    this._language = e, this._update();
                }
                setUnit(e) {
                    this.options.unit = e, this._update();
                }
            },
            FullscreenControl: class {
                constructor(t1 = {}){
                    this._fullscreen = !1, t1 && t1.container && (t1.container instanceof HTMLElement ? this._container = t1.container : e.w("Full screen control 'container' must be a DOM element.")), e.aP([
                        "_onClickFullscreen",
                        "_changeIcon"
                    ], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
                }
                onAdd(t1) {
                    return this._map = t1, this._container || (this._container = this._map.getContainer()), this._controlContainer = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.w("This device does not support fullscreen mode.")), this._controlContainer;
                }
                onRemove() {
                    this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
                }
                _checkFullscreenSupport() {
                    return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
                }
                _setupUI() {
                    const e = this._fullscreenButton = l("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
                    l("span", "mapboxgl-ctrl-icon", e).setAttribute("aria-hidden", "true"), e.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
                }
                _updateTitle() {
                    const e = this._getTitle();
                    this._fullscreenButton.setAttribute("aria-label", e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e);
                }
                _getTitle() {
                    return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
                }
                _isFullscreen() {
                    return this._fullscreen;
                }
                _changeIcon() {
                    (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
                }
                _onClickFullscreen() {
                    this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
                }
            },
            Popup: class extends e.E {
                constructor(t1){
                    super(), this.options = e.l(Object.create(_l), t1), e.aP([
                        "_update",
                        "_onClose",
                        "remove",
                        "_onMouseEvent"
                    ], this), this._classList = new Set(t1 && t1.className ? t1.className.trim().split(/\s+/) : []);
                }
                addTo(t1) {
                    return this._map && this.remove(), this._map = t1, this.options.closeOnClick && t1.on("preclick", this._onClose), this.options.closeOnMove && t1.on("move", this._onClose), t1.on("remove", this.remove), this._update(), t1._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t1.on("mousemove", this._onMouseEvent), t1.on("mouseup", this._onMouseEvent), t1._canvasContainer.classList.add("mapboxgl-track-pointer")) : t1.on("move", this._update), this.fire(new e.z("open")), this;
                }
                isOpen() {
                    return !!this._map;
                }
                remove() {
                    this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
                    const t1 = this._map;
                    return t1 && (t1.off("move", this._update), t1.off("move", this._onClose), t1.off("preclick", this._onClose), t1.off("click", this._onClose), t1.off("remove", this.remove), t1.off("mousemove", this._onMouseEvent), t1.off("mouseup", this._onMouseEvent), t1.off("drag", this._onMouseEvent), t1._canvasContainer && t1._canvasContainer.classList.remove("mapboxgl-track-pointer"), t1._removePopup(this), this._map = void 0), this.fire(new e.z("close")), this;
                }
                getLngLat() {
                    return this._lngLat;
                }
                setLngLat(t1) {
                    this._lngLat = e.bO.convert(t1), this._pos = null, this._trackPointer = !1, this._update();
                    const i = this._map;
                    return i && (i.on("move", this._update), i.off("mousemove", this._onMouseEvent), i._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
                }
                trackPointer() {
                    this._trackPointer = !0, this._pos = null, this._update();
                    const e = this._map;
                    return e && (e.off("move", this._update), e.on("mousemove", this._onMouseEvent), e.on("drag", this._onMouseEvent), e._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
                }
                getElement() {
                    return this._container;
                }
                setText(e) {
                    return this.setDOMContent(document.createTextNode(e));
                }
                setHTML(e) {
                    const t1 = document.createDocumentFragment(), i = document.createElement("body");
                    let o;
                    for(i.innerHTML = e; o = i.firstChild, o;)t1.appendChild(o);
                    return this.setDOMContent(t1);
                }
                getMaxWidth() {
                    return this._container && this._container.style.maxWidth;
                }
                setMaxWidth(e) {
                    return this.options.maxWidth = e, this._update(), this;
                }
                setDOMContent(e) {
                    let t1 = this._content;
                    if (t1) for(; t1.hasChildNodes();)t1.firstChild && t1.removeChild(t1.firstChild);
                    else t1 = this._content = l("div", "mapboxgl-popup-content", this._container || void 0);
                    if (t1.appendChild(e), this.options.closeButton) {
                        const e = this._closeButton = l("button", "mapboxgl-popup-close-button", t1);
                        e.type = "button", e.setAttribute("aria-label", "Close popup"), e.setAttribute("aria-hidden", "true"), e.innerHTML = "&#215;", e.addEventListener("click", this._onClose);
                    }
                    return this._update(), this._focusFirstElement(), this;
                }
                addClassName(e) {
                    return this._classList.add(e), this._updateClassList(), this;
                }
                removeClassName(e) {
                    return this._classList.delete(e), this._updateClassList(), this;
                }
                setOffset(e) {
                    return this.options.offset = e, this._update(), this;
                }
                toggleClassName(e) {
                    let t1;
                    return this._classList.delete(e) ? t1 = !1 : (this._classList.add(e), t1 = !0), this._updateClassList(), t1;
                }
                _onMouseEvent(e) {
                    this._update(e.point);
                }
                _getAnchor(e) {
                    if (this.options.anchor) return this.options.anchor;
                    const t1 = this._map, i = this._container, o = this._pos;
                    if (!t1 || !i || !o) return "bottom";
                    const s = i.offsetWidth, r = i.offsetHeight, a = o.x < s / 2, n = o.x > t1.transform.width - s / 2;
                    if (o.y + e < r) return a ? "top-left" : n ? "top-right" : "top";
                    if (o.y > t1.transform.height - r) {
                        if (a) return "bottom-left";
                        if (n) return "bottom-right";
                    }
                    return a ? "left" : n ? "right" : "bottom";
                }
                _updateClassList() {
                    const e = this._container;
                    if (!e) return;
                    const t1 = [
                        ...this._classList
                    ];
                    t1.push("mapboxgl-popup"), this._anchor && t1.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t1.push("mapboxgl-popup-track-pointer"), e.className = t1.join(" ");
                }
                _update(t1) {
                    const i = this._map, o = this._content;
                    if (!i || !this._lngLat && !this._trackPointer || !o) return;
                    let s = this._container;
                    if (s || (s = this._container = l("div", "mapboxgl-popup", i.getContainer()), this._tip = l("div", "mapboxgl-popup-tip", s), s.appendChild(o)), this.options.maxWidth && s.style.maxWidth !== this.options.maxWidth && (s.style.maxWidth = this.options.maxWidth), i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = nl(this._lngLat, this._pos, i.transform)), !this._trackPointer || t1) {
                        const o = this._pos = this._trackPointer && t1 instanceof e.P ? t1 : i.project(this._lngLat), s = fl(this.options.offset), r = this._anchor = this._getAnchor(s.y), a = fl(this.options.offset, r), n = o.add(a).round();
                        i._requestDomTask(()=>{
                            this._container && r && (this._container.style.transform = `${ll[r]} translate(${n.x}px,${n.y}px)`);
                        });
                    }
                    if (!this._marker && i._showingGlobe()) {
                        const t1 = e.dH(i.transform, this._lngLat) ? 0 : 1;
                        this._setOpacity(t1);
                    }
                    this._updateClassList();
                }
                _focusFirstElement() {
                    if (!this.options.focusAfterOpen || !this._container) return;
                    const e = this._container.querySelector(pl);
                    e && e.focus();
                }
                _onClose() {
                    this.remove();
                }
                _setOpacity(e) {
                    this._container && (this._container.style.opacity = `${e}`), this._content && (this._content.style.pointerEvents = e ? "auto" : "none");
                }
            },
            Marker: cl,
            Style: bo,
            LngLat: e.bO,
            LngLatBounds: e.az,
            Point: e.P,
            MercatorCoordinate: e.aa,
            FreeCameraOptions: Hi,
            Evented: e.E,
            config: e.e,
            prewarm: e.dM,
            clearPrewarmedResources: e.dN,
            get accessToken () {
                return e.e.ACCESS_TOKEN;
            },
            set accessToken (t){
                e.e.ACCESS_TOKEN = t;
            },
            get baseApiUrl () {
                return e.e.API_URL;
            },
            set baseApiUrl (t){
                e.e.API_URL = t;
            },
            get workerCount () {
                return e.dO.workerCount;
            },
            set workerCount (t){
                e.dO.workerCount = t;
            },
            get maxParallelImageRequests () {
                return e.e.MAX_PARALLEL_IMAGE_REQUESTS;
            },
            set maxParallelImageRequests (t){
                e.e.MAX_PARALLEL_IMAGE_REQUESTS = t;
            },
            clearStorage (t1) {
                e.dP(t1);
            },
            get workerUrl () {
                return e.dQ.workerUrl;
            },
            set workerUrl (t){
                e.dQ.workerUrl = t;
            },
            get workerClass () {
                return e.dQ.workerClass;
            },
            set workerClass (t){
                e.dQ.workerClass = t;
            },
            get workerParams () {
                return e.dQ.workerParams;
            },
            set workerParams (t){
                e.dQ.workerParams = t;
            },
            get dracoUrl () {
                return e.dR();
            },
            set dracoUrl (t){
                e.dS(t);
            },
            get meshoptUrl () {
                return e.dT();
            },
            set meshoptUrl (t){
                e.dU(t);
            },
            setNow: e.q.setNow,
            restoreNow: e.q.restoreNow
        };
        return ml;
    });
    //
    // Our custom intro provides a specialized "define()" function, called by the
    // AMD modules below, that sets up the worker blob URL and then executes the
    // main module, storing its exported value as 'mapboxgl'
    var mapboxgl$1 = mapboxgl;
    return mapboxgl$1;
}); //# sourceMappingURL=mapbox-gl.js.map
}}),
}]);

//# sourceMappingURL=node_modules_mapbox-gl_dist_mapbox-gl_0f9823.js.map